/* This file has been post-processed for GNU C */


/* Automatically generated by
	CCodeGeneratorTheoGlobalStructure * VMMakerTheo-CompatibleUserName.1590750105 uuid: 425dce87-f9c1-538b-b472-cd34b723f2b5
   from
	TheoStackInterpreter * VMMakerTheo-CompatibleUserName.1590750105 uuid: 425dce87-f9c1-538b-b472-cd34b723f2b5
 */
static char __buildInfo[] = "TheoStackInterpreter * VMMakerTheo-CompatibleUserName.1590750105 uuid: 425dce87-f9c1-538b-b472-cd34b723f2b5 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include <errno.h>
#include "sqGnu.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"

/* TheoStackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
void
warning(char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline(on)

void
invalidCompactClassError(char *s, struct foo * self) { /* Print a (compact) class index error message and exit. */
#if SPURVM
	printf("\nClass %s does not have the required class index\n", s);
#else
	printf("\nClass %s does not have the required compact class index\n", s);
#endif
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 * Note: on windows 64 via mingw-w64, the 2nd argument NULL to _setjmp prevents stack unwinding
 */
#undef sigsetjmp
#undef siglongjmp
#if _MSC_VER
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN64 && __GNUC__
# define sigsetjmp(jb,ssmf) _setjmp(jb,NULL)
# define siglongjmp(jb,v) longjmp(jb,v)
#elif _WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

#define odd(v) ((int)(v)&1)
#define even(v) (!odd(v))

/* end TheoStackInterpreter class>>preambleCCode */


/*** Constants ***/
#define ActiveProcessIndex 1
#define AlternateHeaderHasPrimFlag 0x80000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 245
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BecameActiveClassFlag 8
#define BecameCompiledMethodFlag 2
#define BecamePointerObjectFlag 1
#define BytecodeSetHasDirectedSuperSend 1
#define BytecodeSetHasExtensions 1
#define CacheProbeMax 3
#define CharacterTable null
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 37
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 52
#define ClassChannelQueue 32
#define ClassChannelQueueCompactIndex 70
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 34
#define ClassFullBlockClosure 37
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMessage 15
#define ClassMessageCompactIndex 35
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 36
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define COGMTVM 0
#define ConstMinusOne 0xFFFFFFFFFFFFFFF9ULL
#define ConstOne 9
#define ConstTwo 17
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DisownVMForFFICall 16
#define DisownVMForThreading 32
#define DisownVMLockOutFullGC 8
#define DumpStackOnLowSpace 0
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootsSize 2048
#define FailImbalancedPrimitives 1
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 8
#define FoxCallerSavedIP 8
#define FoxFrameFlags -16
#define FoxMethod -8
#define FoxReceiver -32
#define FoxSavedFP 0
#define FoxThisContext -24
#define FrameSlots 6
#define FullClosureCompiledBlockIndex 1
#define FullClosureFirstCopiedValueIndex 4
#define FullClosureReceiverIndex 3
#define GCCheckPrimCall 64
#define GCModeBecome 8
#define GCModeFreeSpace 32
#define GCModeFull 1
#define GCModeImageSegment 16
#define GCModeIncremental 4
#define GCModeNewSpace 2
#define HashMultiplyConstant 1664525
#define HeaderIndex 0
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 1
#endif
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x100000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongStoreBytecode 129
#define LowcodeVM 0
#define MarkObjectsForEnumerationPrimitives 0
#define MarkOnTenure 5
#define MarkStackRootIndex 0x1000
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MaxRTRefCount 7
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 27
#define MethodHeaderTempCountShift 21
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MournQueueRootIndex 4098
#define MULTIPLEBYTECODESETS 1
#define MyListIndex 3
#define NewspeakVM 0
#define NextLinkIndex 0
#define NilObject 0
#define NSMethodCacheSize 4096
#define ObjStackFixedSlots 4
#define ObjStackFreex 2
#define ObjStackLimit 0xFF8
#define ObjStackMyx 1
#define ObjStackNextx 3
#define ObjStackPageSlots 0xFFC
#define ObjStackTopx 0
#define OldBecameNewFlag 4
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrFFIException 22
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNeedCompaction 23
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrNotFound 11
#define PrimErrObjectIsPinned 16
#define PrimErrOSError 21
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimErrWritePastObject 17
#define PrimNoErr 0
#define PrimNumberDoExternalCall 218
#define PrimNumberDoPrimitive 118
#define PrimNumberExternalCall 117
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RememberedSetRootIndex 4099
#define ReturnToInterpreter 1
#define ScavengeInProgress 1
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorAttemptToAssign 50
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorSistaTrap 59
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define SistaVM 0
#define SlidingCompactionInProgress 2
#define SmallContextSlots 22
#define SPURVM 1
#define SpecialChannel 31
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TempVectReadBarrier 0
#define TenureByAge 1
#define TenureByClass 2
#define TenureToShrinkRT 3
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TopHashBit 0x200000
#define TopOopBit 0x8000000000000000ULL
#define TrueObject 2
#define V3PrimitiveBitsMask 0x80000FF8U
#define ValueIndex 1
#if !defined(VMBIGENDIAN) /* Allow this to be overridden on the compiler command line */
# define VMBIGENDIAN 0
#endif
#define WeaklingStackRootIndex 0x1001
#define XIndex 0
#define YIndex 1

typedef struct {
	usqInt	sEdenBytes;
	usqInt	sPastBytes;
	usqInt	sRememberedSetSize;
	usqInt	sRememberedSetRedZone;
	usqInt	sRememberedSetLimit;
	usqInt	sStatTenures;
	usqInt	tTenureCriterion;
	usqInt	tTenureThreshold;
	usqInt	tRefCountToShrinkRT;
	usqInt	eSurvivorBytes;
	usqInt	eRememberedSetSize;
	usqInt	eStatTenures;
 } SpurScavengeLogRecord;


typedef struct {
	usqInt	segStart;
	usqInt	segSize;
	sqInt	swizzle;
	usqInt	containsPinned;
	usqInt	savedSegSize;
	usqInt	lastFreeObject;
 } SpurSegmentInfo;


typedef struct {
	usqInt	start;
	usqInt	limit;
 } SpurNewSpaceSpace;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	top;
 } SpurContiguousObjStack;


typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	int	padToWord;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage


typedef struct {
	char  *imagePath;
	char *imageArguments;
	struct foo *interpreterState;
 } ThreadInterpreterParameter;



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

struct foo;
typedef struct ModuleEntry ModuleEntry;

extern sqInt interpret(struct foo * self);
static sqInt NoDbgRegParms addressIsInPage(StackPage * self_in_addressIsInPage, char *address, struct foo * self);
static sqInt NoDbgRegParms isFree(StackPage * self_in_isFree, struct foo * self);
static void NoDbgRegParms freeStackPageNoAssert(StackPage *aPage, struct foo * self);
static sqInt NoDbgRegParms freeStackPage(StackPage *aPage, struct foo * self);
static void NoDbgRegParms markStackPageMostRecentlyUsed(StackPage *page, struct foo * self);
static void NoDbgRegParms markStackPageNextMostRecentlyUsed(StackPage *page, struct foo * self);
static StackPage * newStackPage(struct foo * self);
static sqInt pageListIsWellFormed(struct foo * self);
static StackPage * NoDbgRegParms stackPageAt(sqInt index, struct foo * self);
static StackPage * NoDbgRegParms stackPageFor(void *pointer, struct foo * self);
static double statAverageLivePagesWhenMapping(struct foo * self);
#if IMMUTABILITY
static sqInt NoDbgRegParms canBeImmutable(sqInt oop, struct foo * self);
#endif /* IMMUTABILITY */
extern char * cStringOrNullFor(sqInt oop, struct foo * self);
extern sqInt failed(struct foo * self);
static sqInt NoDbgRegParms isNegativeIntegerValueOf(sqInt oop, struct foo * self);
extern sqInt isPositiveMachineIntegerObject(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative, struct foo * self);
static usqLong NoDbgRegParms magnitude64BitValueOf(sqInt oop, struct foo * self);
extern unsigned int positive32BitValueOf(sqInt oop, struct foo * self);
extern usqLong positive64BitValueOf(sqInt oop, struct foo * self);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop, struct foo * self);
static void primitiveAdd(struct foo * self);
EXPORT(void) primitiveAddLargeIntegers(struct foo * self);
static void primitiveAdoptInstance(struct foo * self);
EXPORT(void) primitiveAllInstances(struct foo * self);
EXPORT(void) primitiveAllObjects(struct foo * self);
static void primitiveArctan(struct foo * self);
static void primitiveArrayBecome(struct foo * self);
static void primitiveArrayBecomeOneWay(struct foo * self);
static void primitiveArrayBecomeOneWayCopyHash(struct foo * self);
static void primitiveArrayBecomeOneWayNoCopyHash(struct foo * self);
static void primitiveAsCharacter(struct foo * self);
static void primitiveAsFloat(struct foo * self);
static void primitiveAt(struct foo * self);
static void primitiveAtPut(struct foo * self);
static void primitiveBeCursor(struct foo * self);
static void primitiveBeDisplay(struct foo * self);
static void primitiveBeep(struct foo * self);
static void primitiveBehaviorHash(struct foo * self);
static void primitiveBitAnd(struct foo * self);
EXPORT(void) primitiveBitAndLargeIntegers(struct foo * self);
static void primitiveBitOr(struct foo * self);
EXPORT(void) primitiveBitOrLargeIntegers(struct foo * self);
static void primitiveBitShift(struct foo * self);
EXPORT(void) primitiveBitShiftLargeIntegers(struct foo * self);
static void primitiveBitXor(struct foo * self);
EXPORT(void) primitiveBitXorLargeIntegers(struct foo * self);
static void primitiveBytesLeft(struct foo * self);
static void primitiveCalloutToFFI(struct foo * self);
static void primitiveChangeClass(struct foo * self);
static void primitiveClass(struct foo * self);
static void primitiveClearVMProfile(struct foo * self);
static void primitiveClipboardText(struct foo * self);
EXPORT(sqInt) primitiveClockLogAddresses(struct foo * self);
static void primitiveClosureValue(struct foo * self);
extern void primitiveClosureValueNoContextSwitch(struct foo * self);
static void primitiveClosureValueWithArgs(struct foo * self);
static void primitiveCoarseLocalMicrosecondClock(struct foo * self);
static void primitiveCoarseUTCMicrosecondClock(struct foo * self);
EXPORT(void) primitiveCompareBytes(struct foo * self);
EXPORT(void) primitiveCompareWith(struct foo * self);
static void primitiveConstantFill(struct foo * self);
static void primitiveControlVMProfiling(struct foo * self);
static void primitiveCopyObject(struct foo * self);
EXPORT(sqInt) primitiveCrashVM(struct foo * self);
EXPORT(sqInt) primitiveDisablePowerManager(struct foo * self);
static void primitiveDiv(struct foo * self);
static void primitiveDivide(struct foo * self);
EXPORT(void) primitiveDivideLargeIntegers(struct foo * self);
EXPORT(void) primitiveDivLargeIntegers(struct foo * self);
static void primitiveEnterCriticalSection(struct foo * self);
static void primitiveEqual(struct foo * self);
EXPORT(void) primitiveEqualLargeIntegers(struct foo * self);
static void primitiveExitCriticalSection(struct foo * self);
static void primitiveExitToDebugger(struct foo * self);
static void primitiveExp(struct foo * self);
static void primitiveExponent(struct foo * self);
extern sqInt primitiveFail(struct foo * self);
extern sqInt primitiveFailForFFIExceptionat(usqLong exceptionCode, usqInt pc, struct foo * self);
extern sqInt primitiveFailForOSError(sqLong osError, struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
extern sqInt primitiveFailureCode(struct foo * self);
static void primitiveFetchNextMourner(struct foo * self);
static void primitiveFloatAdd(struct foo * self);
static void primitiveFloatAt(struct foo * self);
static void primitiveFloatAtPut(struct foo * self);
static void primitiveFloatDivide(struct foo * self);
static void primitiveFloatEqual(struct foo * self);
static void primitiveFloatGreaterOrEqual(struct foo * self);
static void primitiveFloatGreaterThan(struct foo * self);
static void primitiveFloatLessOrEqual(struct foo * self);
static void primitiveFloatLessThan(struct foo * self);
static void primitiveFloatMultiply(struct foo * self);
static void primitiveFloatNotEqual(struct foo * self);
static void primitiveFloatSubtract(struct foo * self);
static void primitiveFlushCache(struct foo * self);
static void primitiveFlushExternalPrimitives(struct foo * self);
static void primitiveForceDisplayUpdate(struct foo * self);
static void primitiveFormPrint(struct foo * self);
static void primitiveFractionalPart(struct foo * self);
static void primitiveFullClosureValue(struct foo * self);
extern void primitiveFullClosureValueNoContextSwitch(struct foo * self);
static void primitiveFullClosureValueWithArgs(struct foo * self);
static void primitiveGetAttribute(struct foo * self);
EXPORT(sqInt) primitiveGetenv(struct foo * self);
#if IMMUTABILITY
static void primitiveGetImmutability(struct foo * self);
#else
# define primitiveGetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
EXPORT(sqInt) primitiveGetLogDirectory(struct foo * self);
static void primitiveGetNextEvent(struct foo * self);
EXPORT(sqInt) primitiveGetWindowLabel(struct foo * self);
EXPORT(sqInt) primitiveGetWindowSize(struct foo * self);
static void primitiveGreaterOrEqual(struct foo * self);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(struct foo * self);
static void primitiveGreaterThan(struct foo * self);
EXPORT(void) primitiveGreaterThanLargeIntegers(struct foo * self);
static void primitiveGrowMemoryByAtLeast(struct foo * self);
static void primitiveHashMultiply(struct foo * self);
EXPORT(sqInt) primitiveHeartbeatFrequency(struct foo * self);
EXPORT(sqInt) primitiveHighResClock(struct foo * self);
static void primitiveIdentical(struct foo * self);
static void primitiveIdentityHash(struct foo * self);
EXPORT(sqInt) primitiveImageFormatVersion(struct foo * self);
static void primitiveImageName(struct foo * self);
static void primitiveImmediateAsInteger(struct foo * self);
static void primitiveInputSemaphore(struct foo * self);
static void primitiveInputWord(struct foo * self);
static void primitiveIntegerAt(struct foo * self);
static void primitiveIntegerAtPut(struct foo * self);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(struct foo * self);
static void primitiveInterruptSemaphore(struct foo * self);
static void primitiveInvokeObjectAsMethod(struct foo * self);
EXPORT(sqInt) primitiveIsBigEnder(struct foo * self);
static void primitiveIsPinned(struct foo * self);
EXPORT(sqInt) primitiveIsWindowObscured(struct foo * self);
static void primitiveKbdNext(struct foo * self);
static void primitiveKbdPeek(struct foo * self);
static void primitiveLessOrEqual(struct foo * self);
EXPORT(void) primitiveLessOrEqualLargeIntegers(struct foo * self);
static void primitiveLessThan(struct foo * self);
EXPORT(void) primitiveLessThanLargeIntegers(struct foo * self);
static void primitiveListBuiltinModule(struct foo * self);
static void primitiveListExternalModule(struct foo * self);
static void primitiveLoadImageSegment(struct foo * self);
static void primitiveLocalMicrosecondClock(struct foo * self);
static void primitiveLogN(struct foo * self);
static void primitiveLowSpaceSemaphore(struct foo * self);
static void primitiveMakePoint(struct foo * self);
static void primitiveMaxIdentityHash(struct foo * self);
extern usqInt primitiveMethod(struct foo * self);
static void primitiveMillisecondClock(struct foo * self);
EXPORT(sqInt) primitiveMillisecondClockMask(struct foo * self);
static void primitiveMod(struct foo * self);
EXPORT(void) primitiveModLargeIntegers(struct foo * self);
static void primitiveMouseButtons(struct foo * self);
static void primitiveMousePoint(struct foo * self);
static void primitiveMultiply(struct foo * self);
EXPORT(void) primitiveMultiplyLargeIntegers(struct foo * self);
static void primitiveNew(struct foo * self);
static void primitiveNewMethod(struct foo * self);
static void primitiveNewWithArg(struct foo * self);
static void primitiveNextInstance(struct foo * self);
static void primitiveNextObject(struct foo * self);
static void primitiveNoop(struct foo * self);
static void primitiveNotEqual(struct foo * self);
EXPORT(void) primitiveNotEqualLargeIntegers(struct foo * self);
static void primitiveNotIdentical(struct foo * self);
static void primitiveObjectAt(struct foo * self);
static void primitiveObjectAtPut(struct foo * self);
EXPORT(sqInt) primitivePathToUsing(struct foo * self);
static void primitivePerformInSuperclass(struct foo * self);
static void primitivePerformWithArgs(struct foo * self);
EXPORT(sqInt) primitiveProfilePrimitive(struct foo * self);
EXPORT(sqInt) primitiveProfileSample(struct foo * self);
EXPORT(sqInt) primitiveProfileSemaphore(struct foo * self);
EXPORT(sqInt) primitiveProfileStart(struct foo * self);
static void primitiveQuit(struct foo * self);
static void primitiveQuo(struct foo * self);
EXPORT(void) primitiveQuoLargeIntegers(struct foo * self);
static void primitiveRelinquishProcessor(struct foo * self);
EXPORT(void) primitiveRemLargeIntegers(struct foo * self);
static void primitiveResume(struct foo * self);
static void primitiveScanCharacters(struct foo * self);
EXPORT(sqInt) primitiveScreenDepth(struct foo * self);
EXPORT(sqInt) primitiveScreenScaleFactor(struct foo * self);
static void primitiveScreenSize(struct foo * self);
static void primitiveSecondsClock(struct foo * self);
static void primitiveSetDisplayMode(struct foo * self);
static void primitiveSetFullScreen(struct foo * self);
#if IMMUTABILITY
static void primitiveSetImmutability(struct foo * self);
#else
# define primitiveSetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
static void primitiveSetInterruptKey(struct foo * self);
EXPORT(sqInt) primitiveSetLogDirectory(struct foo * self);
static void primitiveSetOrHasIdentityHash(struct foo * self);
EXPORT(sqInt) primitiveSetWindowLabel(struct foo * self);
EXPORT(sqInt) primitiveSetWindowSize(struct foo * self);
static void primitiveShortAt(struct foo * self);
static void primitiveShortAtPut(struct foo * self);
static void primitiveShowDisplayRect(struct foo * self);
static void primitiveSignal(struct foo * self);
static void primitiveSignalAtBytesLeft(struct foo * self);
static void primitiveSine(struct foo * self);
static void primitiveSize(struct foo * self);
static void primitiveSizeInBytes(struct foo * self);
static void primitiveSizeInBytesOfInstance(struct foo * self);
static void primitiveSmallFloatAdd(struct foo * self);
static void primitiveSmallFloatArctan(struct foo * self);
static void primitiveSmallFloatDivide(struct foo * self);
static void primitiveSmallFloatEqual(struct foo * self);
static void primitiveSmallFloatExp(struct foo * self);
static void primitiveSmallFloatExponent(struct foo * self);
static void primitiveSmallFloatFractionalPart(struct foo * self);
static void primitiveSmallFloatGreaterOrEqual(struct foo * self);
static void primitiveSmallFloatGreaterThan(struct foo * self);
static void primitiveSmallFloatLessOrEqual(struct foo * self);
static void primitiveSmallFloatLessThan(struct foo * self);
static void primitiveSmallFloatLogN(struct foo * self);
static void primitiveSmallFloatMultiply(struct foo * self);
static void primitiveSmallFloatNotEqual(struct foo * self);
static void primitiveSmallFloatSine(struct foo * self);
static void primitiveSmallFloatSquareRoot(struct foo * self);
static void primitiveSmallFloatSubtract(struct foo * self);
static void primitiveSmallFloatTimesTwoPower(struct foo * self);
static void primitiveSmallFloatTruncated(struct foo * self);
static void primitiveSnapshot(struct foo * self);
static void primitiveSnapshotEmbedded(struct foo * self);
static void primitiveSomeInstance(struct foo * self);
static void primitiveSomeObject(struct foo * self);
static void primitiveSpecialObjectsOop(struct foo * self);
static void primitiveSquareRoot(struct foo * self);
static void primitiveStoreImageSegment(struct foo * self);
static void primitiveStringAt(struct foo * self);
static void primitiveStringAtPut(struct foo * self);
static void primitiveStringReplace(struct foo * self);
static void primitiveSubtract(struct foo * self);
EXPORT(void) primitiveSubtractLargeIntegers(struct foo * self);
static void primitiveSuspend(struct foo * self);
static void primitiveTestAndSetOwnershipOfCriticalSection(struct foo * self);
static void primitiveTestDisplayDepth(struct foo * self);
static void primitiveTimesTwoPower(struct foo * self);
static void primitiveTruncated(struct foo * self);
static void primitiveUnloadModule(struct foo * self);
static void primitiveUpdateTimezone(struct foo * self);
static void primitiveUTCMicrosecondClock(struct foo * self);
static void primitiveUtcAndTimezoneOffset(struct foo * self);
EXPORT(sqInt) primitiveUtcWithOffset(struct foo * self);
static void primitiveVMPath(struct foo * self);
static void primitiveVMProfileSamplesInto(struct foo * self);
static void primitiveWait(struct foo * self);
static void primitiveYield(struct foo * self);
extern sqInt signalNoResume(sqInt aSemaphore, struct foo * self);
extern int signed32BitValueOf(sqInt oop, struct foo * self);
extern sqLong signed64BitValueOf(sqInt oop, struct foo * self);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop, struct foo * self);
extern usqInt sizeOfAlienData(sqInt oop, struct foo * self);
extern void * startOfAlienData(sqInt oop, struct foo * self);
extern sqInt success(sqInt successBoolean, struct foo * self);
static sqInt NoDbgRegParms initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage, struct foo * self);
static sqInt NoDbgRegParms pageIndexFor(void *pointer, struct foo * self);
static usqInt NoDbgRegParms addressAfter(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex, struct foo * self);
static sqInt NoDbgRegParms allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex, struct foo * self);
extern sqInt byteSwapped(sqInt w, struct foo * self);
static usqInt NoDbgRegParms bytesInObject(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms changeClassOfto(sqInt rcvr, sqInt argClass, struct foo * self);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop, struct foo * self);
static sqInt defaultEdenBytes(struct foo * self);
extern sqInt fetchClassTagOf(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms fetchLong32ofFloatObject(sqInt fieldIndex, sqInt oop, struct foo * self);
extern sqInt floatObjectOf(double aFloat, struct foo * self);
extern double floatValueOf(sqInt oop, struct foo * self);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader, struct foo * self);
static sqInt NoDbgRegParms initFreeChunkWithBytesat(usqLong numBytes, sqInt address, struct foo * self);
static void NoDbgRegParms initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address, struct foo * self);
extern sqInt instantiateClassindexableSize(sqInt classObj, usqInt nElements, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern sqInt integerValueOf(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isImmediateFloat(sqInt oop, struct foo * self);
extern sqInt isIntegerObject(sqInt oop, struct foo * self);
extern sqInt isIntegerValue(sqInt intValue, struct foo * self);
static sqInt NoDbgRegParms isLilliputianSize(sqInt chunkBytes, struct foo * self);
extern sqInt isMarked(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isSmallFloatValue(double aFloat, struct foo * self);
static sqInt NoDbgRegParms lengthOfformat(sqInt objOop, sqInt fmt, struct foo * self);
static sqInt maxSlotsForAlloc(struct foo * self);
static sqInt numFreeLists(struct foo * self);
extern sqInt shortentoIndexableSize(sqInt objOop, sqInt indexableSize, struct foo * self);
static double NoDbgRegParms smallFloatValueOf(sqInt oop, struct foo * self);
extern usqInt smallObjectBytesForSlots(sqInt numSlots, struct foo * self);
static sqInt wordIndexableFormat(struct foo * self);
static void NoDbgRegParms NeverInline addToEphemeronList(sqInt ephemeronCorpse, struct foo * self);
static void NoDbgRegParms NeverInline addToWeakList(sqInt weakCorpse, struct foo * self);
static sqInt allNewSpaceObjectsHaveZeroRTRefCount(struct foo * self);
static sqInt allWeakSurvivorsOnWeakList(struct foo * self);
static void NeverInline computeRefCountToShrinkRT(struct foo * self);
static sqInt NoDbgRegParms copyAndForwardMourner(sqInt mourner, struct foo * self);
static sqInt NoDbgRegParms copyAndForward(sqInt survivor, struct foo * self);
static sqInt NoDbgRegParms NeverInline copyToOldSpacebytesformat(sqInt survivor, sqInt bytesInObject, sqInt formatOfSurvivor, struct foo * self);
static usqInt NoDbgRegParms firstCorpse(sqInt headOfCorpseList, struct foo * self);
static void growRememberedSet(struct foo * self);
static sqInt NoDbgRegParms isInRememberedSet(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isMaybeOldScavengeSurvivor(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isScavengeSurvivor(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isonWeaklingList(sqInt oop, sqInt listHead, struct foo * self);
static usqInt newSpaceCapacity(struct foo * self);
static sqInt noUnfiredEphemeronsAtEndOfRememberedSet(struct foo * self);
extern void openScavengeLog(struct foo * self);
extern void printRememberedSet(struct foo * self);
static void processEphemerons(struct foo * self);
static void processWeaklings(struct foo * self);
static sqInt NoDbgRegParms processWeakSurvivor(sqInt weakObj, struct foo * self);
extern sqInt remember(sqInt objOop, struct foo * self);
static void NoDbgRegParms scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress, struct foo * self);
static void scavengeLoop(struct foo * self);
static sqInt NoDbgRegParms scavengeReferentsOf(sqInt referrer, struct foo * self);
static void NoDbgRegParms scavengeRememberedSetStartingAt(sqInt n, struct foo * self);
static float scavengerTenuringThreshold(struct foo * self);
static sqInt scavengeUnfiredEphemeronsOnEphemeronList(struct foo * self);
static void NeverInline writeScavengeLog(struct foo * self);
static sqInt NoDbgRegParms accessibleObjectAfter(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms NeverInline activeAndDeferredScan(sqInt anEphemeron, struct foo * self);
static void NoDbgRegParms addFreeSubTree(sqInt freeTree, struct foo * self);
extern sqInt addGCRoot(sqInt *varLoc, struct foo * self);
extern sqInt addressCouldBeObj(sqInt address, struct foo * self);
extern sqInt addressCouldBeOop(sqInt address, struct foo * self);
static sqInt NoDbgRegParms addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes, struct foo * self);
static sqInt NoDbgRegParms allInstancesOf(sqInt aClass, struct foo * self);
static sqInt allObjects(struct foo * self);
static sqInt allObjectsUnmarked(struct foo * self);
static sqInt allOldMarkedWeakObjectsOnWeaklingStack(struct foo * self);
static sqInt allocateLargestFreeChunk(struct foo * self);
static sqInt NoDbgRegParms allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex, struct foo * self);
static sqInt NoDbgRegParms allocateOldSpaceChunkOfBytes(usqInt chunkBytes, struct foo * self);
extern sqInt allocatePinnedSlots(sqInt nSlots, struct foo * self);
static sqInt allocationUnit(struct foo * self);
static sqInt NoDbgRegParms allStrongSlotsOfWeaklingAreMarked(sqInt aWeakling, struct foo * self);
static sqInt allUnscannedEphemeronsAreActive(struct foo * self);
extern sqInt arrayFormat(struct foo * self);
static sqInt NoDbgRegParms NeverInline assertInnerValidFreeObject(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms becomeEffectFlagsFor(sqInt objOop, struct foo * self);
extern sqInt becomewith(sqInt array1, sqInt array2, struct foo * self);
static sqInt NoDbgRegParms becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag, struct foo * self);
extern void beRootIfOld(sqInt oop, struct foo * self);
static sqInt bitsSetInFreeSpaceMaskForAllFreeLists(struct foo * self);
static sqInt bridgeSize(struct foo * self);
static sqInt byteFormatMask(struct foo * self);
extern sqInt byteSizeOf(sqInt oop, struct foo * self);
extern sqInt characterObjectOf(sqInt characterCode, struct foo * self);
extern void characterTable(struct foo * self);
extern usqInt characterValueOf(sqInt oop, struct foo * self);
extern sqInt checkedLongAt(sqInt byteAddress, struct foo * self);
static sqInt checkHeapFreeSpaceIntegrity(struct foo * self);
static sqInt NoDbgRegParms checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid, struct foo * self);
extern sqInt checkOkayOop(usqInt oop, struct foo * self);
extern sqInt checkOopHasOkayClass(usqInt obj, struct foo * self);
static sqInt NoDbgRegParms checkOopIntegritynamed(sqInt obj, char *name, struct foo * self);
static sqInt NoDbgRegParms checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i, struct foo * self);
extern sqInt classAlien(struct foo * self);
extern sqInt classArray(struct foo * self);
extern sqInt classAtIndex(sqInt classIndex, struct foo * self);
static sqInt NoDbgRegParms classAtIndexput(sqInt classIndex, sqInt objOop, struct foo * self);
extern sqInt classBitmap(struct foo * self);
extern sqInt classByteArray(struct foo * self);
extern sqInt classCharacter(struct foo * self);
extern sqInt classExternalAddress(struct foo * self);
extern sqInt classExternalData(struct foo * self);
extern sqInt classExternalFunction(struct foo * self);
extern sqInt classExternalLibrary(struct foo * self);
extern sqInt classExternalStructure(struct foo * self);
extern sqInt classFloat(struct foo * self);
static sqInt NoDbgRegParms classFormatForInstanceFormat(sqInt aFormat, struct foo * self);
static sqInt classIndexFieldWidth(struct foo * self);
extern sqInt classIndexOf(sqInt objOop, struct foo * self);
extern sqInt classLargeNegativeInteger(struct foo * self);
extern sqInt classLargePositiveInteger(struct foo * self);
extern sqInt classOrNilAtIndex(sqInt classIndex, struct foo * self);
extern sqInt classPoint(struct foo * self);
extern sqInt classSemaphore(struct foo * self);
extern sqInt classSmallInteger(struct foo * self);
extern sqInt classString(struct foo * self);
extern sqInt classTableMinorIndexMask(struct foo * self);
extern sqInt classTablePageSize(struct foo * self);
extern sqInt classTableRootObj(struct foo * self);
static sqInt classTableRootSlots(struct foo * self);
extern sqInt classTagForClass(sqInt classObj, struct foo * self);
extern sqInt classUnsafeAlien(struct foo * self);
static void clearLeakMapAndMapAccessibleFreeSpace(struct foo * self);
static void clearLeakMapAndMapAccessibleObjects(struct foo * self);
static sqInt NoDbgRegParms cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning, struct foo * self);
extern sqInt clone(sqInt objOop, struct foo * self);
extern sqInt compactClassIndexOf(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms copyObjtoAddrstopAtsavedFirstFieldsindex(sqInt objOop, sqInt segAddr, sqInt endSeg, sqInt savedFirstFields, sqInt i, struct foo * self);
extern void countMarkedAndUnmarkdObjects(sqInt printFlags, struct foo * self);
static usqLong currentAllocatedBytes(struct foo * self);
extern sqInt displayObject(struct foo * self);
static void NoDbgRegParms doScavenge(sqInt tenuringCriterion, struct foo * self);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots, struct foo * self);
static void NoDbgRegParms emptyObjStack(sqInt objStack, struct foo * self);
static sqInt NoDbgRegParms ensureRoomOnObjStackAt(sqInt objStackRootIndex, struct foo * self);
static sqInt NoDbgRegParms enterIntoClassTable(sqInt aBehavior, struct foo * self);
static sqInt ephemeronFormat(struct foo * self);
static sqInt NoDbgRegParms existInstancesInNewSpaceOf(sqInt classObj, struct foo * self);
static void NoDbgRegParms expungeFromClassTable(sqInt aBehavior, struct foo * self);
extern sqInt falseObject(struct foo * self);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms NeverInline fetchClassOfNonImm(sqInt objOop, struct foo * self);
extern sqInt fetchClassOf(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt obj, struct foo * self);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop, struct foo * self);
static sqInt NoDbgRegParms fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop, struct foo * self);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt objOop, struct foo * self);
static sqInt findLargestFreeChunk(struct foo * self);
extern void findStringBeginningWith(char *aCString, struct foo * self);
extern void findString(char *aCString, struct foo * self);
static sqInt firstAccessibleObject(struct foo * self);
static void * NoDbgRegParms firstFixedFieldOfMaybeImmediate(sqInt oop, struct foo * self);
extern void * firstFixedField(sqInt objOop, struct foo * self);
extern void * firstIndexableField(sqInt objOop, struct foo * self);
static sqInt firstStringyFakeFormat(struct foo * self);
extern sqInt fixedFieldsOfClassFormatMask(struct foo * self);
extern sqInt fixedFieldsOfClassFormat(sqInt classFormat, struct foo * self);
static sqInt NoDbgRegParms fixedFieldsOfClass(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength, struct foo * self);
static sqInt NoDbgRegParms NeverInline fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue, struct foo * self);
static sqInt NoDbgRegParms followFieldofObject(sqInt fieldIndex, sqInt anObject, struct foo * self);
extern sqInt followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth, struct foo * self);
extern sqInt followForwarded(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms followObjFieldofObject(sqInt fieldIndex, sqInt anObject, struct foo * self);
extern sqInt formatOfClass(sqInt classPointer, struct foo * self);
static sqInt NoDbgRegParms formatOf(sqInt objOop, struct foo * self);
static sqInt forwardedFormat(struct foo * self);
static sqInt NoDbgRegParms forwardersIn(sqInt anObject, struct foo * self);
static sqInt freeChunkNextIndex(struct foo * self);
static sqInt freeChunkParentIndex(struct foo * self);
static sqInt freeChunkPrevIndex(struct foo * self);
static sqInt NoDbgRegParms freeChunkWithBytesat(sqInt bytes, sqInt address, struct foo * self);
extern sqInt freeObject(sqInt objOop, struct foo * self);
extern usqLong NeverInline fullGC(struct foo * self);
static float getHeapGrowthToSizeGCRatio(struct foo * self);
static sqInt NoDbgRegParms goodContextSize(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms growOldSpaceByAtLeast(sqInt minAmmount, struct foo * self);
extern usqLong headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex, struct foo * self);
static usqLong NoDbgRegParms headerForSlotshashformatclassIndex(sqInt numSlots, sqInt hash, sqInt formatField, sqInt classIndex, struct foo * self);
static sqInt hiddenRootSlots(struct foo * self);
static sqInt hiddenRootsObject(struct foo * self);
static sqInt imageSegmentVersion(struct foo * self);
#if IMMUTABILITY
extern sqInt immutableBitMask(struct foo * self);
#endif /* IMMUTABILITY */
extern void incrementalGC(struct foo * self);
extern sqInt indexOfin(sqInt anElement, sqInt anObject, struct foo * self);
static void NoDbgRegParms inFreeTreeReplacewith(sqInt treeNode, sqInt newNode, struct foo * self);
static sqInt NoDbgRegParms initialInstanceOf(sqInt classObj, struct foo * self);
static void NeverInline initializeNewSpaceVariables(struct foo * self);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift, struct foo * self);
extern void inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList, struct foo * self);
static void NoDbgRegParms NeverInline inPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag, struct foo * self);
extern sqInt instanceSizeOf(sqInt classObj, struct foo * self);
static sqInt NoDbgRegParms instantiateClass(sqInt classObj, struct foo * self);
extern sqInt instSpecOfClassFormat(sqInt classFormat, struct foo * self);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer, struct foo * self);
static sqInt NoDbgRegParms isAnyPointerFormat(sqInt format, struct foo * self);
extern sqInt isArrayNonImm(sqInt oop, struct foo * self);
extern sqInt isArray(sqInt oop, struct foo * self);
extern sqInt isBytes(sqInt oop, struct foo * self);
extern sqInt isCharacterObject(sqInt oop, struct foo * self);
extern sqInt isCharacterValue(sqInt anInteger, struct foo * self);
static sqInt NoDbgRegParms isClassAtUniqueIndex(sqInt aClass, struct foo * self);
static sqInt NoDbgRegParms isCompiledMethodFormat(sqInt format, struct foo * self);
extern sqInt isCompiledMethod(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isContextHeader(sqInt aHeader, struct foo * self);
static sqInt NoDbgRegParms isContextNonImm(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isContext(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isCopiedIntoSegment(sqInt anObjectInTheHeap, struct foo * self);
static sqInt NoDbgRegParms isEmptyObjStack(sqInt objStack, struct foo * self);
static sqInt NoDbgRegParms isEnumerableObjectNoAssert(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isEnumerableObject(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isEphemeronFormat(sqInt format, struct foo * self);
static sqInt NoDbgRegParms isEphemeron(sqInt objOop, struct foo * self);
extern sqInt isFixedSizePointerFormat(sqInt format, struct foo * self);
static sqInt NoDbgRegParms isForwardedClassTag(sqInt classIndex, struct foo * self);
extern sqInt isForwarded(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isFreeObject(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isFreeOop(sqInt oop, struct foo * self);
extern sqInt isImmediate(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isInClassTable(sqInt objOop, struct foo * self);
extern sqInt isIndexable(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isInEden(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isInFutureSpace(sqInt address, struct foo * self);
extern sqInt isInMemory(sqInt address, struct foo * self);
static sqInt NoDbgRegParms isInNewSpace(sqInt objOop, struct foo * self);
extern sqInt isInOldSpace(sqInt address, struct foo * self);
static sqInt NoDbgRegParms isInPastSpace(sqInt address, struct foo * self);
static sqInt NoDbgRegParms isLargeFreeObject(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isMaybeFiredEphemeron(sqInt objOop, struct foo * self);
extern sqInt isNonImmediate(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isObjEphemeron(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isObjImmutable(sqInt anOop, struct foo * self);
extern sqInt isOldObject(sqInt objOop, struct foo * self);
extern sqInt isOopCompiledMethod(sqInt oop, struct foo * self);
extern sqInt isOopForwarded(sqInt oop, struct foo * self);
extern sqInt isOopImmutable(sqInt oop, struct foo * self);
extern sqInt isOopMutable(sqInt oop, struct foo * self);
extern sqInt isPinned(sqInt objOop, struct foo * self);
extern sqInt isPointers(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format, struct foo * self);
extern sqInt isReallyYoungObject(sqInt obj, struct foo * self);
extern sqInt isReallyYoung(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isRemembered(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms isSegmentBridge(sqInt objOop, struct foo * self);
extern sqInt isUnambiguouslyForwarder(sqInt objOop, struct foo * self);
extern sqInt isUnmarked(sqInt objOop, struct foo * self);
extern sqInt isValidClassTag(sqInt classIndex, struct foo * self);
static sqInt NoDbgRegParms isValidObjStackAt(sqInt objStackRootIndex, struct foo * self);
static sqInt NoDbgRegParms isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx, struct foo * self);
static sqInt NoDbgRegParms isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage, struct foo * self);
static sqInt NoDbgRegParms isValidObjStack(sqInt objStack, struct foo * self);
static sqInt NoDbgRegParms isWeakFormat(sqInt format, struct foo * self);
static sqInt NoDbgRegParms isWeakNonImm(sqInt objOop, struct foo * self);
extern sqInt isWeak(sqInt oop, struct foo * self);
extern sqInt isWordsOrBytes(sqInt oop, struct foo * self);
extern sqInt isWords(sqInt oop, struct foo * self);
extern sqInt isYoungObject(sqInt objOop, struct foo * self);
extern sqInt isYoung(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex, struct foo * self);
static sqInt NoDbgRegParms isonObjStack(sqInt oop, sqInt objStack, struct foo * self);
static sqInt NoDbgRegParms keyOfEphemeron(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms knownClassAtIndex(sqInt classIndex, struct foo * self);
static sqInt lastPointerFormat(struct foo * self);
extern sqInt lastPointerOfWhileSwizzling(sqInt objOop, struct foo * self);
extern sqInt lastPointerOf(sqInt objOop, struct foo * self);
extern sqInt leakCheckBecome(struct foo * self);
extern sqInt leakCheckFullGC(struct foo * self);
extern sqInt leakCheckIncremental(struct foo * self);
extern sqInt leakCheckNewSpaceGC(struct foo * self);
static sqInt NoDbgRegParms lengthOfMaybeImmediate(sqInt oop, struct foo * self);
extern sqInt lengthOf(sqInt objOop, struct foo * self);
extern sqInt literalCountOfMethodHeader(sqInt header, struct foo * self);
extern sqInt literalCountOf(sqInt methodPointer, struct foo * self);
static sqInt NoDbgRegParms NeverInline loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray, struct foo * self);
extern void longPrintInstancesOf(sqInt aClassOop, struct foo * self);
extern void longPrintInstancesWithClassIndex(sqInt classIndex, struct foo * self);
extern void longPrintReferencesTo(sqInt anOop, struct foo * self);
static void mapExtraRoots(struct foo * self);
static void NeverInline mapMournQueue(struct foo * self);
static sqInt NoDbgRegParms mapOopsFromtooutPointersoutHashes(sqInt segStart, sqInt segAddr, sqInt outPointerArray, sqInt savedOutHashes, struct foo * self);
static void NoDbgRegParms markAndTraceClassOf(sqInt objOop, struct foo * self);
static void NoDbgRegParms markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents, struct foo * self);
extern void NeverInline markAndTrace(sqInt objOop, struct foo * self);
static sqInt markInactiveEphemerons(struct foo * self);
static void NoDbgRegParms NeverInline markObjects(sqInt objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged, struct foo * self);
static void markWeaklingsAndMarkAndFireEphemerons(struct foo * self);
extern sqInt maybeMethodClassOfseemsToBeInstantiating(sqInt methodObj, sqInt format, struct foo * self);
extern sqInt maybeSplObj(sqInt index, struct foo * self);
static sqInt memoryActiveProcess(struct foo * self);
static sqInt NoDbgRegParms methodHeaderOf(sqInt methodObj, struct foo * self);
extern sqInt minSlotsForShortening(struct foo * self);
static sqInt newObjectHash(struct foo * self);
static sqInt newSpaceIsEmpty(struct foo * self);
extern sqInt nilObject(struct foo * self);
static void NeverInline nilUnmarkedWeaklingSlots(struct foo * self);
static sqInt NoDbgRegParms noCheckClassAtIndex(sqInt classIndex, struct foo * self);
static sqInt NoDbgRegParms noCheckPushonObjStack(sqInt objOop, sqInt objStack, struct foo * self);
static sqInt NoDbgRegParms noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject, struct foo * self);
static sqInt NoDbgRegParms noInlineObjectAfterlimit(sqInt objOop, sqInt limit, struct foo * self);
extern sqInt nonIndexablePointerFormat(struct foo * self);
static sqInt noUnscannedEphemerons(struct foo * self);
static sqInt NoDbgRegParms numBytesOfBytes(sqInt objOop, struct foo * self);
extern sqInt numBytesOf(sqInt objOop, struct foo * self);
extern usqInt numPointerSlotsOf(sqInt objOop, struct foo * self);
static usqInt NoDbgRegParms numSlotsOfAny(sqInt objOop, struct foo * self);
extern usqInt numSlotsOf(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms numStrongSlotsOfInephemeral(sqInt objOop, struct foo * self);
extern sqInt numStrongSlotsOfWeakling(sqInt objOop, struct foo * self);
extern sqInt objectAfter(sqInt objOop, struct foo * self);
extern sqInt objectBefore(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms objectStartingAt(sqInt address, struct foo * self);
static sqInt NoDbgRegParms NeverInline objectsReachableFromRoots(sqInt arrayOfRoots, struct foo * self);
extern sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop, struct foo * self);
static sqInt NoDbgRegParms okayOop(sqInt signedOop, struct foo * self);
extern sqInt oldSpaceObjectAfter(sqInt objOop, struct foo * self);
static void NoDbgRegParms NeverInline outOfPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag, struct foo * self);
extern sqInt pinObject(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms popObjStack(sqInt objStack, struct foo * self);
extern sqInt popRemappableOop(struct foo * self);
static void NoDbgRegParms postBecomeScanClassTable(sqInt effectsFlags, struct foo * self);
extern sqInt primitiveErrorTable(struct foo * self);
extern void printActivationsOf(sqInt aMethodObj, struct foo * self);
extern void printBogons(struct foo * self);
extern void printContextReferencesTo(sqInt anOop, struct foo * self);
extern void printEntity(sqInt oop, struct foo * self);
extern void printForwarders(struct foo * self);
extern void printFreeChunks(struct foo * self);
extern void printFreeChunk(sqInt freeChunk, struct foo * self);
static void NoDbgRegParms printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode, struct foo * self);
extern void printFreeListHeads(struct foo * self);
extern sqInt printFreeList(sqInt chunkOrIndex, struct foo * self);
extern void printFreeTree(struct foo * self);
static void NoDbgRegParms printFreeTreeChunk(sqInt chunkOrZero, struct foo * self);
extern void printHeaderOf(sqInt objOop, struct foo * self);
static void NoDbgRegParms printHeaderTypeOf(sqInt objOop, struct foo * self);
extern void printInstancesOf(sqInt aClassOop, struct foo * self);
extern void printInstancesWithClassIndex(sqInt classIndex, struct foo * self);
extern void printInvalidClassTableEntries(struct foo * self);
#if LLDB
extern void printMarkedOops(struct foo * self);
#endif /* LLDB */
extern void printMethodImplementorsOf(sqInt anOop, struct foo * self);
extern void printMethodReferencesTo(sqInt anOop, struct foo * self);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress, struct foo * self);
extern void printObjectsWithHash(sqInt hash, struct foo * self);
static void NoDbgRegParms printObjStackPagemyIndexpageType(sqInt objStackPage, sqInt myx, sqInt pageType, struct foo * self);
static void NoDbgRegParms printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType, struct foo * self);
extern void printObjStack(sqInt objStack, struct foo * self);
extern void NeverInline printOopsExcept(sqInt (*function)(sqInt), struct foo * self);
extern void printOopsFromto(sqInt startAddress, sqInt endAddress, struct foo * self);
extern void NeverInline printOopsSuchThat(sqInt (*function)(sqInt), struct foo * self);
extern void printReferencesTo(sqInt anOop, struct foo * self);
#if LLDB
extern void printUnmarkedOops(struct foo * self);
#endif /* LLDB */
static sqInt NoDbgRegParms pushOnUnscannedEphemeronsStack(sqInt anEphemeron, struct foo * self);
extern void pushRemappableOop(sqInt oop, struct foo * self);
static void NoDbgRegParms queueMourner(sqInt anEphemeronOrWeakArray, struct foo * self);
extern sqInt rawHashBitsOf(sqInt objOop, struct foo * self);
static sqInt NoDbgRegParms relocateObjStackForPlanningCompactor(sqInt objStack, struct foo * self);
extern sqInt removeGCRoot(sqInt *varLoc, struct foo * self);
static sqInt NoDbgRegParms returnrestoringObjectsInsavedFirstFieldsandsavedHashes(sqInt errCode, sqInt firstArray, sqInt savedFirstFields, sqInt secondArray, sqInt savedHashes, struct foo * self);
static sqInt NoDbgRegParms returnrestoringObjectsInupTosavedFirstFields(sqInt errCode, sqInt firstArray, sqInt limitOrTag, sqInt savedFirstFields, struct foo * self);
static void NoDbgRegParms NeverInline reverseBytesIn32BitWordsIn(sqInt segmentWordArray, struct foo * self);
static void NoDbgRegParms runLeakCheckerForFreeSpace(sqInt gcModes, struct foo * self);
static void NoDbgRegParms runLeakCheckerFor(sqInt gcModes, struct foo * self);
static void NoDbgRegParms runLeakCheckerForexcludeUnmarkedObjsclassIndicesShouldBeValid(sqInt gcModes, sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid, struct foo * self);
static void NoDbgRegParms scavengingGCTenuringIf(sqInt tenuringCriterion, struct foo * self);
static sqInt NoDbgRegParms NeverInline setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd, struct foo * self);
extern void shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress, struct foo * self);
extern sqInt shouldRemapOop(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms sizeOfObjStack(sqInt objStack, struct foo * self);
static sqInt slidingCompactionInProgress(struct foo * self);
extern sqInt slotSizeOf(sqInt oop, struct foo * self);
extern sqInt splObj(sqInt index, struct foo * self);
static usqInt NoDbgRegParms startOfObject(sqInt objOop, struct foo * self);
EXPORT(sqInt) statNumGCs(struct foo * self);
extern usqInt storeCheckBoundary(struct foo * self);
static sqInt NoDbgRegParms storeImageSegmentIntooutPointersroots(sqInt segmentWordArrayArg, sqInt outPointerArrayArg, sqInt arrayOfRootsArg, struct foo * self);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer, struct foo * self);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer, struct foo * self);
extern sqInt stringForCString(const char *aCString, struct foo * self);
static sqInt NoDbgRegParms sufficientSpaceAfterGC(sqInt numBytes, struct foo * self);
static sqInt NoDbgRegParms swizzleObjStackAt(sqInt objStackRootIndex, struct foo * self);
extern void tenuringIncrementalGC(struct foo * self);
static sqInt NoDbgRegParms topOfObjStack(sqInt objStack, struct foo * self);
extern sqInt topRemappableOop(struct foo * self);
static sqInt totalFreeListBytes(struct foo * self);
extern sqInt trueObject(struct foo * self);
static sqInt NoDbgRegParms unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes, struct foo * self);
static sqInt NoDbgRegParms NeverInline unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index, struct foo * self);
static void NoDbgRegParms unlinkSolitaryFreeTreeNode(sqInt freeTreeNode, struct foo * self);
extern sqInt unpinObject(sqInt objOop, struct foo * self);
static void NoDbgRegParms updateListStartingAt(sqInt freeNode, struct foo * self);
static sqInt validClassTableHashes(struct foo * self);
static sqInt validClassTableRootPages(struct foo * self);
extern sqInt validFreeTree(struct foo * self);
static sqInt NoDbgRegParms validFreeTreeChunk(sqInt chunk, struct foo * self);
static const char * NoDbgRegParms validFreeTreeChunkparent(sqInt chunk, sqInt parent, struct foo * self);
static sqInt validObjStacks(struct foo * self);
extern sqInt vmEndianness(struct foo * self);
static void NeverInline compact(struct foo * self);
static sqInt NeverInline copyAndUnmarkMobileObjects(struct foo * self);
static void NoDbgRegParms NeverInline copyAndUnmark(sqInt firstPass, struct foo * self);
static void NoDbgRegParms freeFromupTonextObject(usqInt initialToFinger, usqInt limit, sqInt nextObject, struct foo * self);
static sqInt initializeScanCheckingForFullyCompactedHeap(struct foo * self);
static sqInt NoDbgRegParms isMobile(sqInt obj, struct foo * self);
static sqInt NoDbgRegParms isPostMobile(sqInt obj, struct foo * self);
static sqInt NeverInline planCompactSavingForwarders(struct foo * self);
static void NoDbgRegParms reinitializeScanFrom(sqInt initialObject, struct foo * self);
extern sqInt remapObj(sqInt objOop, struct foo * self);
static sqInt savedFirstFieldsSpaceWasAllocated(struct foo * self);
static sqInt NoDbgRegParms scanForFirstFreeAndFirstMobileObjectFrom(sqInt initialObject, struct foo * self);
extern sqInt shouldRemapObj(sqInt objOop, struct foo * self);
static void NeverInline updatePointers(struct foo * self);
static void NoDbgRegParms updatePointersInsavedFirstFieldPointer(sqInt obj, sqInt firstFieldPtr, struct foo * self);
static sqInt NoDbgRegParms useSegmentForSavedFirstFieldsSpace(sqInt spaceEstimate, struct foo * self);
static sqInt NoDbgRegParms validRelocationPlanInPass(sqInt onePass, struct foo * self);
static usqInt NoDbgRegParms segLimit(SpurSegmentInfo * self_in_segLimit, struct foo * self);
static SpurSegmentInfo * NoDbgRegParms addSegmentOfSize(sqInt ammount, struct foo * self);
static void NoDbgRegParms adjustSegmentSwizzlesBy(sqInt firstSegmentShift, struct foo * self);
static sqInt allBridgesMarked(struct foo * self);
static void allocateOrExtendSegmentInfos(struct foo * self);
static sqInt NoDbgRegParms bridgeAt(sqInt segIndex, struct foo * self);
static sqInt NoDbgRegParms bridgeFor(SpurSegmentInfo *aSegment, struct foo * self);
static void NoDbgRegParms bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil, struct foo * self);
static void checkSegments(struct foo * self);
static void collapseSegmentsPostSwizzle(struct foo * self);
static void * NoDbgRegParms firstGapOfSizeAtLeast(sqInt size, struct foo * self);
static sqInt NoDbgRegParms isEmptySegment(SpurSegmentInfo *seg, struct foo * self);
static sqInt NoDbgRegParms isInSegments(usqInt address, struct foo * self);
static sqInt NoDbgRegParms isValidSegmentBridge(sqInt objOop, struct foo * self);
static SpurSegmentInfo * NoDbgRegParms nextNonEmptySegmentAfter(sqInt i, struct foo * self);
static void postSnapshot(struct foo * self);
static void NeverInline prepareForSnapshot(struct foo * self);
static sqInt NoDbgRegParms readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes, struct foo * self);
EXPORT(SpurSegmentInfo *) segmentContainingObj(sqInt objOop, struct foo * self);
static sqInt segmentOverlap(struct foo * self);
static sqInt NoDbgRegParms shrinkObjectMemory(usqInt delta, struct foo * self);
static sqInt someSegmentContainsPinned(struct foo * self);
static sqInt NoDbgRegParms swizzleObj(sqInt objOop, struct foo * self);
static usqInt totalBytesInSegments(struct foo * self);
static sqInt NoDbgRegParms writeImageSegmentsToFile(sqImageFile aBinaryStream, struct foo * self);
static sqInt NoDbgRegParms writeSegmentnextSegmenttoFile(SpurSegmentInfo *segment, SpurSegmentInfo *nextSegment, sqImageFile aBinaryStream, struct foo * self);
extern sqInt activeProcess(struct foo * self);
extern void addIdleUsecs(sqInt idleUsecs, struct foo * self);
static void NoDbgRegParms addLastLinktoList(sqInt proc, sqInt aList, struct foo * self);
static void NoDbgRegParms addNewMethodToCache(sqInt classObj, struct foo * self);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj, struct foo * self);
static sqInt NoDbgRegParms addressOfinGIV(char *GIVElement, struct foo *interpreterState, struct foo * self);
static char * allOnesAsCharStar(struct foo * self);
extern sqInt argumentCountOfClosure(sqInt closurePointer, struct foo * self);
extern sqInt argumentCountOfMethodHeader(sqInt header, struct foo * self);
extern sqInt argumentCountOf(sqInt methodPointer, struct foo * self);
extern void * arrayValueOf(sqInt arrayOop, struct foo * self);
static sqInt NoDbgRegParms asciiOfCharacter(sqInt characterObj, struct foo * self);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp, struct foo * self);
static void NoDbgRegParms assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln, struct foo * self);
extern sqInt booleanValueOf(sqInt obj, struct foo * self);
EXPORT(sqInt) callbackEnter(sqInt *callbackID, struct foo * self);
EXPORT(sqInt) callbackLeave(sqInt cbID, struct foo * self);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader, struct foo * self);
static sqInt NoDbgRegParms channelIn(struct foo *anInterpreterState, struct foo * self);
extern sqInt characterForAscii(sqInt ascii, struct foo * self);
extern sqInt checkAllAccessibleObjectsOkay(struct foo * self);
static sqInt NoDbgRegParms checkCodeIntegrity(sqInt fullGCFlag, struct foo * self);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(struct foo * self);
extern sqInt checkedIntegerValueOf(sqInt intOop, struct foo * self);
static sqInt NoDbgRegParms checkForEventsMayContextSwitch(sqInt mayContextSwitch, struct foo * self);
static sqInt NoDbgRegParms checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset, struct foo * self);
static sqInt checkInterpreterIntegrity(struct foo * self);
static sqInt NoDbgRegParms checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP, struct foo * self);
static sqInt NoDbgRegParms checkOkayFields(sqInt oop, struct foo * self);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack, struct foo * self);
static sqInt NoDbgRegParms checkOkayStackPage(StackPage *thePage, struct foo * self);
static sqInt NoDbgRegParms checkOkayStackZone(sqInt writeBack, struct foo * self);
static void NoDbgRegParms checkProfileTick(sqInt aPrimitiveMethod, struct foo * self);
static sqInt checkStackIntegrity(struct foo * self);
static sqInt NoDbgRegParms checkStackPointerForMaybeMarriedContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms checkStackPointerIndexForFrame(char *theFP, struct foo * self);
static sqInt NoDbgRegParms classNameOfIs(sqInt aClass, char *className, struct foo * self);
static sqInt NoDbgRegParms contexthasSender(sqInt thisCntx, sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP, struct foo * self);
extern sqInt copiedValueCountOfClosure(sqInt closurePointer, struct foo * self);
extern sqInt copiedValueCountOfFullClosure(sqInt closurePointer, struct foo * self);
extern sqInt copyBits(struct foo * self);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y, struct foo * self);
static sqInt NoDbgRegParms NeverInline couldBeProcess(sqInt oop, struct foo * self);
static void cr(struct foo * self);
static void NoDbgRegParms createActualMessageTo(sqInt lookupClass, struct foo * self);
static sqInt defaultNumStackPages(struct foo * self);
extern sqInt disownVM(sqInt flags, struct foo * self);
static sqInt divorceAllFrames(struct foo * self);
static void NoDbgRegParms divorceFramesIn(StackPage *aStackPage, struct foo * self);
static sqInt NoDbgRegParms doPrimitiveDivby(sqInt rcvr, sqInt arg, struct foo * self);
static sqInt NoDbgRegParms doPrimitiveModby(sqInt rcvr, sqInt arg, struct foo * self);
extern sqInt doSignalSemaphoreWithIndex(sqInt index, struct foo * self);
static void dummyReferToProxy(struct foo * self);
extern void dumpPrimTraceLog(struct foo * self);
static sqInt NoDbgRegParms ensureCallerContext(char *theFP, struct foo * self);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes, struct foo * self);
static sqInt enterSmalltalkExecutiveImplementation(struct foo * self);
static void NoDbgRegParms externalDivorceFrameandContext(char *theFP, sqInt ctxt, struct foo * self);
static char * NoDbgRegParms externalEnsureIsBaseFrame(char *aFramePtr, struct foo * self);
static sqInt NoDbgRegParms externalInstVarofContext(sqInt offset, sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop, struct foo * self);
static sqInt externalQuickPrimitiveResponse(struct foo * self);
static void failUnbalancedPrimitive(struct foo * self);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
static sqInt NoDbgRegParms fetchPointerofMarriedContext(sqInt offset, sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms findClassContainingMethodstartingAt(sqInt meth, sqInt classObj, struct foo * self);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr, struct foo * self);
static char * NoDbgRegParms findFrameAboveinPage(char *theFP, StackPage *thePage, struct foo * self);
static sqInt NoDbgRegParms findHomeForContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext, struct foo * self);
static sqInt NoDbgRegParms findNewMethodInClassTag(sqInt classTagArg, struct foo * self);
extern sqInt findSelectorOfMethod(sqInt meth, struct foo * self);
static char * NoDbgRegParms findSPOfon(char *theFP, StackPage *thePage, struct foo * self);
static sqInt NoDbgRegParms flushExternalPrimitiveOf(sqInt methodObj, struct foo * self);
static void NoDbgRegParms followForwardedFrameContentsstackPointer(char *theFP, char *theSP, struct foo * self);
static void NoDbgRegParms followForwardingPointersInStackZone(sqInt theBecomeEffectsFlags, struct foo * self);
extern sqInt forceInterruptCheck(struct foo * self);
extern void forceInterruptCheckFromHeartbeat(struct foo * self);
static sqInt NoDbgRegParms frameCallerContext(char *theFP, struct foo * self);
static sqInt NoDbgRegParms frameContext(char *theFP, struct foo * self);
static sqInt NoDbgRegParms frameHasContext(char *theFP, struct foo * self);
static sqInt NoDbgRegParms frameIsBlockActivation(char *theFP, struct foo * self);
static sqInt NoDbgRegParms frameMethodObject(char *theFP, struct foo * self);
static sqInt NoDbgRegParms frameMethod(char *theFP, struct foo * self);
static sqInt NoDbgRegParms frameNumArgs(char *theFP, struct foo * self);
static char * NoDbgRegParms frameOfMarriedContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms frameReceiver(char *theFP, struct foo * self);
static sqInt NoDbgRegParms frameStackedReceiverOffset(char *theFP, struct foo * self);
static void freeUntracedStackPages(struct foo * self);
extern sqInt fullDisplayUpdate(struct foo * self);
extern void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
extern sqInt getCurrentBytecode(struct foo * self);
static sqInt getDesiredCogCodeSize(struct foo * self);
static sqInt getErrorObjectFromPrimFailCode(struct foo * self);
extern sqInt getFullScreenFlag(struct foo * self);
extern sqInt getInterruptKeycode(struct foo * self);
extern sqInt getInterruptPending(struct foo * self);
extern usqLong getNextWakeupUsecs(struct foo * self);
static int getNumberOfImage();
extern sqInt getSavedWindowSize(struct foo * self);
static sqInt getSnapshotScreenSize(struct foo * self);
extern sqInt * getStackPointer(struct foo * self);
extern sqInt getThisSessionID(struct foo * self);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag, struct foo * self);
static void NoDbgRegParms growAllGlobalsStruct(int numberImages);
static sqInt NoDbgRegParms haltIn(struct foo *interpreterState, struct foo * self);
static sqInt NoDbgRegParms handleForwardedSelectorFaultFor(sqInt selectorOop, struct foo * self);
static sqInt NoDbgRegParms handleForwardedSendFaultForTag(sqInt classTag, struct foo * self);
static sqInt NoDbgRegParms handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP, struct foo * self);
static void NeverInline handleStackOverflow(struct foo * self);
static sqInt NoDbgRegParms handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch, struct foo * self);
extern sqInt highBit(usqInt anUnsignedValue, struct foo * self);
static sqInt NoDbgRegParms ifCurrentStackPageHasValidHeadPointers(StackPage *thePage, struct foo * self);
static usqInt NoDbgRegParms iframeMethod(char *theFP, struct foo * self);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP, struct foo * self);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass, struct foo * self);
static void initAllGlobalsStruct();
static void initializeExtraClassInstVarIndices(struct foo * self);
static sqInt initStackPagesAndInterpret(struct foo * self);
static sqInt NoDbgRegParms instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr, struct foo * self);
static sqInt NeverInline interpreterAllocationReserveBytes(struct foo * self);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean, struct foo * self);
static sqInt NoDbgRegParms isBaseFrame(char *theFP, struct foo * self);
extern sqInt isBooleanObject(sqInt oop, struct foo * self);
extern sqInt isFloatObject(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isFrameonPage(char *aFrame, StackPage *aPage, struct foo * self);
extern sqInt isKindOfInteger(sqInt oop, struct foo * self);
extern sqInt isLargeIntegerObject(sqInt oop, struct foo * self);
extern sqInt isLargeNegativeIntegerObject(sqInt oop, struct foo * self);
extern sqInt isLargePositiveIntegerObject(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isLiveContext(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms isMarriedOrWidowedContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms isMetaPrimitiveIndex(sqInt primIndex, struct foo * self);
static sqInt isPrimitiveFunctionPointerAnIndex(struct foo * self);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger, struct foo * self);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index, struct foo * self);
static sqInt NoDbgRegParms isSingleContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms isWidowedContextDuringGC(sqInt aOnceMarriedContext, struct foo * self);
static sqInt NoDbgRegParms isWidowedContext(sqInt aOnceMarriedContext, struct foo * self);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index, struct foo * self);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass, struct foo * self);
extern sqInt isKindOf(sqInt oop, char *className, struct foo * self);
extern sqInt isMemberOf(sqInt oop, char *className, struct foo * self);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop, struct foo * self);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer, struct foo * self);
extern void loadAndExecute(ThreadInterpreterParameter *threadInterpreterParameters);
extern sqInt loadBitBltFrom(sqInt bb, struct foo * self);
extern void loadInitialContext(struct foo * self);
static void lockFetchNextBytecode(struct foo * self);
extern void longPrintOop(sqInt oop, struct foo * self);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader, struct foo * self);
static sqInt NoDbgRegParms lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag, struct foo * self);
static sqInt NoDbgRegParms lookupMethodInClass(sqInt class, struct foo * self);
static sqInt NoDbgRegParms lookupOrdinaryNoMNUEtcInClass(sqInt class, struct foo * self);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class, struct foo * self);
static StackPage * NoDbgRegParms makeBaseFrameFor(sqInt aContext, struct foo * self);
static void NoDbgRegParms makeContextSnapshotSafe(sqInt ctxt, struct foo * self);
extern usqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue, struct foo * self);
static void mapInterpreterOops(struct foo * self);
static void NeverInline mapStackPages(struct foo * self);
static sqInt NoDbgRegParms markAndTraceStackPages(sqInt fullGCFlag, struct foo * self);
static void NoDbgRegParms markAndTraceStackPage(StackPage *thePage, struct foo * self);
static void markAndTraceUntracedReachableStackPages(struct foo * self);
static sqInt NoDbgRegParms marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame, struct foo * self);
static void NoDbgRegParms marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms marryFrameSP(char *theFP, char *theSP, struct foo * self);
static sqInt NoDbgRegParms maybeLeakCheckExternalPrimCall(sqInt aMethodObj, struct foo * self);
extern sqInt maybeSelectorOfMethod(sqInt methodObj, struct foo * self);
extern sqInt methodArgumentCount(struct foo * self);
extern sqInt methodClassAssociationOf(sqInt methodPointer, struct foo * self);
extern sqInt methodClassOf(sqInt methodPointer, struct foo * self);
static sqInt NoDbgRegParms methodHeaderIndicatesLargeFrame(sqInt methodHeader, struct foo * self);
extern sqInt methodPrimitiveIndex(struct foo * self);
extern sqInt methodReturnBool(sqInt boolean, struct foo * self);
extern sqInt methodReturnFloat(double aFloat, struct foo * self);
extern sqInt methodReturnInteger(sqInt integer, struct foo * self);
extern sqInt methodReturnReceiver(struct foo * self);
extern sqInt methodReturnString(char *aCString, struct foo * self);
extern sqInt methodReturnValue(sqInt oop, struct foo * self);
extern sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj, struct foo * self);
static sqInt NoDbgRegParms methodUsesPrimitiveErrorCode(sqInt aMethodObj, struct foo * self);
EXPORT(void) moduleUnloaded(char *aModuleName, struct foo * self);
static char * NoDbgRegParms moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage, struct foo * self);
static char * NoDbgRegParms nameOfClass(sqInt classOop, struct foo * self);
extern struct foo * newGIV();
static struct foo * NoDbgRegParms newImageWithArguments(char *imagePath, char *imageArgs, struct foo * self);
static int NoDbgRegParms nextInInterpreter(struct foo *anInterpreterState, struct foo * self);
static sqInt NoDbgRegParms noInlineTemporaryin(sqInt offset, char *theFP, struct foo * self);
static sqInt NoDbgRegParms noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop, struct foo * self);
static sqInt NoDbgRegParms noMarkedContextsOnPage(StackPage *thePage, struct foo * self);
static sqInt NoDbgRegParms numSlotsOfMarriedContext(sqInt aContext, struct foo * self);
static sqInt numStkPages(struct foo * self);
extern sqInt objCouldBeClassObj(sqInt objOop, struct foo * self);
extern sqInt ownVM(sqInt threadIndexAndFlags, struct foo * self);
extern sqInt penultimateLiteralOf(sqInt aMethodOop, struct foo * self);
extern sqInt popStack(struct foo * self);
extern sqInt pop(sqInt nItems, struct foo * self);
extern void popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt positive32BitIntegerFor(unsigned int integerValue, struct foo * self);
extern sqInt positive64BitIntegerFor(usqLong integerValue, struct foo * self);
static sqInt NoDbgRegParms positiveMachineIntegerFor(usqIntptr_t value, struct foo * self);
static sqInt postGCUpdateDisplayBits(struct foo * self);
EXPORT(void) primitiveEventProcessingControl(struct foo * self);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader, struct foo * self);
extern sqInt primitiveIndexOf(sqInt methodPointer, struct foo * self);
static void NoDbgRegParms printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass, struct foo * self);
static void NoDbgRegParms printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage, struct foo * self);
extern void printAllStacks(struct foo * self);
extern void printCallStack(struct foo * self);
static sqInt NoDbgRegParms printCallStackFP(char *theFP, struct foo * self);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame, struct foo * self);
static sqInt NoDbgRegParms printCallStackOfcurrentFP(sqInt aContext, char *currFP, struct foo * self);
extern void printChar(sqInt aByte, struct foo * self);
static sqInt NoDbgRegParms printContextCallStackOf(sqInt aContext, struct foo * self);
extern void printContext(sqInt aContext, struct foo * self);
extern void printExternalHeadFrame(struct foo * self);
static sqInt NoDbgRegParms printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort, struct foo * self);
static void NoDbgRegParms printFrameFlagsForFP(char *theFP, struct foo * self);
static void NoDbgRegParms printFrameOopat(char *name, char *address, struct foo * self);
EXPORT(void) printFramesInPage(StackPage *thePage, struct foo * self);
EXPORT(void) printFramesOnStackPageListInUse(struct foo * self);
static void NoDbgRegParms printFrameThingandFrameat(char *name, char *theFP, char *address, struct foo * self);
static void NoDbgRegParms printFrameThingat(char *name, char *address, struct foo * self);
extern sqInt printFrame(char *theFP, struct foo * self);
extern sqInt printFrameWithSP(char *theFP, char *theSP, struct foo * self);
extern sqInt printHexnp(usqInt n, struct foo * self);
extern void printHex(usqInt n, struct foo * self);
extern void printLikelyImplementorsOfSelector(sqInt selector, struct foo * self);
static void NoDbgRegParms printLocalSPLocalFPLocalIPCurrentBytecode(char *anSP, char *anFP, char *anIP, sqInt byteCode, struct foo * self);
extern void printMethodCache(struct foo * self);
extern void printMethodDictionaryOf(sqInt behavior, struct foo * self);
extern void printMethodDictionary(sqInt dictionary, struct foo * self);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt, struct foo * self);
static void NoDbgRegParms printNum(sqInt n, struct foo * self);
static void NoDbgRegParms printOopShort(sqInt oop, struct foo * self);
extern sqInt printOop(sqInt oop, struct foo * self);
extern void printProcessStack(sqInt aProcess, struct foo * self);
extern sqInt printProcsOnList(sqInt procList, struct foo * self);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame, struct foo * self);
extern void printStackPageList(struct foo * self);
extern void printStackPageListInUse(struct foo * self);
extern void printStackPages(struct foo * self);
extern void printStackPagesInUse(struct foo * self);
static void NoDbgRegParms printStackPageuseCount(StackPage *page, sqInt n, struct foo * self);
extern void printStackReferencesTo(sqInt oop, struct foo * self);
static void NoDbgRegParms printStringOf(sqInt oop, struct foo * self);
extern void print(char *s, struct foo * self);
extern void pushBool(sqInt trueOrFalse, struct foo * self);
static sqInt NoDbgRegParms pushedReceiverOrClosureOfFrame(char *theFP, struct foo * self);
extern void pushFloat(double f, struct foo * self);
extern sqInt pushInteger(sqInt integerValue, struct foo * self);
extern void push(sqInt object, struct foo * self);
static void NoDbgRegParms putLongtoFile(sqInt aLong, sqImageFile aFile, struct foo * self);
static void NoDbgRegParms putShorttoFile(short aShort, sqImageFile aFile, struct foo * self);
static void NoDbgRegParms putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly, struct foo * self);
static void NoDbgRegParms putWord32toFile(int aWord32, sqImageFile aFile, struct foo * self);
static sqInt NoDbgRegParms quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAtV2(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset, struct foo * self);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset, struct foo * self);
static void NoDbgRegParms NeverInline reapAndResetErrorCodeToheader(char *theSP, sqInt methodHeader, struct foo * self);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext, struct foo * self);
static sqInt NoDbgRegParms removeFirstLinkOfList(sqInt aList, struct foo * self);
static sqInt NoDbgRegParms resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly, struct foo * self);
static sqInt retryPrimitiveOnFailure(struct foo * self);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext, struct foo * self);
static sqInt NoDbgRegParms reverseDisplayFromto(sqInt startIndex, sqInt endIndex, struct foo * self);
static void NoDbgRegParms rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void), struct foo * self);
static sqInt NoDbgRegParms roomToPushNArgs(sqInt n, struct foo * self);
static sqInt NoDbgRegParms safeMethodClassOf(sqInt methodPointer, struct foo * self);
static sqInt NoDbgRegParms saneFunctionPointerForFailureOfPrimIndex(sqInt primIndex, struct foo * self);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext, struct foo * self);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr, struct foo * self);
extern void setBreakMNUSelector(char *aString, struct foo * self);
extern void setBreakSelector(char *aString, struct foo * self);
extern void setFullScreenFlag(sqInt value, struct foo * self);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
extern void setInterruptKeycode(sqInt value, struct foo * self);
extern void setInterruptPending(sqInt value, struct foo * self);
extern void setMyCurrentThread(pthread_t aThread, size_t index);
extern void setNextWakeupUsecs(usqLong value, struct foo * self);
static void NoDbgRegParms setNumberOfImage(int numberImages);
extern void setSavedWindowSize(sqInt value, struct foo * self);
static void setSignalLowSpaceFlagAndSaveProcess(struct foo * self);
static void NoDbgRegParms setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms shortPrintContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms shortPrintFrameAndCallers(char *theFP, struct foo * self);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage, struct foo * self);
EXPORT(void) shortPrintFramesOnStackPageListInUse(struct foo * self);
static sqInt NoDbgRegParms shortPrintFrame(char *theFP, struct foo * self);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n, struct foo * self);
static sqInt NoDbgRegParms shortPrintOop(sqInt oop, struct foo * self);
static sqInt NoDbgRegParms shortReversePrintFrameAndCallers(char *aFramePointer, struct foo * self);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b, struct foo * self);
static sqInt signalExternalSemaphores(struct foo * self);
extern sqInt signed32BitIntegerFor(sqInt integerValue, struct foo * self);
extern sqInt signed64BitIntegerFor(sqLong integerValue, struct foo * self);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader, struct foo * self);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader, struct foo * self);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr, struct foo * self);
static sqInt NoDbgRegParms snapshot(sqInt embedded, struct foo * self);
static void space(struct foo * self);
extern sqInt specialSelector(sqInt index, struct foo * self);
static void NoDbgRegParms spurPostBecomeAction(sqInt theBecomeEffectsFlags, struct foo * self);
extern double stackFloatValue(sqInt offset, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
static sqInt stackLimitBytes(struct foo * self);
static sqInt stackLimitOffset(struct foo * self);
extern sqInt stackObjectValue(sqInt offset, struct foo * self);
static sqInt stackPageByteSize(struct foo * self);
static sqInt stackPageHeadroom(struct foo * self);
static sqInt NoDbgRegParms stackPointerForMaybeMarriedContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms stackPointerIndexForFrame(char *theFP, struct foo * self);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset, struct foo * self);
extern sqIntptr_t stackSignedMachineIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackTop(struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt startPCOfMethod(sqInt aCompiledMethod, struct foo * self);
extern sqInt stObjectat(sqInt array, sqInt index, struct foo * self);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value, struct foo * self);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue, struct foo * self);
static char * NoDbgRegParms storeSenderOfFramewithValue(char *theFP, sqInt anOop, struct foo * self);
extern sqInt stSizeOf(sqInt oop, struct foo * self);
extern sqInt superclassOf(sqInt classPointer, struct foo * self);
static sqInt NoDbgRegParms synchronousSignal(sqInt aSemaphore, struct foo * self);
extern sqInt tempCountOf(sqInt methodPointer, struct foo * self);
extern sqInt temporaryCountOfMethodHeader(sqInt header, struct foo * self);
static void NoDbgRegParms transferTo(sqInt newProc, struct foo * self);
extern sqInt ultimateLiteralOf(sqInt aMethodOop, struct foo * self);
static sqInt NoDbgRegParms NeverInline unfollowatIndex(sqInt litVar, sqInt literalIndex, struct foo * self);
static sqInt NoDbgRegParms updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b, struct foo * self);
static void NoDbgRegParms updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP, struct foo * self);
static sqInt NoDbgRegParms validInstructionPointerinFrame(usqInt anInstrPointer, char *fp, struct foo * self);
extern sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp, struct foo * self);
static sqInt validStackPageBaseFrames(struct foo * self);
static sqInt NoDbgRegParms validStackPageBaseFrame(StackPage *aPage, struct foo * self);
static void NoDbgRegParms NeverInline voidLongRunningPrimitive(char *reason, struct foo * self);
static sqInt NoDbgRegParms voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims, struct foo * self);
static sqInt wakeHighestPriority(struct foo * self);
extern char * whereIs(sqInt anOop, struct foo * self);
static sqInt NeverInline writeImageFileIO(struct foo * self);
static sqInt NoDbgRegParms cloneContext(sqInt aContext, struct foo * self);
static sqInt NoDbgRegParms fieldOrSenderFPofContext(sqInt index, sqInt contextObj, struct foo * self);
static sqInt NoDbgRegParms fieldofFrame(sqInt index, char *theFP, struct foo * self);
static sqInt NoDbgRegParms isAppropriateForCopyObject(sqInt oop, struct foo * self);
static double NoDbgRegParms NeverInline noInlineLoadFloatOrIntFrom(sqInt floatOrInt, struct foo * self);
static void NoDbgRegParms primitiveAllVMParameters(sqInt paramsArraySize, struct foo * self);
static void primitiveChannelBootstrap(struct foo * self);
static void primitiveClone(struct foo * self);
static void primitiveClosureCopyWithCopiedValues(struct foo * self);
static void primitiveContextAt(struct foo * self);
static void primitiveContextAtPut(struct foo * self);
static void primitiveContextSize(struct foo * self);
static void primitiveContextXray(struct foo * self);
static void primitiveDeferDisplayUpdates(struct foo * self);
static void primitiveDoNamedPrimitiveWithArgs(struct foo * self);
static void primitiveDoPrimitiveWithArgs(struct foo * self);
static void primitiveExecuteMethod(struct foo * self);
static void primitiveExecuteMethodArgsArray(struct foo * self);
static void primitiveExternalCall(struct foo * self);
static void primitiveFindHandlerContext(struct foo * self);
static void primitiveFindNextUnwindContext(struct foo * self);
static void primitiveFlushCacheByMethod(struct foo * self);
static void primitiveFlushCacheBySelector(struct foo * self);
static void primitiveFullGC(struct foo * self);
static sqInt NoDbgRegParms primitiveGetVMParameter(sqInt arg, struct foo * self);
static void primitiveGIVElementOfInterpreter(struct foo * self);
static void primitiveHaltInterpreter(struct foo * self);
static void primitiveIncrementalGC(struct foo * self);
static void primitiveInstVarAt(struct foo * self);
static void primitiveInstVarAtPut(struct foo * self);
EXPORT(sqInt) primitiveLongRunningPrimitive(struct foo * self);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(struct foo * self);
static void primitiveNextInInterpreter(struct foo * self);
static void primitiveObjectPointsTo(struct foo * self);
static void primitiveOpenNewImage(struct foo * self);
static void primitiveOwnInterpreterState(struct foo * self);
static void primitivePerform(struct foo * self);
static void primitivePin(struct foo * self);
EXPORT(void) primitiveSetGCSemaphore(struct foo * self);
static void primitiveSignalAtMilliseconds(struct foo * self);
static void primitiveSignalAtUTCMicroseconds(struct foo * self);
static void primitiveSlotAt(struct foo * self);
static void primitiveSlotAtPut(struct foo * self);
static void primitiveStoreStackp(struct foo * self);
static void primitiveTerminateTo(struct foo * self);
static void primitiveTopFrameInInterpreter(struct foo * self);
static void primitiveVMParameter(struct foo * self);
EXPORT(void) primitiveVoidReceiver(struct foo * self);
static void primitiveVoidVMState(struct foo * self);
static void NoDbgRegParms pruneStackstackp(sqInt stack, sqInt stackp, struct foo * self);
static void unmarkAfterPathTo(struct foo * self);
static void unmarkAllFrames(struct foo * self);
extern ModuleEntry *  getFirstModule(struct foo * self);
extern VirtualMachine *  getInterpreterProxy(struct foo * self);
extern ModuleEntry *  getSqueakModule(struct foo * self);
extern void initMutexForFetchNextBytecodeandCond(pthread_mutex_t *aMutex, pthread_cond_t **aCond, struct foo * self);
extern void mutexLockandCond(pthread_mutex_t *aMutex, pthread_cond_t **aCond);
extern void printMethodCacheFor(sqInt thing, struct foo * self);
extern void setFirstModule(ModuleEntry *aModuleEntry, struct foo * self);
extern void setSqueakModule(ModuleEntry *aModuleEntry, struct foo * self);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss char * framePointer;
_iss usqInt method;
_iss usqInt instructionPointer;
_iss sqInt nilObj;
_iss StackPage * stackPage;
_iss sqInt argumentCount;
_iss sqInt bytecodeSetSelector;
_iss usqInt freeStart;
_iss sqInt specialObjectsOop;
_iss int isStepable;
_iss usqInt endOfMemory;
_iss usqInt newMethod;
_iss usqInt newSpaceLimit;
_iss sqInt messageSelector;
_iss usqInt oldSpaceStart;
_iss SpurSegmentInfo * segments;
_iss usqInt totalFreeOldSpace;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss sqInt needGCFlag;
_iss sqInt hiddenRootsObj;
_iss usqInt pastSpaceStart;
_iss sqInt numSegments;
_iss StackPage * pages;
_iss usqInt scavengeThreshold;
_iss sqInt * freeLists;
_iss char * stackMemory;
_iss sqInt markStack;
_iss sqInt classTableFirstPage;
_iss sqInt rememberedSetSize;
_iss char * stackLimit;
_iss sqInt bytesPerPage;
_iss sqInt * rememberedSet;
_iss SpurContiguousObjStack savedFirstFieldsSpace;
_iss sqInt weaklingStack;
_iss usqInt freeListsMask;
_iss usqInt firstFreeObject;
_iss StackPage * mostRecentlyUsedPage;
_iss sqInt remapBufferCount;
_iss SpurContiguousObjStack unscannedEphemerons;
_iss SpurNewSpaceSpace pastSpace;
_iss SpurScavengeLogRecord scavengeLogRecord;
_iss usqInt lastMobileObject;
_iss usqInt newSpaceStart;
_iss sqInt tempOop;
_iss sqInt numStackPages;
_iss sqInt profileProcess;
_iss sqInt futureSurvivorStart;
_iss sqInt numClassTablePages;
_iss sqInt classTableIndex;
_iss sqInt numRememberedEphemerons;
_iss sqInt profileMethod;
_iss SpurNewSpaceSpace futureSpace;
_iss sqInt mobileStart;
_iss sqInt mournQueue;
_iss SpurNewSpaceSpace eden;
_iss sqInt jmpDepth;
_iss sqInt tenureThreshold;
_iss sqLong nextProfileTick;
_iss char * objStackInvalidBecause;
_iss sqInt profileSemaphore;
_iss sqInt sweepIndex;
_iss sqInt ephemeronList;
_iss sqInt growHeadroom;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss sqInt tenureCriterion;
_iss usqInt totalHeapSizeIncludingBridges;
_iss sqInt becomeEffectsFlags;
_iss usqInt freeOldSpaceStart;
_iss sqInt classNameIndex;
_iss sqInt invalidObjStackPage;
_iss usqInt objectAfterLastMobileObject;
_iss sqInt previousRememberedSetSize;
_iss sqInt tempOop2;
_iss sqInt lkupClass;
_iss sqInt pendingFinalizationSignals;
_iss sqInt gcPhaseInProgress;
_iss sqInt metaAccessorDepth;
_iss sqInt metaclassNumSlots;
_iss sqInt preemptionYields;
_iss sqInt extraRootCount;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt numSegInfos;
_iss sqInt savedFirstFieldsSpaceNotInOldSpace;
_iss sqInt edenBytes;
_iss usqInt firstMobileObject;
_iss sqInt highestRunnableProcessPriority;
_iss sqInt newFinalization;
_iss usqLong nextWakeupUsecs;
_iss usqLong statGCEndUsecs;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss usqLong statCheckForEvents;
_iss sqInt statTenures;
_iss sqInt weakList;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt firstSegmentSize;
_iss usqLong gcStartUsecs;
_iss sqInt marking;
_iss sqLong oldSpaceUsePriorToScavenge;
_iss sqInt rememberedSetLimit;
_iss sqInt savedWindowSize;
_iss sqInt statSurvivorCount;
_iss sqInt thisClassIndex;
_iss sqInt firstFieldOfRememberedSet;
_iss sqInt imageHeaderFlags;
_iss sqInt lastHash;
_iss usqInt lowSpaceThreshold;
_iss usqInt memory;
_iss FILE * scavengeLog;
_iss sqInt shrinkThreshold;
_iss usqLong statIOProcessEvents;
_iss sqInt statMaxAllocSegmentTime;
_iss sqInt statScavenges;
_iss sqInt biasForGC;
_iss sqInt fullScreenFlag;
_iss sqInt globalSessionID;
_iss struct VirtualMachine* interpreterProxy;
_iss sqInt interruptKeycode;
_iss sqInt rememberedSetRedZone;
_iss usqLong statAllocatedBytes;
_iss sqInt statFullGCs;
_iss sqInt statNumMaps;
_iss sqInt anomaly;
_iss sqInt bogon;
_iss float heapGrowthToSizeGCRatio;
_iss usqInt heapSizeAtPreviousGC;
_iss sqInt imageFloatsBigEndian;
_iss sqInt interruptPending;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt methodDictLinearSearchLimit;
_iss usqLong nextPollUsecs;
_iss sqLong osErrorCode;
_iss usqLong statCompactionUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statFullGCUsecs;
_iss sqInt statGrowMemory;
_iss usqLong statIdleUsecs;
_iss usqLong statMarkUsecs;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statPageCountWhenMappingSum;
_iss usqLong statProcessSwitch;
_iss usqLong statScavengeGCUsecs;
_iss sqInt statShrinkMemory;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss usqLong statSweepUsecs;
_iss sqInt canSwizzle;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcSemaphoreIndex;
_iss sqInt inFFIFlags;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt refCountToShrinkRT;
_iss sqInt signalLowSpace;
_iss sqInt statMarkCount;
_iss sqInt statRootTableCount;
_iss usqLong statSGCDeltaUsecs;
_iss double tenuringProportion;
_iss sqInt the2ndUnknownShort;
_iss sqInt theUnknownShort;
_iss usqInt exceptionPC;
_iss usqLong gcSweepEndUsecs;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt statCompactPassCount;
_iss usqLong statIGCDeltaUsecs;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt statRootTableOverflows;
_iss sqInt tenuringClassIndex;
_iss sqInt channel;
_iss sqInt checkAllocFiller;
_iss sqInt statIncrGCs;
_iss pthread_mutex_t mutexForFetchBytecode;
_iss pthread_cond_t * step;
_iss sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
_iss sqInt *extraRoots[ExtraRootsSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss usqInt byteCount;
_iss ModuleEntry * firstModule;
_iss pthread_t myCurrentThread;
_iss sqInt preferredPinningSegment;
_iss ModuleEntry * squeakModule;
_iss sqInt statCoalesces;
_iss usqLong statFGCDeltaUsecs;
_iss usqLong statIncrGCUsecs;
_iss void (*primitiveFunctionPointer)();
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
int numberOfImage;
struct foo * all_threads_global;
pthread_t * thread_id;
# define GIV(interpreterInstVar)  self->interpreterInstVar
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static sqInt primitiveFunctionPointer;
sqInt checkForLeaks;
sqInt debugCallbackPath;
void * displayBits;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
sqInt extraVMMemory;
int displayWidth;
jmp_buf reenterInterpreter; /* private export */;
sqInt sendWheelEvents;
sqInt breakLookupClassTag;
int displayDepth;
int displayHeight;
usqInt maxOldSpaceSize;
sqInt breakSelectorLength = MinSmallInteger;
sqInt inIOProcessEvents;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);
sqInt deferDisplayUpdates;
static void (*interruptCheckChain)(void) = 0;
static int (*sHEAFn)() = 0;
char * breakSelector;
sqInt debugCallbackInvokes;
sqInt debugCallbackReturns;
sqInt ffiExceptionResponse;
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ primitiveOpenNewImage,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ primitiveNextInInterpreter,
	/* 151 */ primitiveChannelBootstrap,
	/* 152 */ primitiveTopFrameInInterpreter,
	/* 153 */ primitiveGIVElementOfInterpreter,
	/* 154 */ primitiveHaltInterpreter,
	/* 155 */ primitiveOwnInterpreterState,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ primitiveCompareWith,
	/* 159 */ primitiveHashMultiply,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ primitiveImmediateAsInteger,
	/* 172 */ primitiveFetchNextMourner,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ primitiveGrowMemoryByAtLeast,
	/* 181 */ primitiveSizeInBytesOfInstance,
	/* 182 */ primitiveSizeInBytes,
	/* 183 */ primitiveIsPinned,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ primitiveFullClosureValue,
	/* 208 */ primitiveFullClosureValueWithArgs,
	/* 209 */ primitiveFullClosureValueNoContextSwitch,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ primitiveUtcAndTimezoneOffset,
	/* 245 */ primitiveCoarseUTCMicrosecondClock,
	/* 246 */ primitiveCoarseLocalMicrosecondClock,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ primitiveArrayBecomeOneWayNoCopyHash,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ primitiveSmallFloatAdd,
	/* 542 */ primitiveSmallFloatSubtract,
	/* 543 */ primitiveSmallFloatLessThan,
	/* 544 */ primitiveSmallFloatGreaterThan,
	/* 545 */ primitiveSmallFloatLessOrEqual,
	/* 546 */ primitiveSmallFloatGreaterOrEqual,
	/* 547 */ primitiveSmallFloatEqual,
	/* 548 */ primitiveSmallFloatNotEqual,
	/* 549 */ primitiveSmallFloatMultiply,
	/* 550 */ primitiveSmallFloatDivide,
	/* 551 */ primitiveSmallFloatTruncated,
	/* 552 */ primitiveSmallFloatFractionalPart,
	/* 553 */ primitiveSmallFloatExponent,
	/* 554 */ primitiveSmallFloatTimesTwoPower,
	/* 555 */ primitiveSmallFloatSquareRoot,
	/* 556 */ primitiveSmallFloatSine,
	/* 557 */ primitiveSmallFloatArctan,
	/* 558 */ primitiveSmallFloatLogN,
	/* 559 */ primitiveSmallFloatExp,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
static signed char primitiveAccessorDepthTable[MaxPrimitiveIndex + 2 /* 577 */] = {
/*0*/	-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0,-1,-1, 0,-1,-1, 0, 0, 0,-1,
/*20*/	0, 0, 0,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0,-1,-1,-1, 0, 0, 0,
/*40*/	0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/*60*/	0, 0, 0,-1,-1,-1,-1,-1, 0, 0,-1,-1, 0, 1, 1, 0, 0, 0, 0, 0,
/*80*/	-1,-1,-1, 0,-1,-1, 0, 0, 1,-1,-1, 0, 0, 0, 0,-1,-1,-1, 0, 0,
/*100*/	1, 1, 3, 2,-1,-1,-1,-1,-1,-1, 0, 0,-1,-1,-1, 1,-1,-1, 1, 0,
/*120*/	-1, 0,-1, 0, 0, 0, 0, 0, 0,-1,-1,-1, 1, 0, 0,-1, 0,-1,-1,-1,
/*140*/	-1, 1,-1, 1, 0,-1,-1,-1, 0, 0, 1, 1, 2, 1, 1,-1,-1,-1, 1, 1,
/*160*/	0, 0,-1, 0, 0,-1,-1,-1, 1, 0, 0, 1,-1, 1, 1,-1,-1,-1,-1,-1,
/*180*/	0,-1,-1, 0, 0, 0, 1, 1, 1, 0,-1,-1,-1,-1,-1, 1, 2,-1,-1,-1,
/*200*/	0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0,-1,-1,-1,-1, 3,-1,
/*220*/	-1, 2, 2,-1,-1,-1,-1,-1,-1,-1, 0,-1, 2, 0,-1,-1,-1,-1,-1,-1,
/*240*/	-1,-1, 0,-1, 0,-1,-1,-1, 0,-1,-1, 0, 0,-1, 0,-1,-1,-1,-1,-1,
/*260*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*280*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*300*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*320*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*340*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*360*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*380*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*400*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*420*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*440*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*460*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*480*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*500*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*520*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*540*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,
/*560*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0,-1,-1
	};
sqInt checkedPluginName;
char expensiveAsserts = 0;
sqInt forStepping;
const char *interpreterVersion = "Croquet Closure Stack VM [TheoStackInterpreter * VMMakerTheo-CompatibleUserName.1590750105]";
volatile int sendTrace;
sqInt suppressHeartbeatFlag;


/*** Macros ***/
#define mostRecentlyUsedPage(self) GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages, self) ((pages) + (index))
#define statMaxPageCountWhenMapping(self) GIV(statMaxPageCountWhenMapping)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize, self) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define numTagBits(self) 3
#define shiftForWord(self) 3
#define smallFloatExponentBits(self) 8
#define smallFloatExponentOffset(self) 896
#define smallFloatMantissaBits(self) 52
#define smallFloatTag(self) 4
#define tagMask(self) 0x7
#define wordSize(self) 8
#define eden(self) GIV(eden)
#define futureSpace(self) GIV(futureSpace)
#define futureSurvivorStart(self) GIV(futureSurvivorStart)
#define pastSpace(self) GIV(pastSpace)
#define rememberedSetLimit(self) GIV(rememberedSetLimit)
#define rememberedSetSize(self) GIV(rememberedSetSize)
#define arrayClassIndexPun(self) 16
#define characterTag(self) 2
#define classIndexMask(self) 0x3FFFFF
#define classIsItselfClassIndexPun(self) 31
#define classTableMajorIndexShift(self) 10
#define endOfMemory(self) GIV(endOfMemory)
#define firstByteFormat(self) 16
#define firstClassIndexPun(self) 16
#define firstCompiledMethodFormat(self) 24
#define firstLongFormat(self) 10
#define firstShortFormat(self) 12
#define fixedFieldsFieldWidth(self) 16
#define formatFieldWidthShift(self) 5
#define formatMask(self) 0x1F
#define formatShift(self) 24
#define freeStart(self) GIV(freeStart)
#define greyBitShift(self) 31
#define identityHashFullWordShift(self) 32
#define identityHashHalfWordMask(self) 0x3FFFFF
#define immutableBitShift(self) 23
#define indexablePointersFormat(self) 3
#define isForwardedObjectClassIndexPun(self) 8
#define isFreeObjectClassIndexPun(self) 0
#define lastClassIndexPun(self) 31
#define markedBitFullShift(self) 55
#define markedBitHalfShift(self) 23
#define maxOldSpaceSize(self) maxOldSpaceSize
#define memory(self) GIV(memory)
#define newSpaceLimit(self) GIV(newSpaceLimit)
#define numSlotsFullShift(self) 56
#define numSlotsHalfShift(self) 24
#define numSlotsMask(self) 0xFF
#define oldSpaceStart(self) GIV(oldSpaceStart)
#define pastSpaceStart(self) GIV(pastSpaceStart)
#define pinnedBitShift(self) 30
#define remapBufferCount(self) GIV(remapBufferCount)
#define rememberedBitShift(self) 29
#define rootTableCapacity(self) GIV(rememberedSetLimit)
#define rootTableCount(self) GIV(rememberedSetSize)
#define segmentBridgePun(self) 3
#define sixtyFourBitIndexableFormat(self) 9
#define sixtyFourBitLongsClassIndexPun(self) 19
#define smallIntegerTag(self) 1
#define startOfMemory(self) GIV(memory)
#define thirtyTwoBitLongsClassIndexPun(self) 18
#define weakArrayClassIndexPun(self) 17
#define weakArrayFormat(self) 4
#define numSegments(self) GIV(numSegments)
#define segments(self) GIV(segments)
#define alternateHeaderNumLiteralsMask(self) 0x7FFF
#define checkAllocFiller(self) GIV(checkAllocFiller)
#define dispatchFunctionPointer(aFunctionPointer, self) (aFunctionPointer)(self)
#define enterSmalltalkExecutive(self) enterSmalltalkExecutiveImplementation(self)
#define flush(self) fflush(stdout)
#define initialEnterSmalltalkExecutive(self) enterSmalltalkExecutiveImplementation(self)
#define printFloat(f, self) printf("%g", f)
#define remoteIsInstVarAccess(self) 128
#define stackPageFrameBytes(self) (256 * BytesPerWord)
#define allocatype(numElements, elementType, self) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray, self) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop, self) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop, self) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop, self) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop, self) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop, self) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop, self) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop, self) ((usqInt)(anOop) < (usqInt)(otherOop))



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* TheoStackInterpreter>>#interpret */
sqInt
interpret(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt extA;
    sqInt extB;
    sqInt lkupClassTag;
    char * localFP;
    char * localIP;
    sqInt localReturnValue;
    char * localSP;
    sqInt numExtB;

	currentBytecode = 0;
	if (GIV(stackLimit) == 0) {
		return initStackPagesAndInterpret(self);
	}
	browserPluginInitialiseIfNeeded(self);
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin initExtensions */
	extA = (numExtB = (extB = 0));
	/* begin fetchNextBytecode */
	if (GIV(isStepable)) {
		printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
		/* begin externalizeIPandSP */
		GIV(instructionPointer) = oopForPointer(localIP);
		GIV(stackPointer) = localSP;
		GIV(framePointer) = localFP;
		printCallStack(self);
		lockFetchNextBytecode(self);
	}
	currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		case 0:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 0, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 1:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 1, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 2:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 2, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 3:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 3, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 4:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 4, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 5:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 5, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 6:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 6, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 7:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 7, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 8:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 8, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 64 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 9:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 9, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 72 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 10:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 10, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 80 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 11:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 11, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 88 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 12:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 12, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 96 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 13:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 13, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 104 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 14:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 14, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 112 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 15:
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 15, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 120 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 16:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 16, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 17:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 17, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 18:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 18, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 19:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 19, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 20:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 20, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 21:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 21, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 22:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 22, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 23:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 23, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 24:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 24, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 25:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 25, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 26:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 26, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 27:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 27, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 28, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 29, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 30, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 0x1F, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 32:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 32, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 33:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 33, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 34:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 34, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 35:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 35, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 36:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 36, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 37:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 37, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 38:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 38, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 39:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 39, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 40:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 40, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 41:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 41, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 42:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 42, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 43:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 43, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 44:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 44, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 45:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 45, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 46:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 46, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 47:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 47, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 48:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 48, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 136 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 49:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 49, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 144 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 50:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 50, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 152 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 51:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 51, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 160 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 52:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 52, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 168 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 53:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 53, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 176 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 54:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 54, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 184 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 55:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 55, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 192 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 56:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 56, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 200 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 57:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 57, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 208 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 58:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 58, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 216 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 59:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 59, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 224 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 60:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 60, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 232 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 61:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 61, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 240 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 62:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 0x3E, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 0xF8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 63:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 0x3F, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 256 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 64:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 64, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 0 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 65:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 65, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 1 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 66:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 66, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 2 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 67:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 67, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 3 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 68:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 68, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 4 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 69:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 69, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 5 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 70:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 70, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 6 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 71:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 71, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 7 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 72:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 72, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 8 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 73:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 73, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 9 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 74:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 74, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 10 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 75:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 75, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 11 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 76:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 76, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 12 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 77:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 77, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 13 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 78:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 78, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 14 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 79:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 79, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 15 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 80, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 136 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 16 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 81, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 144 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 17 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 82, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 152 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 18 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 83, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 160 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 19 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 84, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 168 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 20 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 85, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 176 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 21 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 86, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 184 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 22 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 87, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 192 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 23 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 88, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 200 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 24 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 89, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 208 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 25 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 90, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 216 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 26 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 91, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 224 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 27 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 92, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 232 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 28 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 93, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 240 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 29 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 94, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 0xF8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 30 /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 95, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 256 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 0x1F /* currentBytecode bitAnd: 31 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				/* begin receiver */
				rcvr = longAt(localFP + FoxReceiver);
				/* begin internalStackTop */
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(rcvr, self))));
				if (((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), top);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((usqInt)(instVarIndex + 1) << 3) | 1));
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l13;
				}
#        endif /* IMMUTABILITY */
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr, self)));
				if ((assert(isNonImmediate(rcvr, self)),
				oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((top & (tagMask(self))) == 0)
					 && (oopisLessThan(top, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(rcvr, self);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(instVarIndex) << (shiftForWord(self))))), top);
	l13:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 104:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 104, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 105:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 105, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 106:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 106, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 107:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 107, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 108:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 108, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 109:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 109, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 110:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 110, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 111:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 111, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 112:
		case 332: /*76*/
			/* pushReceiverBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				object = longAt(localFP + FoxReceiver);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 113:
		case 333: /*77*/
			/* pushConstantTrueBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				object = GIV(trueObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 114:
		case 334: /*78*/
			/* pushConstantFalseBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				object = GIV(falseObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 115:
		case 335: /*79*/
			/* pushConstantNilBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				object = GIV(nilObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			break;
		case 117:
		case 336: /*80*/
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			break;
		case 118:
		case 337: /*81*/
			/* pushConstantOneBytecode */
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			break;
		case 120:
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver);
				/* begin receiver */
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				sqInt index;
				sqInt index1;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt objOop;
				sqInt objOop1;
				sqInt onSamePage;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt ourContext3;
				sqInt senderContext;
				sqInt senderOop;
				sqInt senderOop1;
				sqInt senderOop2;
				char *theFP;
				char *theFP1;
				char *theFPAbove;
				sqInt theMethod;
				sqInt theMethod1;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt unwindContextOrNilOrZero;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(commonReturn);
				frameToReturnTo = ((char *) 0);
				if (!((byteAt((localFP + FoxFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l868;
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed(self));
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				closure = longAt(localFP + (frameStackedReceiverOffset(localFP, self)));

				/* avoid compiler warning */
				/* Walk the closure's lexical chain to find the context or frame to return from (home).
				   If home is missing (Sista closures) then throw cannotReturn rather than crash. */
				home = null;
				while (closure != GIV(nilObj)) {
					/* begin followField:ofObject: */
					objOop = longAt((closure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))));
					if (((objOop & (tagMask(self))) == 0)
					 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, closure, objOop, self);
					}
					home = objOop;
					if (!(((home & (tagMask(self))) == 0)
						 && (((longAt(home)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
						/* begin internalCannotReturn: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP, self), self));
							ourContext = longAt(localFP + FoxThisContext);
							goto l900;
						}
						ourContext = marryFrameSP(localFP, localSP, self);
	l900:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord(self))))));
						GIV(argumentCount) = 1;
						goto normalSend;
						/* return self */
						goto l868;
					}
					/* begin followField:ofObject: */
					objOop1 = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord(self))))));
					if (((objOop1 & (tagMask(self))) == 0)
					 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, home, objOop1, self);
					}
					closure = objOop1;
				}
				/* begin findUnwindThroughContext: */

				/* Since nothing changes we don't need to internalize. */
				onSamePage = ((((((longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
				 && (!(isWidowedContext(home, self))))
				 && ((pageIndexForstackMemorybytesPerPage(GIV(framePointer), GIV(stackMemory), GIV(bytesPerPage), self)) == (pageIndexFor(frameOfMarriedContext(home, self), self)));
				theFP1 = GIV(framePointer);
				theFPAbove = GIV(framePointer);
				do {
					if (((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0)
					 && (home == (longAt(theFP1 + FoxThisContext)))) {
						ctxtOrNilOrZero = 0;
						goto l897;
					}
					if (!((byteAt((theFP1 + FoxFrameFlags) + 3)) != 0)) {
						theMethod1 = longAt(theFP1 + FoxMethod);
						if ((primitiveIndexOfMethodheader(theMethod1, methodHeaderOf(theMethod1, self), self)) == 198) {
							if (theFP1 == theFPAbove) {
								theSP = findSPOfon(theFP1, stackPageFor(theFP1, self), self);
							}
							else {
								assert(!(isBaseFrame(theFPAbove, self)));
								theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove, self))) + BytesPerWord;
							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(theFP1, self), self));
								ctxtOrNilOrZero = longAt(theFP1 + FoxThisContext);
								goto l897;
							}
							ctxtOrNilOrZero = marryFrameSP(theFP1, theSP, self);
							goto l897;
						}
					}
					theFPAbove = theFP1;
					theFP1 = pointerForOop(longAt(theFP1 + FoxSavedFP));
				} while(theFP1 != 0);
				senderContext = longAt(theFPAbove + FoxCallerContext);
				if (!(((senderContext & (tagMask(self))) == 0)
					 && (((longAt(senderContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
					/* begin nilObject */
					ctxtOrNilOrZero = GIV(nilObj);
					goto l897;
				}
				ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, home, self);
	l897:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
				assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject(self))))));
				if (ctxtOrNilOrZero == 0) {
					/* begin fetchPointer:ofObject: */
					theMethod = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
					if ((primitiveIndexOfMethodheader(theMethod, methodHeaderOf(theMethod, self), self)) == 198) {
						unwindContextOrNilOrZero = home;
						goto l891;
					}
					unwindContextOrNilOrZero = 0;
					goto l891;
				}
				if (!(onSamePage
					 || (ctxtOrNilOrZero == GIV(nilObj)))) {
					if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, home, self)) == GIV(nilObj)) {
						/* begin nilObject */
						unwindContextOrNilOrZero = GIV(nilObj);
						goto l891;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
	l891:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP, self), self));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l883;
					}
					ourContext1 = marryFrameSP(localFP, localSP, self);
	l883:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord(self))))));
					GIV(argumentCount) = 1;
					goto normalSend;
					/* return self */
					goto l868;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP, self), self));
						ourContext2 = longAt(localFP + FoxThisContext);
						goto l890;
					}
					ourContext2 = marryFrameSP(localFP, localSP, self);
	l890:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext2);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAboutToReturn) << (shiftForWord(self))))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l868;
				}
				contextToReturnTo = null;
				if (((((longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP, self));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - 1);
					if ((longAt(theFP + FoxSavedFP)) == 0) {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
					else {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					/* begin fetchPointer:ofObject: */
					contextToReturnTo = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
					if ((((contextToReturnTo & (tagMask(self))) == 0)
					 && (((longAt(contextToReturnTo)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))
					 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP, self));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
						assert((((senderOop1) & 7) == 1));
						frameToReturnTo = pointerForOop(senderOop1 - 1);
						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					/* begin establishFrameForContextToReturnTo: */
					if (!(((contextToReturnTo & (tagMask(self))) == 0)
						 && (((longAt(contextToReturnTo)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l876;
					}
					if (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
						if (isWidowedContext(contextToReturnTo, self)) {

							/* error: home's sender is dead; cannot return */
							frameToReturnTo = 0;
							goto l876;
						}
						/* begin frameOfMarriedContext: */
						senderOop2 = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
						assert((((senderOop2) & 7) == 1));
						frameToReturnTo = pointerForOop(senderOop2 - 1);
						goto l876;
					}
					if (!(((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))))) & 7) == 1))) {
						frameToReturnTo = 0;
						goto l876;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo, self);
					markStackPageMostRecentlyUsed(thePage1, self);
					frameToReturnTo = (thePage1->baseFP);
	l876:	/* end establishFrameForContextToReturnTo: */;
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP, self), self));
							ourContext3 = longAt(localFP + FoxThisContext);
							goto l869;
						}
						ourContext3 = marryFrameSP(localFP, localSP, self);
	l869:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext3);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord(self))))));
						GIV(argumentCount) = 1;
						goto normalSend;
						/* return self */
						goto l868;
					}
				}
				assert(pageListIsWellFormed(self));
				/* begin stackPageFor: */
				index1 = pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage), self);
				newPage = stackPageAtpages(index1, GIV(pages), self);
				if (newPage != GIV(stackPage)) {
					currentCtx = longAt(((GIV(stackPage)->baseFP)) + FoxCallerContext);
					freeStackPage(GIV(stackPage), self);
					while (1) {
						assert(isContext(currentCtx, self));
						if ((((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx, self)), self)) == newPage)) break;
						if (((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
							/* begin stackPageFor: */
							index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
							thePage = stackPageAtpages(index, GIV(pages), self);
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage, self), newStackPage(self), self);
							}
							currentCtx = longAt(((thePage->baseFP)) + FoxCallerContext);
							freeStackPage(thePage, self);
						}
						else {
							/* begin fetchPointer:ofObject: */
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx, self));
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer = GIV(nilObj);
							assert(!(isOopForwarded(currentCtx, self)));
							longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer);
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer1 = GIV(nilObj);
							assert(!(isOopForwarded(currentCtx, self)));
							longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage, self);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = ((assert(!(isBaseFrame(callerFP, self))),
(callerFP + (frameStackedReceiverOffset(callerFP, self))) + BytesPerWord)) - BytesPerWord;
				}
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method), self));
				
#        if MULTIPLEBYTECODESETS
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
					? 256
					: 0);
#        endif /* MULTIPLEBYTECODESETS */
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput(localSP, localReturnValue);
			}
	l868:	/* end case */;
			break;
		case 121:
		case 345: /*89*/
			/* returnTrue */
			{
				VM_LABEL(returnTrue);
				/* begin trueObject */
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			break;
		case 122:
		case 346: /*90*/
			/* returnFalse */
			{
				VM_LABEL(returnFalse);
				/* begin falseObject */
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			break;
		case 123:
		case 347: /*91*/
			/* returnNil */
			{
				VM_LABEL(returnNil);
				/* begin nilObject */
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			break;
		case 124:
		case 348: /*92*/
			/* returnTopFromMethod */
			{
				VM_LABEL(returnTopFromMethod);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			break;
		case 125:
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt index;
				sqInt isAContext;
				sqInt ourContext;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					/* begin isContext: */
					isAContext = ((contextToReturnTo & (tagMask(self))) == 0)
					 && (((longAt(contextToReturnTo)) & (classIndexMask(self))) == ClassMethodContextCompactIndex);
					if (isAContext
					 && ((((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
					 && (!(isWidowedContext(contextToReturnTo, self))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
						assert((((senderOop) & 7) == 1));
						theFP = pointerForOop(senderOop - 1);
						/* begin stackPageFor: */
						index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
						thePage = stackPageAtpages(index, GIV(pages), self);
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage), self);
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l907;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l907;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
	l907:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage), self);
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))))) & 7) == 1)))) {
							/* begin internalCannotReturn: */
							if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(localFP, self), self));
								ourContext = longAt(localFP + FoxThisContext);
								goto l905;
							}
							ourContext = marryFrameSP(localFP, localSP, self);
	l905:	/* end ensureFrameIsMarried:SP: */;
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							/* begin splObj: */
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord(self))))));
							GIV(argumentCount) = 1;
							goto normalSend;
							/* return self */
							goto l911;
						}
						thePage = makeBaseFrameFor(contextToReturnTo, self);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage), self);
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage, self);
					assert((stackPageFor(theFP, self)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method), self));
					
#          if MULTIPLEBYTECODESETS
					GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
						? 256
						: 0);
#          endif /* MULTIPLEBYTECODESETS */
					localIP = pointerForOop(longAtPointer(localSP));
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP, self));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					/* return self */
	l911:	/* end baseFrameReturn */;
					goto l901;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord(self))))));
				localFP = callersFPOrNull;
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method), self));
				
#        if MULTIPLEBYTECODESETS
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
					? 256
					: 0);
#        endif /* MULTIPLEBYTECODESETS */
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput(localSP, localReturnValue);
			}
	l901:	/* end case */;
			break;
		case 126:
		case 127:
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (numSlotsOf(GIV(specialObjectsOop), self))
					? (/* begin fetchPointer:ofObject: */
						longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorUnknownBytecode) << (shiftForWord(self)))))))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP, self), self));
					ourContext = longAt(localFP + FoxThisContext);
					goto l913;
				}
				ourContext = marryFrameSP(localFP, localSP, self);
	l913:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt object3;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l34;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l34;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin fetchPointer:ofObject: */
					object2 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord(self))))));
					longAtPointerput((localSP -= BytesPerOop), object2);
					goto l34;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord(self))))));
					if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						litVar = unfollowatIndex(litVar, variableIndex, self);
					}
					/* begin internalPush: */
					object3 = longAt((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
					longAtPointerput((localSP -= BytesPerOop), object3);
					goto l34;
				}
			}
	l34:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt objOop;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				if (variableType == 0) {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					objOop = longAt(localFP + FoxReceiver);
					
#          if IMMUTABILITY
					assert(!((isImmediate(objOop, self))));
					if (((((usqInt) (longAt(objOop))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), objOop);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l49;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(objOop, self)));
					if ((assert(isNonImmediate(objOop, self)),
					oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((value & (tagMask(self))) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(objOop, self);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), value);
	l49:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l44;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l44;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord(self))))));
					if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						litVar = unfollowatIndex(litVar, variableIndex, self);
					}
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(litVar, self))));
					if (((((usqInt) (longAt(litVar))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l41;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar, self)));
					if ((assert(isNonImmediate(litVar, self)),
					oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((value & (tagMask(self))) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(litVar, self);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))), value);
	l41:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l44;
				}
				error("illegal store");
	l44:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt objOop;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				if (variableType == 0) {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					objOop = longAt(localFP + FoxReceiver);
					
#          if IMMUTABILITY
					assert(!((isImmediate(objOop, self))));
					if (((((usqInt) (longAt(objOop))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), objOop);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l62;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(objOop, self)));
					if ((assert(isNonImmediate(objOop, self)),
					oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((value & (tagMask(self))) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(objOop, self);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), value);
	l62:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l57;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l57;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord(self))))));
					if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						litVar = unfollowatIndex(litVar, variableIndex, self);
					}
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(litVar, self))));
					if (((((usqInt) (longAt(litVar))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l54;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar, self)));
					if ((assert(isNonImmediate(litVar, self)),
					oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((value & (tagMask(self))) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(litVar, self);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))), value);
	l54:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l57;
				}
				error("illegal store");
	l57:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord(self))))));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(normalSend);
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				lkupClassTag = (((tagBits = rcvr & (tagMask(self)))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask(self)));
				assert(lkupClassTag != (nilObject(self)));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					sqInt aValue;
					sqInt classTablePage;
					sqInt fieldIndex;
					sqInt fieldIndex1;
					sqInt hash1;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt nArgs;
					sqInt numTemps;
					sqInt object;
					sqInt probe1;
					sqInt rcvr;
					char *savedFramePointer;
					char *savedStackPointer;
					sqInt succeeded;

					VM_LABEL(commonSendOrdinary);
					nArgs = 0;
					savedFramePointer = ((char *) 0);
					savedStackPointer = ((char *) 0);
					/* begin sendBreakpoint:receiver: */
					sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector), self), lengthOfMaybeImmediate(GIV(messageSelector), self), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)), self);
					/* begin internalFindNewMethodOrdinary */
					hash1 = GIV(messageSelector) ^ (((sqInt)((usqInt)(lkupClassTag) << 2)));

					/* first probe */
					probe1 = hash1 & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						GIV(primitiveFunctionPointer) = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l916;
					}

					/* second probe */
					probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						GIV(primitiveFunctionPointer) = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l916;
					}
					probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						GIV(primitiveFunctionPointer) = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l916;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask(self))) == 0)
					 && (((longAt(GIV(messageSelector))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))
					 || (lkupClassTag == (isForwardedObjectClassIndexPun(self)))) {
						if (((GIV(messageSelector) & (tagMask(self))) == 0)
						 && (((longAt(GIV(messageSelector))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector), self);
						}
						if (lkupClassTag == (isForwardedObjectClassIndexPun(self))) {
							lkupClassTag = handleForwardedSendFaultForTag(lkupClassTag, self);
						}
						if (lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag, self)) {
							goto l926;
						}
					}
					/* begin classForClassTag: */
					assert((lkupClassTag >= 0)
					 && ((lkupClassTag <= (tagMask(self)))
					 || ((lkupClassTag >= (arrayClassIndexPun(self)))
					 && (lkupClassTag <= (classIndexMask(self))))));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) lkupClassTag) >> (classTableMajorIndexShift(self));
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l921;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = lkupClassTag & ((1U << (classTableMajorIndexShift(self))) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
	l921:	/* end classForClassTag: */;
					lookupMethodInClass(GIV(lkupClass), self);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass), self);
	l916:	;
	l926:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (GIV(primitiveFunctionPointer) != 0) {
						if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex(self));
							localPrimIndex = ((sqInt) GIV(primitiveFunctionPointer));
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								/* begin internalStackTopPut: */
								aValue = longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord(self))))));
								longAtPointerput(localSP, aValue);
								goto l930;
							}
							if (localPrimIndex == 256) {
								goto l930;
							}
							if (localPrimIndex == 257) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(trueObj));
								goto l930;
							}
							if (localPrimIndex == 258) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(falseObj));
								goto l930;
							}
							if (localPrimIndex == 259) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(nilObj));
								goto l930;
							}
							longAtPointerput(localSP, (((usqInt)(localPrimIndex - 261) << 3) | 1));
							goto l930;
						}
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
						assert((remapBufferCount(self)) == 0);
						nArgs = GIV(argumentCount);
						savedStackPointer = GIV(stackPointer);
						savedFramePointer = GIV(framePointer);
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
						assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
						/* begin maybeRetryPrimitiveOnFailure */
						if (GIV(primFailCode)) {
							retryPrimitiveOnFailure(self);
						}
						/* begin maybeFailForLastObjectOverwrite */
						if (checkAllocFiller(self)) {
							if (((freeStart(self)) < GIV(scavengeThreshold))
							 && ((longAt(freeStart(self))) != (freeStart(self)))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrWritePastObject;
							}
						}
						if ((!GIV(primFailCode))
						 && ((GIV(framePointer) == savedFramePointer)
						 && (!0))) {

							/* Don't fail if primitive has done something radical, e.g. perform: */
							if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
								flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
								failUnbalancedPrimitive(self);
								GIV(stackPointer) = savedStackPointer;
							}
						}
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod), self);
						}
						/* begin successful */
						succeeded = !GIV(primFailCode);
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							browserPluginReturnIfNeeded();
							goto l930;
						}
					}
					/* begin internalActivateNewMethod */
					assert(isCompiledMethod(GIV(newMethod), self));
					/* begin fetchPointer:ofObject: */
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
					numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
					assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader, self)));

					/* could new rcvr be set at point of send? */
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(!(isOopForwarded(rcvr, self)));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localIP);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localFP);
					localFP = localSP;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
					/* begin setMethod:methodHeader: */
					GIV(method) = GIV(newMethod);
					assert(isOopCompiledMethod(GIV(method), self));
					assert((methodHeaderOf(GIV(method), self)) == methodHeader);
					
#          if MULTIPLEBYTECODESETS
					GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
						? 256
						: 0);
#          endif /* MULTIPLEBYTECODESETS */
					/* begin internalPush: */
					object = (VMBIGENDIAN
						? ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
						: ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)))) + (0)) + (0));
					longAtPointerput((localSP -= BytesPerOop), object);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					}
					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1);
					if ((/* begin alternateHeaderHasPrimitiveFlag: */
					methodHeader & AlternateHeaderHasPrimFlag)) {

						/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
						   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
						localIP += 3;
						if (GIV(primFailCode) != 0) {
							reapAndResetErrorCodeToheader(localSP, methodHeader, self);
						}
					}
					assert((frameNumArgs(localFP, self)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP, self)));
					assert(!(frameHasContext(localFP, self)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader, self), self);
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
											}
	l930:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
			}
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				sqInt index1;
				sqInt litVar;
				sqInt litVar1;
				sqInt obj;
				sqInt obj1;
				sqInt object;
				sqInt object11;
				sqInt object2;
				sqInt object3;
				int onCurrentPage;
				sqInt opType;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char * theFP;
				StackPage * thePage;
				sqInt top;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord(self))))));
					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l69;
				}
				if (opType == 1) {
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord(self))))));
					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l69;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					/* begin pushMaybeContextReceiverVariable: */
					obj = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((longAt(obj)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						assert(byte3 < MethodIndex);
						assert(isContext(obj, self));
						if (!(((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))) {
							/* begin fetchPointer:ofObject: */
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord(self))))));
							goto l98;
						}
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed(self));
						if (isWidowedContext(obj, self)) {
							/* begin fetchPointer:ofObject: */
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord(self))))));
							goto l98;
						}
						/* begin frameOfMarriedContext: */
						senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
						assert((((senderOop) & 7) == 1));
						spouseFP = pointerForOop(senderOop - 1);
						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */
								object3 = longAt(spouseFP + FoxCallerContext);
								goto l98;
							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(callerFP, self), self));
								object3 = longAt(callerFP + FoxThisContext);
								goto l98;
							}
							object3 = marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP, self))),
							(spouseFP + (frameStackedReceiverOffset(spouseFP, self))) + BytesPerWord), self);
							goto l98;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP, self))) < (lengthOf(obj, self)));
							object3 = (((usqInt)(stackPointerIndexForFrame(spouseFP, self)) << 3) | 1);
							goto l98;
						}
						if (byte3 == InstructionPointerIndex) {
							object3 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP), self);
							goto l98;
						}
						error("bad index");
						object3 = 0;
	l98:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object3);
					}
					else {
						/* begin internalPush: */
						object11 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord(self))))));
						longAtPointerput((localSP -= BytesPerOop), object11);
					}
					goto l69;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin fetchPointer:ofObject: */
					object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord(self))))));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l69;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					/* begin pushLiteralVariable: */
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord(self))))));
					if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						litVar = unfollowatIndex(litVar, byte3, self);
					}
					/* begin internalPush: */
					object2 = longAt((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
					longAtPointerput((localSP -= BytesPerOop), object2);
					goto l69;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP, self)));
					/* begin fetchPointer:ofObject: */
					litVar1 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord(self))))));
					if (((longAt(litVar1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						litVar1 = unfollowatIndex(litVar1, byte3, self);
					}
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(litVar1, self))));
					if (((((usqInt) (longAt(litVar1))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar1);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), top);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l80;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar1, self)));
					if ((assert(isNonImmediate(litVar1, self)),
					oopisGreaterThanOrEqualTo(litVar1, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((top & (tagMask(self))) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar1))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(litVar1, self);
							}
						}
					}
					longAtput((litVar1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))), top);
	l80:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l69;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				obj1 = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((longAt(obj1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
				 && ((((((longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
				 || (0)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj1, self));
					assert(!((isObjImmutable(obj1, self))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed(self));
					if (!((((((longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
						 && (!(isWidowedContext(obj1, self))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(obj1, self)));
						if ((assert(isNonImmediate(obj1, self)),
						oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart), self))) {

							/* most stores into young objects */
							if (((top & (tagMask(self))) == 0)
							 && (oopisLessThan(top, GIV(newSpaceLimit), self))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(obj1))) >> (rememberedBitShift(self))) & 1) != 0)) {
									remember(obj1, self);
								}
							}
						}
						longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord(self))))), top);
						if (byte3 == StackPointerIndex) {
						}
						goto l78;
					}
					/* begin frameOfMarriedContext: */
					senderOop1 = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
					assert((((senderOop1) & 7) == 1));
					theFP = pointerForOop(senderOop1 - 1);
					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
						thePage = stackPageAtpages(index1, GIV(pages), self);
						assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top, self);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage), self);
						}
						goto l78;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj1, self);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj1, self)));
					if ((assert(isNonImmediate(obj1, self)),
					oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((top & (tagMask(self))) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(obj1))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(obj1, self);
							}
						}
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord(self))))), top);
					if (byte3 == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage), self);
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__, self);
	l78:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(obj1, self))));
					if (((((usqInt) (longAt(obj1))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), obj1);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), top);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(byte3 + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l83;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj1, self)));
					if ((assert(isNonImmediate(obj1, self)),
					oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((top & (tagMask(self))) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(obj1))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(obj1, self);
							}
						}
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord(self))))), top);
	l83:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
	l69:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord(self))))));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto superclassSend */
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt aValue;
				sqInt classPointer;
				sqInt err;
				sqInt hash;
				sqInt literal;
				sqInt objOop;
				sqInt objOop1;
				sqInt objOop11;
				sqInt objOop2;
				sqInt offset;
				sqInt referent;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				offset = ((assert((((((assert(isCompiledMethod(GIV(method), self)),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(GIV(method), self)),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
				/* begin followField:ofObject: */
				objOop11 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
				if (((objOop11 & (tagMask(self))) == 0)
				 && (((longAt(objOop11)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop11 = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, GIV(method), objOop11, self);
				}
				literal = objOop11;
				if ((literal != GIV(nilObj))
				 && (((literal & (tagMask(self))) == 0)
				 && (((((usqInt) (longAt(literal))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))) {
					assert((numSlotsOf(literal, self)) > ValueIndex);
					/* begin followField:ofObject: */
					objOop2 = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
					if (((objOop2 & (tagMask(self))) == 0)
					 && (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop2 = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop2, self);
					}
					classPointer = objOop2;
				}
				else {
					/* begin nilObject */
					classPointer = GIV(nilObj);
				}
				/* begin followField:ofObject: */
				objOop = longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
				if (((objOop & (tagMask(self))) == 0)
				 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop, self);
				}
				superclass = objOop;

				/* To maintain the invariant that all receivers are unforwarded we need an explicit
				   read barrier in the super send cases.  Even though we always follow receivers
				   on become  e.g. super doSomethingWith: (self become: other) forwards the receiver
				   self pushed on the stack. */
				assert(addressCouldBeClassObj(superclass, self));
				lkupClassTag = (((hash = (long32At(superclass + 4)) & (identityHashHalfWordMask(self)))) != 0
					? hash
					: (objCouldBeClassObj(superclass, self)
							? (((err = enterIntoClassTable(superclass, self))) != 0
									? -err
									: (/* begin rawHashBitsOf: */
										(long32At(superclass + 4)) & (identityHashHalfWordMask(self))))
							: -PrimErrBadReceiver));
				/* begin ensureReceiverUnforwarded */
				if ((((longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop))) & (tagMask(self))) == 0)
				 && (((longAt(longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin internalStackValue:put: */
					objOop1 = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(isUnambiguouslyForwarder(objOop1, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					aValue = referent;
					longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), aValue);
				}
				assert(lkupClassTag != (nilObject(self)));
				goto commonSendOrdinary;
			}
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x3F) + LiteralStart)) << (shiftForWord(self))))));
				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			break;
		case 135:
		case 472: /*216*/
			/* popStackBytecode */
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 136:
		case 339: /*83*/
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 137:
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP, self), self));
					ourContext = longAt(localFP + FoxThisContext);
					goto l106;
				}
				ourContext = marryFrameSP(localFP, localSP, self);
	l106:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				usqInt array;
				sqInt i;
				usqInt newObj;
				usqInt numBytes;
				int popValues;
				sqInt size;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(pushNewArrayBytecode);
				/* begin fetchByte */
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((size >= 0)
				 && ((knownClassAtIndex(ClassArrayCompactIndex, self)) != GIV(nilObj)));
				assert((2 /* arrayFormat */) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex, self), self)));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(size < (numSlotsMask(self)));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((size < 1
	? 8 /* allocationUnit */
	: size * BytesPerOop));
				assert((numBytes % (allocationUnit(self))) == 0);
				assert((newObj % (allocationUnit(self))) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck(self);
					}
					if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						array = 0;
						goto l107;
					}
				}
				long64Atput(newObj, (((((usqLong) size)) << (numSlotsFullShift(self))) + (2U << (formatShift(self)))) + ClassArrayCompactIndex);
				GIV(freeStart) += numBytes;
				array = newObj;
	l107:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((size - i) - 1) * BytesPerOop));
						assert(!(isOopForwarded(array, self)));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer1 = GIV(nilObj);
						assert(!(isOopForwarded(array, self)));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer1);
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 139:
			/* callPrimitiveBytecode */
			{
				sqInt header;

				VM_LABEL(callPrimitiveBytecode);
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(method), self));
				/* begin fetchPointer:ofObject: */
				header = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
				if (((/* begin alternateHeaderHasPrimitiveFlag: */
				header & AlternateHeaderHasPrimFlag))
				 && ((((sqInt)localIP)) == ((GIV(method) + ((LiteralStart + ((assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize))) {
					localIP = (localIP + (3)) - 1;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l113;
				}
				else {
					goto respondToUnknownBytecode;
					goto l113;
				}
			}
	l113:	/* end case */;
			break;
		case 140:
		case 507: /*251*/
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				object = longAt((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord(self))))));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 141:
		case 508: /*252*/
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector, self)));
				if ((assert(isNonImmediate(tempVector, self)),
				oopisGreaterThanOrEqualTo(tempVector, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if ((((longAtPointer(localSP)) & (tagMask(self))) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(tempVector, self);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord(self))))), longAtPointer(localSP));
			}
			break;
		case 142:
		case 509: /*253*/
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector, self)));
				if ((assert(isNonImmediate(tempVector, self)),
				oopisGreaterThanOrEqualTo(tempVector, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if ((((longAtPointer(localSP)) & (tagMask(self))) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(tempVector, self);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord(self))))), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				usqInt newClosure;
				usqInt newClosure1;
				usqInt newObj;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				usqInt numBytes;
				sqInt numCopied;
				sqInt numSlots;
				sqInt objFormat;
				sqInt valuePointer;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				/* begin fetchByte */
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = ((sqInt)((usqInt)((byteAtPointer(++localIP))) << 8));
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP, self), self));
					context = longAt(localFP + FoxThisContext);
					goto l138;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop), self);
	l138:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = indexablePointersFormat(self);
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				assert((numSlots >= 0)
				 && ((knownClassAtIndex(ClassBlockClosureCompactIndex, self)) != GIV(nilObj)));
				assert(((objFormat < (firstByteFormat(self))
					? objFormat
					: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex, self), self)));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask(self)));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit(self))) == 0);
				assert((newObj % (allocationUnit(self))) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck(self);
					}
					if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l141;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
	l141:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord(self))))), (((usqInt)initialIP << 3) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))), (((usqInt)numArgs << 3) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop));
						assert(!(isOopForwarded(newClosure, self)));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord(self))))), valuePointer);
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 144:
		case 432: /*176*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 145:
		case 433: /*177*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 146:
		case 434: /*178*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 147:
		case 435: /*179*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 148:
		case 436: /*180*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 149:
		case 437: /*181*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 150:
		case 438: /*182*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 151:
		case 439: /*183*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);
#        endif /* MULTIPLEBYTECODESETS */
			}
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord(self))))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l147;
					}
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
	l147:	/* end jumplfFalseBy: */;
			}
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1, self);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
									}
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord(self))))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l152;
					}
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
	l152:	/* end jumplfTrueBy: */;
			}
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord(self))))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l156;
					}
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
	l156:	/* end jumplfFalseBy: */;
			}
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					result = ((rcvr >> 3)) + ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 3) | 1));
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l158;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l168;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l168;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l168;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l168:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l161;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l161;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l161;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l161:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l158;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((0 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l158:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					result = ((rcvr >> 3)) - ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 3) | 1));
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l169;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l179;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l179;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l179;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l179:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l172;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l172;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l172;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l172:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l169;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((1 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l169:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l180;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l186;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l186;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l186;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l186:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l189;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l189;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l189;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l189:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l180;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((2 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l180:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l944;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l944;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */
						offset = (((sqInt)((usqInt)((bytecode - 168)) << 8))) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(localIP);
#            endif /* MULTIPLEBYTECODESETS */
						goto l944;
					}
				}
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = bytecode;
#        endif /* MULTIPLEBYTECODESETS */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
	l944:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l190;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l196;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l196;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l196;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l196:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l199;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l199;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l199;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l199:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l190;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((3 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l190:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
					goto l947;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
					goto l947;
				}
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = bytecode;
#        endif /* MULTIPLEBYTECODESETS */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
	l947:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l200;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l206;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l206;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l206;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l206:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l209;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l209;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l209;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l209:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l200;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((4 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l200:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l210;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l216;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l216;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l216;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l216:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l219;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l219;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l219;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l219:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l210;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((5 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l210:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l220;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l226;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l226;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l226;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l226:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l229;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l229;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l229;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l229:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l220;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((6 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l220:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l230;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l236;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l236;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l236;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l236:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l239;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l239;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l239;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l239:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l230;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((7 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l230:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt oop;
				sqInt overflow;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					overflow = (rcvr > 0
						? (arg > 0
								? rcvr > ((MaxSmallInteger) / arg)
								: arg < ((MinSmallInteger) / rcvr))
						: (arg > 0
								? rcvr < ((MinSmallInteger) / arg)
								: (rcvr < 0)
									 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 3) | 1);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), oop);
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l240;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l250;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l250;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l250;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l250:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l243;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l243;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l243;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l243:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l240;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((8 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l240:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 3) | 1));
							/* begin fetchNextBytecode */
							if (GIV(isStepable)) {
								printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
								/* begin externalizeIPandSP */
								GIV(instructionPointer) = oopForPointer(localIP);
								GIV(stackPointer) = localSP;
								GIV(framePointer) = localFP;
								printCallStack(self);
								lockFetchNextBytecode(self);
							}
							currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
							goto l251;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l261;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l261;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l261;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l261:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l254;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l254;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l254;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l254:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l251;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((9 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l251:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;
				sqInt objOop;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)), self);
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)mod << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l262;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((10 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l262:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				sqInt arg;
				sqInt classObj;
				sqInt knownClassIndex;
				usqInt newObj;
				usqInt numBytes;
				sqInt numSlots;
				sqInt objFormat;
				sqInt objOop;
				usqInt pt;
				sqInt rcvr;

				VM_LABEL(bytecodePrimMakePoint);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if (((rcvr & (tagMask(self))
					? !(rcvr & (characterTag(self)))
					: ((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex))
				 && ((arg & (tagMask(self))
					? !(arg & (characterTag(self)))
					: ((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex))) {
					/* begin eeInstantiateSmallClass:numSlots: */
					classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
					numSlots = YIndex + 1;
					assert((rawHashBitsOf(classObj, self)) != 0);
					/* begin eeInstantiateSmallClassIndex:format:numSlots: */
					knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
					/* begin instSpecOfClassFormat: */
					objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
					assert((numSlots >= 0)
					 && ((knownClassIndex != 0)
					 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
					assert(((objFormat < (firstByteFormat(self))
						? objFormat
						: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
					/* begin allocateSmallNewSpaceSlots:format:classIndex: */
					assert(numSlots < (numSlotsMask(self)));
					newObj = GIV(freeStart);
					numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
					assert((numBytes % (allocationUnit(self))) == 0);
					assert((newObj % (allocationUnit(self))) == 0);
					if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
						if (!GIV(needGCFlag)) {
							/* begin scheduleScavenge */
							GIV(needGCFlag) = 1;
							forceInterruptCheck(self);
						}
						if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
							error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
							pt = 0;
							goto l271;
						}
					}
					long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + knownClassIndex);
					GIV(freeStart) += numBytes;
					pt = newObj;
	l271:	/* end eeInstantiateSmallClass:numSlots: */;
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(pt, self)));
					longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self))))), rcvr);
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(pt, self)));
					longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self))))), arg);
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), pt);
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l266;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((11 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l266:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt objOop;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((((integerArgument) & 7) == 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l276;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = signed64BitValueOf(integerReceiver, self);
				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 3))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 61 /* numSmallIntegerBits */)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l276;
						}
						shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
						if (!(integerReceiver == (((sqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l276;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-61 /* numSmallIntegerBits */))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l276;
						}
						shifted = ((sqInt) integerReceiver) >> (0 - integerArgument);
					}
					shifted = ((((((usqInt) shifted) >> 60) + 1) & 15) <= 1
						? (((usqInt)shifted << 3) | 1)
						: signed64BitIntegerFor(shifted, self));
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
	l276:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l275;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((12 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l275:	/* end case */;
			break;
		case 189:
			/* bytecodePrimDiv */
			{
				sqInt objOop;
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)), self);
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)quotient << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l281;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((13 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l281:	/* end case */;
			break;
		case 190:
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l285;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd(self);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l285;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((14 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l285:	/* end case */;
			break;
		case 191:
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l290;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr(self);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l290;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((15 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l290:	/* end case */;
			break;
		case 192:
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt class;
				sqInt classFormat;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				usqLong fmt;
				usqLong fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				usqInt numSlots11;
				usqInt numSlots12;
				usqInt numSlots2;
				usqInt numSlots3;
				sqInt objOop;
				sqInt objOop1;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				usqInt result1;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;

				VM_LABEL(bytecodePrimAt);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask(self))) == 0)
				 && ((((index) & 7) == 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */
					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						/* begin fetchClassTagOfNonImm: */
						lkupClassTag = (longAt(rcvr)) & (classIndexMask(self));
						/* begin fetchPointer:ofObject: */
						objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
						GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((16 * 2)) << (shiftForWord(self))))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag, self))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l295;
						}
						if (GIV(primitiveFunctionPointer) == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr, self)));
							/* begin baseHeader: */
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
							if (((fmt >= (firstShortFormat(self))) && (fmt <= ((firstByteFormat(self)) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l310;
							}
							if ((fmt == (indexablePointersFormat(self)))
							 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l310;
							}
							/* begin lengthOf:format: */
							numSlots11 = byteAt(rcvr + 7);
							numSlots2 = (numSlots11 == (numSlotsMask(self))
								? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
								: numSlots11);
							if (fmt <= 5 /* ephemeronFormat */) {
								totalLength = numSlots2;
								goto l320;
							}
							if (fmt >= (firstByteFormat(self))) {

								/* bytes, including CompiledMethod */
								totalLength = (numSlots2 << (shiftForWord(self))) - (fmt & 7);
								goto l320;
							}
							if (fmt >= (firstShortFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt & 3);
								goto l320;
							}
							if (fmt >= (firstLongFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt & 1);
								goto l320;
							}
							if (fmt == (sixtyFourBitIndexableFormat(self))) {
								totalLength = numSlots2;
								goto l320;
							}
							totalLength = 0;
	l320:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt >= (sixtyFourBitIndexableFormat(self)))
							 || (fmt == 2 /* arrayFormat */)) {
								fixedFields = 0;
								goto l304;
							}
							if (fmt < 2 /* arrayFormat */) {
								fixedFields = totalLength;
								goto l304;
							}
							class = fetchClassOfNonImm(rcvr, self);
							/* begin fixedFieldsOfClassFormat: */
							classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
							fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l304:	/* end fixedFieldsOf:format:length: */;
							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
	l310:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (GIV(primitiveFunctionPointer) == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr, self)));
								/* begin baseHeader: */
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt1 = (((unsigned sqLong)hdr1) >> (formatShift(self))) & (formatMask(self));
								if (((fmt1 >= (firstShortFormat(self))) && (fmt1 <= ((firstByteFormat(self)) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l308;
								}
								
								/* special flag for strings */
								/* begin lengthOf:format: */
								numSlots12 = byteAt(rcvr + 7);
								numSlots3 = (numSlots12 == (numSlotsMask(self))
									? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
									: numSlots12);
								if (fmt1 <= 5 /* ephemeronFormat */) {
									totalLength1 = numSlots3;
									goto l321;
								}
								if (fmt1 >= (firstByteFormat(self))) {

									/* bytes, including CompiledMethod */
									totalLength1 = (numSlots3 << (shiftForWord(self))) - (fmt1 & 7);
									goto l321;
								}
								if (fmt1 >= (firstShortFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
									goto l321;
								}
								if (fmt1 >= (firstLongFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
									goto l321;
								}
								if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
									totalLength1 = numSlots3;
									goto l321;
								}
								totalLength1 = 0;
	l321:	/* end lengthOf:format: */;
								fixedFields1 = 0;
								fmt1 += 32 /* firstStringyFakeFormat */;
								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
	l308:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l295;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 3);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1, self))
						 && (oopisLessThanOrEqualTo(index1, stSize, self))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat(self))) {
								assert(!(isContextNonImm(rcvr, self)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin fetchPointer:ofObject: */
								result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord(self))))));
								goto l307;
							}
							if (fmt2 < (firstByteFormat(self))) {

								/* 64, 32, & 16 bits */
								if (fmt2 >= (firstShortFormat(self))) {
									result = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))))))) << 3) | 1);
									goto l307;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat(self))) {
									result = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 3)))), self);
									goto l307;
								}
								/* begin fetchLong32:ofObject: */
								result1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))))));
								/* begin positive32BitIntegerFor: */
								result = ((((((usqInt)(((unsigned int) result1)))) & 0xFFFFFFFFU) << 3) | 1);
								goto l307;
							}
							if (fmt2 >= 32 /* firstStringyFakeFormat */) {

								/* Spur supports the String at:[put:] primitives on WideString and DoubleByteString */
								/* String */
								if (fmt2 < ((firstByteFormat(self)) + 32 /* firstStringyFakeFormat */)) {
									if (fmt2 < ((firstShortFormat(self)) + 32 /* firstStringyFakeFormat */)) {
										/* begin fetchLong32:ofObject: */
										result1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))))));
									}
									else {
										/* begin fetchUnsignedShort16:ofObject: */
										result1 = ((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))))));
									}
								}
								else {
									/* begin fetchByte:ofObject: */
									result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));
								}
								/* begin characterForAscii: */
								result = (result1 << (numTagBits(self))) + (characterTag(self));
								goto l307;
							}
							else {
								if ((fmt2 < (firstCompiledMethodFormat(self)))
								 || (index1 >= ((((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 3) | 1);
									goto l307;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr, self)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
	l307:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l295;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)((16 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l295:	/* end case */;
			break;
		case 193:
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt class;
				sqInt classFormat;
				sqInt correctRcvr;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				usqLong fmt;
				usqLong fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				sqInt isCharacter;
				usqInt numSlots11;
				usqInt numSlots12;
				usqInt numSlots2;
				usqInt numSlots3;
				sqInt objOop;
				sqInt objOop1;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;
				usqLong val64ToPut;
				sqInt valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				
#        if IMMUTABILITY
				/* begin isOopMutable: */
				correctRcvr = ((rcvr & (tagMask(self))) == 0)
				 && (!(((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0));
#        else /* IMMUTABILITY */
				/* begin isNonImmediate: */
				correctRcvr = (rcvr & (tagMask(self))) == 0;
#        endif /* IMMUTABILITY */
				if (correctRcvr
				 && ((((index) & 7) == 1))) {

					/* Index into atPutCache */
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						/* begin fetchClassTagOfNonImm: */
						lkupClassTag = (longAt(rcvr)) & (classIndexMask(self));
						/* begin fetchPointer:ofObject: */
						objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
						GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((17 * 2)) << (shiftForWord(self))))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag, self))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l323;
						}
						if (GIV(primitiveFunctionPointer) == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr, self)));
							/* begin baseHeader: */
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
							if (((fmt >= (firstShortFormat(self))) && (fmt <= ((firstByteFormat(self)) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l363;
							}
							if ((fmt == (indexablePointersFormat(self)))
							 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l363;
							}
							/* begin lengthOf:format: */
							numSlots11 = byteAt(rcvr + 7);
							numSlots2 = (numSlots11 == (numSlotsMask(self))
								? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
								: numSlots11);
							if (fmt <= 5 /* ephemeronFormat */) {
								totalLength = numSlots2;
								goto l361;
							}
							if (fmt >= (firstByteFormat(self))) {

								/* bytes, including CompiledMethod */
								totalLength = (numSlots2 << (shiftForWord(self))) - (fmt & 7);
								goto l361;
							}
							if (fmt >= (firstShortFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt & 3);
								goto l361;
							}
							if (fmt >= (firstLongFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt & 1);
								goto l361;
							}
							if (fmt == (sixtyFourBitIndexableFormat(self))) {
								totalLength = numSlots2;
								goto l361;
							}
							totalLength = 0;
	l361:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt >= (sixtyFourBitIndexableFormat(self)))
							 || (fmt == 2 /* arrayFormat */)) {
								fixedFields = 0;
								goto l335;
							}
							if (fmt < 2 /* arrayFormat */) {
								fixedFields = totalLength;
								goto l335;
							}
							class = fetchClassOfNonImm(rcvr, self);
							/* begin fixedFieldsOfClassFormat: */
							classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
							fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l335:	/* end fixedFieldsOf:format:length: */;
							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
	l363:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (GIV(primitiveFunctionPointer) == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr, self)));
								/* begin baseHeader: */
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt1 = (((unsigned sqLong)hdr1) >> (formatShift(self))) & (formatMask(self));
								if (((fmt1 >= (firstShortFormat(self))) && (fmt1 <= ((firstByteFormat(self)) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l352;
								}
								
								/* special flag for strings */
								/* begin lengthOf:format: */
								numSlots12 = byteAt(rcvr + 7);
								numSlots3 = (numSlots12 == (numSlotsMask(self))
									? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
									: numSlots12);
								if (fmt1 <= 5 /* ephemeronFormat */) {
									totalLength1 = numSlots3;
									goto l329;
								}
								if (fmt1 >= (firstByteFormat(self))) {

									/* bytes, including CompiledMethod */
									totalLength1 = (numSlots3 << (shiftForWord(self))) - (fmt1 & 7);
									goto l329;
								}
								if (fmt1 >= (firstShortFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
									goto l329;
								}
								if (fmt1 >= (firstLongFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
									goto l329;
								}
								if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
									totalLength1 = numSlots3;
									goto l329;
								}
								totalLength1 = 0;
	l329:	/* end lengthOf:format: */;
								fixedFields1 = 0;
								fmt1 += 32 /* firstStringyFakeFormat */;
								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
	l352:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l323;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						index1 = (index >> 3);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1, self))
						 && (oopisLessThanOrEqualTo(index1, stSize, self))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat(self))) {
								assert(!(isContextNonImm(rcvr, self)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								assert(!(isForwarded(rcvr, self)));
								if ((assert(isNonImmediate(rcvr, self)),
								oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

									/* most stores into young objects */
									if (((value & (tagMask(self))) == 0)
									 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
											remember(rcvr, self);
										}
									}
								}
								longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord(self))))), value);
								goto l338;
							}
							if (fmt2 < (firstByteFormat(self))) {

								/* 64, 32, & 16 bits */
								if (fmt2 >= (firstShortFormat(self))) {
									valToPut = ((((value) & 7) == 1)
										? (value >> 3)
										: -1);
									if (!((valToPut >= 0)
										 && (valToPut <= 0xFFFF))) {
										/* begin primitiveFailFor: */
										GIV(primFailCode) = PrimErrBadArgument;
										goto l338;
									}
									/* begin storeShort16:ofObject:withValue: */
									shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))), valToPut);
									goto l338;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat(self))) {
									val64ToPut = positive64BitValueOf(value, self);
									if (!GIV(primFailCode)) {
										/* begin storeLong64:ofObject:withValue: */
										long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 3))), val64ToPut);
										goto l338;
									}
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l338;
								}
								valToPut = positive32BitValueOf(value, self);
								if (!GIV(primFailCode)) {
									/* begin storeLong32:ofObject:withValue: */
									long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))), valToPut);
									goto l338;
								}
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l338;
							}
							if (fmt2 >= 32 /* firstStringyFakeFormat */) {
								/* begin isCharacterObject: */
								isCharacter = value & (characterTag(self));
								if (!isCharacter) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l338;
								}
								/* begin characterValueOf: */
								valToPut = ((usqInt) (((usqInt)value))) >> (numTagBits(self));
								if (fmt2 < ((firstByteFormat(self)) + 32 /* firstStringyFakeFormat */)) {
									if (fmt2 < ((firstShortFormat(self)) + 32 /* firstStringyFakeFormat */)) {
										assert(fmt2 != ((sixtyFourBitIndexableFormat(self)) + (firstStringyFakeFormat(self))));
										/* begin storeLong32:ofObject:withValue: */
										long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))), valToPut);
										goto l338;
									}
									else {
										if (!((valToPut >= 0)
											 && (valToPut <= 0xFFFF))) {
											/* begin primitiveFailFor: */
											GIV(primFailCode) = PrimErrBadArgument;
											goto l338;
										}
										/* begin storeShort16:ofObject:withValue: */
										shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))), valToPut);
										goto l338;
									}
								}
							}
							else {
								if ((fmt2 >= (firstCompiledMethodFormat(self)))
								 && (index1 < ((((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1))) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadIndex;
									goto l338;
								}
								valToPut = ((((value) & 7) == 1)
									? (value >> 3)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l338;
							}
							/* begin storeByte:ofObject:withValue: */
							byteAtput((rcvr + BaseHeaderSize) + (index1 - 1), valToPut);
							goto l338;
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr, self)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
						/* return self */
	l338:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l323;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)((17 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
	l323:	/* end case */;
			break;
		case 194:
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt fmt;
				sqInt fmt1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				sqInt objOop;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isString = 0;
					goto l371;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex = (longAt(rcvr)) & (classIndexMask(self));
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l371;
	l371:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf:format: */
					fmt = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
					/* begin numSlotsOfAny: */
					numSlots1 = byteAt(rcvr + 7);
					numSlots = (numSlots1 == (numSlotsMask(self))
						? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots1);
					if (fmt <= 5 /* ephemeronFormat */) {
						sz = numSlots;
						goto l373;
					}
					if (fmt >= (firstByteFormat(self))) {

						/* bytes, including CompiledMethod */
						sz = (numSlots << (shiftForWord(self))) - (fmt & 7);
						goto l373;
					}
					if (fmt >= (firstShortFormat(self))) {
						sz = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
						goto l373;
					}
					if (fmt >= (firstLongFormat(self))) {
						sz = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
						goto l373;
					}
					if (fmt == (sixtyFourBitIndexableFormat(self))) {
						sz = numSlots;
						goto l373;
					}
					sz = 0;
	l373:	/* end lengthOf:format: */;
					longAtPointerput(localSP, (((usqInt)sz << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l367;
				}
				/* begin is:instanceOf:compactClassIndex: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isArray = 0;
					goto l368;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex1 = (longAt(rcvr)) & (classIndexMask(self));
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l368;
	l368:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf:format: */
					fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
					/* begin numSlotsOfAny: */
					numSlots11 = byteAt(rcvr + 7);
					numSlots2 = (numSlots11 == (numSlotsMask(self))
						? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots11);
					if (fmt1 <= 5 /* ephemeronFormat */) {
						sz = numSlots2;
						goto l372;
					}
					if (fmt1 >= (firstByteFormat(self))) {

						/* bytes, including CompiledMethod */
						sz = (numSlots2 << (shiftForWord(self))) - (fmt1 & 7);
						goto l372;
					}
					if (fmt1 >= (firstShortFormat(self))) {
						sz = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
						goto l372;
					}
					if (fmt1 >= (firstLongFormat(self))) {
						sz = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
						goto l372;
					}
					if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
						sz = numSlots2;
						goto l372;
					}
					sz = 0;
	l372:	/* end lengthOf:format: */;
					longAtPointerput(localSP, (((usqInt)sz << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l367;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((18 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l367:	/* end case */;
			break;
		case 195:
		case 371: /*115*/
			/* bytecodePrimNext */
			{
				sqInt objOop;

				VM_LABEL(bytecodePrimNext);
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((19 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = ((fetchPointerofObject((19 * 2) + 1, splObj(SpecialSelectors, self), self)) >> 3);
				goto normalSend;
			}
			break;
		case 196:
		case 372: /*116*/
			/* bytecodePrimNextPut */
			{
				sqInt objOop;

				VM_LABEL(bytecodePrimNextPut);
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((20 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = ((fetchPointerofObject((20 * 2) + 1, splObj(SpecialSelectors, self), self)) >> 3);
				goto normalSend;
			}
			break;
		case 197:
		case 373: /*117*/
			/* bytecodePrimAtEnd */
			{
				sqInt objOop;

				VM_LABEL(bytecodePrimAtEnd);
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((21 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = ((fetchPointerofObject((21 * 2) + 1, splObj(SpecialSelectors, self), self)) >> 3);
				goto normalSend;
			}
			break;
		case 198:
			/* bytecodePrimIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask(self))) == 0)
				 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP, self);
				}
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((arg & (tagMask(self))) == 0)
				 && (((longAt(arg)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP, self);
				}
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 199:
		case 375: /*119*/
			/* bytecodePrimClass */
			{
				sqInt aValue;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				if (((rcvr & (tagMask(self))) == 0)
				 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP, self);
				}
				/* begin internalStackTopPut: */
				aValue = (((tagBits = rcvr & (tagMask(self)))) != 0
					? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
					: fetchClassOfNonImm(rcvr, self));
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 200:
			/* bytecodePrimNotIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask(self))) == 0)
				 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP, self);
				}
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((arg & (tagMask(self))) == 0)
				 && (((longAt(arg)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP, self);
				}
				/* begin booleanCheat: */
				if (rcvr != arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 201:
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isBlock = 0;
					goto l392;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex = (longAt(rcvr)) & (classIndexMask(self));
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l392;
	l392:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue(self);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l388;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((25 * 2)) << (shiftForWord(self))))));
				goto normalSend;
			}
	l388:	/* end case */;
			break;
		case 202:
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isBlock = 0;
					goto l398;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex = (longAt(rcvr)) & (classIndexMask(self));
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l398;
	l398:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue(self);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l394;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((26 * 2)) << (shiftForWord(self))))));
				goto normalSend;
			}
	l394:	/* end case */;
			break;
		case 203:
		case 379: /*123*/
			/* bytecodePrimDo */
			{
				sqInt objOop;

				VM_LABEL(bytecodePrimDo);
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((27 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = ((fetchPointerofObject((27 * 2) + 1, splObj(SpecialSelectors, self), self)) >> 3);
				goto normalSend;
			}
			break;
		case 204:
		case 380: /*124*/
			/* bytecodePrimNew */
			{
				sqInt objOop;

				VM_LABEL(bytecodePrimNew);
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((28 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 205:
		case 381: /*125*/
			/* bytecodePrimNewWithArg */
			{
				sqInt objOop;

				VM_LABEL(bytecodePrimNewWithArg);
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((29 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			break;
		case 206:
			/* bytecodePrimPointX */
			{
				sqInt classOop;
				sqInt objOop;
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
				/* begin isNonImmediate: */
				ok = (rcvr & (tagMask(self))) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr, self));
					ok = ((longAt(rcvr)) & (classIndexMask(self))) == ((long32At(classOop + 4)) & (identityHashHalfWordMask(self)));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self)))))));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l406;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((30 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l406:	/* end case */;
			break;
		case 207:
			/* bytecodePrimPointY */
			{
				sqInt classOop;
				sqInt objOop;
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
				/* begin isNonImmediate: */
				ok = (rcvr & (tagMask(self))) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr, self));
					ok = ((longAt(rcvr)) & (classIndexMask(self))) == ((long32At(classOop + 4)) & (identityHashHalfWordMask(self)));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self)))))));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l414;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((0x1F * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l414:	/* end case */;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 221:
		case 222:
		case 223:
		case 384: /*128*/
		case 385: /*129*/
		case 386: /*130*/
		case 387: /*131*/
		case 388: /*132*/
		case 389: /*133*/
		case 390: /*134*/
		case 391: /*135*/
		case 392: /*136*/
		case 393: /*137*/
		case 394: /*138*/
		case 395: /*139*/
		case 396: /*140*/
		case 397: /*141*/
		case 398: /*142*/
		case 399: /*143*/
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				lkupClassTag = (((tagBits = rcvr & (tagMask(self)))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask(self)));
				assert(lkupClassTag != (nilObject(self)));
				goto commonSendOrdinary;
			}
			break;
		case 224:
		case 225:
		case 226:
		case 227:
		case 228:
		case 229:
		case 230:
		case 231:
		case 232:
		case 233:
		case 234:
		case 235:
		case 236:
		case 237:
		case 238:
		case 239:
		case 400: /*144*/
		case 401: /*145*/
		case 402: /*146*/
		case 403: /*147*/
		case 404: /*148*/
		case 405: /*149*/
		case 406: /*150*/
		case 407: /*151*/
		case 408: /*152*/
		case 409: /*153*/
		case 410: /*154*/
		case 411: /*155*/
		case 412: /*156*/
		case 413: /*157*/
		case 414: /*158*/
		case 415: /*159*/
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				lkupClassTag = (((tagBits = rcvr & (tagMask(self)))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask(self)));
				assert(lkupClassTag != (nilObject(self)));
				goto commonSendOrdinary;
			}
			break;
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 248:
		case 249:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
		case 416: /*160*/
		case 417: /*161*/
		case 418: /*162*/
		case 419: /*163*/
		case 420: /*164*/
		case 421: /*165*/
		case 422: /*166*/
		case 423: /*167*/
		case 424: /*168*/
		case 425: /*169*/
		case 426: /*170*/
		case 427: /*171*/
		case 428: /*172*/
		case 429: /*173*/
		case 430: /*174*/
		case 431: /*175*/
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord(self))))));
				GIV(argumentCount) = 2;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				lkupClassTag = (((tagBits = rcvr & (tagMask(self)))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask(self)));
				assert(lkupClassTag != (nilObject(self)));
				goto commonSendOrdinary;
			}
			break;
		case 256: /*0*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode16);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 256, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 257: /*1*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode17);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 257, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 258: /*2*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode18);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 258, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 259: /*3*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode19);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 259, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 260: /*4*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode20);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 260, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 261: /*5*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode21);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 261, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 262: /*6*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode22);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 262, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 263: /*7*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode23);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 263, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 264: /*8*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode24);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 264, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 64 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 265: /*9*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode25);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 265, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 72 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 266: /*10*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode26);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 266, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 80 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 267: /*11*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode27);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 267, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 88 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 268: /*12*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode28);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 268, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 96 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 269: /*13*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode29);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 269, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 104 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 270: /*14*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode30);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 270, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 112 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 271: /*15*/
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode31);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 271, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 120 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 272: /*16*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 272, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 0 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 273: /*17*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode1);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 273, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 1 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 274: /*18*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode2);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 274, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 2 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 275: /*19*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode3);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 275, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 3 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 276: /*20*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode4);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 276, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 4 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 277: /*21*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode5);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 277, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 5 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 278: /*22*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode6);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 278, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 6 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 279: /*23*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode7);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 279, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 7 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 280: /*24*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode8);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 280, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 8 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 281: /*25*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode9);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 281, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 9 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 282: /*26*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode10);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 282, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 10 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 283: /*27*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode11);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 283, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 11 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 284: /*28*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode12);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 284, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 12 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 285: /*29*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode13);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 285, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 13 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 286: /*30*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode14);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 286, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 14 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 287: /*31*/
			/* pushLiteralVariable16CasesBytecode */
			{
				sqInt litVar;
				sqInt object;

				VM_LABEL(pushLiteralVariable16CasesBytecode15);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 287, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 15) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, 15 /* currentBytecode bitAnd: 15 */, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 288: /*32*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode32);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 288, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 289: /*33*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode33);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 289, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 290: /*34*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode34);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 290, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 291: /*35*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode35);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 291, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 292: /*36*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode36);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 292, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 293: /*37*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode37);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 293, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 294: /*38*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode38);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 294, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 295: /*39*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode39);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 295, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 296: /*40*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode40);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 296, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 297: /*41*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode41);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 297, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 298: /*42*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode42);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 298, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 299: /*43*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode43);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 299, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 300: /*44*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode44);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 300, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 301: /*45*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode45);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 301, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 302: /*46*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode46);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 302, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 303: /*47*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode47);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 303, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 304: /*48*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode48);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 304, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 136 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 305: /*49*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode49);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 305, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 144 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 306: /*50*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode50);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 306, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 152 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 307: /*51*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode51);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 307, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 160 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 308: /*52*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode52);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 308, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 168 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 309: /*53*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode53);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 309, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 176 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 310: /*54*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode54);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 310, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 184 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 311: /*55*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode55);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 311, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 192 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 312: /*56*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode56);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 312, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 200 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 313: /*57*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode57);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 313, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 208 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 314: /*58*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode58);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 314, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 216 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 315: /*59*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode59);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 315, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 224 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 316: /*60*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode60);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 316, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 232 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 317: /*61*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode61);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 317, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 240 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 318: /*62*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode62);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 318, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 0xF8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 319: /*63*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode63);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 319, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 256 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 320: /*64*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode16);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 320, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 321: /*65*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode17);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 321, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 322: /*66*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode18);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 322, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 323: /*67*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode19);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 323, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 324: /*68*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode20);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 324, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 325: /*69*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode21);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 325, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 326: /*70*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode22);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 326, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 327: /*71*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode23);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 327, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 328: /*72*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode24);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 328, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 329: /*73*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode25);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 329, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 330: /*74*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode26);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 330, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 331: /*75*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode27);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 331, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin pushTemporaryVariable: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 338: /*82*/
			/* extPushPseudoVariable */
			{
				sqInt objOop;
				sqInt objOop1;
				sqInt theThingToPush;

				VM_LABEL(extPushPseudoVariable);
				
				switch (extB) {
				case 0:
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP, self), self));
						theThingToPush = longAt(localFP + FoxThisContext);
						goto l447;
					}
					theThingToPush = marryFrameSP(localFP, localSP, self);
	l447:	/* end ensureFrameIsMarried:SP: */;
					break;
				case 1:
					/* begin memoryActiveProcess */
					objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
					objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
					theThingToPush = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
					break;
				default:
					goto respondToUnknownBytecode;

				}
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), theThingToPush);
				extB = 0;
				numExtB = 0;
			}
			break;
		case 340: /*84*/
		case 341: /*85*/
		case 342: /*86*/
		case 343: /*87*/
		case 474: /*218*/
		case 475: /*219*/
		case 476: /*220*/
		case 477: /*221*/
		case 478: /*222*/
		case 479: /*223*/
		case 486: /*230*/
		case 502: /*246*/
		case 503: /*247*/
		case 510: /*254*/
		case 511: /*255*/
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			break;
		case 344: /*88*/
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver1);
				/* begin receiver */
				localReturnValue = longAt(localFP + FoxReceiver);
				goto commonReturn;
			}
			break;
		case 349: /*93*/
			/* returnNilFromBlock */
			{
				VM_LABEL(returnNilFromBlock);
				/* begin nilObject */
				localReturnValue = GIV(nilObj);
				goto commonCallerReturn;
			}
			break;
		case 350: /*94*/
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock1);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				goto commonCallerReturn;
			}
			break;
		case 351: /*95*/
			/* extNopBytecode */
			{
				VM_LABEL(extNopBytecode);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				numExtB = (extA = (extB = 0));
			}
			break;
		case 352: /*96*/
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimAdd1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					result = ((rcvr >> 3)) + ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 3) | 1));
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l457;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l467;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l467;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l467;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l467:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l460;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l460;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l460;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l460:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l457;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((0 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l457:	/* end case */;
			break;
		case 353: /*97*/
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimSubtract1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					result = ((rcvr >> 3)) - ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 3) | 1));
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l468;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l478;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l478;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l478;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l478:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l471;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l471;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l471;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l471:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l468;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((1 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l468:	/* end case */;
			break;
		case 354: /*98*/
			/* bytecodePrimLessThanSistaV1 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimLessThanSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr < arg) {
						/* goto booleanCheatTrueSistaV1 */
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l479;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l485;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l485;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l485;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l485:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l488;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l488;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l488;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l488:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l479;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((2 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l479:	/* end case */;
			
		booleanCheatTrueSistaV1:
			/* booleanCheatTrueSistaV1 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrueSistaV1);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if (bytecode >= 192) {
					if (bytecode <= 199) {

						/* short jumpIfFalse 192 - 199 */
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l948;
					}
					if (bytecode == 239) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l948;
					}
					if (bytecode == 238) {

						/* long jumpIfTrue 238 */
						offset = byteAtPointer(++localIP);
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(localIP);
#            endif /* MULTIPLEBYTECODESETS */
						goto l948;
					}
				}
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = bytecode;
#        endif /* MULTIPLEBYTECODESETS */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
	l948:	/* end case */;
			break;
		case 355: /*99*/
			/* bytecodePrimGreaterThanSistaV1 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimGreaterThanSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr > arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						/* goto booleanCheatFalseSistaV1 */
					}
					goto l489;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l495;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l495;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l495;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l495:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l498;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l498;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l498;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l498:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l489;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((3 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l489:	/* end case */;
			
		booleanCheatFalseSistaV1:
			/* booleanCheatFalseSistaV1 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalseSistaV1);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 199)
				 && (bytecode > 191)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 191)) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
					goto l951;
				}
				if (bytecode == 239) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
					goto l951;
				}
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = bytecode;
#        endif /* MULTIPLEBYTECODESETS */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
	l951:	/* end case */;
			break;
		case 356: /*100*/
			/* bytecodePrimLessOrEqualSistaV1 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimLessOrEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr <= arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l499;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l505;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l505;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l505;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l505:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l508;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l508;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l508;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l508:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l499;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((4 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l499:	/* end case */;
			break;
		case 357: /*101*/
			/* bytecodePrimGreaterOrEqualSistaV1 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimGreaterOrEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr >= arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l509;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l515;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l515;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l515;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l515:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l518;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l518;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l518;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l518:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l509;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((5 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l509:	/* end case */;
			break;
		case 358: /*102*/
			/* bytecodePrimEqualSistaV1 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					/* begin booleanCheatSistaV1: */
					if (rcvr == arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l519;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l525;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l525;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l525;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l525:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l528;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l528;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l528;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l528:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l519;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((6 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l519:	/* end case */;
			break;
		case 359: /*103*/
			/* bytecodePrimNotEqualSistaV1 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimNotEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					/* begin booleanCheatSistaV1: */
					if (rcvr != arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l529;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask(self)))) != 0) {
					if (tagBits == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr, self));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
						bits = rot;
						memcpy((&value), (&bits), sizeof(value));
						rcvr1 = value;
						goto l535;
					}
					if ((tagBits == (smallIntegerTag(self)))
					 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l535;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l535;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
	l535:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask(self)))) != 0) {
					if (tagBits1 == (smallFloatTag(self))) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg, self));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
						}
						/* begin rotateRight: */
						rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
						bits1 = rot1;
						memcpy((&value1), (&bits1), sizeof(value1));
						arg1 = value1;
						goto l538;
					}
					if ((tagBits1 == (smallIntegerTag(self)))
					 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
					(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l538;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l538;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
	l538:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (!aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l529;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((7 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l529:	/* end case */;
			break;
		case 360: /*104*/
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt oop;
				sqInt overflow;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimMultiply1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					overflow = (rcvr > 0
						? (arg > 0
								? rcvr > ((MaxSmallInteger) / arg)
								: arg < ((MinSmallInteger) / rcvr))
						: (arg > 0
								? rcvr < ((MinSmallInteger) / arg)
								: (rcvr < 0)
									 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 3) | 1);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), oop);
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l539;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l549;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l549;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l549;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l549:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l542;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l542;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l542;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l542:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l539;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((8 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l539:	/* end case */;
			break;
		case 361: /*105*/
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt objOop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimDivide1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & arg) & (smallIntegerTag(self))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 3) | 1));
							/* begin fetchNextBytecode */
							if (GIV(isStepable)) {
								printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
								/* begin externalizeIPandSP */
								GIV(instructionPointer) = oopForPointer(localIP);
								GIV(stackPointer) = localSP;
								GIV(framePointer) = localFP;
								printCallStack(self);
								lockFetchNextBytecode(self);
							}
							currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
							goto l550;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if (((tagBits = rcvr & (tagMask(self)))) != 0) {
						if (tagBits == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr, self));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits(self));
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l560;
						}
						if ((tagBits == (smallIntegerTag(self)))
						 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(rcvr) << shift)))) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l560;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l560;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l560:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask(self)))) != 0) {
						if (tagBits1 == (smallFloatTag(self))) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg, self));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits(self));
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
							}
							/* begin rotateRight: */
							rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l553;
						}
						if ((tagBits1 == (smallIntegerTag(self)))
						 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
						(((sqInt) (((sqInt)((usqInt)(arg) << shift1)))) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l553;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l553;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l553:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1, self));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l550;
					}
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((9 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l550:	/* end case */;
			break;
		case 362: /*106*/
			/* bytecodePrimMod */
			{
				sqInt mod;
				sqInt objOop;

				VM_LABEL(bytecodePrimMod1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)), self);
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)mod << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l561;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((10 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l561:	/* end case */;
			break;
		case 363: /*107*/
			/* bytecodePrimMakePoint */
			{
				sqInt arg;
				sqInt classObj;
				sqInt knownClassIndex;
				usqInt newObj;
				usqInt numBytes;
				sqInt numSlots;
				sqInt objFormat;
				sqInt objOop;
				usqInt pt;
				sqInt rcvr;

				VM_LABEL(bytecodePrimMakePoint1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if (((rcvr & (tagMask(self))
					? !(rcvr & (characterTag(self)))
					: ((longAt(rcvr)) & (classIndexMask(self))) == ClassFloatCompactIndex))
				 && ((arg & (tagMask(self))
					? !(arg & (characterTag(self)))
					: ((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex))) {
					/* begin eeInstantiateSmallClass:numSlots: */
					classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
					numSlots = YIndex + 1;
					assert((rawHashBitsOf(classObj, self)) != 0);
					/* begin eeInstantiateSmallClassIndex:format:numSlots: */
					knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
					/* begin instSpecOfClassFormat: */
					objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
					assert((numSlots >= 0)
					 && ((knownClassIndex != 0)
					 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
					assert(((objFormat < (firstByteFormat(self))
						? objFormat
						: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
					/* begin allocateSmallNewSpaceSlots:format:classIndex: */
					assert(numSlots < (numSlotsMask(self)));
					newObj = GIV(freeStart);
					numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
					assert((numBytes % (allocationUnit(self))) == 0);
					assert((newObj % (allocationUnit(self))) == 0);
					if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
						if (!GIV(needGCFlag)) {
							/* begin scheduleScavenge */
							GIV(needGCFlag) = 1;
							forceInterruptCheck(self);
						}
						if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
							error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
							pt = 0;
							goto l570;
						}
					}
					long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + knownClassIndex);
					GIV(freeStart) += numBytes;
					pt = newObj;
	l570:	/* end eeInstantiateSmallClass:numSlots: */;
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(pt, self)));
					longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self))))), rcvr);
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(pt, self)));
					longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self))))), arg);
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), pt);
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l565;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((11 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l565:	/* end case */;
			break;
		case 364: /*108*/
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt objOop;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((((integerArgument) & 7) == 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l575;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = signed64BitValueOf(integerReceiver, self);
				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 3))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 61 /* numSmallIntegerBits */)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l575;
						}
						shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
						if (!(integerReceiver == (((sqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l575;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-61 /* numSmallIntegerBits */))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l575;
						}
						shifted = ((sqInt) integerReceiver) >> (0 - integerArgument);
					}
					shifted = ((((((usqInt) shifted) >> 60) + 1) & 15) <= 1
						? (((usqInt)shifted << 3) | 1)
						: signed64BitIntegerFor(shifted, self));
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
	l575:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l574;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((12 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l574:	/* end case */;
			break;
		case 365: /*109*/
			/* bytecodePrimDiv */
			{
				sqInt objOop;
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)), self);
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)quotient << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l580;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((13 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l580:	/* end case */;
			break;
		case 366: /*110*/
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd1);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l584;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd(self);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l584;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((14 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l584:	/* end case */;
			break;
		case 367: /*111*/
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr1);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l589;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr(self);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l589;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((15 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l589:	/* end case */;
			break;
		case 368: /*112*/
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt class;
				sqInt classFormat;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				usqLong fmt;
				usqLong fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				usqInt numSlots11;
				usqInt numSlots12;
				usqInt numSlots2;
				usqInt numSlots3;
				sqInt objOop;
				sqInt objOop1;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				usqInt result1;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;

				VM_LABEL(bytecodePrimAt1);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask(self))) == 0)
				 && ((((index) & 7) == 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */
					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						/* begin fetchClassTagOfNonImm: */
						lkupClassTag = (longAt(rcvr)) & (classIndexMask(self));
						/* begin fetchPointer:ofObject: */
						objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
						GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((16 * 2)) << (shiftForWord(self))))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag, self))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l594;
						}
						if (GIV(primitiveFunctionPointer) == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr, self)));
							/* begin baseHeader: */
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
							if (((fmt >= (firstShortFormat(self))) && (fmt <= ((firstByteFormat(self)) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l609;
							}
							if ((fmt == (indexablePointersFormat(self)))
							 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l609;
							}
							/* begin lengthOf:format: */
							numSlots11 = byteAt(rcvr + 7);
							numSlots2 = (numSlots11 == (numSlotsMask(self))
								? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
								: numSlots11);
							if (fmt <= 5 /* ephemeronFormat */) {
								totalLength = numSlots2;
								goto l619;
							}
							if (fmt >= (firstByteFormat(self))) {

								/* bytes, including CompiledMethod */
								totalLength = (numSlots2 << (shiftForWord(self))) - (fmt & 7);
								goto l619;
							}
							if (fmt >= (firstShortFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt & 3);
								goto l619;
							}
							if (fmt >= (firstLongFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt & 1);
								goto l619;
							}
							if (fmt == (sixtyFourBitIndexableFormat(self))) {
								totalLength = numSlots2;
								goto l619;
							}
							totalLength = 0;
	l619:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt >= (sixtyFourBitIndexableFormat(self)))
							 || (fmt == 2 /* arrayFormat */)) {
								fixedFields = 0;
								goto l603;
							}
							if (fmt < 2 /* arrayFormat */) {
								fixedFields = totalLength;
								goto l603;
							}
							class = fetchClassOfNonImm(rcvr, self);
							/* begin fixedFieldsOfClassFormat: */
							classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
							fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l603:	/* end fixedFieldsOf:format:length: */;
							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
	l609:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (GIV(primitiveFunctionPointer) == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr, self)));
								/* begin baseHeader: */
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt1 = (((unsigned sqLong)hdr1) >> (formatShift(self))) & (formatMask(self));
								if (((fmt1 >= (firstShortFormat(self))) && (fmt1 <= ((firstByteFormat(self)) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l607;
								}
								
								/* special flag for strings */
								/* begin lengthOf:format: */
								numSlots12 = byteAt(rcvr + 7);
								numSlots3 = (numSlots12 == (numSlotsMask(self))
									? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
									: numSlots12);
								if (fmt1 <= 5 /* ephemeronFormat */) {
									totalLength1 = numSlots3;
									goto l620;
								}
								if (fmt1 >= (firstByteFormat(self))) {

									/* bytes, including CompiledMethod */
									totalLength1 = (numSlots3 << (shiftForWord(self))) - (fmt1 & 7);
									goto l620;
								}
								if (fmt1 >= (firstShortFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
									goto l620;
								}
								if (fmt1 >= (firstLongFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
									goto l620;
								}
								if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
									totalLength1 = numSlots3;
									goto l620;
								}
								totalLength1 = 0;
	l620:	/* end lengthOf:format: */;
								fixedFields1 = 0;
								fmt1 += 32 /* firstStringyFakeFormat */;
								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
	l607:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l594;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 3);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1, self))
						 && (oopisLessThanOrEqualTo(index1, stSize, self))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat(self))) {
								assert(!(isContextNonImm(rcvr, self)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin fetchPointer:ofObject: */
								result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord(self))))));
								goto l606;
							}
							if (fmt2 < (firstByteFormat(self))) {

								/* 64, 32, & 16 bits */
								if (fmt2 >= (firstShortFormat(self))) {
									result = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))))))) << 3) | 1);
									goto l606;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat(self))) {
									result = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 3)))), self);
									goto l606;
								}
								/* begin fetchLong32:ofObject: */
								result1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))))));
								/* begin positive32BitIntegerFor: */
								result = ((((((usqInt)(((unsigned int) result1)))) & 0xFFFFFFFFU) << 3) | 1);
								goto l606;
							}
							if (fmt2 >= 32 /* firstStringyFakeFormat */) {

								/* Spur supports the String at:[put:] primitives on WideString and DoubleByteString */
								/* String */
								if (fmt2 < ((firstByteFormat(self)) + 32 /* firstStringyFakeFormat */)) {
									if (fmt2 < ((firstShortFormat(self)) + 32 /* firstStringyFakeFormat */)) {
										/* begin fetchLong32:ofObject: */
										result1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))))));
									}
									else {
										/* begin fetchUnsignedShort16:ofObject: */
										result1 = ((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))))));
									}
								}
								else {
									/* begin fetchByte:ofObject: */
									result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));
								}
								/* begin characterForAscii: */
								result = (result1 << (numTagBits(self))) + (characterTag(self));
								goto l606;
							}
							else {
								if ((fmt2 < (firstCompiledMethodFormat(self)))
								 || (index1 >= ((((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 3) | 1);
									goto l606;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr, self)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
	l606:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l594;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)((16 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l594:	/* end case */;
			break;
		case 369: /*113*/
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt class;
				sqInt classFormat;
				sqInt correctRcvr;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				usqLong fmt;
				usqLong fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				sqInt isCharacter;
				usqInt numSlots11;
				usqInt numSlots12;
				usqInt numSlots2;
				usqInt numSlots3;
				sqInt objOop;
				sqInt objOop1;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;
				usqLong val64ToPut;
				sqInt valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut1);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				
#        if IMMUTABILITY
				/* begin isOopMutable: */
				correctRcvr = ((rcvr & (tagMask(self))) == 0)
				 && (!(((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0));
#        else /* IMMUTABILITY */
				/* begin isNonImmediate: */
				correctRcvr = (rcvr & (tagMask(self))) == 0;
#        endif /* IMMUTABILITY */
				if (correctRcvr
				 && ((((index) & 7) == 1))) {

					/* Index into atPutCache */
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						/* begin fetchClassTagOfNonImm: */
						lkupClassTag = (longAt(rcvr)) & (classIndexMask(self));
						/* begin fetchPointer:ofObject: */
						objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
						GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((17 * 2)) << (shiftForWord(self))))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag, self))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l622;
						}
						if (GIV(primitiveFunctionPointer) == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr, self)));
							/* begin baseHeader: */
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
							if (((fmt >= (firstShortFormat(self))) && (fmt <= ((firstByteFormat(self)) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l662;
							}
							if ((fmt == (indexablePointersFormat(self)))
							 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l662;
							}
							/* begin lengthOf:format: */
							numSlots11 = byteAt(rcvr + 7);
							numSlots2 = (numSlots11 == (numSlotsMask(self))
								? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
								: numSlots11);
							if (fmt <= 5 /* ephemeronFormat */) {
								totalLength = numSlots2;
								goto l660;
							}
							if (fmt >= (firstByteFormat(self))) {

								/* bytes, including CompiledMethod */
								totalLength = (numSlots2 << (shiftForWord(self))) - (fmt & 7);
								goto l660;
							}
							if (fmt >= (firstShortFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt & 3);
								goto l660;
							}
							if (fmt >= (firstLongFormat(self))) {
								totalLength = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt & 1);
								goto l660;
							}
							if (fmt == (sixtyFourBitIndexableFormat(self))) {
								totalLength = numSlots2;
								goto l660;
							}
							totalLength = 0;
	l660:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt >= (sixtyFourBitIndexableFormat(self)))
							 || (fmt == 2 /* arrayFormat */)) {
								fixedFields = 0;
								goto l634;
							}
							if (fmt < 2 /* arrayFormat */) {
								fixedFields = totalLength;
								goto l634;
							}
							class = fetchClassOfNonImm(rcvr, self);
							/* begin fixedFieldsOfClassFormat: */
							classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
							fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l634:	/* end fixedFieldsOf:format:length: */;
							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
	l662:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (GIV(primitiveFunctionPointer) == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr, self)));
								/* begin baseHeader: */
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt1 = (((unsigned sqLong)hdr1) >> (formatShift(self))) & (formatMask(self));
								if (((fmt1 >= (firstShortFormat(self))) && (fmt1 <= ((firstByteFormat(self)) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l651;
								}
								
								/* special flag for strings */
								/* begin lengthOf:format: */
								numSlots12 = byteAt(rcvr + 7);
								numSlots3 = (numSlots12 == (numSlotsMask(self))
									? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
									: numSlots12);
								if (fmt1 <= 5 /* ephemeronFormat */) {
									totalLength1 = numSlots3;
									goto l628;
								}
								if (fmt1 >= (firstByteFormat(self))) {

									/* bytes, including CompiledMethod */
									totalLength1 = (numSlots3 << (shiftForWord(self))) - (fmt1 & 7);
									goto l628;
								}
								if (fmt1 >= (firstShortFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
									goto l628;
								}
								if (fmt1 >= (firstLongFormat(self))) {
									totalLength1 = (numSlots3 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
									goto l628;
								}
								if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
									totalLength1 = numSlots3;
									goto l628;
								}
								totalLength1 = 0;
	l628:	/* end lengthOf:format: */;
								fixedFields1 = 0;
								fmt1 += 32 /* firstStringyFakeFormat */;
								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
	l651:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l622;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						index1 = (index >> 3);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1, self))
						 && (oopisLessThanOrEqualTo(index1, stSize, self))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat(self))) {
								assert(!(isContextNonImm(rcvr, self)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								assert(!(isForwarded(rcvr, self)));
								if ((assert(isNonImmediate(rcvr, self)),
								oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

									/* most stores into young objects */
									if (((value & (tagMask(self))) == 0)
									 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
											remember(rcvr, self);
										}
									}
								}
								longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord(self))))), value);
								goto l637;
							}
							if (fmt2 < (firstByteFormat(self))) {

								/* 64, 32, & 16 bits */
								if (fmt2 >= (firstShortFormat(self))) {
									valToPut = ((((value) & 7) == 1)
										? (value >> 3)
										: -1);
									if (!((valToPut >= 0)
										 && (valToPut <= 0xFFFF))) {
										/* begin primitiveFailFor: */
										GIV(primFailCode) = PrimErrBadArgument;
										goto l637;
									}
									/* begin storeShort16:ofObject:withValue: */
									shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))), valToPut);
									goto l637;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat(self))) {
									val64ToPut = positive64BitValueOf(value, self);
									if (!GIV(primFailCode)) {
										/* begin storeLong64:ofObject:withValue: */
										long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 3))), val64ToPut);
										goto l637;
									}
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l637;
								}
								valToPut = positive32BitValueOf(value, self);
								if (!GIV(primFailCode)) {
									/* begin storeLong32:ofObject:withValue: */
									long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))), valToPut);
									goto l637;
								}
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l637;
							}
							if (fmt2 >= 32 /* firstStringyFakeFormat */) {
								/* begin isCharacterObject: */
								isCharacter = value & (characterTag(self));
								if (!isCharacter) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l637;
								}
								/* begin characterValueOf: */
								valToPut = ((usqInt) (((usqInt)value))) >> (numTagBits(self));
								if (fmt2 < ((firstByteFormat(self)) + 32 /* firstStringyFakeFormat */)) {
									if (fmt2 < ((firstShortFormat(self)) + 32 /* firstStringyFakeFormat */)) {
										assert(fmt2 != ((sixtyFourBitIndexableFormat(self)) + (firstStringyFakeFormat(self))));
										/* begin storeLong32:ofObject:withValue: */
										long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))), valToPut);
										goto l637;
									}
									else {
										if (!((valToPut >= 0)
											 && (valToPut <= 0xFFFF))) {
											/* begin primitiveFailFor: */
											GIV(primFailCode) = PrimErrBadArgument;
											goto l637;
										}
										/* begin storeShort16:ofObject:withValue: */
										shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 1))), valToPut);
										goto l637;
									}
								}
							}
							else {
								if ((fmt2 >= (firstCompiledMethodFormat(self)))
								 && (index1 < ((((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1))) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadIndex;
									goto l637;
								}
								valToPut = ((((value) & 7) == 1)
									? (value >> 3)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l637;
							}
							/* begin storeByte:ofObject:withValue: */
							byteAtput((rcvr + BaseHeaderSize) + (index1 - 1), valToPut);
							goto l637;
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr, self)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
						/* return self */
	l637:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l622;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)((17 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
	l622:	/* end case */;
			break;
		case 370: /*114*/
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt fmt;
				sqInt fmt1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				sqInt objOop;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(bytecodePrimSize1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isString = 0;
					goto l670;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex = (longAt(rcvr)) & (classIndexMask(self));
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l670;
	l670:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf:format: */
					fmt = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
					/* begin numSlotsOfAny: */
					numSlots1 = byteAt(rcvr + 7);
					numSlots = (numSlots1 == (numSlotsMask(self))
						? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots1);
					if (fmt <= 5 /* ephemeronFormat */) {
						sz = numSlots;
						goto l672;
					}
					if (fmt >= (firstByteFormat(self))) {

						/* bytes, including CompiledMethod */
						sz = (numSlots << (shiftForWord(self))) - (fmt & 7);
						goto l672;
					}
					if (fmt >= (firstShortFormat(self))) {
						sz = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
						goto l672;
					}
					if (fmt >= (firstLongFormat(self))) {
						sz = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
						goto l672;
					}
					if (fmt == (sixtyFourBitIndexableFormat(self))) {
						sz = numSlots;
						goto l672;
					}
					sz = 0;
	l672:	/* end lengthOf:format: */;
					longAtPointerput(localSP, (((usqInt)sz << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l666;
				}
				/* begin is:instanceOf:compactClassIndex: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isArray = 0;
					goto l667;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex1 = (longAt(rcvr)) & (classIndexMask(self));
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l667;
	l667:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf:format: */
					fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
					/* begin numSlotsOfAny: */
					numSlots11 = byteAt(rcvr + 7);
					numSlots2 = (numSlots11 == (numSlotsMask(self))
						? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots11);
					if (fmt1 <= 5 /* ephemeronFormat */) {
						sz = numSlots2;
						goto l671;
					}
					if (fmt1 >= (firstByteFormat(self))) {

						/* bytes, including CompiledMethod */
						sz = (numSlots2 << (shiftForWord(self))) - (fmt1 & 7);
						goto l671;
					}
					if (fmt1 >= (firstShortFormat(self))) {
						sz = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
						goto l671;
					}
					if (fmt1 >= (firstLongFormat(self))) {
						sz = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
						goto l671;
					}
					if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
						sz = numSlots2;
						goto l671;
					}
					sz = 0;
	l671:	/* end lengthOf:format: */;
					longAtPointerput(localSP, (((usqInt)sz << 3) | 1));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l666;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((18 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l666:	/* end case */;
			break;
		case 374: /*118*/
			/* bytecodePrimIdenticalSistaV1 */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdenticalSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & (tagMask(self))) == 0)
				 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP, self);
				}
				if (((arg & (tagMask(self))) == 0)
				 && (((longAt(arg)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP, self);
				}
				/* begin booleanCheatSistaV1: */
				if (rcvr == arg) {
					goto booleanCheatTrueSistaV1;
				}
				else {
					goto booleanCheatFalseSistaV1;
				}
			}
			break;
		case 376: /*120*/
			/* bytecodePrimNotIdenticalSistaV1 */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdenticalSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & (tagMask(self))) == 0)
				 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP, self);
				}
				if (((arg & (tagMask(self))) == 0)
				 && (((longAt(arg)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP, self);
				}
				/* begin booleanCheatSistaV1: */
				if (rcvr != arg) {
					goto booleanCheatTrueSistaV1;
				}
				else {
					goto booleanCheatFalseSistaV1;
				}
			}
			break;
		case 377: /*121*/
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue1);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isBlock = 0;
					goto l691;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex = (longAt(rcvr)) & (classIndexMask(self));
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l691;
	l691:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue(self);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l687;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((25 * 2)) << (shiftForWord(self))))));
				goto normalSend;
			}
	l687:	/* end case */;
			break;
		case 378: /*122*/
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt objOop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord(self))))));
				if (rcvr & (tagMask(self))) {
					isBlock = 0;
					goto l697;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr, self)));
				/* begin classIndexOf: */
				ccIndex = (longAt(rcvr)) & (classIndexMask(self));
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l697;
	l697:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue(self);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						if (GIV(isStepable)) {
							printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							printCallStack(self);
							lockFetchNextBytecode(self);
						}
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l693;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((26 * 2)) << (shiftForWord(self))))));
				goto normalSend;
			}
	l693:	/* end case */;
			break;
		case 382: /*126*/
			/* bytecodePrimPointX */
			{
				sqInt classOop;
				sqInt objOop;
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
				/* begin isNonImmediate: */
				ok = (rcvr & (tagMask(self))) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr, self));
					ok = ((longAt(rcvr)) & (classIndexMask(self))) == ((long32At(classOop + 4)) & (identityHashHalfWordMask(self)));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self)))))));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l705;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((30 * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l705:	/* end case */;
			break;
		case 383: /*127*/
			/* bytecodePrimPointY */
			{
				sqInt classOop;
				sqInt objOop;
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
				/* begin isNonImmediate: */
				ok = (rcvr & (tagMask(self))) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr, self));
					ok = ((longAt(rcvr)) & (classIndexMask(self))) == ((long32At(classOop + 4)) & (identityHashHalfWordMask(self)));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self)))))));
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l713;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
				GIV(messageSelector) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((0x1F * 2)) << (shiftForWord(self))))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l713:	/* end case */;
			break;
		case 440: /*184*/
		case 441: /*185*/
		case 442: /*186*/
		case 443: /*187*/
		case 444: /*188*/
		case 445: /*189*/
		case 446: /*190*/
		case 447: /*191*/
			/* shortConditionalJumpTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpTrue);
				/* begin jumplfTrueBy: */
				offset = (currentBytecode & 7) + 1;
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord(self))))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l729;
					}
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
	l729:	/* end jumplfTrueBy: */;
			}
			break;
		case 448: /*192*/
		case 449: /*193*/
		case 450: /*194*/
		case 451: /*195*/
		case 452: /*196*/
		case 453: /*197*/
		case 454: /*198*/
		case 455: /*199*/
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse1);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord(self))))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l733;
					}
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
	l733:	/* end jumplfFalseBy: */;
			}
			break;
		case 456: /*200*/
		case 457: /*201*/
		case 458: /*202*/
		case 459: /*203*/
		case 460: /*204*/
		case 461: /*205*/
		case 462: /*206*/
		case 463: /*207*/
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode1);
				/* begin receiver */
				rcvr = longAt(localFP + FoxReceiver);
				/* begin internalStackTop */
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(rcvr, self))));
				if (((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), top);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((usqInt)(instVarIndex + 1) << 3) | 1));
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l737;
				}
#        endif /* IMMUTABILITY */
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr, self)));
				if ((assert(isNonImmediate(rcvr, self)),
				oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((top & (tagMask(self))) == 0)
					 && (oopisLessThan(top, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(rcvr, self);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(instVarIndex) << (shiftForWord(self))))), top);
	l737:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 464: /*208*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 464, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 465: /*209*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 465, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 466: /*210*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 466, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 467: /*211*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 467, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 468: /*212*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 468, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 469: /*213*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 469, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 470: /*214*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 470, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 471: /*215*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, 471, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 473: /*217*/
			/* unconditionnalTrapBytecode */
			{
				VM_LABEL(unconditionnalTrapBytecode);
				goto respondToUnknownBytecode;
				goto l745;
			}
	l745:	/* end case */;
			break;
		case 480: /*224*/
			/* extABytecode */
			{
				VM_LABEL(extABytecode);
				extA = (((usqInt) extA << 8)) + (byteAtPointer(++localIP));
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 481: /*225*/
			/* extBBytecode */
			{
				sqInt byte;

				VM_LABEL(extBBytecode);
				byte = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extB = ((numExtB == 0)
				 && (byte > 0x7F)
					? byte - 256
					: (((usqInt) extB << 8)) + byte);
				numExtB += 1;
			}
			break;
		case 482: /*226*/
			/* extPushReceiverVariableBytecode */
			{
				char *callerFP;
				sqInt index;
				sqInt obj;
				sqInt object;
				sqInt object1;
				sqInt senderOop;
				char *spouseFP;

				VM_LABEL(extPushReceiverVariableBytecode);
				index = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extA = 0;
				/* begin pushMaybeContextReceiverVariable: */
				obj = longAt(localFP + FoxReceiver);
				if ((index <= StackPointerIndex)
				 && (((longAt(obj)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
					/* begin internalPush: */
					assert(index < MethodIndex);
					assert(isContext(obj, self));
					if (!(((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))) {
						/* begin fetchPointer:ofObject: */
						object = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
						goto l748;
					}
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed(self));
					if (isWidowedContext(obj, self)) {
						/* begin fetchPointer:ofObject: */
						object = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
						goto l748;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
					assert((((senderOop) & 7) == 1));
					spouseFP = pointerForOop(senderOop - 1);
					if (index == SenderIndex) {
						/* begin ensureCallerContext: */
						callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
						if (callerFP == 0) {

							/* base frame, context in saved ip slot (or base of stack in Cog) */
							object = longAt(spouseFP + FoxCallerContext);
							goto l748;
						}
						/* begin ensureFrameIsMarried:SP: */
						if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(callerFP, self), self));
							object = longAt(callerFP + FoxThisContext);
							goto l748;
						}
						object = marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP, self))),
						(spouseFP + (frameStackedReceiverOffset(spouseFP, self))) + BytesPerWord), self);
						goto l748;
					}
					if (index == StackPointerIndex) {
						assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP, self))) < (lengthOf(obj, self)));
						object = (((usqInt)(stackPointerIndexForFrame(spouseFP, self)) << 3) | 1);
						goto l748;
					}
					if (index == InstructionPointerIndex) {
						object = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP), self);
						goto l748;
					}
					error("bad index");
					object = 0;
	l748:	/* end instVar:ofContext: */;
					longAtPointerput((localSP -= BytesPerOop), object);
				}
				else {
					/* begin internalPush: */
					object1 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
					longAtPointerput((localSP -= BytesPerOop), object1);
				}
			}
			break;
		case 483: /*227*/
			/* extPushLiteralVariableBytecode */
			{
				sqInt index;
				sqInt litVar;
				sqInt object;

				VM_LABEL(extPushLiteralVariableBytecode);
				index = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extA = 0;
				/* begin pushLiteralVariable: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((index + LiteralStart)) << (shiftForWord(self))))));
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, index, self);
				}
				/* begin internalPush: */
				object = longAt((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 484: /*228*/
			/* extPushLiteralBytecode */
			{
				sqInt index;
				sqInt object;

				VM_LABEL(extPushLiteralBytecode);
				index = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extA = 0;
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((index + LiteralStart)) << (shiftForWord(self))))));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 485: /*229*/
			/* longPushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;
				sqInt object;

				VM_LABEL(longPushTemporaryVariableBytecode);
				/* begin fetchByte */
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				object = (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 487: /*231*/
			/* pushNewArrayBytecode */
			{
				usqInt array;
				sqInt i;
				usqInt newObj;
				usqInt numBytes;
				int popValues;
				sqInt size;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(pushNewArrayBytecode1);
				/* begin fetchByte */
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((size >= 0)
				 && ((knownClassAtIndex(ClassArrayCompactIndex, self)) != GIV(nilObj)));
				assert((2 /* arrayFormat */) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex, self), self)));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(size < (numSlotsMask(self)));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((size < 1
	? 8 /* allocationUnit */
	: size * BytesPerOop));
				assert((numBytes % (allocationUnit(self))) == 0);
				assert((newObj % (allocationUnit(self))) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck(self);
					}
					if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						array = 0;
						goto l760;
					}
				}
				long64Atput(newObj, (((((usqLong) size)) << (numSlotsFullShift(self))) + (2U << (formatShift(self)))) + ClassArrayCompactIndex);
				GIV(freeStart) += numBytes;
				array = newObj;
	l760:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((size - i) - 1) * BytesPerOop));
						assert(!(isOopForwarded(array, self)));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer1 = GIV(nilObj);
						assert(!(isOopForwarded(array, self)));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer1);
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 488: /*232*/
			/* extPushIntegerBytecode */
			{
				sqInt value;

				VM_LABEL(extPushIntegerBytecode);
				value = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extB) << 8)));
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extB = 0;
				numExtB = 0;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), (((usqInt)value << 3) | 1));
			}
			break;
		case 489: /*233*/
			/* extPushCharacterBytecode */
			{
				sqInt object;
				sqInt value;

				VM_LABEL(extPushCharacterBytecode);
				value = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extB) << 8)));
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				object = (((sqInt)((usqInt)(value) << (numTagBits(self))))) + (characterTag(self));
				longAtPointerput((localSP -= BytesPerOop), object);
				numExtB = (extB = 0);
			}
			break;
		case 490: /*234*/
			/* extSendBytecode */
			{
				sqInt byte;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(extSendBytecode);
				byte = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin literal:ofMethod: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((((((usqInt) byte) >> 3) + (((sqInt)((usqInt)(extA) << 5)))) + LiteralStart)) << (shiftForWord(self))))));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((sqInt)((usqInt)(extB) << 3)));
				extB = 0;
				numExtB = 0;
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				lkupClassTag = (((tagBits = rcvr & (tagMask(self)))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask(self)));
				goto commonSendOrdinary;
			}
			break;
		case 491: /*235*/
			/* extSendSuperBytecode */
			{
				sqInt byte;

				VM_LABEL(extSendSuperBytecode);
				byte = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin literal:ofMethod: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((((((usqInt) byte) >> 3) + (((sqInt)((usqInt)(extA) << 5)))) + LiteralStart)) << (shiftForWord(self))))));
				extA = 0;
				if (extB >= 64) {
					GIV(argumentCount) = (byte & 7) + (((sqInt)((usqInt)((extB - 64)) << 3)));
					extB = 0;
					numExtB = 0;
					/* goto directedSuperclassSend */
					goto l769;
				}
				GIV(argumentCount) = (byte & 7) + (((sqInt)((usqInt)(extB) << 3)));
				extB = 0;
				numExtB = 0;
				goto superclassSend;
			}
	l769:	/* end case */;
			
		directedSuperclassSend:
			/* directedSuperclassSend */
			{
				sqInt aValue;
				sqInt class;
				sqInt err;
				sqInt hash;
				sqInt objOop;
				sqInt objOop1;
				sqInt referent;
				sqInt referent1;
				sqInt superclass;
				sqInt top;

				VM_LABEL(directedSuperclassSend);
				/* begin internalPopStack */
				top = longAt(localSP);
				localSP += BytesPerOop;
				class = top;
				if (((longAt(class)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(class, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((class + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					class = referent;
				}
				/* begin followField:ofObject: */
				objOop = longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
				if (((objOop & (tagMask(self))) == 0)
				 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, class, objOop, self);
				}
				superclass = objOop;

				/* To maintain the invariant that all receivers are unforwarded we need an explicit
				   read barrier in the super send cases.  Even though we always follow receivers
				   on become  e.g. super doSomethingWith: (self become: other) forwards the receiver
				   self pushed on the stack. */
				assert(addressCouldBeClassObj(superclass, self));
				lkupClassTag = (((hash = (long32At(superclass + 4)) & (identityHashHalfWordMask(self)))) != 0
					? hash
					: (objCouldBeClassObj(superclass, self)
							? (((err = enterIntoClassTable(superclass, self))) != 0
									? -err
									: (/* begin rawHashBitsOf: */
										(long32At(superclass + 4)) & (identityHashHalfWordMask(self))))
							: -PrimErrBadReceiver));
				/* begin ensureReceiverUnforwarded */
				if ((((longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop))) & (tagMask(self))) == 0)
				 && (((longAt(longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin internalStackValue:put: */
					objOop1 = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(isUnambiguouslyForwarder(objOop1, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent1 = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent1 & (tagMask(self))) == 0)
					 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					aValue = referent1;
					longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), aValue);
				}
				assert(lkupClassTag != (nilObject(self)));
				goto commonSendOrdinary;
			}
			break;
		case 492: /*236*/
			/* callMappedInlinedPrimitive */
			{
				VM_LABEL(callMappedInlinedPrimitive);
				localIP -= 2;
				goto respondToUnknownBytecode;
			}
			break;
		case 493: /*237*/
			/* extUnconditionalJump */
			{
				sqInt bcpcDelta;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extUnconditionalJump);
				byte = byteAtPointer(++localIP);
				offset = byte + (((sqInt)((usqInt)(extB) << 8)));
				bcpcDelta = (offset < 0
					? numExtB * 2
					: 0);
				extB = 0;
				numExtB = 0;
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if (((offset + bcpcDelta) < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1, self);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
									}
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 494: /*238*/
			/* extJumpIfTrue */
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfTrue);
				byte = byteAtPointer(++localIP);
				offset = byte + (((sqInt)((usqInt)(extB) << 8)));
				numExtB = (extB = (extA = 0));
				/* begin jumplfTrueBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord(self))))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l775;
					}
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
	l775:	/* end jumplfTrueBy: */;
			}
			break;
		case 495: /*239*/
			/* extJumpIfFalse */
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfFalse);
				byte = byteAtPointer(++localIP);
				offset = byte + (((sqInt)((usqInt)(extB) << 8)));
				numExtB = (extB = (extA = 0));
				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);
#          endif /* MULTIPLEBYTECODESETS */
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord(self))))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l779;
					}
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
	l779:	/* end jumplfFalseBy: */;
			}
			break;
		case 496: /*240*/
			/* extStoreAndPopReceiverVariableBytecode */
			{
				sqInt index1;
				sqInt obj;
				int onCurrentPage;
				sqInt senderOop;
				char * theFP;
				StackPage * thePage;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopReceiverVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storeMaybeContextReceiverVariable:withValue: */
				obj = longAt(localFP + FoxReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(obj)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
				 && ((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
				 || (0)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj, self));
					assert(!((isObjImmutable(obj, self))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed(self));
					if (!((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
						 && (!(isWidowedContext(obj, self))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(obj, self)));
						if ((assert(isNonImmediate(obj, self)),
						oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart), self))) {

							/* most stores into young objects */
							if (((value & (tagMask(self))) == 0)
							 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(obj))) >> (rememberedBitShift(self))) & 1) != 0)) {
									remember(obj, self);
								}
							}
						}
						longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), value);
						if (variableIndex == StackPointerIndex) {
						}
						goto l783;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - 1);
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
						thePage = stackPageAtpages(index1, GIV(pages), self);
						assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, value, self);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage), self);
						}
						goto l783;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj, self);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj, self)));
					if ((assert(isNonImmediate(obj, self)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((value & (tagMask(self))) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(obj))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(obj, self);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), value);
					if (variableIndex == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage), self);
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__, self);
	l783:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(obj, self))));
					if (((((usqInt) (longAt(obj))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), obj);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l781;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj, self)));
					if ((assert(isNonImmediate(obj, self)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((value & (tagMask(self))) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(obj))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(obj, self);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), value);
	l781:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 497: /*241*/
			/* extStoreAndPopLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopLiteralVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				extA = 0;
				/* begin storeLiteralVariable:withValue: */

				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord(self))))));
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, variableIndex, self);
				}
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(litVar, self))));
				if (((((usqInt) (longAt(litVar))) >> (immutableBitShift(self))) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), litVar);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), value);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l794;
				}
#        endif /* IMMUTABILITY */
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar, self)));
				if ((assert(isNonImmediate(litVar, self)),
				oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((value & (tagMask(self))) == 0)
					 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(litVar, self);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))), value);
	l794:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 498: /*242*/
			/* longStoreAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreAndPopTemporaryVariableBytecode);
				/* begin longStoreTemporaryVariableBytecode */
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 499: /*243*/
			/* extStoreReceiverVariableBytecode */
			{
				sqInt anObject;
				sqInt index1;
				sqInt obj;
				int onCurrentPage;
				sqInt senderOop;
				char * theFP;
				StackPage * thePage;
				sqInt variableIndex;

				VM_LABEL(extStoreReceiverVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				/* begin storeMaybeContextReceiverVariable:withValue: */
				anObject = longAtPointer(localSP);
				/* begin storeMaybeContext:receiverVariable:withValue: */
				obj = longAt(localFP + FoxReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(obj)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
				 && ((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
				 || (0)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj, self));
					assert(!((isObjImmutable(obj, self))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed(self));
					if (!((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
						 && (!(isWidowedContext(obj, self))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(obj, self)));
						if ((assert(isNonImmediate(obj, self)),
						oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart), self))) {

							/* most stores into young objects */
							if (((anObject & (tagMask(self))) == 0)
							 && (oopisLessThan(anObject, GIV(newSpaceLimit), self))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(obj))) >> (rememberedBitShift(self))) & 1) != 0)) {
									remember(obj, self);
								}
							}
						}
						longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), anObject);
						if (variableIndex == StackPointerIndex) {
						}
						goto l803;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - 1);
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
						thePage = stackPageAtpages(index1, GIV(pages), self);
						assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, anObject, self);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage), self);
						}
						goto l803;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj, self);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj, self)));
					if ((assert(isNonImmediate(obj, self)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((anObject & (tagMask(self))) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(obj))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(obj, self);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), anObject);
					if (variableIndex == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage), self);
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__, self);
	l803:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(obj, self))));
					if (((((usqInt) (longAt(obj))) >> (immutableBitShift(self))) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), obj);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), anObject);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l801;
					}
#          endif /* IMMUTABILITY */
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj, self)));
					if ((assert(isNonImmediate(obj, self)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((anObject & (tagMask(self))) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(obj))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(obj, self);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord(self))))), anObject);
	l801:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 500: /*244*/
			/* extStoreLiteralVariableBytecode */
			{
				sqInt anObject;
				sqInt litVar;
				sqInt variableIndex;

				VM_LABEL(extStoreLiteralVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				/* begin storeLiteralVariable:withValue: */
				anObject = longAtPointer(localSP);

				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin fetchPointer:ofObject: */
				litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord(self))))));
				if (((longAt(litVar)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					litVar = unfollowatIndex(litVar, variableIndex, self);
				}
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(litVar, self))));
				if (((((usqInt) (longAt(litVar))) >> (immutableBitShift(self))) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), litVar);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), anObject);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord(self))))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l814;
				}
#        endif /* IMMUTABILITY */
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar, self)));
				if ((assert(isNonImmediate(litVar, self)),
				oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((anObject & (tagMask(self))) == 0)
					 && (oopisLessThan(anObject, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(litVar, self);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))), anObject);
	l814:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			break;
		case 501: /*245*/
			/* longStoreTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreTemporaryVariableBytecode);
				/* begin fetchByte */
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin temporary:in:put: */
				if (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
			}
			break;
		case 504: /*248*/
			/* callPrimitiveBytecode */
			{
				sqInt header;

				VM_LABEL(callPrimitiveBytecode1);
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(method), self));
				/* begin fetchPointer:ofObject: */
				header = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
				if (((/* begin alternateHeaderHasPrimitiveFlag: */
				header & AlternateHeaderHasPrimFlag))
				 && ((((sqInt)localIP)) == ((GIV(method) + ((LiteralStart + ((assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize))) {
					localIP = (localIP + (3)) - 1;
					/* begin fetchNextBytecode */
					if (GIV(isStepable)) {
						printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						printCallStack(self);
						lockFetchNextBytecode(self);
					}
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l821;
				}
				else {
					goto respondToUnknownBytecode;
					goto l821;
				}
			}
	l821:	/* end case */;
			break;
		case 505: /*249*/
			/* extPushFullClosureBytecode */
			{
				sqInt byte;
				sqInt compiledBlock;
				sqInt compiledBlockLiteralIndex;
				sqInt context;
				sqInt header;
				sqInt i;
				int ignoreContext;
				usqInt newClosure;
				usqInt newClosure1;
				usqInt newObj;
				sqInt numArgs;
				usqInt numBytes;
				sqInt numCopied;
				sqInt numCopied1;
				sqInt numSlots;
				sqInt objFormat;
				int receiverIsOnStack;
				sqInt startIndex;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(extPushFullClosureBytecode);
				compiledBlockLiteralIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				assert(GIV(method) == (iframeMethod(localFP, self)));
				/* begin literal:ofMethod: */
				compiledBlock = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((compiledBlockLiteralIndex + LiteralStart)) << (shiftForWord(self))))));
				assert(isOopCompiledMethod(compiledBlock, self));
				/* begin argumentCountOf: */
				assert(isCompiledMethod(compiledBlock, self));
				/* begin fetchPointer:ofObject: */
				header = longAt((compiledBlock + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
				numArgs = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
				byte = byteAtPointer(++localIP);
				numCopied = byte & ((1U << 6) - 1);
				receiverIsOnStack = byte & (1U << 7);
				ignoreContext = byte & (1U << 6);
				/* begin pushFullClosureNumArgs:copiedValues:compiledBlock:receiverIsOnStack:ignoreContext: */
				if (ignoreContext) {
					/* begin nilObject */
					context = GIV(nilObj);
				}
				else {
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP, self), self));
						context = longAt(localFP + FoxThisContext);
						goto l845;
					}
					context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop), self);
	l845:	/* end ensureFrameIsMarried:SP: */;
				}
				/* begin fullClosureIn:numArgs:numCopiedValues:compiledBlock: */
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = indexablePointersFormat(self);
				numSlots = FullClosureFirstCopiedValueIndex + numCopied;
				assert((numSlots >= 0)
				 && ((knownClassAtIndex(ClassFullBlockClosureCompactIndex, self)) != GIV(nilObj)));
				assert(((objFormat < (firstByteFormat(self))
					? objFormat
					: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(ClassFullBlockClosureCompactIndex, self), self)));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask(self)));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit(self))) == 0);
				assert((newObj % (allocationUnit(self))) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck(self);
					}
					if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l833;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + ClassFullBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
	l833:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord(self))))), compiledBlock);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))), (((usqInt)numArgs << 3) | 1));
				newClosure = newClosure1;
				if (receiverIsOnStack) {
					startIndex = FullClosureReceiverIndex;
					numCopied1 = numCopied + 1;
				}
				else {
					startIndex = FullClosureFirstCopiedValueIndex;
					/* begin storePointerUnchecked:ofObject:withValue: */
					valuePointer = longAt(localFP + FoxReceiver);
					assert(!(isOopForwarded(newClosure, self)));
					longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord(self))))), valuePointer);
					numCopied1 = numCopied;
				}
				if (numCopied1 > 0) {
					for (i = 0; i < numCopied1; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer1 = longAtPointer(localSP + (((numCopied1 - i) - 1) * BytesPerOop));
						assert(!(isOopForwarded(newClosure, self)));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + startIndex)) << (shiftForWord(self))))), valuePointer1);
					}
					/* begin internalPop: */
					localSP += numCopied1 * BytesPerOop;
				}
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 506: /*250*/
			/* extPushClosureBytecode */
			{
				sqInt blockSize;
				sqInt byte;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				usqInt newClosure;
				usqInt newClosure1;
				usqInt newObj;
				sqInt numArgs;
				usqInt numBytes;
				sqInt numCopied;
				sqInt numSlots;
				sqInt objFormat;
				sqInt valuePointer;

				VM_LABEL(extPushClosureBytecode);
				byte = byteAtPointer(++localIP);
				numArgs = (byte & 7) + ((extA % 16) * 8);
				numCopied = ((((usqInt) byte) >> 3) & 7) + ((extA / 16) * 8);
				extA = 0;
				blockSize = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extB) << 8)));
				numExtB = (extB = 0);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP, self), self));
					context = longAt(localFP + FoxThisContext);
					goto l851;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop), self);
	l851:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = indexablePointersFormat(self);
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				assert((numSlots >= 0)
				 && ((knownClassAtIndex(ClassBlockClosureCompactIndex, self)) != GIV(nilObj)));
				assert(((objFormat < (firstByteFormat(self))
					? objFormat
					: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex, self), self)));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask(self)));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit(self))) == 0);
				assert((newObj % (allocationUnit(self))) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck(self);
					}
					if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l853;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
	l853:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord(self))))), (((usqInt)initialIP << 3) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1, self)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))), (((usqInt)numArgs << 3) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop));
						assert(!(isOopForwarded(newClosure, self)));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord(self))))), valuePointer);
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				if (GIV(isStepable)) {
					printLocalSPLocalFPLocalIPCurrentBytecode(localSP, localSP, localIP, currentBytecode, self);
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					printCallStack(self);
					lockFetchNextBytecode(self);
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		}
	}

	/* undo the pre-increment of IP before returning */
	localIP -= 1;
	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static sqInt NoDbgRegParms
addressIsInPage(StackPage * self_in_addressIsInPage, char *address, struct foo * self)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static sqInt NoDbgRegParms
isFree(StackPage * self_in_isFree, struct foo * self)
{
	return ((self_in_isFree->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static void NoDbgRegParms
freeStackPageNoAssert(StackPage *aPage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return;
	}
	if ((((prev = (aPage->prevPage))->baseFP)) == 0) {
		return;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static sqInt NoDbgRegParms
freeStackPage(StackPage *aPage, struct foo * self)
{
	freeStackPageNoAssert(aPage, self);
	assert(pageListIsWellFormed(self));
	return 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageMostRecentlyUsed(StackPage *page, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed(self));
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed(self));
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageNextMostRecentlyUsed(StackPage *page, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed(self));
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree, self);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page, self)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP), self))
				 && (addressIsInPage(page, (page->headSP), self))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages(self))))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static StackPage * NoDbgRegParms
stackPageAt(sqInt index, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages), self);
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static StackPage * NoDbgRegParms
stackPageFor(void *pointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage), self);
	return stackPageAtpages(index, GIV(pages), self);
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statNumMaps) == 0
		? 0.0
		: (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps));
}

	/* InterpreterPrimitives>>#canBeImmutable: */
#if IMMUTABILITY
static sqInt NoDbgRegParms
canBeImmutable(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt processLists;
    sqInt scheduler;

	assert(isNonImmediate(oop, self));
	if (((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		return 0;
	}
	if ((assert(isNonImmediate(oop, self)),
	isEphemeronFormat((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self))) {
		return 0;
	}
	if (isWeakFormat((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)) {
		return 0;
	}
	if (((longAt(oop)) & (classIndexMask(self))) == (rawHashBitsOf(splObj(ClassSemaphore, self), self))) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	scheduler = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	processLists = longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord(self))))));
	if (oop == scheduler) {
		return 0;
	}
	if (oop == processLists) {
		return 0;
	}
	if ((classIndexOf(longAt((processLists + BaseHeaderSize) + (1U << (shiftForWord(self)))), self)) == ((longAt(oop)) & (classIndexMask(self)))) {
		return 0;
	}
	if ((classIndexOf(longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self)))))), self)) == ((longAt(oop)) & (classIndexMask(self)))) {
		return 0;
	}
	return 1;
}
#endif /* IMMUTABILITY */


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

	/* InterpreterPrimitives>>#cStringOrNullFor: */
char *
cStringOrNullFor(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    char *cString;
    sqInt fmt;
    sqInt isString;
    sqInt len;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self))))));
	if (oop & (tagMask(self))) {
		isString = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop)) & (classIndexMask(self));
	isString = ClassByteStringCompactIndex == ccIndex;
	goto l2;
	l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		len = numSlots;
		goto l4;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		len = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l4;
	}
	if (fmt >= (firstShortFormat(self))) {
		len = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l4;
	}
	if (fmt >= (firstLongFormat(self))) {
		len = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l4;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		len = numSlots;
		goto l4;
	}
	len = 0;
	l4:	/* end lengthOf:format: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop, self), len);
	cString[len] = 0;
	return cString;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

	/* InterpreterPrimitives>>#isNegativeIntegerValueOf: */
static sqInt NoDbgRegParms
isNegativeIntegerValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt ok;
    sqInt smallInt;

	if ((((oop) & 7) == 1)) {
		smallInt = (oop >> 3);
		return smallInt < 0;
	}
	if ((oop & (tagMask(self))) == 0) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop, self)));
		/* begin classIndexOf: */
		ccIndex = (longAt(oop)) & (classIndexMask(self));
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (ok) {
			return 0;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop, self)));
		/* begin classIndexOf: */
		ccIndex1 = (longAt(oop)) & (classIndexMask(self));
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
		goto l4;
	l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (ok) {
			return 1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Answer if oop is a value of an integer in address range, i.e up to the
	size of a machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

	/* InterpreterPrimitives>>#isPositiveMachineIntegerObject: */
sqInt
isPositiveMachineIntegerObject(sqInt oop, struct foo * self)
{
    sqInt ccIndex;
    sqInt ok;

	if ((((oop) & 7) == 1)) {
		return ((oop >> 3)) >= 0;
	}
	if (oop & (tagMask(self))) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	return ok
	 && ((numBytesOfBytes(oop, self)) <= (sizeof(usqIntptr_t)));
}


/*	Return a Large Integer object for the given integer magnitude and sign */

	/* InterpreterPrimitives>>#magnitude64BitIntegerFor:neg: */
static sqInt NoDbgRegParms
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int isSmall;
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt smallVal;
    sqInt sz;

	isSmall = (isNegative
		? magnitude <= ((MaxSmallInteger) + 1)
		: magnitude <= (MaxSmallInteger));
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return (((usqInt)smallVal << 3) | 1);
	}
	if (isNegative) {
		/* begin knownClassAtIndex: */
		assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize(self)))));
		/* begin fetchPointer:ofObject: */
		largeClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeIntegerCompactIndex) << (shiftForWord(self))))));
	}
	else {
		/* begin knownClassAtIndex: */
		assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize(self)))));
		/* begin fetchPointer:ofObject: */
		largeClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveIntegerCompactIndex) << (shiftForWord(self))))));
	}
	sz = 8;
	newLargeInteger = instantiateClassindexableSize(largeClass, sz, self);
	
	/* Memory is eight byte aligned in SPUR, so we are sure to have room for 64bits word whatever allocated sz */
	long64Atput((newLargeInteger + BaseHeaderSize) + (0U << 3), SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude));
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#magnitude64BitValueOf: */
static usqLong NoDbgRegParms
magnitude64BitValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt ok;
    sqInt smallIntValue;
    sqInt sz;
    usqLong value;

	if ((((oop) & 7) == 1)) {
		smallIntValue = (oop >> 3);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return ((usqLong) smallIntValue);
	}
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex1 = (longAt(oop)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;
	l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop, self)));
		/* begin classIndexOf: */
		ccIndex = (longAt(oop)) & (classIndexMask(self));
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	sz = ((numSlotsOf(oop, self)) << (shiftForWord(self))) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize) + (0U << 3))));
	}
	else {

		/* ] */
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive32BitValueOf: */
unsigned int
positive32BitValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt value64;

	if ((((oop) & 7) == 1)) {
		value64 = (oop >> 3);
		if ((value64 < 0)
		 || ((((unsigned int) value64)) != value64)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value64 = 0;
		}
		return value64;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive64BitValueOf: */
usqLong
positive64BitValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fmt;
    sqInt ok;
    sqInt sz;
    usqLong value;

	if ((((oop) & 7) == 1)) {
		if (((oop >> 3)) < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return (oop >> 3);
	}
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	sz = ((numSlotsOf(oop, self)) << (shiftForWord(self))) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize) + (0U << 3))));
	}
	else {

		/* ] */
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */
/*	only two callers & one is primitiveNewWithArg */

	/* InterpreterPrimitives>>#positiveMachineIntegerValueOf: */
usqIntptr_t
positiveMachineIntegerValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt ok;
    sqInt value;

	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	bs = ((numSlotsOf(oop, self)) << (shiftForWord(self))) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize) + (0U << 3))));
	}
	else {

		/* ] */
		return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
}

	/* InterpreterPrimitives>>#primitiveAdd */
static void
primitiveAdd(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1, self)) + (stackIntegerValue(0, self));
	if (!GIV(primFailCode)) {
		if ((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveAddLargeIntegers */
EXPORT(void)
primitiveAddLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	bIsNegative = isNegativeIntegerValueOf(oopArg, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

	/* InterpreterPrimitives>>#primitiveAdoptInstance */
static void
primitiveAdoptInstance(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt i;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((arg & (tagMask(self)))
	 || ((GIV(argumentCount) > 1)
	 && ((rcvr & (tagMask(self)))
	 || (!(objCouldBeClassObj(rcvr, self)))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	err = changeClassOfto(arg, rcvr, self);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {

		/* changeClassOf:to: answers errors as if rcvr (the class) is an argument... */
		if (err == PrimErrBadReceiver) {
			err = PrimErrBadArgument;
		}
		else {
			if (err == PrimErrBadArgument) {
				err = PrimErrBadReceiver;
			}
		}
		GIV(primFailCode) = err;
	}
	return;
}


/*	Answer an array of all instances of the receiver that exist
	when the primitive is called, excluding any that may be
	garbage collected as a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllInstances */
EXPORT(void)
primitiveAllInstances(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	result = allInstancesOf(longAt(GIV(stackPointer)), self);
	if ((((result) & 7) == 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 3)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)), self);
		result = allInstancesOf(longAt(GIV(stackPointer)), self);
		if ((((result) & 7) == 1)) {
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Answer an array of all objects that exist when the primitive
	is called, excluding those that may be garbage collected as
	a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllObjects */
EXPORT(void)
primitiveAllObjects(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	result = allObjects(self);
	if ((((result) & 7) == 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 3)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)), self);
		result = allObjects(self);
		if ((((result) & 7) == 1)) {
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveArctan */
static void
primitiveArctan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double rcvr;

	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(atan(rcvr), self);
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecome */
static void
primitiveArrayBecome(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 0, self);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWay */
static void
primitiveArrayBecomeOneWay(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1, self);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument
	deciding whether to
	copy the receiver's elements identity hashes over the argument's elements
	identity hashes.
 */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayCopyHash */
static void
primitiveArrayBecomeOneWayCopyHash(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copyHashFlag;
    sqInt ec;

	copyHashFlag = 0;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			copyHashFlag = 0;
		}
		else {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	ec = becomewithtwoWaycopyHash(longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), 0, copyHashFlag, self);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but does /not/ copy the receiver's
	elements identity hashes over the argument's elements identity hashes. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayNoCopyHash */
static void
primitiveArrayBecomeOneWayNoCopyHash(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 0, self);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}

	/* InterpreterPrimitives>>#primitiveAsCharacter */
static void
primitiveAsCharacter(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    sqInt reasonCode;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((((characterCode) & 7) == 1))
		 && (((characterCode = (characterCode >> 3)),
		((characterCode >= 0) && (characterCode <= ((1U << 30) - 1))))))) {
		/* begin primitiveFailFor: */
		reasonCode = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		GIV(primFailCode) = reasonCode;
		return;
	}
	characterObject = (((sqInt)((usqInt)(characterCode) << (numTagBits(self))))) + (characterTag(self));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}


/*	N.B. This will answer inexact results for integers with > 53 bits of
	magnitude. 
 */

	/* InterpreterPrimitives>>#primitiveAsFloat */
static void
primitiveAsFloat(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	assert((((rcvr) & 7) == 1));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(((double) ((rcvr >> 3)) ), self));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveAt */
static void
primitiveAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    unsigned int integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l10;
	}
	if (((index & (smallIntegerTag(self))) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l10;
	}
	index = (index >> 3);
	/* begin stObject:at: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l6;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l6;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l6;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l6;
	}
	totalLength = 0;
	l6:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l7;
	}
	class = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr, self), self);
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr, self)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr, self)));
		stSize = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1, self))
		 && ((oopisLessThanOrEqualTo(index, stSize, self))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr, self), self);
			goto l9;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat(self))
		? (((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1
		: 1), self))
	 && (oopisLessThanOrEqualTo(index, stSize, self))) {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin fetchPointer:ofObject: */
			result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord(self))))));
			goto l9;
		}
		if (fmt >= (firstByteFormat(self))) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l9;
		}
		if (fmt >= (firstShortFormat(self))) {
			result = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
			goto l9;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			result = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))), self);
			goto l9;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		result = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
		goto l9;
	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
	l9:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	l10:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveAtPut */
static void
primitiveAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class1;
    sqInt classFormat1;
    sqInt fixedFields1;
    usqLong fmt1;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt rcvr;
    sqInt reasonCode1;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp11;
    sqInt sp3;
    sqInt stSize1;
    sqInt totalLength1;
    usqLong unsigned64BitValueToStore1;
    unsigned int unsignedValueToStore1;
    sqInt value;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l30;
	}
	if (((index & (smallIntegerTag(self))) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l30;
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l30;
	}
	index = (index >> 3);
	/* begin stObject:at:put: */
	hdr1 = long64At(rcvr);
	fmt1 = (((unsigned sqLong)hdr1) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots11 = byteAt(rcvr + 7);
	numSlots2 = (numSlots11 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt1 <= 5 /* ephemeronFormat */) {
		totalLength1 = numSlots2;
		goto l18;
	}
	if (fmt1 >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength1 = (numSlots2 << (shiftForWord(self))) - (fmt1 & 7);
		goto l18;
	}
	if (fmt1 >= (firstShortFormat(self))) {
		totalLength1 = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
		goto l18;
	}
	if (fmt1 >= (firstLongFormat(self))) {
		totalLength1 = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
		goto l18;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
		totalLength1 = numSlots2;
		goto l18;
	}
	totalLength1 = 0;
	l18:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt1 >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt1 == 2 /* arrayFormat */)) {
		fixedFields1 = 0;
		goto l24;
	}
	if (fmt1 < 2 /* arrayFormat */) {
		fixedFields1 = totalLength1;
		goto l24;
	}
	class1 = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat1 = ((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields1 = classFormat1 & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l24:	/* end fixedFieldsOf:format:length: */;
	if ((fmt1 == (indexablePointersFormat(self)))
	 && ((hdr1 & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr, self), self);
			assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(rcvr, self)));
			stSize1 = sp3;
			goto l25;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp11) & 7) == 1))) {
			stSize1 = 0;
			goto l25;
		}
		assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(rcvr, self)));
		stSize1 = (sp11 >> 3);
	l25:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1, self))
		 && ((oopisLessThanOrEqualTo(index, stSize1, self))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr, self), value, self);
			goto l29;
		}
	}
	else {
		stSize1 = totalLength1 - fixedFields1;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat(self))
		? (((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1
		: 1), self))
	 && (oopisLessThanOrEqualTo(index, stSize1, self))) {
		/* begin subscript:with:storing:format: */
		if (fmt1 <= 5 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr, self)));
			if ((assert(isNonImmediate(rcvr, self)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((value & (tagMask(self))) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(rcvr, self);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord(self))))), value);
			goto l19;
		}
		if (fmt1 >= (firstByteFormat(self))) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l19;
			}
			signedValueToStore1 = (value >> 3);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l19;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
			goto l19;
		}
		if (fmt1 >= (firstShortFormat(self))) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l19;
			}
			signedValueToStore1 = (value >> 3);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l19;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 1))), signedValueToStore1);
			goto l19;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
			unsigned64BitValueToStore1 = positive64BitValueOf(value, self);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 3))), unsigned64BitValueToStore1);
			}
			goto l19;
		}
		unsignedValueToStore1 = positive32BitValueOf(value, self);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))), unsignedValueToStore1);
		}
	l19:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode1 = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode1;
	}
	l29:	/* end stObject:at:put: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
	l30:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

	/* InterpreterPrimitives>>#primitiveBeCursor */
static void
primitiveBeCursor(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	bitsObj = 0;
	cursorBitsIndex = 0;
	cursorObj = 0;
	depth = 0;
	extentX = 0;
	extentY = 0;
	maskBitsIndex = 0;
	maskObj = 0;
	offsetObj = 0;
	ourCursor = 0;
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin success: */
		successBoolean = (((cursorObj & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(cursorObj))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && ((lengthOfformat(cursorObj, (((usqInt) (longAt(cursorObj))) >> (formatShift(self))) & (formatMask(self)), self)) >= 5);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0U << (shiftForWord(self))));
		extentX = fetchIntegerofObject(1, cursorObj, self);
		extentY = fetchIntegerofObject(2, cursorObj, self);
		depth = fetchIntegerofObject(3, cursorObj, self);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4U << (shiftForWord(self))));
		/* begin success: */
		successBoolean1 = (((offsetObj & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(offsetObj))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && ((lengthOfformat(offsetObj, (((usqInt) (longAt(offsetObj))) >> (formatShift(self))) & (formatMask(self)), self)) >= 2);
		if (!successBoolean1) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj, self);
		offsetY = fetchIntegerofObject(1, offsetObj, self);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */
			/* begin success: */
			successBoolean2 = (extentX > 0)
			 && (extentY > 0);
			if (!successBoolean2) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean3 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			if (!successBoolean3) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean4 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			if (!successBoolean4) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (((bitsObj & (tagMask(self))) == 0)
			 && (((((((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self))) >= (firstLongFormat(self))) && (((((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self))) <= ((firstShortFormat(self)) - 1)))))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self)), self)) == (extentX * extentY));
			if (!successBoolean5) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
		else {
			/* begin success: */
			successBoolean6 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean6) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (offsetX >= -16)
			 && (offsetX <= 0);
			if (!successBoolean7) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean8 = (offsetY >= -16)
			 && (offsetY <= 0);
			if (!successBoolean8) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & (tagMask(self))) == 0)
			 && (((((((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self))) >= (firstLongFormat(self))) && (((((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self))) <= ((firstShortFormat(self)) - 1)))))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self)), self)) == 16);
			if (!successBoolean9) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean12 = (((maskObj & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(maskObj))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && ((lengthOfformat(maskObj, (((usqInt) (longAt(maskObj))) >> (formatShift(self))) & (formatMask(self)), self)) >= 5);
		if (!successBoolean12) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0U << (shiftForWord(self))));
			extentX = fetchIntegerofObject(1, maskObj, self);
			extentY = fetchIntegerofObject(2, maskObj, self);
			depth = fetchIntegerofObject(3, maskObj, self);
		}
		if (!GIV(primFailCode)) {
			/* begin success: */
			successBoolean10 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean10) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean11 = (((bitsObj & (tagMask(self))) == 0)
			 && (((((((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self))) >= (firstLongFormat(self))) && (((((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self))) <= ((firstShortFormat(self)) - 1)))))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift(self))) & (formatMask(self)), self)) == 16);
			if (!successBoolean11) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable,
	and if possible pin the display bitmap. Further, invoke ioBeDisplay
	to alow the VM to record the location, width heigth & depth of the bitmap. */

	/* InterpreterPrimitives>>#primitiveBeDisplay */
static void
primitiveBeDisplay(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsOop;
    void *bitsOrHandle;
    int changed;
    sqInt depthOop;
    sqInt heightOop;
    sqInt rcvr;
    sqInt widthOop;

	rcvr = longAt(GIV(stackPointer));
	if (!((((rcvr & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && (((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self)), self)) >= 4)
		 && (((bitsOop = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord(self))))),
		((((bitsOop & (tagMask(self))) == 0)
			 && (isPureBitsFormat((((usqInt) (longAt(bitsOop))) >> (formatShift(self))) & (formatMask(self)), self)))
			 || ((((bitsOop) & 7) == 1)))
			 && (((((((widthOop = longAt((rcvr + BaseHeaderSize) + (1U << (shiftForWord(self))))))) & 7) == 1))
			 && (((((((heightOop = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord(self))))))) & 7) == 1))
			 && ((((((depthOop = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord(self))))))) & 7) == 1))))))))) {
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	/* begin splObj:put: */
	assert(!(isForwarded(GIV(specialObjectsOop), self)));
	if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
	oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((rcvr & (tagMask(self))) == 0)
		 && (oopisLessThan(rcvr, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(GIV(specialObjectsOop), self);
			}
		}
	}
	longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheDisplay) << (shiftForWord(self))))), rcvr);
	if (((bitsOop & (tagMask(self))) == 0)
	 && (!(((((usqInt) (longAt(bitsOop))) >> (pinnedBitShift(self))) & 1) != 0))) {

		/* Answers 0 if memory required to pin bit not enough memory available. */
		rcvr = pinObject(bitsOop, self);
		if (rcvr != 0) {
			bitsOop = rcvr;
		}
	}
	/* begin ioBeDisplay:width:height:depth: */
	bitsOrHandle = ((bitsOop & (tagMask(self))) == 0
		? firstIndexableField(bitsOop, self)
		: ((void *)bitsOop));
	changed = displayBits != bitsOrHandle;
	displayBits = bitsOrHandle;
	displayWidth = (widthOop >> 3);
	displayHeight = (heightOop >> 3);
	displayDepth = (depthOop >> 3);
	ioNoteDisplayChangedwidthheightdepth(bitsOrHandle, (widthOop >> 3), (heightOop >> 3), (depthOop >> 3));
}


/*	make the basic beep noise */

	/* InterpreterPrimitives>>#primitiveBeep */
static void
primitiveBeep(struct foo * self)
{
	ioBeep(self);
}

	/* InterpreterPrimitives>>#primitiveBehaviorHash */
static void
primitiveBehaviorHash(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt err;
    sqInt hash;
    sqInt hashOrError;
    char *sp;

	assert((isNonImmediate(stackTop(self), self))
	 && (addressCouldBeClassObj(stackTop(self), self)));
	assert(addressCouldBeClassObj(longAt(GIV(stackPointer)), self));
	hashOrError = (((hash = (long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask(self)))) != 0
		? hash
		: (objCouldBeClassObj(longAt(GIV(stackPointer)), self)
				? (((err = enterIntoClassTable(longAt(GIV(stackPointer)), self))) != 0
						? -err
						: (long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask(self)))
				: -PrimErrBadReceiver));
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)hashOrError << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = -hashOrError;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitAnd */
static void
primitiveBitAnd(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt fmt1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;


	/* Note no short-cut for SmallIntegers.  Either the inline interpreter bytecode or the JIT primitive will handle this case. */
	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((((oop1) & 7) == 1)) {
		value = (oop1 >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l4;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l4;
	}
	if (oop1 & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l4;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop1, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop1)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l4;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop1))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	bs = ((numSlotsOf(oop1, self)) << (shiftForWord(self))) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l4;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop1 + BaseHeaderSize) + (0U << 3))))));
		goto l4;
	}
	else {

		/* ] */
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))))));
		goto l4;
	}
	l4:	/* end positiveMachineIntegerValueOf: */;
	/* begin positiveMachineIntegerValueOf: */
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((oop2) & 7) == 1)) {
		value1 = (oop2 >> 3);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l8;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l8;
	}
	if (oop2 & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l8;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop2, self)));
	/* begin classIndexOf: */
	ccIndex1 = (longAt(oop2)) & (classIndexMask(self));
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l5;
	l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l8;
	}
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt) (longAt(oop2))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt1 >= (firstByteFormat(self)));
	bs1 = ((numSlotsOf(oop2, self)) << (shiftForWord(self))) - (fmt1 & 7);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l8;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop2 + BaseHeaderSize) + (0U << 3))))));
		goto l8;
	}
	else {

		/* ] */
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize) + (0U << 2))))))));
		goto l8;
	}
	l8:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positiveMachineIntegerFor(integerArgumentValue & integerReceiverValue, self);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitAndLargeIntegers */
EXPORT(void)
primitiveBitAndLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitOr */
static void
primitiveBitOr(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt fmt1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;


	/* Note no short-cut for SmallIntegers.  Either the inline interpreter bytecode or the JIT primitive will handle this case. */
	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((((oop1) & 7) == 1)) {
		value = (oop1 >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l4;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l4;
	}
	if (oop1 & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l4;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop1, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop1)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l4;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop1))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	bs = ((numSlotsOf(oop1, self)) << (shiftForWord(self))) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l4;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop1 + BaseHeaderSize) + (0U << 3))))));
		goto l4;
	}
	else {

		/* ] */
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))))));
		goto l4;
	}
	l4:	/* end positiveMachineIntegerValueOf: */;
	/* begin positiveMachineIntegerValueOf: */
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((oop2) & 7) == 1)) {
		value1 = (oop2 >> 3);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l8;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l8;
	}
	if (oop2 & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l8;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop2, self)));
	/* begin classIndexOf: */
	ccIndex1 = (longAt(oop2)) & (classIndexMask(self));
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l5;
	l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l8;
	}
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt) (longAt(oop2))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt1 >= (firstByteFormat(self)));
	bs1 = ((numSlotsOf(oop2, self)) << (shiftForWord(self))) - (fmt1 & 7);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l8;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop2 + BaseHeaderSize) + (0U << 3))))));
		goto l8;
	}
	else {

		/* ] */
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize) + (0U << 2))))))));
		goto l8;
	}
	l8:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positiveMachineIntegerFor(integerArgumentValue | integerReceiverValue, self);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitOrLargeIntegers */
EXPORT(void)
primitiveBitOrLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Perform a bitShift. In 32-bits deal only with non-negative 32-bit
	integers. In 64-bits deal with signed 64-bit quantities (max (2^63)-1). */

	/* InterpreterPrimitives>>#primitiveBitShift */
static void
primitiveBitShift(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt shifted;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	if (!((((integerArgument) & 7) == 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerReceiver = signed64BitValueOf(integerReceiver, self);
	if (!GIV(primFailCode)) {
		if (((integerArgument = (integerArgument >> 3))) >= 0) {

			/* Left shift -- must fail bits would be lost */
			if (!(integerArgument <= 61 /* numSmallIntegerBits */)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
			if (!(integerReceiver == (((sqInt) shifted) >> integerArgument))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		else {

			/* Right shift -- OK to lose bits */
			if (!(integerArgument >= (-61 /* numSmallIntegerBits */))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((sqInt) integerReceiver) >> (0 - integerArgument);
		}
		shifted = ((((((usqInt) shifted) >> 60) + 1) & 15) <= 1
			? (((usqInt)shifted << 3) | 1)
			: signed64BitIntegerFor(shifted, self));
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitShiftLargeIntegers */
EXPORT(void)
primitiveBitShiftLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		shift = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
		goto l1;
	}
	l1:	/* end stackIntegerValue: */;
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	if (GIV(primFailCode)) {
		return;
	}
	if (shift >= 0) {

		/* Protect against overflow */

		/* This is to avoid undue (usqInt) cast */
		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > (result >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a << shift;
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = a >> shift;
		}
		if (aIsNegative
		 && ((result << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitXor */
static void
primitiveBitXor(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt fmt1;
    sqInt integerArgument;
    usqInt integerArgumentValue;
    sqInt integerReceiver;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    sqInt oop1;
    char *sp;
    char *sp1;
    sqInt value;
    sqInt value1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerArgument) & 7) == 1))
	 && ((((integerReceiver) & 7) == 1))) {

		/* xoring will leave the tag bits zero, whether the tag is 1 or zero, so add it back in. */
		/* begin pop:thenPush: */
		oop = (integerArgument ^ integerReceiver) + (smallIntegerTag(self));
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin positiveMachineIntegerValueOf: */
		if ((((integerArgument) & 7) == 1)) {
			value = (integerArgument >> 3);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerArgumentValue = ((usqIntptr_t) null);
				goto l4;
			}
			integerArgumentValue = ((usqIntptr_t) value);
			goto l4;
		}
		if (integerArgument & (tagMask(self))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l4;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(integerArgument, self)));
		/* begin classIndexOf: */
		ccIndex = (longAt(integerArgument)) & (classIndexMask(self));
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l4;
		}
		/* begin numBytesOfBytes: */
		fmt = (((usqInt) (longAt(integerArgument))) >> (formatShift(self))) & (formatMask(self));
		assert(fmt >= (firstByteFormat(self)));
		bs = ((numSlotsOf(integerArgument, self)) << (shiftForWord(self))) - (fmt & 7);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l4;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((integerArgument + BaseHeaderSize) + (0U << 3))))));
			goto l4;
		}
		else {

			/* ] */
			integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerArgument + BaseHeaderSize) + (0U << 2))))))));
			goto l4;
		}
	l4:	/* end positiveMachineIntegerValueOf: */;
		/* begin positiveMachineIntegerValueOf: */
		if ((((integerReceiver) & 7) == 1)) {
			value1 = (integerReceiver >> 3);
			if (value1 < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerReceiverValue = ((usqIntptr_t) null);
				goto l8;
			}
			integerReceiverValue = ((usqIntptr_t) value1);
			goto l8;
		}
		if (integerReceiver & (tagMask(self))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l8;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(integerReceiver, self)));
		/* begin classIndexOf: */
		ccIndex1 = (longAt(integerReceiver)) & (classIndexMask(self));
		ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
		goto l5;
	l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok1) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l8;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(integerReceiver))) >> (formatShift(self))) & (formatMask(self));
		assert(fmt1 >= (firstByteFormat(self)));
		bs1 = ((numSlotsOf(integerReceiver, self)) << (shiftForWord(self))) - (fmt1 & 7);
		if (bs1 > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l8;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs1 > 4)) {
			integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((integerReceiver + BaseHeaderSize) + (0U << 3))))));
			goto l8;
		}
		else {

			/* ] */
			integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerReceiver + BaseHeaderSize) + (0U << 2))))))));
			goto l8;
		}
	l8:	/* end positiveMachineIntegerValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			oop1 = positiveMachineIntegerFor(integerArgumentValue ^ integerReceiverValue, self);
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitXorLargeIntegers */
EXPORT(void)
primitiveBitXorLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Answer bytes available at this moment. For more meaningful 
	results, calls to this primitive should be precedeed by a full 
	or incremental garbage collection. */

	/* InterpreterPrimitives>>#primitiveBytesLeft */
static void
primitiveBytesLeft(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt chunk;
    sqInt freeChunk;
    sqInt i;
    sqInt integerVal;
    sqInt integerVal1;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) == 0) {

		/* old behavior - just return the size of free memory */
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((GIV(totalFreeOldSpace) << 3) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* Spur behavior; if argument is nil answer size of largest free chunk in oldSpace. */
		if ((longAt(GIV(stackPointer))) == GIV(nilObj)) {
			/* begin pop:thenPushInteger: */
			freeChunk = findLargestFreeChunk(self);
			if (!(freeChunk)) {
				for (i = 0x3F; i >= 1; i += -1) {
					chunk = GIV(freeLists)[i];
					if (!(chunk == null)) {
						integerVal = bytesInObject(chunk, self);
						goto l2;
					}
				}
				integerVal = 0;
				goto l2;
			}
			integerVal = bytesInObject(freeChunk, self);
	l2:	/* end sizeOfLargestFreeChunk */;
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushInteger: */
			integerVal1 = (((GIV(totalFreeOldSpace) + ((((eden(self)).limit)) - GIV(freeStart))) + ((((pastSpace(self)).limit)) - GIV(pastSpaceStart))) + ((((futureSpace(self)).limit)) - (((futureSpace(self)).limit)))) - (interpreterAllocationReserveBytes(self));
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerVal1 << 3) | 1));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

	/* InterpreterPrimitives>>#primitiveCalloutToFFI */
static void
primitiveCalloutToFFI(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static void *function = (void *)-1;
    void (*primitiveCallout)(void);

	/* begin functionForPrimitiveCallout */
	if ((((sqInt)function)) == -1) {
		function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims", self);
	}
	primitiveCallout = ((void (*)(void)) function);
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		primitiveCallout();
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

	/* InterpreterPrimitives>>#primitiveChangeClass */
static void
primitiveChangeClass(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l2;
	}
	arg = oop;
	l2:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (oop1 & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l3;
	}
	rcvr = oop1;
	l3:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	argClass = fetchClassOfNonImm(arg, self);
	err = changeClassOfto(rcvr, argClass, self);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

	/* InterpreterPrimitives>>#primitiveClass */
static void
primitiveClass(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    sqInt oop;
    char *sp;
    sqInt tagBits;

	instance = longAt(GIV(stackPointer));
	if ((GIV(argumentCount) > 0)
	 && (((instance & (tagMask(self))) == 0)
	 && (((longAt(instance)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		if (((tagBits = instance & (tagMask(self)))) != 0) {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))));
		}
		else {
			oop = fetchClassOfNonImm(instance, self);
		}
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Void the VM profile histograms. */

	/* InterpreterPrimitives>>#primitiveClearVMProfile */
static void
primitiveClearVMProfile(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

	/* InterpreterPrimitives>>#primitiveClipboardText */
static void
primitiveClipboardText(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt formatField;
    usqInt newObj;
    usqInt numBytes1;
    sqInt numSlots;
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(s))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			/* begin numBytesOfBytes: */
			fmt = (((usqInt) (longAt(s))) >> (formatShift(self))) & (formatMask(self));
			assert(fmt >= (firstByteFormat(self)));
			sz = ((numSlotsOf(s, self)) << (shiftForWord(self))) - (fmt & 7);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize(self);
		/* begin allocateBytes:classIndex: */
		assert(addressCouldBeClassObj(classAtIndex(ClassByteStringCompactIndex, self), self));
		assert((instSpecOfClass(classAtIndex(ClassByteStringCompactIndex, self), self)) == (firstByteFormat(self)));
		/* begin allocateSlots:format:classIndex: */
		numSlots = ((sz + BytesPerOop) - 1) / BytesPerOop;
		formatField = (firstByteFormat(self)) + ((8 - sz) & (BytesPerWord - 1));
		if (numSlots >= (numSlotsMask(self))) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				s = null;
				goto l4;
			}
			newObj = GIV(freeStart) + BaseHeaderSize;
			numBytes1 = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj = GIV(freeStart);
			numBytes1 = BaseHeaderSize + ((numSlots < 1
	? /* begin allocationUnit */ 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck(self);
			}
			s = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes1, formatField, ClassByteStringCompactIndex, self);
			goto l4;
		}
		if (numSlots >= (numSlotsMask(self))) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
			longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(self), formatField, ClassByteStringCompactIndex, self));
		}
		else {
			longAtput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + ClassByteStringCompactIndex);
		}
		assert((numBytes1 % (allocationUnit(self))) == 0);
		assert((newObj % (allocationUnit(self))) == 0);
		GIV(freeStart) += numBytes1;
		s = newObj;
	l4:	/* end allocateBytes:classIndex: */;
		if (!(s)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

	/* InterpreterPrimitives>>#primitiveClockLogAddresses */
EXPORT(sqInt)
primitiveClockLogAddresses(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt midx;
    void *msecs;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;

	midx = 0;
	msecs = ((void *) 0);
	uidx = 0;
	usecs = ((void *) 0);
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self)))))), 5, self);
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result, self));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isOopForwarded(objOop, self)));
	longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))), (((usqInt)runInNOut << 3) | 1));
	/* begin positive32BitIntegerFor: */
	v1 = ((((((usqInt)(((unsigned int) (((usqInt)usecs)))))) & 0xFFFFFFFFU) << 3) | 1);
	goto l5;
	l5:	/* end positive32BitIntegerFor: */;
	/* begin positive32BitIntegerFor: */
	v2 = ((((((usqInt)(((unsigned int) (((usqInt)msecs)))))) & 0xFFFFFFFFU) << 3) | 1);
	goto l6;
	l6:	/* end positive32BitIntegerFor: */;
	if (GIV(primFailCode)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	objOop3 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop3, self)));
	if ((assert(isNonImmediate(objOop3, self)),
	oopisGreaterThanOrEqualTo(objOop3, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((v1 & (tagMask(self))) == 0)
		 && (oopisLessThan(v1, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop3))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(objOop3, self);
			}
		}
	}
	longAtput((objOop3 + BaseHeaderSize) + (1U << (shiftForWord(self))), v1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isOopForwarded(objOop1, self)));
	longAtput((objOop1 + BaseHeaderSize) + (2U << (shiftForWord(self))), (((usqInt)uidx << 3) | 1));
	/* begin storePointer:ofObject:withValue: */
	objOop4 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop4, self)));
	if ((assert(isNonImmediate(objOop4, self)),
	oopisGreaterThanOrEqualTo(objOop4, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((v2 & (tagMask(self))) == 0)
		 && (oopisLessThan(v2, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop4))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(objOop4, self);
			}
		}
	}
	longAtput((objOop4 + BaseHeaderSize) + (3U << (shiftForWord(self))), v2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isOopForwarded(objOop2, self)));
	longAtput((objOop2 + BaseHeaderSize) + (4U << (shiftForWord(self))), (((usqInt)midx << 3) | 1));
	/* begin pop:thenPush: */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveClosureValue */
static void
primitiveClosureValue(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))));
	if (!(((outerContext & (tagMask(self))) == 0)
		 && (((longAt(outerContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
	if (!(((closureMethod & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext, self));
	numCopied = (numSlotsOf(blockClosure, self)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext, self)));
	assert(isOopCompiledMethod(closureMethod, self));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	objOop = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext, objOop, self);
	}
	object1 = objOop;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer), self));
	assert(!(frameHasContext(GIV(framePointer), self)));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord(self))))));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1, self);
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveClosureValueNoContextSwitch */
void
primitiveClosureValueNoContextSwitch(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))));
	if (!(((outerContext & (tagMask(self))) == 0)
		 && (((longAt(outerContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
	if (!(((closureMethod & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext, self));
	numCopied = (numSlotsOf(blockClosure, self)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext, self)));
	assert(isOopCompiledMethod(closureMethod, self));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	objOop = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext, objOop, self);
	}
	object1 = objOop;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer), self));
	assert(!(frameHasContext(GIV(framePointer), self)));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord(self))))));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0, self);
	}
}

	/* InterpreterPrimitives>>#primitiveClosureValueWithArgs */
static void
primitiveClosureValueWithArgs(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt index;
    sqInt numArgs;
    sqInt numCopied;
    usqInt numSlots;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(roomToPushNArgs(arraySize, self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))));
	if (!(((outerContext & (tagMask(self))) == 0)
		 && (((longAt(outerContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
	if (!(((closureMethod & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext, self));
	numCopied = (numSlotsOf(blockClosure, self)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext, self)));
	assert(isOopCompiledMethod(closureMethod, self));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	objOop = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext, objOop, self);
	}
	object1 = objOop;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp7;
	}
	assert(frameIsBlockActivation(GIV(framePointer), self));
	assert(!(frameHasContext(GIV(framePointer), self)));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord(self))))));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1, self);
	}
}


/*	Return the value of the microsecond clock in the local timezone, as
	updated by the heartbeat, as an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseLocalMicrosecondClock */
static void
primitiveCoarseLocalMicrosecondClock(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicroseconds(self), self);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the microsecond clock as updated by the heartbeat as
	an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseUTCMicrosecondClock */
static void
primitiveCoarseUTCMicrosecondClock(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioUTCMicroseconds(self), self);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Compare two byte-indexed objects for equality */

	/* InterpreterPrimitives>>#primitiveCompareBytes */
EXPORT(void)
primitiveCompareBytes(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt fmt;
    sqInt fmt1;
    sqInt i;
    sqInt len1;
    sqInt len2;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numSlots;
    usqInt numSlots1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((((arg1 & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(arg1))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))
		 && (((arg2 & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(arg2))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (arg1 == arg2) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOf: */
	if (arg1 & (tagMask(self))) {
		len1 = 0;
		goto l2;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(arg1))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOf: */
	assert((classIndexOf(arg1, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(arg1 + 7);
	numBytes = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(arg1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord(self));
	if (fmt >= (firstByteFormat(self))) {

		/* bytes (the common case), including CompiledMethod */
		len1 = numBytes - (fmt & 7);
		goto l2;
	}
	if (fmt <= (sixtyFourBitIndexableFormat(self))) {
		len1 = numBytes;
		goto l2;
	}
	if (fmt >= (firstShortFormat(self))) {
		len1 = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
		goto l2;
	}
	len1 = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l2:	/* end byteSizeOf: */;
	/* begin byteSizeOf: */
	if (arg2 & (tagMask(self))) {
		len2 = 0;
		goto l4;
	}
	/* begin numBytesOf: */
	fmt1 = (((usqInt) (longAt(arg2))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOf: */
	assert((classIndexOf(arg2, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(arg2 + 7);
	numBytes1 = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(arg2 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	numBytes1 = numBytes1 << (shiftForWord(self));
	if (fmt1 >= (firstByteFormat(self))) {

		/* bytes (the common case), including CompiledMethod */
		len2 = numBytes1 - (fmt1 & 7);
		goto l4;
	}
	if (fmt1 <= (sixtyFourBitIndexableFormat(self))) {
		len2 = numBytes1;
		goto l4;
	}
	if (fmt1 >= (firstShortFormat(self))) {
		len2 = numBytes1 - (((sqInt)((usqInt)((fmt1 & 3)) << 1)));
		goto l4;
	}
	len2 = numBytes1 - (((sqInt)((usqInt)((fmt1 & 1)) << 2)));
	l4:	/* end byteSizeOf: */;
	if (!(len1 == len2)) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return;
	}
	for (i = 0; i < len1; i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp3;
}


/*	<string1> primitiveCompareWith: string2 [collated: order] */
/*	1 - fetch the parameters from the stack */

	/* InterpreterPrimitives>>#primitiveCompareWith */
EXPORT(void)
primitiveCompareWith(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt c1;
    sqInt c11;
    sqInt c2;
    sqInt c21;
    sqInt fmt;
    sqInt fmt1;
    sqInt i;
    sqInt i1;
    sqInt min;
    sqInt min1;
    sqInt order;
    sqInt result;
    char *sp;
    sqInt string1;
    sqInt string2;
    sqInt strLength1;
    sqInt strLength2;


	/* 1 - fetch the parameters from the stack */
	order = 0;
	if (!(GIV(argumentCount) == 1)) {
		if (GIV(argumentCount) != 2) {
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		order = longAt(GIV(stackPointer));
		if (!((((order & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(order))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))
			 && ((numBytesOfBytes(order, self)) == 256))) {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	string1 = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));

	/* 2 - check their types - all parameters are ByteObject */
	string2 = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	if (!((((string1 & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(string1))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))
		 && (((string2 & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(string2))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(string1))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	strLength1 = ((numSlotsOf(string1, self)) << (shiftForWord(self))) - (fmt & 7);
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt) (longAt(string2))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt1 >= (firstByteFormat(self)));
	strLength2 = ((numSlotsOf(string2, self)) << (shiftForWord(self))) - (fmt1 & 7);
	if (order == null) {
		/* begin rawCompare:length:with:length:accessBlock: */
		min = ((strLength1 < strLength2) ? strLength1 : strLength2);
		for (i = 0; i < min; i += 1) {
			c1 = byteAt((string1 + BaseHeaderSize) + i);
			c2 = byteAt((string2 + BaseHeaderSize) + i);
			if (!(c1 == c2)) {
				result = c1 - c2;
				goto l1;
			}
		}
		result = strLength1 - strLength2;
	l1:	/* end rawCompare:length:with:length:accessBlock: */;
	}
	else {
		/* begin rawCompare:length:with:length:accessBlock: */
		min1 = ((strLength1 < strLength2) ? strLength1 : strLength2);
		for (i1 = 0; i1 < min1; i1 += 1) {
			/* begin fetchByte:ofObject: */
			c11 = byteAt((order + BaseHeaderSize) + ((byteAt((string1 + BaseHeaderSize) + i1)) + 1));
			/* begin fetchByte:ofObject: */
			c21 = byteAt((order + BaseHeaderSize) + ((byteAt((string2 + BaseHeaderSize) + i1)) + 1));
			if (!(c11 == c21)) {
				result = c11 - c21;
				goto l3;
			}
		}
		result = strLength1 - strLength2;
	l3:	/* end rawCompare:length:with:length:accessBlock: */;
	}
	/* begin methodReturnInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)result << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Fill the receiver, which must be an indexable non-pointer
	object, with the given integer value. */

	/* InterpreterPrimitives>>#primitiveConstantFill */
static void
primitiveConstantFill(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    usqLong fillValue;
    sqInt format;
    usqInt i;
    sqInt oddBytes;
    sqInt rcvr;

	/* begin primitiveConstantFillSpur */
	fillValue = positive64BitValueOf(longAt(GIV(stackPointer)), self);
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((!GIV(primFailCode))
		 && (((rcvr & (tagMask(self))) == 0)
		 && (((format = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self)))) >= (sixtyFourBitIndexableFormat(self)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		goto l2;
	}
	if (format >= (firstShortFormat(self))) {
		if (format >= (firstByteFormat(self))) {
			if ((fillValue > 0xFF)
			 || (format >= (firstCompiledMethodFormat(self)))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				goto l2;
			}
			fillValue = ((fillValue + (fillValue << 8)) + (fillValue << 16)) + (fillValue << 24);
			oddBytes = format & 7;
		}
		else {
			if (fillValue > 0xFFFF) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				goto l2;
			}
			fillValue += fillValue << 16;
			oddBytes = ((sqInt)((usqInt)((format & 3)) << 1));
		}
		fillValue += fillValue << 32;
	}
	else {
		if (format == (sixtyFourBitIndexableFormat(self))) {
			oddBytes = 0;
		}
		else {
			if (fillValue > 0xFFFFFFFFU) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				goto l2;
			}
			fillValue += fillValue << 32;
			oddBytes = ((sqInt)((usqInt)((format & 1)) << 2));
		}
	}
	end = addressAfter(rcvr, self);
	i = rcvr + BaseHeaderSize;
	while (i < end) {
		long64Atput(i, fillValue);
		i += 8;
	}
	if (oddBytes > 0) {
		flag("endianness");
		fillValue = fillValue >> (8 * oddBytes);
		long64Atput(i - 8, fillValue);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	l2:	/* end primitiveConstantFillSpur */;
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

	/* InterpreterPrimitives>>#primitiveControlVMProfiling */
static void
primitiveControlVMProfiling(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((((bufferSize) & 7) == 1))
			 && (((bufferSize = (bufferSize >> 3))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), (((usqInt)numSamples << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	Fail if the objects are not in a fit state to be copied (e.g. married
	contexts and Cogged methods) */

	/* InterpreterPrimitives>>#primitiveCopyObject */
static void
primitiveCopyObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt fmt;
    sqInt i;
    usqInt length;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt valuePointer;

	if (!(GIV(argumentCount) >= 1)) {
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (rcvr & (tagMask(self))) {
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (arg & (tagMask(self))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((longAt(rcvr)) & (classIndexMask(self))) != ((longAt(arg)) & (classIndexMask(self)))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self)), self)) {
		/* begin numBytesOf: */
		fmt = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(rcvr + 7);
		numBytes = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		numBytes = numBytes << (shiftForWord(self));
		if (fmt >= (firstByteFormat(self))) {

			/* bytes (the common case), including CompiledMethod */
			length = numBytes - (fmt & 7);
			goto l4;
		}
		if (fmt <= (sixtyFourBitIndexableFormat(self))) {
			length = ((sqInt) numBytes);
			goto l4;
		}
		if (fmt >= (firstShortFormat(self))) {
			length = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
			goto l4;
		}
		length = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l4:	/* end numBytesOf: */;
		if (!((((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self))) == ((((usqInt) (longAt(arg))) >> (formatShift(self))) & (formatMask(self))))
			 && (length == (numBytesOf(arg, self))))) {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		memcpy(((void *)(rcvr + BaseHeaderSize)), ((void *)(arg + BaseHeaderSize)), length);
	}
	else {
		if (!(isAppropriateForCopyObject(rcvr, self))) {
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(rcvr + 7);
		length = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		if (!((isAppropriateForCopyObject(arg, self))
			 && (length == (lengthOfformat(arg, (((usqInt) (longAt(arg))) >> (formatShift(self))) & (formatMask(self)), self))))) {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		for (i = 0; i < length; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			assert(!(isForwarded(rcvr, self)));
			if ((assert(isNonImmediate(rcvr, self)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((valuePointer & (tagMask(self))) == 0)
				 && (oopisLessThan(valuePointer, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(rcvr, self);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

	/* InterpreterPrimitives>>#primitiveCrashVM */
EXPORT(sqInt)
primitiveCrashVM(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((((longAt(GIV(stackPointer)))) & 7) == 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 3);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		crashInThisThread = null;
	l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveDisablePowerManager */
EXPORT(sqInt)
primitiveDisablePowerManager(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integer = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveDiv */
static void
primitiveDiv(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)), self);
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt) quotient) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)quotient << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}

	/* InterpreterPrimitives>>#primitiveDivide */
static void
primitiveDivide(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integerReceiver = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
	l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		integerArgument = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if ((((((usqInt) (integerReceiver / integerArgument)) >> 60) + 1) & 15) <= 1) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)(integerReceiver / integerArgument) << 3) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivideLargeIntegers */
EXPORT(void)
primitiveDivideLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	bIsNegative = isNegativeIntegerValueOf(oopArg, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (GIV(primFailCode)) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivLargeIntegers */
EXPORT(void)
primitiveDivLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	bIsNegative = isNegativeIntegerValueOf(oopArg, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */
			rem = a % b;
			if (!(rem == 0)) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */
				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process.
	For simulation if there is an argument it is taken to be the effective
	activeProcess (see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveEnterCriticalSection */
static void
primitiveEnterCriticalSection(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt objOop;
    sqInt objOop1;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin memoryActiveProcess */
		objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
		objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord(self))))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection, self)));
		if ((assert(isNonImmediate(criticalSection, self)),
		oopisGreaterThanOrEqualTo(criticalSection, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((activeProc & (tagMask(self))) == 0)
			 && (oopisLessThan(activeProc, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(criticalSection))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(criticalSection, self);
				}
			}
		}
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord(self))))), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp2;
	addLastLinktoList(activeProc, criticalSection, self);
	transferTo(wakeHighestPriority(self), self);
}

	/* InterpreterPrimitives>>#primitiveEqual */
static void
primitiveEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & (smallIntegerTag(self))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver == integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (signed64BitValueOf(integerReceiver, self)) == (signed64BitValueOf(integerArgument, self));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveEqualLargeIntegers */
EXPORT(void)
primitiveEqualLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Exit the critical section.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveExitCriticalSection */
static void
primitiveExitCriticalSection(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */
	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	if ((assert(!(isForwarded(criticalSection, self))),
	(longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))))) == GIV(nilObj))) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(criticalSection, self)));
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord(self))))), GIV(nilObj));
	}
	else {

		/* store check unnecessary because criticalSection referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */
		owningProcess = removeFirstLinkOfList(criticalSection, self);
		assert(!(isOopForwarded(criticalSection, self)));
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord(self))))), owningProcess);
		resumepreemptedYieldingIf(owningProcess, GIV(preemptionYields), self);
	}
}

	/* InterpreterPrimitives>>#primitiveExitToDebugger */
static void
primitiveExitToDebugger(struct foo * self)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveExp */
static void
primitiveExp(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double rcvr;

	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(exp(rcvr), self);
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	Exponent part of this float.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveExponent */
static void
primitiveExponent(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int pwr;
    double rcvr;

	pwr = 0;
	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {

		/* rcvr = frac * 2^pwr, where frac is in [0.5..1.0) */
		frexp(rcvr, (&pwr));
		longAtPointerput(GIV(stackPointer), (((usqInt)(pwr - 1) << 3) | 1));
	}
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Set PrimErrFFIException primitive failure and associated exceptionCode
	(a.k.a. 
	osErrorCode) and exceptionPC. Under control of the ffiExceptionResponse
	flag, if in a primitive with an error code and the inFFIFlags indicate
	we're in an FFI call,
	then fail the primitive.
	ffiExceptionResponse < 0 never fail
	ffiExceptionResponse = 0 fail if method has a primitive error code
	(default) ffiExceptionResponse > 0 always fail */

	/* InterpreterPrimitives>>#primitiveFailForFFIException:at: */
sqInt
primitiveFailForFFIExceptionat(usqLong exceptionCode, usqInt pc, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;

	if (((GIV(inFFIFlags) & DisownVMForFFICall) == 0)
	 || (ffiExceptionResponse < 0)) {

		/* i.e. never fail */
		return 0;
	}
	GIV(osErrorCode) = ((sqLong) exceptionCode);
	GIV(exceptionPC) = pc;
	GIV(primFailCode) = PrimErrFFIException;
	if ((ffiExceptionResponse > 0)
	 || ((((GIV(newMethod) & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))
	 && (methodUsesPrimitiveErrorCode(GIV(newMethod), self)))) {
		ownVM(DisownVMForFFICall, self);
		/* begin activateFailingPrimitiveMethod */
		assert(GIV(primFailCode) != 0);
		assert(addressCouldBeObj(GIV(newMethod), self));
		assert(isCompiledMethod(GIV(newMethod), self));
		assert((primitiveIndexOf(GIV(newMethod), self)) != 0);
		/* begin justActivateNewMethod: */
		assert(isCompiledMethod(GIV(newMethod), self));
		/* begin fetchPointer:ofObject: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
		/* begin argumentCountOfMethodHeader: */
		numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

		/* could new rcvr be set at point of send? */
		rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvr, self)));
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp2;
		GIV(framePointer) = GIV(stackPointer);
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp3;
		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method), self));
		assert((methodHeaderOf(GIV(method), self)) == methodHeader);
		
#    if MULTIPLEBYTECODESETS
		GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
			? 256
			: 0);
#    endif /* MULTIPLEBYTECODESETS */
		/* begin push: */
		object = (VMBIGENDIAN
			? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
			: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp5;
		/* begin push: */
		longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp6;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp;
		}
		GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
		if ((/* begin alternateHeaderHasPrimitiveFlag: */
		methodHeader & AlternateHeaderHasPrimFlag)) {

			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			GIV(instructionPointer) += 3;
			if (GIV(primFailCode) != 0) {
				reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader, self);
			}
		}
		longjmp(reenterInterpreter, ReturnToInterpreter);
	}
	return 0;
}


/*	Set PrimErrOSError primitive failure and associated osErrorCode. */

	/* InterpreterPrimitives>>#primitiveFailForOSError: */
sqInt
primitiveFailForOSError(sqLong osError, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(osErrorCode) = osError;
	return (GIV(primFailCode) = PrimErrOSError);
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}

	/* InterpreterPrimitives>>#primitiveFailureCode */
sqInt
primitiveFailureCode(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#primitiveFetchNextMourner */
static void
primitiveFetchNextMourner(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mourner;
    char *sp;

	mourner = (GIV(mournQueue) != GIV(nilObj)
		? popObjStack(GIV(mournQueue), self)
		: 0);
	if (mourner == null) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNotFound;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), mourner);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatAdd */
static void
primitiveFloatAdd(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg, self));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAt */
static void
primitiveFloatAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    unsigned int integerValue;
    unsigned int integerValue1;
    sqInt rcvr;
    sqInt reasonCode;
    usqInt result;
    char *sp;
    char *sp1;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		/* begin positive32BitIntegerFor: */
		integerValue = ((unsigned int) (fetchLong32ofFloatObject((VMBIGENDIAN
	? 0
	: 1), rcvr, self)));
		result = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
		goto l2;
	l2:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin positive32BitIntegerFor: */
		integerValue1 = ((unsigned int) (fetchLong32ofFloatObject((VMBIGENDIAN
	? 1
	: 0), rcvr, self)));
		result = ((((((usqInt)integerValue1)) & 0xFFFFFFFFU) << 3) | 1);
		goto l3;
	l3:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((((index) & 7) == 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAtPut */
static void
primitiveFloatAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    usqInt valueToStore;

	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore, self);
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (rcvr & (smallFloatTag(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((((index) & 7) == 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}

	/* InterpreterPrimitives>>#primitiveFloatDivide */
static void
primitiveFloatDivide(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg, self));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatEqual */
static void
primitiveFloatEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterOrEqual */
static void
primitiveFloatGreaterOrEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatGreaterOrEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr >= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterThan */
static void
primitiveFloatGreaterThan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatGreater:thanArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr > arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessOrEqual */
static void
primitiveFloatLessOrEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatLessOrEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr <= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessThan */
static void
primitiveFloatLessThan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatLess:thanArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr < arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatMultiply */
static void
primitiveFloatMultiply(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr * arg, self));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatNotEqual */
static void
primitiveFloatNotEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (!aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatSubtract */
static void
primitiveFloatSubtract(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop, self));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l3;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(rcvrOop) << shift)))) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l3;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l3;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask(self)))) != 0) {
		if (tagBits1 == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop, self));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits1 == (smallIntegerTag(self)))
		 && (((shift1 = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(argOop) << shift1)))) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr - arg, self));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

	/* InterpreterPrimitives>>#primitiveFlushCache */
static void
primitiveFlushCache(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;

	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invokation.
 */

	/* InterpreterPrimitives>>#primitiveFlushExternalPrimitives */
static void
primitiveFlushExternalPrimitives(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    sqInt i1;
    sqInt i2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin flushExternalPrimitives */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {

			/* This is a compiled method */
			flushExternalPrimitiveOf(objOop1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {

			/* This is a compiled method */
			flushExternalPrimitiveOf(objOop1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if (((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {

				/* This is a compiled method */
				flushExternalPrimitiveOf(objOop11, self);
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i2 = 0; i2 < MaxExternalPrimitiveTableSize; i2 += 1) {
		GIV(externalPrimitiveTable)[i2] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

	/* InterpreterPrimitives>>#primitiveForceDisplayUpdate */
static void
primitiveForceDisplayUpdate(struct foo * self)
{
	ioForceDisplayUpdate(self);
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

	/* InterpreterPrimitives>>#primitiveFormPrint */
static void
primitiveFormPrint(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt depth;
    sqInt fmt;
    sqInt h;
    double hScale;
    sqInt landscapeFlag;
    usqInt numBytes;
    usqInt numSlots;
    sqInt ok;
    sqInt pixelsPerWord;
    sqInt rcvr;
    double vScale;
    sqInt w;
    sqInt wordsPerLine;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l2;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l2;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	landscapeFlag = null;
	l2:	/* end booleanValueOf: */;
	vScale = floatValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	hScale = floatValueOf(longAt(GIV(stackPointer) + (2 * BytesPerWord)), self);
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if (!((((rcvr & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && ((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self)), self)) >= 4))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord(self))));
		w = fetchIntegerofObject(1, rcvr, self);
		h = fetchIntegerofObject(2, rcvr, self);
		depth = fetchIntegerofObject(3, rcvr, self);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if (((bitsArray & (tagMask(self))) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(bitsArray))) >> (formatShift(self))) & (formatMask(self)), self))) {
			/* begin numBytesOf: */
			fmt = (((usqInt) (longAt(bitsArray))) >> (formatShift(self))) & (formatMask(self));
			/* begin numSlotsOf: */
			assert((classIndexOf(bitsArray, self)) > (isForwardedObjectClassIndexPun(self)));
			numSlots = byteAt(bitsArray + 7);
			numBytes = (numSlots == (numSlotsMask(self))
				? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(bitsArray - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots);
			numBytes = numBytes << (shiftForWord(self));
			if (fmt >= (firstByteFormat(self))) {

				/* bytes (the common case), including CompiledMethod */
				bitsArraySize = numBytes - (fmt & 7);
				goto l4;
			}
			if (fmt <= (sixtyFourBitIndexableFormat(self))) {
				bitsArraySize = numBytes;
				goto l4;
			}
			if (fmt >= (firstShortFormat(self))) {
				bitsArraySize = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
				goto l4;
			}
			bitsArraySize = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l4:	/* end numBytesOf: */;
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		ok = ioFormPrint(bitsArray + BaseHeaderSize, w, h, depth, hScale, vScale, landscapeFlag);
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {

		/* pop hScale, vScale, and landscapeFlag; leave rcvr on stack */
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
}


/*	Fractional part of this float.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveFractionalPart */
static void
primitiveFractionalPart(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double rcvr;
    double trunc;

	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(modf(rcvr, (&trunc)), self);
		longAtPointerput(GIV(stackPointer), aValue);
	}
}

	/* InterpreterPrimitives>>#primitiveFullClosureValue */
static void
primitiveFullClosureValue(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numCopied;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	closureMethod = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord(self))))));
	if (!(((closureMethod & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewFullClosure:method:numArgs:mayContextSwitch: */
	assert(closureMethod == (fetchPointerofObject(FullClosureCompiledBlockIndex, blockClosure, self)));
	numCopied = (numSlotsOf(blockClosure, self)) - FullClosureFirstCopiedValueIndex;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp3;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp4;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp6;
	/* begin push: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FullClosureReceiverIndex, blockClosure, objOop, self);
	}
	object1 = objOop;
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp7;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + FullClosureFirstCopiedValueIndex)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer), self));
	assert(!(frameHasContext(GIV(framePointer), self)));
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(closureMethod, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = ((numArgs + numCopied) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp1;
	}
	GIV(instructionPointer) = ((closureMethod + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1, self);
	}
}


/*	An exact clone of primitiveFullClosureValue except that this version will
	not check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveFullClosureValueNoContextSwitch */
void
primitiveFullClosureValueNoContextSwitch(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numCopied;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	closureMethod = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord(self))))));
	if (!(((closureMethod & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewFullClosure:method:numArgs:mayContextSwitch: */
	assert(closureMethod == (fetchPointerofObject(FullClosureCompiledBlockIndex, blockClosure, self)));
	numCopied = (numSlotsOf(blockClosure, self)) - FullClosureFirstCopiedValueIndex;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp3;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp4;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp6;
	/* begin push: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FullClosureReceiverIndex, blockClosure, objOop, self);
	}
	object1 = objOop;
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp7;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + FullClosureFirstCopiedValueIndex)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer), self));
	assert(!(frameHasContext(GIV(framePointer), self)));
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(closureMethod, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = ((numArgs + numCopied) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp1;
	}
	GIV(instructionPointer) = ((closureMethod + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0, self);
	}
}

	/* InterpreterPrimitives>>#primitiveFullClosureValueWithArgs */
static void
primitiveFullClosureValueWithArgs(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt i;
    sqInt index;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numCopied;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(roomToPushNArgs(arraySize, self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	closureMethod = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord(self))))));
	if (!(((closureMethod & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewFullClosure:method:numArgs:mayContextSwitch: */
	assert(closureMethod == (fetchPointerofObject(FullClosureCompiledBlockIndex, blockClosure, self)));
	numCopied = (numSlotsOf(blockClosure, self)) - FullClosureFirstCopiedValueIndex;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp3;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp4;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp6;
	/* begin push: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FullClosureReceiverIndex, blockClosure, objOop, self);
	}
	object1 = objOop;
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp7;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp8 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + FullClosureFirstCopiedValueIndex)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp8;
	}
	assert(frameIsBlockActivation(GIV(framePointer), self));
	assert(!(frameHasContext(GIV(framePointer), self)));
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(closureMethod, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = ((numArgs + numCopied) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp1;
	}
	GIV(instructionPointer) = ((closureMethod + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1, self);
	}
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

	/* InterpreterPrimitives>>#primitiveGetAttribute */
static void
primitiveGetAttribute(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    sqInt integerPointer;
    sqInt s;
    char *sp;
    sqInt sz;

	sz = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		attr = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		attr = 0;
		goto l1;
	}
	l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		sz = attributeSize(attr, self);
	}
	if (!GIV(primFailCode)) {
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self)))))), sz, self);
		getAttributeIntoLength(attr, s + BaseHeaderSize, sz, self);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Access to environment variables via getenv. No putenv or setenv as yet. */

	/* InterpreterPrimitives>>#primitiveGetenv */
EXPORT(sqInt)
primitiveGetenv(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *key;
    sqInt oop;
    sqInt result;
    char *sp;
    char *var;

	result = 0;
	if (sHEAFn != 0) {

		/* secHasEnvironmentAccess */
		if (!(sHEAFn(self))) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrInappropriate);
		}
	}
	key = cStringOrNullFor(longAt(GIV(stackPointer)), self);
	if (key == 0) {
		if (!GIV(primFailCode)) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = GIV(primFailCode));
	}
	var = getenv(key);
	free(key);
	if (var != 0) {
		result = stringForCString(var, self);
		if (!(result)) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrNoMemory);
		}
	}
	assert(GIV(primFailCode) == 0);
	/* begin pop:thenPush: */
	oop = (var == 0
		? GIV(nilObj)
		: result);
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGetImmutability */
#if IMMUTABILITY
static void
primitiveGetImmutability(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt trueOrFalse;

	rcvr = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin pop:thenPushBool: */
	trueOrFalse = (rcvr & (tagMask(self)))
	 || (((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Primitive. Answer the VM's current log directory */

	/* InterpreterPrimitives>>#primitiveGetLogDirectory */
EXPORT(sqInt)
primitiveGetLogDirectory(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory(self);
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(splObj(ClassByteString, self), sz, self);
	for (i = 0; i < sz; i += 1) {
		byteAtput((stringOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), stringOop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Return the next input event from the VM event queue. */

	/* InterpreterPrimitives>>#primitiveGetNextEvent */
static void
primitiveGetNextEvent(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqIntptr_t eventTypeIs;
    sqIntptr_t evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqIntptr_t value;

	arg = longAt(GIV(stackPointer));
	if (!((((arg & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(arg))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && ((slotSizeOf(arg, self)) == 8))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (GIV(primFailCode)) {
		return;
	}
	eventTypeIs = evtBuf[0];
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt) (evtBuf[0])) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(arg, self)));
		longAtput((arg + BaseHeaderSize) + (0U << (shiftForWord(self))), (((usqInt)(evtBuf[0]) << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	if (eventTypeIs == 6) {

		/* Event is Complex, assume evtBuf is populated correctly and return */
		for (i = 1; i <= 7; i += 1) {
			value = evtBuf[i];
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(arg, self)));
			if ((assert(isNonImmediate(arg, self)),
			oopisGreaterThanOrEqualTo(arg, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((value & (tagMask(self))) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(arg))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(arg, self);
					}
				}
			}
			longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), value);
		}
	}
	else {

		/* Event time stamp */
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt) ((evtBuf[1]) & MillisecondClockMask)) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(arg, self)));
			longAtput((arg + BaseHeaderSize) + (1U << (shiftForWord(self))), (((usqInt)((evtBuf[1]) & MillisecondClockMask) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode)) {
			return;
		}
		for (i = 2; i <= 7; i += 1) {
			value = evtBuf[i];
			if ((((((usqInt) value) >> 60) + 1) & 15) <= 1) {
				/* begin storeInteger:ofObject:withValue: */
				if ((((((usqInt) value) >> 60) + 1) & 15) <= 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(arg, self)));
					longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), (((usqInt)value << 3) | 1));
				}
				else {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
			}
			else {
				value = positiveMachineIntegerFor(value, self);
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(arg, self)));
				if ((assert(isNonImmediate(arg, self)),
				oopisGreaterThanOrEqualTo(arg, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((value & (tagMask(self))) == 0)
					 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(arg))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(arg, self);
						}
					}
				}
				longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), value);
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's label */

	/* InterpreterPrimitives>>#primitiveGetWindowLabel */
EXPORT(sqInt)
primitiveGetWindowLabel(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt labelOop;
    char *ptr;
    char *sp;
    sqInt sz;

	ptr = ioGetWindowLabel(self);
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	sz = strlen(ptr);
	labelOop = instantiateClassindexableSize(splObj(ClassByteString, self), sz, self);
	for (i = 0; i < sz; i += 1) {
		byteAtput((labelOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), labelOop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveGetWindowSize */
EXPORT(sqInt)
primitiveGetWindowSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt h;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt object;
    sqInt objFormat;
    usqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth(self);
	h = ioGetWindowHeight(self);
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj, self)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l3;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
	l3:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self))))), (((usqInt)w << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self))))), (((usqInt)h << 3) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGreaterOrEqual */
static void
primitiveGreaterOrEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & (smallIntegerTag(self))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver >= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterOrEqualLargeIntegers */
EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr >= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGreaterThan */
static void
primitiveGreaterThan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & (smallIntegerTag(self))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver > integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterThanLargeIntegers */
EXPORT(void)
primitiveGreaterThanLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr > integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGrowMemoryByAtLeast */
static void
primitiveGrowMemoryByAtLeast(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ammount;
    sqInt segSize;
    char *sp;

	ammount = longAt(GIV(stackPointer));
	if (!((((ammount) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	segSize = growOldSpaceByAtLeast((ammount >> 3), self);
	if (segSize == null) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoMemory;
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)segSize << 3) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Implement 28-bit hashMultiply for SmallInteger and LargePositiveInteger
	receivers. 
 */

	/* InterpreterPrimitives>>#primitiveHashMultiply */
static void
primitiveHashMultiply(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ok;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	if ((((value) & 7) == 1)) {
		value = (value >> 3);
	}
	else {
		/* begin is:instanceOf:compactClassIndex: */
		if (value & (tagMask(self))) {
			ok = 0;
			goto l3;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(value, self)));
		/* begin classIndexOf: */
		ccIndex = (longAt(value)) & (classIndexMask(self));
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l3;
	l3:	/* end is:instanceOf:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		value = SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((value + BaseHeaderSize) + (0U << 2))));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)((value * HashMultiplyConstant) & 0xFFFFFFF) << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

	/* InterpreterPrimitives>>#primitiveHeartbeatFrequency */
EXPORT(sqInt)
primitiveHeartbeatFrequency(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt oop;
    sqInt reset;
    char *sp;

	reset = (GIV(argumentCount) == 1)
	 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	/* begin pop:thenPush: */
	integerValue = ((unsigned int) (ioHeartbeatFrequency(reset)));
	oop = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
	goto l1;
	l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Return the value of the high resolution clock if this system has any. The
	exact frequency of the high res clock is undefined specifically so that we
	can use processor dependent instructions (like RDTSC). The only use for
	the high res clock is for profiling where we can allocate time based on
	sub-msec resolution of the high res clock. If no high-resolution counter
	is available, the platform should return zero.
 */

	/* InterpreterPrimitives>>#primitiveHighResClock */
EXPORT(sqInt)
primitiveHighResClock(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin push: */
	object = positive64BitIntegerFor(ioHighResClock(self), self);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveIdentical */
static void
primitiveIdentical(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if ((((otherObject & (tagMask(self))) == 0)
	 && (((longAt(otherObject)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))
	 || ((GIV(argumentCount) > 1)
	 && (((thisObject & (tagMask(self))) == 0)
	 && (((longAt(thisObject)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
	else {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject == otherObject
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveIdentityHash */
static void
primitiveIdentityHash(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt hash1;
    sqInt integerVal;
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if ((thisReceiver & (tagMask(self)))
	 || ((GIV(argumentCount) > 0)
	 && (((longAt(thisReceiver)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPushInteger: */
		hash = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask(self));
		if (hash == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */
			/* begin newHashBitsOf: */
			hash1 = (newObjectHash(self)) & (identityHashHalfWordMask(self));
			/* begin setHashBitsOf:to: */
			assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask(self)))));
			long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash1);
			hash = hash1;
		}
		integerVal = hash;
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer an integer identifying the type of image. The image version number
	may identify the format of the image (e.g. 32 or 64-bit word size) or
	specific requirements
	of the image (e.g. block closure support required).
	
	This is a named (not numbered) primitive in the null module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveImageFormatVersion */
EXPORT(sqInt)
primitiveImageFormatVersion(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((((usqInt)68021 /* imageFormatVersion */)) & 0xFFFFFFFFU) << 3) | 1);
	goto l1;
	l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	When called with a single string argument, record the string as the
	current image file name. When called with zero arguments, return a string
	containing the current image file name.
 */

	/* InterpreterPrimitives>>#primitiveImageName */
static void
primitiveImageName(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt ok;
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		   If not, assume it's ok */
		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin", self);
		if (sCRIfn != 0) {
			okToRename = ((sqInt (*)(void))sCRIfn)();
			if (!okToRename) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		s = longAt(GIV(stackPointer));
		/* begin assertClassOf:is: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self))))));
		/* begin isNonImmediate: */
		ok = (s & (tagMask(self))) == 0;
		if (ok) {
			/* begin isClassOfNonImm:equalTo: */
			assert(isNonImmediate(s, self));
			ok = ((longAt(s)) & (classIndexMask(self))) == ((long32At(classOop + 4)) & (identityHashHalfWordMask(self)));
		}
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			sz = stSizeOf(s, self);
			imageNamePutLength(s + BaseHeaderSize, sz);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = imageNameSize(self);
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self)))))), sz, self);
		imageNameGetLength(s + BaseHeaderSize, sz);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	For a Smalllnteger, answer itself.
	For a Character, answer its code as an unsigned integer.
	For a SmallFloat, answer the signed, but unadjusted bit pattern (so as to
	keep the result a SmallInteger).
	This is a good value for an immediate's hash. */

	/* InterpreterPrimitives>>#primitiveImmediateAsInteger */
static void
primitiveImmediateAsInteger(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;
    usqInt value;

	value = 0;
	oop = longAt(GIV(stackPointer));
	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
	}
	else {
		if (oop & (characterTag(self))) {
			value = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
		}
		else {
			if (oop & (smallFloatTag(self))) {
				assert(isImmediateFloat(oop, self));
				value = (((usqInt) (((usqInt)oop))) >> ((numTagBits(self)) + 1)) + ((oop & (1U << (numTagBits(self)))
	? (((usqInt)-1)) << ((64 - (numTagBits(self))) - 1)
	: 0));
			}
			else {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadReceiver;
				return;
			}
		}
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

	/* InterpreterPrimitives>>#primitiveInputSemaphore */
static void
primitiveInputSemaphore(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((((arg) & 7) == 1)) {

		/* If arg is integer, then use it as an index
		   into the external objects array and install it
		   as the new event semaphore */
		ioSetInputSemaphore((arg >> 3));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
		return;
	}
	if (TheInputSemaphore == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask(self))) == 0)
	 && (((longAt(arg)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self))))) {
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop), self)));
		if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
		oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((arg & (tagMask(self))) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(GIV(specialObjectsOop), self);
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheInputSemaphore) << (shiftForWord(self))))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

	/* InterpreterPrimitives>>#primitiveInputWord */
static void
primitiveInputWord(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)0 << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveIntegerAt */
static void
primitiveIntegerAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt1;
    sqInt fmt2;
    sqInt index1;
    sqInt numFixed;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt oop;
    sqInt rcvr1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt value;

	
	/* Answer the signed integer element of a pure bits receiver */
	/* begin primitiveSpurIntegerAt */
	index1 = longAt(GIV(stackPointer));
	rcvr1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((index1) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l17;
	}
	if (rcvr1 & (tagMask(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		goto l17;
	}
	fmt2 = (((usqInt) (longAt(rcvr1))) >> (formatShift(self))) & (formatMask(self));
	index1 = ((index1 >> 3)) - 1;
	if (fmt2 >= (firstByteFormat(self))) {
		if (fmt2 >= (firstCompiledMethodFormat(self))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			goto l17;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(rcvr1))) >> (formatShift(self))) & (formatMask(self));
		assert(fmt1 >= (firstByteFormat(self)));
		numSlots2 = ((numSlotsOf(rcvr1, self)) << (shiftForWord(self))) - (fmt1 & 7);
		if ((((usqInt)index1)) < numSlots2) {
			value = byteAt((rcvr1 + BaseHeaderSize) + index1);
			if (value > 0x7F) {
				value -= 256;
			}
			/* begin methodReturnInteger: */
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
			GIV(stackPointer) = sp4;
			goto l17;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l17;
	}
	if (fmt2 >= (firstShortFormat(self))) {
		numSlots2 = ((usqInt) (numBytesOf(rcvr1, self))) >> 1;
		if ((((usqInt)index1)) < numSlots2) {
			value = shortAt((rcvr1 + BaseHeaderSize) + (((sqInt)((usqInt)(index1) << 1))));
			if (value > 0x7FFF) {
				value -= 65536;
			}
			/* begin methodReturnInteger: */
			longAtput((sp5 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
			GIV(stackPointer) = sp5;
			goto l17;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l17;
	}
	if (fmt2 == (sixtyFourBitIndexableFormat(self))) {
		numSlots2 = ((usqInt) (numBytesOf(rcvr1, self))) >> 3;
		if ((((usqInt)index1)) < numSlots2) {
			/* begin methodReturnValue: */
			oop = signed64BitIntegerFor(long64At((rcvr1 + BaseHeaderSize) + (((sqInt)((usqInt)(index1) << 3)))), self);
			/* begin pop:thenPush: */
			longAtput((sp7 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp7;
			goto l17;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l17;
	}
	if (fmt2 >= (firstLongFormat(self))) {
		numSlots2 = ((usqInt) (numBytesOf(rcvr1, self))) >> 2;
		if ((((usqInt)index1)) < numSlots2) {
			value = long32At((rcvr1 + BaseHeaderSize) + (((sqInt)((usqInt)(index1) << 2))));
			if (value > 0x7FFFFFFF) {
				value -= 0x100000000LL;
			}
			/* begin methodReturnInteger: */
			longAtput((sp6 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
			GIV(stackPointer) = sp6;
			goto l17;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l17;
	}
	if ((fmt2 <= 5 /* lastPointerFormat */)
	 && ((fmt2 >= 2 /* arrayFormat */)
	 && ((fmt2 <= (weakArrayFormat(self)))
	 || (fmt2 >= (sixtyFourBitIndexableFormat(self)))))) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr1, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots11 = byteAt(rcvr1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr1 - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots11);
		if (fmt2 == 2 /* arrayFormat */) {
			if ((((usqInt)index1)) < numSlots2) {
				/* begin methodReturnValue: */
				longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), longAt((rcvr1 + BaseHeaderSize) + (((sqInt)((usqInt)(index1) << (shiftForWord(self)))))));
				GIV(stackPointer) = sp2;
				goto l17;
			}
		}
		/* begin fixedFieldsOfClassFormat: */
		classPointer = fetchClassOfNonImm(rcvr1, self);
		classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		numFixed = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
		if ((((index1 + 1) >= numFixed) && ((index1 + 1) <= numSlots2))) {
			/* begin methodReturnValue: */
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), longAt((rcvr1 + BaseHeaderSize) + (((sqInt)((usqInt)((index1 + numFixed)) << (shiftForWord(self)))))));
			GIV(stackPointer) = sp3;
			goto l17;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l17;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	l17:	/* end primitiveSpurIntegerAt */;
}

	/* InterpreterPrimitives>>#primitiveIntegerAtPut */
static void
primitiveIntegerAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt numFixed;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqLong value;
    sqInt valueOop;

	
	/* Assign an indexable variable of a pure bits receiver with a signed integer. */
	/* begin primitiveSpurIntegerAtPut */
	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	value = signed64BitValueOf(valueOop, self);
	if (!((!GIV(primFailCode))
		 && ((((index) & 7) == 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l14;
	}
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		goto l14;
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l14;
	}
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
	index = ((index >> 3)) - 1;
	if (fmt >= (firstByteFormat(self))) {
		if (fmt >= (firstCompiledMethodFormat(self))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			goto l14;
		}
		if (!((((usqInt)((((sqLong)value >> 7)) + 1))) <= 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l14;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
		assert(fmt1 >= (firstByteFormat(self)));
		numSlots = ((numSlotsOf(rcvr, self)) << (shiftForWord(self))) - (fmt1 & 7);
		if ((((usqInt)index)) < numSlots) {
			byteAtput((rcvr + BaseHeaderSize) + index, value);
			/* begin methodReturnValue: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp;
			goto l14;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l14;
	}
	if (fmt >= (firstShortFormat(self))) {
		if (!((((usqInt)((((sqLong)value >> 15)) + 1))) <= 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l14;
		}
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 1;
		if ((((usqInt)index)) < numSlots) {
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 1))), value);
			/* begin methodReturnValue: */
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp1;
			goto l14;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l14;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {

		/* No range check on value in this case because signed64BitValueOf: performed it above. */
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3))), value);
			/* begin methodReturnValue: */
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp2;
			goto l14;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l14;
	}
	if (fmt >= (firstLongFormat(self))) {
		if (!((((usqInt)((((sqLong)value >> 31)) + 1))) <= 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l14;
		}
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))), value);
			/* begin methodReturnValue: */
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp3;
			goto l14;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l14;
	}
	if ((fmt <= 5 /* lastPointerFormat */)
	 && ((fmt >= 2 /* arrayFormat */)
	 && ((fmt <= (weakArrayFormat(self)))
	 || (fmt >= (sixtyFourBitIndexableFormat(self)))))) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(rcvr + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt == 2 /* arrayFormat */) {
			if ((((usqInt)index)) < numSlots) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr, self)));
				if ((assert(isNonImmediate(rcvr, self)),
				oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((valueOop & (tagMask(self))) == 0)
					 && (oopisLessThan(valueOop, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(rcvr, self);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))), valueOop);
				/* begin methodReturnValue: */
				longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
				GIV(stackPointer) = sp4;
				goto l14;
			}
		}
		/* begin fixedFieldsOfClassFormat: */
		classPointer = fetchClassOfNonImm(rcvr, self);
		classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		numFixed = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
		if ((((index + 1) >= numFixed) && ((index + 1) <= numSlots))) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr, self)));
			if ((assert(isNonImmediate(rcvr, self)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((valueOop & (tagMask(self))) == 0)
				 && (oopisLessThan(valueOop, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(rcvr, self);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index + numFixed)) << (shiftForWord(self))))), valueOop);
			/* begin methodReturnValue: */
			longAtput((sp5 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp5;
			goto l14;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l14;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	l14:	/* end primitiveSpurIntegerAtPut */;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

	/* InterpreterPrimitives>>#primitiveInterruptChecksPerMSec */
EXPORT(sqInt)
primitiveInterruptChecksPerMSec(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	oop = (((usqInt)(ioHeartbeatMilliseconds(self)) << 3) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

	/* InterpreterPrimitives>>#primitiveInterruptSemaphore */
static void
primitiveInterruptSemaphore(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask(self))) == 0)
	 && (((longAt(arg)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self))))) {
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop), self)));
		if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
		oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((arg & (tagMask(self))) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(GIV(specialObjectsOop), self);
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord(self))))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

	/* InterpreterPrimitives>>#primitiveInvokeObjectAsMethod */
static void
primitiveInvokeObjectAsMethod(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    sqInt runArgs;
    sqInt runReceiver;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt tagBits;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;

	nArgs = 0;
	savedFramePointer = ((char *) 0);
	savedStackPointer = ((char *) 0);
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && ((knownClassAtIndex(ClassArrayCompactIndex, self)) != GIV(nilObj)));
	assert((2 /* arrayFormat */) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex, self), self)));
	runArgs = allocateNewSpaceSlotsformatclassIndex(GIV(argumentCount), 2 /* arrayFormat */, ClassArrayCompactIndex, self);
	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		top1 = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top1;
		assert(!(isOopForwarded(runArgs, self)));
		longAtput((runArgs + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	runReceiver = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(messageSelector));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), runReceiver);
	GIV(stackPointer) = sp3;
	/* begin fetchPointer:ofObject: */
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorRunWithIn) << (shiftForWord(self))))));
	GIV(argumentCount) = 3;
	if (((tagBits = GIV(newMethod) & (tagMask(self)))) != 0) {
		lookupClassTag = tagBits;
	}
	else {
		/* begin classIndexOf: */
		lookupClassTag = (longAt(GIV(newMethod))) & (classIndexMask(self));
	}
	findNewMethodInClassTag(lookupClassTag, self);
	/* begin executeNewMethod */
	if (GIV(primitiveFunctionPointer) != 0) {
		if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse(self);
			goto l14;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
		assert((remapBufferCount(self)) == 0);
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
		/* begin maybeRetryPrimitiveOnFailure */
		if (GIV(primFailCode)) {
			retryPrimitiveOnFailure(self);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller(self)) {
			if (((freeStart(self)) < GIV(scavengeThreshold))
			 && ((longAt(freeStart(self))) != (freeStart(self)))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if ((!GIV(primFailCode))
		 && ((GIV(framePointer) == savedFramePointer)
		 && (!0))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */
			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				failUnbalancedPrimitive(self);
				GIV(stackPointer) = savedStackPointer;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod), self);
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l14;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr, self)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader1 & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader1, self);
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader, self), self);
	}
	l14:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Answer if running on a big endian machine. */

	/* InterpreterPrimitives>>#primitiveIsBigEnder */
EXPORT(sqInt)
primitiveIsBigEnder(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (VMBIGENDIAN
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer if the receiver is pinned, i.e. immobile. */

	/* InterpreterPrimitives>>#primitiveIsPinned */
static void
primitiveIsPinned(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    char *sp;
    sqInt trueOrFalse;

	obj = longAt(GIV(stackPointer));
	if ((obj & (tagMask(self)))
	 || (((longAt(obj)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	/* begin pop:thenPushBool: */
	trueOrFalse = ((((usqInt) (longAt(obj))) >> (pinnedBitShift(self))) & 1) != 0;
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

	/* InterpreterPrimitives>>#primitiveIsWindowObscured */
EXPORT(sqInt)
primitiveIsWindowObscured(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin pushBool: */
	trueOrFalse = ioIsWindowObscured(self);
	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte
	is the 8-bit ISO character. The next four bits are the Smalltalk modifier
	bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdNext */
static void
primitiveKbdNext(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioGetKeystroke(self);
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), (((usqInt)keystrokeWord << 3) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The
	low byte is the 8-bit ISO character. The next four bits are the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdPeek */
static void
primitiveKbdPeek(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioPeekKeystroke(self);
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), (((usqInt)keystrokeWord << 3) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessOrEqual */
static void
primitiveLessOrEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & (smallIntegerTag(self))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver <= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessOrEqualLargeIntegers */
EXPORT(void)
primitiveLessOrEqualLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr <= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessThan */
static void
primitiveLessThan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & (smallIntegerTag(self))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver < integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessThanLargeIntegers */
EXPORT(void)
primitiveLessThanLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr < integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

	/* InterpreterPrimitives>>#primitiveListBuiltinModule */
static void
primitiveListBuiltinModule(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index, self);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(splObj(ClassByteString, self), length, self);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck(self);
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	Primitive. Return the n-th loaded external module name. */

	/* InterpreterPrimitives>>#primitiveListExternalModule */
static void
primitiveListExternalModule(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index, self);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(splObj(ClassByteString, self), length, self);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck(self);
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	This primitive is called from Smalltalk as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray.
	
	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well
	formed. It will return as its value the original array of roots, and the
	erstwhile segmentWordArray will have been truncated to a size of one word,
	i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to
	an unrecognizable and unusable jumble. But what more could you have done
	with it anyway?
	[How about saving it so the system functions as primtiives are intended?
	eem 5/9/2017 16:31]
	
	In Spur, if the primitive succeeds, the segmentWordArray is also becomed
	into the array of loaded
	objects, to allow fixing up of loaded objects directly without nextObject,
	which Spur doesn't support. */

	/* InterpreterPrimitives>>#primitiveLoadImageSegment */
static void
primitiveLoadImageSegment(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));

	/* Essential type checks */
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((outPointerArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(outPointerArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && (((segmentWordArray & (tagMask(self))) == 0)
		 && (((((((usqInt) (longAt(segmentWordArray))) >> (formatShift(self))) & (formatMask(self))) >= (firstLongFormat(self))) && (((((usqInt) (longAt(segmentWordArray))) >> (formatShift(self))) & (formatMask(self))) <= ((firstShortFormat(self)) - 1))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = loadImageSegmentFromoutPointers(segmentWordArray, outPointerArray, self);
	if (oopisGreaterThan(result, segmentWordArray, self)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = result;
	}
}


/*	Return the value of the microsecond clock in the local timezone as an
	integer. This is the number of microseconds since the Smalltalk epoch,
	1901/1/1 12:00am.
	The microsecond clock is at least 60 bits wide which means it'll get to
	around August
	38435 before it wraps around. Be sure to put it on your calendar. This
	primitive accesses the time as answered by the OS. */

	/* InterpreterPrimitives>>#primitiveLocalMicrosecondClock */
static void
primitiveLocalMicrosecondClock(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicrosecondsNow(self), self);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveLogN */
static void
primitiveLogN(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double rcvr;

	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(log(rcvr), self);
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

	/* InterpreterPrimitives>>#primitiveLowSpaceSemaphore */
static void
primitiveLowSpaceSemaphore(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask(self))) == 0)
	 && (((longAt(arg)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self))))) {
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop), self)));
		if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
		oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((arg & (tagMask(self))) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(GIV(specialObjectsOop), self);
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord(self))))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveMakePoint */
static void
primitiveMakePoint(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    usqInt pt;
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg = longAt(GIV(stackPointer));
	if (!((arg & (tagMask(self))
			? !(arg & (characterTag(self)))
			: ((longAt(arg)) & (classIndexMask(self))) == ClassFloatCompactIndex))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj, self)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pt = 0;
			goto l2;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pt = newObj;
	l2:	/* end eeInstantiateSmallClass:numSlots: */;
	assert(!(isOopForwarded(pt, self)));
	longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self))))), rcvr);
	assert(!(isOopForwarded(pt, self)));
	longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self))))), arg);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMaxIdentityHash */
static void
primitiveMaxIdentityHash(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin pop:thenPushInteger: */
	integerVal = identityHashHalfWordMask(self);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

	/* InterpreterPrimitives>>#primitiveMethod */
usqInt
primitiveMethod(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

	/* InterpreterPrimitives>>#primitiveMillisecondClock */
static void
primitiveMillisecondClock(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = (((usqInt)((ioMSecs(self)) & MillisecondClockMask) << 3) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

	/* InterpreterPrimitives>>#primitiveMillisecondClockMask */
EXPORT(sqInt)
primitiveMillisecondClockMask(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)MillisecondClockMask << 3) | 1));
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveMod */
static void
primitiveMod(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)), self);
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt) mod) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)mod << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveModLargeIntegers */
EXPORT(void)
primitiveModLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	bIsNegative = isNegativeIntegerValueOf(oopArg, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}

	/* Handle remainder of same sign as argument */
	result = a % b;
	if (!(result == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the
	<red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveMouseButtons */
static void
primitiveMouseButtons(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt buttonWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	buttonWord = ioGetButtonState(self);
	/* begin pushInteger: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)buttonWord << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse
	coordinates may be negative if the mouse moves above or to the left of the
	top-left corner of the Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveMousePoint */
static void
primitiveMousePoint(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt oop;
    usqInt pointResult;
    sqInt pointWord;
    char *sp;
    sqInt x;
    sqInt y;

	pointWord = ioMousePoint(self);
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 0xFFFF) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 0xFFFF;
		goto l1;
	}
	else {
		x = ((((usqInt) pointWord) >> 16) & 0xFFFF) - 65536;
		goto l1;
	}
	l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 0xFFFF) & 32768) == 0) {
		y = pointWord & 0xFFFF;
		goto l2;
	}
	else {
		y = (pointWord & 0xFFFF) - 65536;
		goto l2;
	}
	l2:	/* end signExtend16: */;
	/* begin pop:thenPush: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj, self)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l3;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
	l3:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self))))), (((usqInt)x << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self))))), (((usqInt)y << 3) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMultiply */
static void
primitiveMultiply(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt overflow;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integerRcvr = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
	l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		integerArg = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		overflow = (integerRcvr > 0
			? (integerArg > 0
					? integerRcvr > ((MaxSmallInteger) / integerArg)
					: integerArg < ((MinSmallInteger) / integerRcvr))
			: (integerArg > 0
					? integerRcvr < ((MinSmallInteger) / integerArg)
					: (integerRcvr < 0)
						 && (integerArg < ((MaxSmallInteger) / integerRcvr))));
		if (overflow) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		else {
			integerResult = integerRcvr * integerArg;
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveMultiplyLargeIntegers */
EXPORT(void)
primitiveMultiplyLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	bIsNegative = isNegativeIntegerValueOf(oopArg, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (GIV(primFailCode)) {
		return;
	}
	if ((a > 1)
	 && ((b > 1)
	 && (a > (0xFFFFFFFFFFFFFFFFULL / b)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNew */
static void
primitiveNew(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    sqInt reasonCode;
    char *sp;

	
	/* Allocate a new fixed-size instance.  Fail if the allocation would leave
	   less than lowSpaceThreshold bytes free. This *will not* cause a GC :-) */
	obj = instantiateClass(longAt(GIV(stackPointer)), self);
	if (obj == null) {
		/* begin primitiveFailFor: */
		reasonCode = (isFixedSizePointerFormat(instSpecOfClass(longAt(GIV(stackPointer)), self), self)
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNewMethod */
static void
primitiveNewMethod(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt hash;
    sqInt header;
    sqInt i;
    sqInt instSpec;
    sqInt literalCount;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt p;
    sqInt reasonCode;
    sqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	bytecodeCount = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((header) & 7) == 1))
		 && (((((bytecodeCount) & 7) == 1))
		 && (((bytecodeCount = (bytecodeCount >> 3))) >= 0)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	assert((((header) & 7) == 1));
	literalCount = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	size = ((literalCount + LiteralStart) * BytesPerOop) + bytecodeCount;
	/* begin instantiateCompiledMethodClass:indexableSize: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	if (instSpec != (firstCompiledMethodFormat(self))) {
		theMethod = null;
		goto l8;
	}
	numSlots = (size + 7) / 8;
	instSpec += (8 - size) & 7;
	assert(addressCouldBeClassObj(class, self));
	classIndex = (((hash = (long32At(class + 4)) & (identityHashHalfWordMask(self)))) != 0
		? hash
		: (objCouldBeClassObj(class, self)
				? (((err = enterIntoClassTable(class, self))) != 0
						? -err
						: (/* begin rawHashBitsOf: */
							(long32At(class + 4)) & (identityHashHalfWordMask(self))))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -classIndex;
		theMethod = null;
		goto l8;
	}
	if (numSlots > ((1U << (fixedFieldsFieldWidth(self))) - 1)) {
		if (numSlots > (0x10000000000LL)) {
			theMethod = null;
			goto l8;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
			? 8 /* allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord(self))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), instSpec, classIndex, self);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask(self))) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				newObj = null;
				goto l4;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? /* begin allocationUnit */ 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck(self);
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex, self);
			goto l4;
		}
		if (numSlots >= (numSlotsMask(self))) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(self), instSpec, classIndex, self));
		}
		else {
			longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(instSpec) << (formatShift(self)))))) + classIndex);
		}
		assert((numBytes % (allocationUnit(self))) == 0);
		assert((newObj1 % (allocationUnit(self))) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l4:	/* end allocateSlots:format:classIndex: */;
	}
	if (newObj) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj, self), self));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
			longAtput(p, 0);
		}
	}
	theMethod = newObj;
	l8:	/* end instantiateCompiledMethodClass:indexableSize: */;
	if (!(theMethod)) {
		/* begin primitiveFailFor: */
		reasonCode = (isCompiledMethodFormat(instSpecOfClassFormat(((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3), self), self)
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
		return;
	}
	assert(!(isOopForwarded(theMethod, self)));
	longAtput((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))), header);
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theMethod, self)));
		if ((assert(isNonImmediate(theMethod, self)),
		oopisGreaterThanOrEqualTo(theMethod, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((GIV(nilObj) & (tagMask(self))) == 0)
			 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theMethod))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(theMethod, self);
				}
			}
		}
		longAtput((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), GIV(nilObj));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveNewWithArg */
static void
primitiveNewWithArg(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classFormat;
    sqInt fmt;
    sqInt instSpec;
    sqInt obj;
    sqInt ok;
    sqInt oop1;
    sqInt reasonCode;
    usqIntptr_t size;
    char *sp;
    sqInt value;

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((((oop1) & 7) == 1)) {
		value = (oop1 >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l9;
		}
		size = value;
		goto l9;
	}
	if (oop1 & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l9;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop1, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop1)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l6;
	l6:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l9;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop1))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	bs = ((numSlotsOf(oop1, self)) << (shiftForWord(self))) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l9;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop1 + BaseHeaderSize) + (0U << 3))));
		goto l9;
	}
	else {

		/* ] */
		size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))));
		goto l9;
	}
	l9:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {

		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	obj = instantiateClassindexableSize(longAt(GIV(stackPointer) + (1 * BytesPerWord)), size, self);
	if (obj == null) {
		/* begin instSpecOfClass: */
		classFormat = ((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
		/* begin primitiveFailFor: */
		reasonCode = (((instSpec >= 2 /* arrayFormat */)
		 && ((instSpec <= (weakArrayFormat(self)))
		 || (instSpec >= (sixtyFourBitIndexableFormat(self)))))
		 && (!(instSpec >= (firstCompiledMethodFormat(self))))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNextInstance */
static void
primitiveNextInstance(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualObj;
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt numSlots;
    sqInt object;
    char *sp;
    sqInt subsequentObject;

	object = longAt(GIV(stackPointer));
	if (!(object & (tagMask(self)))) {
		/* begin instanceAfter: */
		actualObj = object;
		/* begin classIndexOf: */
		classIndex = (longAt(object)) & (classIndexMask(self));
		if (oopisGreaterThanOrEqualToandLessThan(object, ((eden(self)).start), GIV(freeStart), self)) {
			while (1) {
				/* begin objectAfter:limit: */
				followingWordAddress = addressAfter(actualObj, self);
				if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart), self)) {
					actualObj = GIV(freeStart);
					goto l2;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				actualObj = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
				if (!(oopisLessThan(actualObj, GIV(freeStart), self))) break;
				if (classIndex == ((longAt(actualObj)) & (classIndexMask(self)))) {
					subsequentObject = actualObj;
					goto l6;
				}
			}
			if (oopisGreaterThan(GIV(pastSpaceStart), ((pastSpace(self)).start), self)) {
				/* begin objectStartingAt: */
				address = ((pastSpace(self)).start);
				numSlots = byteAt(address + 7);
				actualObj = (numSlots == (numSlotsMask(self))
					? address + BaseHeaderSize
					: address);
			}
			else {
				actualObj = GIV(nilObj);
			}
		}
		if (oopisGreaterThanOrEqualToandLessThan(actualObj, ((pastSpace(self)).start), GIV(pastSpaceStart), self)) {
			while (1) {
				/* begin objectAfter:limit: */
				followingWordAddress1 = addressAfter(actualObj, self);
				if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart), self)) {
					actualObj = GIV(pastSpaceStart);
					goto l4;
				}
				flag("endianness");
				followingWord1 = longAt(followingWordAddress1);
				actualObj = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
					? followingWordAddress1 + BaseHeaderSize
					: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
				if (!(oopisLessThan(actualObj, GIV(pastSpaceStart), self))) break;
				if (classIndex == ((longAt(actualObj)) & (classIndexMask(self)))) {
					subsequentObject = actualObj;
					goto l6;
				}
			}
			actualObj = GIV(nilObj);
		}
		while (1) {
			/* begin objectAfter:limit: */
			followingWordAddress2 = addressAfter(actualObj, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
				actualObj = GIV(endOfMemory);
				goto l5;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			actualObj = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
			if (!(oopisLessThan(actualObj, GIV(endOfMemory), self))) break;
			if (classIndex == ((longAt(actualObj)) & (classIndexMask(self)))) {
				subsequentObject = actualObj;
				goto l6;
			}
		}
		subsequentObject = null;
	l6:	/* end instanceAfter: */;
		if (subsequentObject) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), subsequentObject);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

	/* InterpreterPrimitives>>#primitiveNextObject */
static void
primitiveNextObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    char *sp;
    char *sp1;

	instance = accessibleObjectAfter(longAt(GIV(stackPointer)), self);
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)0 << 3) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		assert(isInMemory(instance, self));
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

	/* InterpreterPrimitives>>#primitiveNoop */
static void
primitiveNoop(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* InterpreterPrimitives>>#primitiveNotEqual */
static void
primitiveNotEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & (smallIntegerTag(self))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver != integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (signedMachineIntegerValueOf(integerReceiver, self)) != (signedMachineIntegerValueOf(integerArgument, self));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveNotEqualLargeIntegers */
EXPORT(void)
primitiveNotEqualLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr != integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	is the receiver/first argument not the same object as the (last)
	argument?. pop argumentCount because this can be used as a mirror
	primitive. 
 */

	/* InterpreterPrimitives>>#primitiveNotIdentical */
static void
primitiveNotIdentical(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    sqInt referent;
    sqInt referent1;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if (((otherObject & (tagMask(self))) == 0)
	 && (((longAt(otherObject)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		assert(GIV(argumentCount) > 1);
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(thisObject, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((thisObject + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		otherObject = referent;
	}
	if (((thisObject & (tagMask(self))) == 0)
	 && (((longAt(thisObject)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(thisObject, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent1 = longAt((thisObject + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent1 & (tagMask(self))) == 0)
		 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		thisObject = referent1;
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject != otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

	/* InterpreterPrimitives>>#primitiveObjectAt */
static void
primitiveObjectAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l3;
	}
	l3:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index > 0)
		 && (index <= ((literalCountOfMethodHeader(methodHeaderOf(thisReceiver, self), self)) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), longAt((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self)))))));
	GIV(stackPointer) = sp;
}


/*	Store a literal into a CompiledMethod at the given index. Defined for
	CompiledMethods only.
 */

	/* InterpreterPrimitives>>#primitiveObjectAtPut */
static void
primitiveObjectAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt newValue;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & (smallIntegerTag(self))) == 0)
	 || ((index == ConstOne)
	 && ((newValue & (smallIntegerTag(self))) == 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 3);
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(thisReceiver))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (!((index > 0)
		 && (index <= ((literalCountOfMethodHeader(methodHeaderOf(thisReceiver, self), self)) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(thisReceiver, self)));
	if ((assert(isNonImmediate(thisReceiver, self)),
	oopisGreaterThanOrEqualTo(thisReceiver, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((newValue & (tagMask(self))) == 0)
		 && (oopisLessThan(newValue, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(thisReceiver))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(thisReceiver, self);
			}
		}
	}
	longAtput((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self))))), newValue);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	primitivePathTo: anObject using: stack <Array> followWeak: boolean
	Answer a path to anObject from the root that does not pass through
	the current context */

	/* InterpreterPrimitives>>#primitivePathToUsing */
EXPORT(sqInt)
primitivePathToUsing(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt current;
    sqInt err;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt followWeak;
    usqInt freeStartAtStart;
    sqInt goal;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt index;
    sqInt next;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt path;
    char *sp;
    sqInt stack;
    sqInt stackp;
    sqInt stackSize;

	err = 0;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (!(GIV(argumentCount) >= 2)) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (!(((longAt(GIV(stackPointer))) == GIV(trueObj))
		 || ((longAt(GIV(stackPointer))) == GIV(falseObj)))) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	/* begin pathTo:using:followWeak: */
	goal = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	stack = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	followWeak = (longAt(GIV(stackPointer))) == GIV(trueObj);
	if (!(((stack & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(stack))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))) {
		err = PrimErrBadArgument;
		goto l16;
	}
	assert(allObjectsUnmarked(self));

	/* check no allocations during search */
	freeStartAtStart = freeStart(self);
	beRootIfOld(stack, self);
	/* begin lengthOf:format: */
	fmt1 = (((usqInt) (longAt(stack))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(stack + 7);
	numSlots2 = (numSlots11 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(stack - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt1 <= 5 /* ephemeronFormat */) {
		stackSize = numSlots2;
		goto l13;
	}
	if (fmt1 >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		stackSize = (numSlots2 << (shiftForWord(self))) - (fmt1 & 7);
		goto l13;
	}
	if (fmt1 >= (firstShortFormat(self))) {
		stackSize = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
		goto l13;
	}
	if (fmt1 >= (firstLongFormat(self))) {
		stackSize = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
		goto l13;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
		stackSize = numSlots2;
		goto l13;
	}
	stackSize = 0;
	l13:	/* end lengthOf:format: */;
	/* begin mark: */
	assert(!(isFreeObject(stack, self)));
	longAtput(stack, (longAt(stack)) | (1ULL << (markedBitFullShift(self))));
	/* begin specialObjectsOop */
	current = GIV(specialObjectsOop);
	/* begin mark: */
	assert(!(isFreeObject(current, self)));
	longAtput(current, (longAt(current)) | (1ULL << (markedBitFullShift(self))));
	/* begin lengthOf:format: */
	fmt2 = (((usqInt) (longAt(current))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots12 = byteAt(current + 7);
	numSlots3 = (numSlots12 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(current - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots12);
	if (fmt2 <= 5 /* ephemeronFormat */) {
		index = numSlots3;
		goto l15;
	}
	if (fmt2 >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		index = (numSlots3 << (shiftForWord(self))) - (fmt2 & 7);
		goto l15;
	}
	if (fmt2 >= (firstShortFormat(self))) {
		index = (numSlots3 << ((shiftForWord(self)) - 1)) - (fmt2 & 3);
		goto l15;
	}
	if (fmt2 >= (firstLongFormat(self))) {
		index = (numSlots3 << ((shiftForWord(self)) - 2)) - (fmt2 & 1);
		goto l15;
	}
	if (fmt2 == (sixtyFourBitIndexableFormat(self))) {
		index = numSlots3;
		goto l15;
	}
	index = 0;
	l15:	/* end lengthOf:format: */;
	stackp = 0;
	while(1) {
		while (((index -= 1)) >= -1) {
			if ((((((usqInt)current)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)current)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)current)) <= (((usqInt)GIV(pages))))))) {
				if (index >= 0) {
					next = fieldofFrame(index, ((char *) current), self);
				}
				else {
					/* begin nilObject */
					next = GIV(nilObj);
				}
			}
			else {
				if (index >= 0) {
					if (((longAt(current)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
						next = fieldOrSenderFPofContext(index, current, self);
					}
					else {
						/* begin fetchPointer:ofObject: */
						next = longAt((current + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
					}
				}
				else {
					next = fetchClassOfNonImm(current, self);
				}
			}
			if ((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))) {
				assert(isFrameonPage(((char *) next), stackPageFor(((char *) next), self), self));
			}
			else {
				assert(checkOkayOop(next, self));
			}
			if (next == goal) {
				assert(freeStartAtStart == (freeStart(self)));
				unmarkAfterPathTo(self);
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(stack, self)));
				if ((assert(isNonImmediate(stack, self)),
				oopisGreaterThanOrEqualTo(stack, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((current & (tagMask(self))) == 0)
					 && (oopisLessThan(current, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(stack))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(stack, self);
						}
					}
				}
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(stackp) << (shiftForWord(self))))), current);
				pruneStackstackp(stack, stackp, self);
				err = 0;
				goto l16;
			}
			if (((next & (smallIntegerTag(self))) == 0)
			 && (((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))
				? !(((longAt(next + FoxFrameFlags)) & 2) != 0)
				: (!(((((usqInt) (longAt(next))) >> (markedBitFullShift(self))) & 1) != 0))
					 && (((((next & (tagMask(self))) == 0)
					 && (((((usqInt) (longAt(next))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
					 || (((((usqInt) (longAt(next))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))
					 && (followWeak
					 || (!(isWeakFormat((((usqInt) (longAt(next))) >> (formatShift(self))) & (formatMask(self)), self)))))))) {
				if ((stackp + 2) > stackSize) {
					assert(freeStartAtStart == (freeStart(self)));
					unmarkAfterPathTo(self);
					/* begin nilFieldsOf: */
					for (i = 0, iLimiT = ((numSlotsOf(stack, self)) - 1); i <= iLimiT; i += 1) {
						assert(!(isOopForwarded(stack, self)));
						longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), GIV(nilObj));
					}
					err = PrimErrBadIndex;
					goto l16;
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(stack, self)));
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(stackp) << (shiftForWord(self))))), current);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(stack, self)));
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp + 1)) << (shiftForWord(self))))), (((usqInt)index << 3) | 1));
				stackp += 2;
				if ((((((usqInt)(((char *) next)))) & (BytesPerWord - 1)) == 0)
				 && ((((((usqInt)(((char *) next)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) next)))) <= (((usqInt)GIV(pages))))))) {
					/* begin markFrame: */
					longAtput(next + FoxFrameFlags, (longAt(next + FoxFrameFlags)) | 2);
					/* begin fieldsInFrame: */
					index = CtxtTempFrameStart + (stackPointerIndexForFrame(((char *) next), self));
				}
				else {
					/* begin mark: */
					assert(!(isFreeObject(next, self)));
					longAtput(next, (longAt(next)) | (1ULL << (markedBitFullShift(self))));
					if (((((usqInt) (longAt(next))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
						index = ((assert((((((assert(isCompiledMethod(next, self)),
/* begin fetchPointer:ofObject: */
longAt((next + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(next, self)),
/* begin fetchPointer:ofObject: */
longAt((next + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart;
					}
					else {
						/* begin lengthOf:format: */
						fmt = (((usqInt) (longAt(next))) >> (formatShift(self))) & (formatMask(self));
						/* begin numSlotsOfAny: */
						numSlots1 = byteAt(next + 7);
						numSlots = (numSlots1 == (numSlotsMask(self))
							? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(next - BaseHeaderSize))) << 8)))))) >> 8
							: numSlots1);
						if (fmt <= 5 /* ephemeronFormat */) {
							index = numSlots;
							goto l11;
						}
						if (fmt >= (firstByteFormat(self))) {

							/* bytes, including CompiledMethod */
							index = (numSlots << (shiftForWord(self))) - (fmt & 7);
							goto l11;
						}
						if (fmt >= (firstShortFormat(self))) {
							index = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
							goto l11;
						}
						if (fmt >= (firstLongFormat(self))) {
							index = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
							goto l11;
						}
						if (fmt == (sixtyFourBitIndexableFormat(self))) {
							index = numSlots;
							goto l11;
						}
						index = 0;
	l11:	/* end lengthOf:format: */;
					}
				}
				current = next;
			}
		}
		if (current == GIV(specialObjectsOop)) {
			assert(freeStartAtStart == (freeStart(self)));
			unmarkAfterPathTo(self);
			/* begin nilFieldsOf: */
			for (i1 = 0, iLimiT1 = ((numSlotsOf(stack, self)) - 1); i1 <= iLimiT1; i1 += 1) {
				assert(!(isOopForwarded(stack, self)));
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), GIV(nilObj));
			}
			err = PrimErrNotFound;
			goto l16;
		}
		index = ((longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp - 1)) << (shiftForWord(self))))))) >> 3);
		/* begin fetchPointer:ofObject: */
		current = longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp - 2)) << (shiftForWord(self))))));
		stackp -= 2;
	}
	l16:	/* end pathTo:using:followWeak: */;
	if (err != 0) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = err);
	}
	path = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), path);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitivePerformInSuperclass */
static void
primitivePerformInSuperclass(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt currentClass;
    sqInt delta;
    sqInt err;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt lookupClass;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt nItems;
    sqInt numArgs;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt objOop;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    sqInt rcvr1;
    char *savedFramePointer;
    char *savedStackPointer;
    sqInt selector;
    sqInt selector1;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt top;

	nArgs = 0;
	savedFramePointer = ((char *) 0);
	savedStackPointer = ((char *) 0);
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	lookupClass = longAt(GIV(stackPointer));
	if ((GIV(argumentCount) > 3)
	 && (((rcvr & (tagMask(self))) == 0)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((tagBits = rcvr & (tagMask(self)))) != 0) {
		/* begin fetchPointer:ofObject: */
		currentClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))));
	}
	else {
		currentClass = fetchClassOfNonImm(rcvr, self);
	}
	while (currentClass != lookupClass) {
		/* begin followField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop & (tagMask(self))) == 0)
		 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop, self);
		}
		currentClass = objOop;
		if (currentClass == GIV(nilObj)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	selector = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((argumentArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l19;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l19;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */
	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	selector1 = GIV(messageSelector);
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector1, self), lengthOfMaybeImmediate(selector1, self), rcvr, self);
	findNewMethodInClassTag((lookupClass == null
		? (((tagBits1 = rcvr & (tagMask(self)))) != 0
				? tagBits1
				: (longAt(rcvr)) & (classIndexMask(self)))
		: (assert(addressCouldBeClassObj(lookupClass, self)),
			(((hash = (long32At(lookupClass + 4)) & (identityHashHalfWordMask(self)))) != 0
					? hash
					: (objCouldBeClassObj(lookupClass, self)
							? (((err = enterIntoClassTable(lookupClass, self))) != 0
									? -err
									: (/* begin rawHashBitsOf: */
										(long32At(lookupClass + 4)) & (identityHashHalfWordMask(self))))
							: -PrimErrBadReceiver)))), self);
	if ((((GIV(newMethod) & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))
	 && ((argumentCountOf(GIV(newMethod), self)) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop(self)) == ((arraySize == 0
			? rcvr
			: fetchPointerofObject(arraySize - 1, argumentArray, self))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(argumentCount) = performArgCount;
		GIV(primitiveFunctionPointer) = (lookupClass == null
			? primitivePerformWithArgs
			: primitivePerformInSuperclass);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l19;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (GIV(primitiveFunctionPointer) != 0) {
		if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse(self);
			goto l14;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
		assert((remapBufferCount(self)) == 0);
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
		/* begin maybeRetryPrimitiveOnFailure */
		if (GIV(primFailCode)) {
			retryPrimitiveOnFailure(self);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller(self)) {
			if (((freeStart(self)) < GIV(scavengeThreshold))
			 && ((longAt(freeStart(self))) != (freeStart(self)))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if ((!GIV(primFailCode))
		 && ((GIV(framePointer) == savedFramePointer)
		 && (!0))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */
			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				failUnbalancedPrimitive(self);
				GIV(stackPointer) = savedStackPointer;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod), self);
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l14;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr1, self)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader1 & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader1, self);
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader, self), self);
	}
	l14:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	l19:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePerformWithArgs */
static void
primitivePerformWithArgs(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualReceiver;
    sqInt argumentArray;
    usqInt arraySize;
    sqInt delta;
    sqInt i;
    sqInt index;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt nItems;
    sqInt numArgs;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    sqInt selector;
    sqInt selector1;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt tagBits1;
    sqInt top;

	nArgs = 0;
	savedFramePointer = ((char *) 0);
	savedStackPointer = ((char *) 0);
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	actualReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	selector = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l15;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l15;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */
	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), actualReceiver);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self)))))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	selector1 = GIV(messageSelector);
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector1, self), lengthOfMaybeImmediate(selector1, self), actualReceiver, self);
	findNewMethodInClassTag((((tagBits1 = actualReceiver & (tagMask(self)))) != 0
		? tagBits1
		: (longAt(actualReceiver)) & (classIndexMask(self))), self);
	if ((((GIV(newMethod) & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))
	 && ((argumentCountOf(GIV(newMethod), self)) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop(self)) == ((arraySize == 0
			? actualReceiver
			: fetchPointerofObject(arraySize - 1, argumentArray, self))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(argumentCount) = performArgCount;
		GIV(primitiveFunctionPointer) = primitivePerformWithArgs;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l15;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (GIV(primitiveFunctionPointer) != 0) {
		if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse(self);
			goto l14;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
		assert((remapBufferCount(self)) == 0);
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
		/* begin maybeRetryPrimitiveOnFailure */
		if (GIV(primFailCode)) {
			retryPrimitiveOnFailure(self);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller(self)) {
			if (((freeStart(self)) < GIV(scavengeThreshold))
			 && ((longAt(freeStart(self))) != (freeStart(self)))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if ((!GIV(primFailCode))
		 && ((GIV(framePointer) == savedFramePointer)
		 && (!0))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */
			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				failUnbalancedPrimitive(self);
				GIV(stackPointer) = savedStackPointer;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod), self);
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l14;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr, self)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader1 & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader1, self);
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader, self), self);
	}
	l14:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	l15:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

	/* InterpreterPrimitives>>#primitiveProfilePrimitive */
EXPORT(sqInt)
primitiveProfilePrimitive(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
	return 0;
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

	/* InterpreterPrimitives>>#primitiveProfileSample */
EXPORT(sqInt)
primitiveProfileSample(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
	return 0;
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

	/* InterpreterPrimitives>>#primitiveProfileSemaphore */
EXPORT(sqInt)
primitiveProfileSemaphore(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((sema == GIV(nilObj))
		 || (((sema & (tagMask(self))) == 0)
		 && (((longAt(sema)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self)))))) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	GIV(profileSemaphore) = sema;
	GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

	/* InterpreterPrimitives>>#primitiveProfileStart */
EXPORT(sqInt)
primitiveProfileStart(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;
    sqInt integerPointer;

	if (!(GIV(argumentCount) == 1)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		deltaTicks = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		deltaTicks = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(nextProfileTick) = (ioHighResClock(self)) + deltaTicks;
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveQuit */
static void
primitiveQuit(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
		? ((longAt(GIV(stackPointer))) >> 3)
		: 0));
}


/*	Rounds negative results towards zero. */

	/* InterpreterPrimitives>>#primitiveQuo */
static void
primitiveQuo(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	integerResult = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integerRcvr = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
	l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		integerArg = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		integerResult = (integerRcvr > 0
			? (integerArg > 0
					? integerRcvr / integerArg
					: 0 - (integerRcvr / (0 - integerArg)))
			: (integerArg > 0
					? 0 - ((0 - integerRcvr) / integerArg)
					: (0 - integerRcvr) / (0 - integerArg)));
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveQuoLargeIntegers */
EXPORT(void)
primitiveQuoLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	bIsNegative = isNegativeIntegerValueOf(oopArg, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

	/* InterpreterPrimitives>>#primitiveRelinquishProcessor */
static void
primitiveRelinquishProcessor(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		microSecs = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* DO NOT allow relinquishing the processor while we are profiling since this
		   may skew the time base for our measures (it may reduce processor speed etc).
		   Instead we go full speed, therefore measuring the precise time we spend in the
		   inner idle loop as a busy loop. */
		if (GIV(nextProfileTick) == 0) {
			ioRelinquishProcessorForMicroseconds(microSecs, self);
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveRemLargeIntegers */
EXPORT(void)
primitiveRemLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

	/* InterpreterPrimitives>>#primitiveResume */
static void
primitiveResume(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt proc;


	/* rcvr */
	proc = longAt(GIV(stackPointer));
	if (!(isContext(longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self)))))), self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	resumepreemptedYieldingIf(proc, GIV(preemptionYields), self);
}


/*	The character scanner primitive. */

	/* InterpreterPrimitives>>#primitiveScanCharacters */
static void
primitiveScanCharacters(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		kernDelta = (integerPointer >> 3);
		goto l9;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
		goto l9;
	}
	l9:	/* end stackIntegerValue: */;
	stops = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		scanRightX = (integerPointer1 >> 3);
		goto l10;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
		goto l10;
	}
	l10:	/* end stackIntegerValue: */;
	sourceString = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer2) & 7) == 1)) {
		scanStopIndex = (integerPointer2 >> 3);
		goto l11;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
		goto l11;
	}
	l11:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer3) & 7) == 1)) {
		scanStartIndex = (integerPointer3 >> 3);
		goto l12;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
		goto l12;
	}
	l12:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if (GIV(primFailCode)) {
		return;
	}
	if (!((((stops & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(stops))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && (((slotSizeOf(stops, self)) >= 258)
		 && ((((sourceString & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(sourceString))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))
		 && ((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && ((scanStopIndex <= (byteSizeOf(sourceString, self)))
		 && ((((rcvr & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && ((slotSizeOf(rcvr, self)) >= 4))))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr, self);
	scanLastIndex = fetchIntegerofObject(1, rcvr, self);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord(self))));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord(self))));
	if (!((((scanXTable & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(scanXTable))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && ((((scanMap & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(scanMap))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && (((slotSizeOf(scanMap, self)) == 256)
		 && (!GIV(primFailCode)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Okay, here we go. We have eliminated nearly all failure
	   conditions, to optimize the inner fetches. */
	maxGlyph = (slotSizeOf(scanXTable, self)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */

		/* Known to be okay since stops size >= 258 */
		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + (((sqInt)((usqInt)(ascii) << (shiftForWord(self)))))))) == nilOop)) {

			/* Store everything back and get out of here since some stop conditionn needs to be checked */
			if (!((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr, self)));
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord(self))), (((usqInt)scanDestX << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanLastIndex) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr, self)));
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord(self))), (((usqInt)scanLastIndex << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), stopReason);
			GIV(stackPointer) = sp;
			return;
		}

		/* fail if the glyphIndex is out of range */
		glyphIndex = fetchIntegerofObject(ascii, scanMap, self);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable, self);

		/* Above may fail if non-integer entries in scanXTable */
		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable, self);
		if (GIV(primFailCode)) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {

			/* Store everything back and get out of here since we got to the right edge */
			if (!((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr, self)));
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord(self))), (((usqInt)scanDestX << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanLastIndex) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr, self)));
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord(self))), (((usqInt)scanLastIndex << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((sqInt)((usqInt)((CrossedX - 1)) << (shiftForWord(self)))))));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(rcvr, self)));
		longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord(self))), (((usqInt)scanDestX << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt) scanStopIndex) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(rcvr, self)));
		longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord(self))), (((usqInt)scanStopIndex << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((sqInt)((usqInt)((EndOfRun - 1)) << (shiftForWord(self)))))));
	GIV(stackPointer) = sp2;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

	/* InterpreterPrimitives>>#primitiveScreenDepth */
EXPORT(sqInt)
primitiveScreenDepth(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth(self);
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)depth << 3) | 1));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer a float indicating the current scale factor for pixels of the
	Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveScreenScaleFactor */
EXPORT(sqInt)
primitiveScreenScaleFactor(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double factor;
    sqInt object;
    char *sp;

	factor = ioScreenScaleFactor(self);
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin pushFloat: */
	object = floatObjectOf(factor, self);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the
	point is encoded into a single 32bit value in the image header.
	This might well become a problem one day */

	/* InterpreterPrimitives>>#primitiveScreenSize */
static void
primitiveScreenSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt oop;
    usqInt pointResult;
    sqInt pointWord;
    char *sp;

	pointWord = ioScreenSize(self);
	/* begin pop:thenPush: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj, self)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l3;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
	l3:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self))))), (((usqInt)((((usqInt) pointWord) >> 16) & 0xFFFF) << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self))))), (((usqInt)(pointWord & 0xFFFF) << 3) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

	/* InterpreterPrimitives>>#primitiveSecondsClock */
static void
primitiveSecondsClock(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	integerValue = ((unsigned int) (ioSecondsNow(self)));
	oop = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
	goto l1;
	l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

	/* InterpreterPrimitives>>#primitiveSetDisplayMode */
static void
primitiveSetDisplayMode(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    char *sp;
    sqInt w;

	okay = 0;
	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	fsFlag = null;
	l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		h = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		w = (integerPointer1 >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
	l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer2) & 7) == 1)) {
		d = (integerPointer2 >> 3);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		d = 0;
		goto l4;
	}
	l4:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((5 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

	/* InterpreterPrimitives>>#primitiveSetFullScreen */
static void
primitiveSetFullScreen(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveSetImmutability */
#if IMMUTABILITY
static void
primitiveSetImmutability(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt wasImmutable;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	wasImmutable = 
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		if (!(canBeImmutable(rcvr, self))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			return;
		}
		/* begin setIsImmutableOf:to: */
		longAtput(rcvr, (longAt(rcvr)) | (1U << (immutableBitShift(self))));
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			/* begin setIsImmutableOf:to: */
			longAtput(rcvr, (longAt(rcvr)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
		}
		else {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (wasImmutable
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

	/* InterpreterPrimitives>>#primitiveSetInterruptKey */
static void
primitiveSetInterruptKey(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		keycode = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the VM's log directory */

	/* InterpreterPrimitives>>#primitiveSetLogDirectory */
EXPORT(sqInt)
primitiveSetLogDirectory(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(((stringOop & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(stringOop))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin byteSizeOf: */
	if (stringOop & (tagMask(self))) {
		sz = 0;
		goto l3;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(stringOop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOf: */
	assert((classIndexOf(stringOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(stringOop + 7);
	numBytes = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(stringOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord(self));
	if (fmt >= (firstByteFormat(self))) {

		/* bytes (the common case), including CompiledMethod */
		sz = numBytes - (fmt & 7);
		goto l3;
	}
	if (fmt <= (sixtyFourBitIndexableFormat(self))) {
		sz = numBytes;
		goto l3;
	}
	if (fmt >= (firstShortFormat(self))) {
		sz = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
		goto l3;
	}
	sz = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l3:	/* end byteSizeOf: */;
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop, self), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveSetOrHasIdentityHash */
static void
primitiveSetOrHasIdentityHash(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasHash;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt integerPointer;
    sqInt isReceiverAClass;
    sqInt oldHash;
    sqInt oop;
    char *sp;
    char *sp1;
    sqInt thisReceiver;

	if (GIV(argumentCount) == 0) {
		hasHash = (((longAt(GIV(stackPointer))) & (tagMask(self))) == 0)
		 && ((long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask(self)));
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (hasHash
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 2) {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			isReceiverAClass = 1;
			goto l2;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			isReceiverAClass = 0;
			goto l2;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		isReceiverAClass = null;
	l2:	/* end booleanValueOf: */;
		if (GIV(primFailCode)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
	}
	else {
		isReceiverAClass = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		hash = (integerPointer >> 3);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		hash = 0;
		goto l4;
	}
	l4:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		thisReceiver = null;
		goto l3;
	}
	thisReceiver = oop;
	l3:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin hashBitsOf: */
		hash2 = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask(self));
		if (hash2 == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */
			/* begin newHashBitsOf: */
			hash1 = (newObjectHash(self)) & (identityHashHalfWordMask(self));
			/* begin setHashBitsOf:to: */
			assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask(self)))));
			long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash1);
			hash2 = hash1;
		}
		oldHash = hash2;
		/* begin setHashBitsOf:to: */
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask(self)))));
		long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash);
		if (isReceiverAClass
		 && (1)) {
			classAtIndexput(hash, thisReceiver, self);
			allInstancesOf(thisReceiver, self);
		}
		/* begin pop:thenPushInteger: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)oldHash << 3) | 1));
		GIV(stackPointer) = sp1;
	}
}


/*	Primitive. Set the OS window's label */

	/* InterpreterPrimitives>>#primitiveSetWindowLabel */
EXPORT(sqInt)
primitiveSetWindowLabel(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt labelOop;
    usqInt numBytes;
    usqInt numSlots;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(((labelOop & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(labelOop))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin byteSizeOf: */
	if (labelOop & (tagMask(self))) {
		sz = 0;
		goto l3;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(labelOop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOf: */
	assert((classIndexOf(labelOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(labelOop + 7);
	numBytes = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(labelOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord(self));
	if (fmt >= (firstByteFormat(self))) {

		/* bytes (the common case), including CompiledMethod */
		sz = numBytes - (fmt & 7);
		goto l3;
	}
	if (fmt <= (sixtyFourBitIndexableFormat(self))) {
		sz = numBytes;
		goto l3;
	}
	if (fmt >= (firstShortFormat(self))) {
		sz = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
		goto l3;
	}
	sz = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l3:	/* end byteSizeOf: */;
	ioSetWindowLabelOfSize(firstIndexableField(labelOop, self), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveSetWindowSize */
EXPORT(sqInt)
primitiveSetWindowSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt w;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		h = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		w = (integerPointer1 >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
	l3:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioSetWindowWidthHeight(w, h);
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as
	an array of signed 16-bit values. Answer the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word.  */

	/* InterpreterPrimitives>>#primitiveShortAt */
static void
primitiveShortAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & (tagMask(self))) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self)), self)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	index = (index >> 3);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr, self))) >> 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	value = shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))));
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

	/* InterpreterPrimitives>>#primitiveShortAtPut */
static void
primitiveShortAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((value) & 7) == 1))
		 && (((((index) & 7) == 1))
		 && (((value = (value >> 3)),
		(value >= -32768)
			 && (value <= 0x7FFF)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & (tagMask(self))) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self)), self)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	index = (index >> 3);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr, self))) >> 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))), value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

	/* InterpreterPrimitives>>#primitiveShowDisplayRect */
static void
primitiveShowDisplayRect(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		bottom = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		top = (integerPointer1 >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		top = 0;
		goto l3;
	}
	l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer2) & 7) == 1)) {
		right = (integerPointer2 >> 3);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		right = 0;
		goto l4;
	}
	l4:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer3) & 7) == 1)) {
		left = (integerPointer3 >> 3);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		left = 0;
		goto l5;
	}
	l5:	/* end stackIntegerValue: */;
	updateDisplayLeftTopRightBottom(left, top, right, bottom, self);
	if (!GIV(primFailCode)) {
		ioForceDisplayUpdate(self);
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveSignal */
static void
primitiveSignal(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	synchronousSignal(longAt(GIV(stackPointer)), self);
}


/*	Set the low-water mark for free space. When the free space falls
	below this level, the new and new: primitives fail and system attempts
	to allocate space (e.g., to create a method context) cause the low-space
	semaphore (if one is registered) to be signalled. */

	/* InterpreterPrimitives>>#primitiveSignalAtBytesLeft */
static void
primitiveSignalAtBytesLeft(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;

	bytes = longAt(GIV(stackPointer));
	if (((((bytes) & 7) == 1))
	 && (((bytes = (bytes >> 3))) >= 0)) {
		/* begin lowSpaceThreshold: */

		/* N.B. The threshold > 0 guard eliminates a warning when
		   self lowSpaceThreshold: 0
		   is inlined into setSignalLowSpaceFlagAndSaveProcess */
		GIV(lowSpaceThreshold) = bytes;
		if ((bytes > 0)
		 && (GIV(totalFreeOldSpace) < bytes)) {
			growOldSpaceByAtLeast(bytes - GIV(totalFreeOldSpace), self);
		}
		assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveSine */
static void
primitiveSine(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double rcvr;

	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(sin(rcvr), self);
		longAtPointerput(GIV(stackPointer), aValue);
	}
}

	/* InterpreterPrimitives>>#primitiveSize */
static void
primitiveSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask(self)))
	 || (((hdr = long64At(rcvr)),
	((fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self)))) < 2))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		primitiveContextSize(self);
		return;
	}
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l3;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l3;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l3;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l3;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l3;
	}
	totalLength = 0;
	l3:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l4;
	}
	class = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l4:	/* end fixedFieldsOf:format:length: */;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(totalLength - fixedFields) << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSizeInBytes */
static void
primitiveSizeInBytes(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong byteSize;
    sqInt oop;
    char *sp;

	byteSize = ((longAt(GIV(stackPointer))) & (tagMask(self))
		? 0
		: bytesInObject(longAt(GIV(stackPointer)), self));
	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(byteSize, self);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer the byte size of an instance of the receiver. If num args > 0
	then the last argument is a variable size and the size answered is the
	size of an instance of the receiver with that many indexable elements. */

	/* InterpreterPrimitives>>#primitiveSizeInBytesOfInstance */
static void
primitiveSizeInBytesOfInstance(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt byteSize;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt code;
    sqInt err;
    sqInt instSpec;
    sqInt instSpec1;
    sqInt nElements;
    usqInt numSlots;
    sqInt numSlots1;
    sqInt oop;
    char *sp;
    char *sp1;

	if (GIV(argumentCount) > 1) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	err = -1;
	if (GIV(argumentCount) >= 1) {
		if (!(((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		/* begin byteSizeOfInstanceOf:withIndexableSlots:errInto: */
		nElements = ((longAt(GIV(stackPointer))) >> 3);
		classFormat = ((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
		
		switch (instSpec) {
		case 2 /* arrayFormat */:
			numSlots = nElements;
			break;
		case indexablePointersFormat(self):
		case weakArrayFormat(self):
			numSlots = (classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1)) + nElements;
			break;
		case sixtyFourBitIndexableFormat(self):
			numSlots = nElements;
			break;
		case firstLongFormat(self):
			numSlots = (nElements + 1) / 2;
			break;
		case firstShortFormat(self):
			numSlots = (nElements + 3) / 4;
			break;
		case firstByteFormat(self):
		case firstCompiledMethodFormat(self):
			numSlots = (nElements + (BytesPerOop - 1)) / BytesPerOop;
			break;
		default:
			byteSize = (err = PrimErrBadReceiver);
			goto l6;

		}
		if (numSlots >= ((((usqInt)1)) << ((BytesPerOop * 8) - 3 /* logBytesPerOop */))) {
			code = (nElements < 0
				? PrimErrBadArgument
				: PrimErrLimitExceeded);
			byteSize = (err = code);
			goto l6;
		}
		byteSize = (numSlots == 0
			? 8 /* allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord(self))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)));
	l6:	/* end byteSizeOfInstanceOf:withIndexableSlots:errInto: */;
		if (err >= 0) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = err;
			return;
		}
		/* begin pop:thenPush: */
		oop = positive64BitIntegerFor(byteSize, self);
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOfInstanceOf:errInto: */
	classFormat1 = ((longAt(((longAt(GIV(stackPointer) + (0 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	instSpec1 = (((usqInt) classFormat1) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	if (!((instSpec1 <= 1 /* nonIndexablePointerFormat */)
		 || (instSpec1 == 5 /* ephemeronFormat */))) {
		byteSize = (err = PrimErrBadReceiver);
		goto l7;
	}
	numSlots1 = classFormat1 & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	byteSize = (numSlots1 == 0
		? 8 /* allocationUnit */ + BaseHeaderSize
		: (((sqInt)((usqInt)(numSlots1) << (shiftForWord(self))))) + ((numSlots1 >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)));
	l7:	/* end byteSizeOfInstanceOf:errInto: */;
	if (err >= 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = err;
		return;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((byteSize << 3) | 1));
	GIV(stackPointer) = sp1;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatAdd */
static void
primitiveSmallFloatAdd(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg, self));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatArctan */
static void
primitiveSmallFloatArctan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin stackTopPut: */
	aValue = floatObjectOf(atan(rcvr), self);
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatDivide */
static void
primitiveSmallFloatDivide(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (arg == 0.0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg, self));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatEqual */
static void
primitiveSmallFloatEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr == arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Computes E raised to the receiver power.
	Since SmallFloats cannot represent NaNs there's no need to special case. */

	/* InterpreterPrimitives>>#primitiveSmallFloatExp */
static void
primitiveSmallFloatExp(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;

	/* begin stackTopPut: */
	aValue = floatObjectOf(exp(smallFloatValueOf(longAt(GIV(stackPointer)), self)), self);
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Answer the exponent part of this float. */

	/* InterpreterPrimitives>>#primitiveSmallFloatExponent */
static void
primitiveSmallFloatExponent(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqInt exp;

	/* begin stackTopPut: */
	aValue = (((((assert(((longAt(GIV(stackPointer))) & (tagMask(self))) == (smallFloatTag(self))),
((((usqInt)(longAt(GIV(stackPointer))))) <= 15
		? 0
		: ((exp = ((usqInt) (((usqInt)(longAt(GIV(stackPointer)))))) >> (((numTagBits(self)) + (smallFloatMantissaBits(self))) + 1)),
			(exp + (smallFloatExponentOffset(self))) - 0x3FE)))) - 1) << 3) | 1);
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatFractionalPart */
static void
primitiveSmallFloatFractionalPart(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double frac;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double trunc;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	frac = modf(rcvr, (&trunc));
	/* begin stackTopPut: */
	aValue = floatObjectOf(frac, self);
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatGreaterOrEqual */
static void
primitiveSmallFloatGreaterOrEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr >= arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatGreaterThan */
static void
primitiveSmallFloatGreaterThan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr > arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatLessOrEqual */
static void
primitiveSmallFloatLessOrEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr <= arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatLessThan */
static void
primitiveSmallFloatLessThan(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr < arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Natural log. */

	/* InterpreterPrimitives>>#primitiveSmallFloatLogN */
static void
primitiveSmallFloatLogN(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin stackTopPut: */
	aValue = floatObjectOf(log(rcvr), self);
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatMultiply */
static void
primitiveSmallFloatMultiply(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr * arg, self));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatNotEqual */
static void
primitiveSmallFloatNotEqual(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (!(rcvr == arg)
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSine */
static void
primitiveSmallFloatSine(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin stackTopPut: */
	aValue = floatObjectOf(sin(rcvr), self);
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSquareRoot */
static void
primitiveSmallFloatSquareRoot(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	if (rcvr >= 0.0) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(sqrt(rcvr), self);
		longAtPointerput(GIV(stackPointer), aValue);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSubtract */
static void
primitiveSmallFloatSubtract(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop, self));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits(self));
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot1 = (rot1 << 0x3F) + (((usqInt) (((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l6;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrIntOop) << shift)))) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l6;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l6;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr - arg, self));
		GIV(stackPointer) = sp;
	}
}


/*	Multiply the receiver by the power of the argument. */

	/* InterpreterPrimitives>>#primitiveSmallFloatTimesTwoPower */
static void
primitiveSmallFloatTimesTwoPower(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt rcvr;
    sqInt result;
    char *sp;
    int twiceMaxExponent;

	arg = longAt(GIV(stackPointer));
	if (!((((arg) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}

	/* N.B. SmallFloats are finite.  NaN and Infinity overflow into boxed floats.
	   This is doing range checking work that is done in ldexp, but we include
	   it explicitly to exemplify bit manipulation of SmallFloats. */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((assert(isImmediateFloat(rcvr, self)),
	(((usqInt)rcvr)) <= ((1U << (numTagBits(self))) + (smallFloatTag(self))))) {
		result = rcvr;
	}
	else {
		arg = (arg >> 3);
		twiceMaxExponent = 2 * (1U << 11 /* floatExponentBits */);
		if (arg < (-twiceMaxExponent)) {
			assert(isImmediateFloat(rcvr, self));
			result = rcvr & ((1U << (numTagBits(self))) + (tagMask(self)));
		}
		else {

			/* clip arg to at most int range; ldexp's last arg is of type int */
			if (arg > twiceMaxExponent) {
				arg = twiceMaxExponent;
			}
			result = floatObjectOf(ldexp(smallFloatValueOf(rcvr, self), ((int) arg)), self);
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatTruncated */
static void
primitiveSmallFloatTruncated(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double trunc;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	modf(rcvr, (&trunc));
	if ((((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) )))))
	 && ((((((usqInt) (((sqInt)trunc))) >> 60) + 1) & 15) <= 1)) {
		longAtPointerput(GIV(stackPointer), (((usqInt)(((sqInt)trunc)) << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	save a normal snapshot under the same name as it was loaded unless it has
	been renamed by the last primitiveImageName
 */

	/* InterpreterPrimitives>>#primitiveSnapshot */
static void
primitiveSnapshot(struct foo * self)
{
	snapshot(0, self);
}


/*	save an embedded snapshot */

	/* InterpreterPrimitives>>#primitiveSnapshotEmbedded */
static void
primitiveSnapshotEmbedded(struct foo * self)
{
	snapshot(1, self);
}

	/* InterpreterPrimitives>>#primitiveSomeInstance */
static void
primitiveSomeInstance(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt instance;
    char *sp;

	class = longAt(GIV(stackPointer));
	instance = initialInstanceOf(class, self);
	if (instance == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the first object in the heap. */

	/* InterpreterPrimitives>>#primitiveSomeObject */
static void
primitiveSomeObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	object = firstAccessibleObject(self);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

	/* InterpreterPrimitives>>#primitiveSpecialObjectsOop */
static void
primitiveSpecialObjectsOop(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(specialObjectsOop));
	GIV(stackPointer) = sp;
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveSquareRoot */
static void
primitiveSquareRoot(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double rcvr;

	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if ((!GIV(primFailCode))
	 && (rcvr >= 0.0)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(sqrt(rcvr), self);
		longAtPointerput(GIV(stackPointer), aValue);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

	/* InterpreterPrimitives>>#primitiveStoreImageSegment */
static void
primitiveStoreImageSegment(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* Essential type checks */
	arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((arrayOfRoots & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(arrayOfRoots))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && ((((outPointerArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(outPointerArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && (((segmentWordArray & (tagMask(self))) == 0)
		 && (((((((usqInt) (longAt(segmentWordArray))) >> (formatShift(self))) & (formatMask(self))) >= (firstLongFormat(self))) && (((((usqInt) (longAt(segmentWordArray))) >> (formatShift(self))) & (formatMask(self))) <= ((firstShortFormat(self)) - 1)))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots, self);
	if (ecode == PrimErrNeedCompaction) {
		fullGC(self);
		outPointerArray = longAt(GIV(stackPointer));
		segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
		ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots, self);
	}
	if (ecode == PrimNoErr) {

		/* ...leaving the receiver on the stack as return value */
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ecode;
	}
}

	/* InterpreterPrimitives>>#primitiveStringAt */
static void
primitiveStringAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    unsigned int integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l10;
	}
	if (((index & (smallIntegerTag(self))) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l10;
	}
	index = (index >> 3);
	/* begin stObject:at: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l6;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l6;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l6;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l6;
	}
	totalLength = 0;
	l6:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l7;
	}
	class = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr, self), self);
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr, self)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr, self)));
		stSize = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1, self))
		 && ((oopisLessThanOrEqualTo(index, stSize, self))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr, self), self);
			goto l9;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat(self))
		? (((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1
		: 1), self))
	 && (oopisLessThanOrEqualTo(index, stSize, self))) {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin fetchPointer:ofObject: */
			result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord(self))))));
			goto l9;
		}
		if (fmt >= (firstByteFormat(self))) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l9;
		}
		if (fmt >= (firstShortFormat(self))) {
			result = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
			goto l9;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			result = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))), self);
			goto l9;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		result = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
		goto l9;
	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
	l9:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		if (!(((result >= 0) && (result <= ((1U << 30) - 1))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			goto l10;
		}
		/* begin characterForAscii: */
		result = (((sqInt)((usqInt)(((result >> 3))) << (numTagBits(self))))) + (characterTag(self));
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	l10:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveStringAtPut */
static void
primitiveStringAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt signedValueToStore;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;
    usqLong unsigned64BitValueToStore;
    unsigned int unsignedValueToStore;
    sqInt value;
    sqInt value1;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l30;
	}
	if (((index & (smallIntegerTag(self))) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l30;
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l30;
	}
	index = (index >> 3);
	/* begin stObject:at:put: */
	value1 = asciiOfCharacter(value, self);
	/* begin baseHeader: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l6;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l6;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l6;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l6;
	}
	totalLength = 0;
	l6:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l7;
	}
	class = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr, self), self);
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr, self)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr, self)));
		stSize = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1, self))
		 && ((oopisLessThanOrEqualTo(index, stSize, self))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr, self), value1, self);
			goto l15;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat(self))
		? (((literalCountOf(rcvr, self)) + LiteralStart) * BytesPerOop) + 1
		: 1), self))
	 && (oopisLessThanOrEqualTo(index, stSize, self))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr, self)));
			if ((assert(isNonImmediate(rcvr, self)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((value1 & (tagMask(self))) == 0)
				 && (oopisLessThan(value1, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(rcvr, self);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord(self))))), value1);
			goto l13;
		}
		if (fmt >= (firstByteFormat(self))) {
			if (!((((value1) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			signedValueToStore = (value1 >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l13;
		}
		if (fmt >= (firstShortFormat(self))) {
			if (!((((value1) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			signedValueToStore = (value1 >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))), signedValueToStore);
			goto l13;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			unsigned64BitValueToStore = positive64BitValueOf(value1, self);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l13;
		}
		unsignedValueToStore = positive32BitValueOf(value1, self);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l13:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
	l15:	/* end stObject:at:put: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
	l30:	/* end commonAtPut: */;
}


/*	<array> primReplaceFrom: start to: stop with: replacement startingAt:
	repStart 
	<primitive: 105> */

	/* InterpreterPrimitives>>#primitiveStringReplace */
static void
primitiveStringReplace(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt arrayFmt;
    sqInt arrayInstSize;
    sqInt arrayLength;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt i;
    sqInt mustRemember;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt oop;
    sqInt repl;
    sqInt replFmt;
    sqInt replInstSize;
    sqInt replLength;
    sqInt replStart;
    sqInt srcDelta;
    sqInt start;
    sqInt stop;

	/* begin primitiveSpurStringReplace */
	array = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	start = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	stop = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	repl = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	replStart = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((start & (smallIntegerTag(self))) == 0)
	 || (((stop & (smallIntegerTag(self))) == 0)
	 || (((replStart & (smallIntegerTag(self))) == 0)
	 || (repl & (tagMask(self)))))) {

		/* can happen in LgInt copy */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l16;
	}
	start = (start >> 3);
	stop = (stop >> 3);
	replStart = (replStart >> 3);
	if ((stop >= start)
	 && (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(array))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l16;
	}
	arrayFmt = (((usqInt) (longAt(array))) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(array + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (arrayFmt <= 5 /* ephemeronFormat */) {
		arrayLength = numSlots;
		goto l11;
	}
	if (arrayFmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		arrayLength = (numSlots << (shiftForWord(self))) - (arrayFmt & 7);
		goto l11;
	}
	if (arrayFmt >= (firstShortFormat(self))) {
		arrayLength = (numSlots << ((shiftForWord(self)) - 1)) - (arrayFmt & 3);
		goto l11;
	}
	if (arrayFmt >= (firstLongFormat(self))) {
		arrayLength = (numSlots << ((shiftForWord(self)) - 2)) - (arrayFmt & 1);
		goto l11;
	}
	if (arrayFmt == (sixtyFourBitIndexableFormat(self))) {
		arrayLength = numSlots;
		goto l11;
	}
	arrayLength = 0;
	l11:	/* end lengthOf:format: */;
	/* begin classFormatFromInstFormat: */
	if (arrayFmt >= (firstByteFormat(self))) {

		/* this is likely the common case */
		arrayFmt = arrayFmt & -8;
		goto l12;
	}
	if (arrayFmt <= (sixtyFourBitIndexableFormat(self))) {
		arrayFmt = arrayFmt;
		goto l12;
	}
	if (arrayFmt < (firstShortFormat(self))) {
		arrayFmt = arrayFmt & -2;
		goto l12;
	}
	arrayFmt = arrayFmt & -4;
	l12:	/* end classFormatFromInstFormat: */;
	replFmt = (((usqInt) (longAt(repl))) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots11 = byteAt(repl + 7);
	numSlots2 = (numSlots11 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(repl - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (replFmt <= 5 /* ephemeronFormat */) {
		replLength = numSlots2;
		goto l14;
	}
	if (replFmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		replLength = (numSlots2 << (shiftForWord(self))) - (replFmt & 7);
		goto l14;
	}
	if (replFmt >= (firstShortFormat(self))) {
		replLength = (numSlots2 << ((shiftForWord(self)) - 1)) - (replFmt & 3);
		goto l14;
	}
	if (replFmt >= (firstLongFormat(self))) {
		replLength = (numSlots2 << ((shiftForWord(self)) - 2)) - (replFmt & 1);
		goto l14;
	}
	if (replFmt == (sixtyFourBitIndexableFormat(self))) {
		replLength = numSlots2;
		goto l14;
	}
	replLength = 0;
	l14:	/* end lengthOf:format: */;
	/* begin classFormatFromInstFormat: */
	if (replFmt >= (firstByteFormat(self))) {

		/* this is likely the common case */
		replFmt = replFmt & -8;
		goto l15;
	}
	if (replFmt <= (sixtyFourBitIndexableFormat(self))) {
		replFmt = replFmt;
		goto l15;
	}
	if (replFmt < (firstShortFormat(self))) {
		replFmt = replFmt & -2;
		goto l15;
	}
	replFmt = replFmt & -4;
	l15:	/* end classFormatFromInstFormat: */;
	if (!((arrayFmt == replFmt)
		 && (arrayFmt < (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l16;
	}
	if (arrayFmt <= 5 /* lastPointerFormat */) {
		/* begin fixedFieldsOf:format:length: */
		if ((arrayFmt >= (sixtyFourBitIndexableFormat(self)))
		 || (arrayFmt == 2 /* arrayFormat */)) {
			arrayInstSize = 0;
			goto l8;
		}
		if (arrayFmt < 2 /* arrayFormat */) {
			arrayInstSize = arrayLength;
			goto l8;
		}
		class = fetchClassOfNonImm(array, self);
		/* begin fixedFieldsOfClassFormat: */
		classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		arrayInstSize = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l8:	/* end fixedFieldsOf:format:length: */;
		/* begin fixedFieldsOf:format:length: */
		if ((replFmt >= (sixtyFourBitIndexableFormat(self)))
		 || (replFmt == 2 /* arrayFormat */)) {
			replInstSize = 0;
			goto l9;
		}
		if (replFmt < 2 /* arrayFormat */) {
			replInstSize = replLength;
			goto l9;
		}
		class1 = fetchClassOfNonImm(repl, self);
		/* begin fixedFieldsOfClassFormat: */
		classFormat1 = ((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		replInstSize = classFormat1 & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l9:	/* end fixedFieldsOf:format:length: */;
		if (!((start >= 1)
			 && (((start - 1) <= stop)
			 && (((stop + arrayInstSize) <= arrayLength)
			 && ((replStart >= 1)
			 && ((((stop - start) + replStart) + replInstSize) <= replLength)))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			goto l16;
		}
		start += arrayInstSize;
		stop += arrayInstSize;
		srcDelta = (replStart + replInstSize) - start;
		if ((assert(isNonImmediate(array, self)),
		oopisGreaterThanOrEqualTo(array, GIV(oldSpaceStart), self))) {
			mustRemember = 0;
			for (i = (start - 1); i < stop; i += 1) {
				oop = longAt((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << (shiftForWord(self))))));
				if (((oop & (tagMask(self))) == 0)
				 && (oopisLessThan(oop, GIV(newSpaceLimit), self))) {
					mustRemember = 1;
				}
				assert(!(isOopForwarded(array, self)));
				longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), oop);
			}
			if (mustRemember) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(array))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(array, self);
				}
			}
		}
		else {
			for (i = (start - 1); i < stop; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(array, self)));
				longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), longAt((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << (shiftForWord(self)))))));
			}
		}
	}
	else {
		if (!((start >= 1)
			 && (((start - 1) <= stop)
			 && ((stop <= arrayLength)
			 && ((replStart >= 1)
			 && (((stop - start) + replStart) <= replLength)))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			goto l16;
		}
		srcDelta = replStart - start;
		if (arrayFmt >= (firstShortFormat(self))) {

			/* 8 & 16-bit word type objects */
			if (arrayFmt >= (firstByteFormat(self))) {

				/* byte-type objects */
				for (i = (start - 1); i < stop; i += 1) {
					/* begin storeByte:ofObject:withValue: */
					byteAtput((array + BaseHeaderSize) + i, byteAt((repl + BaseHeaderSize) + (srcDelta + i)));
				}
			}
			else {

				/* short type objects */
				for (i = (start - 1); i < stop; i += 1) {
					/* begin storeShort16:ofObject:withValue: */
					shortAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 1))), shortAt((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << 1)))));
				}
			}
		}
		else {

			/* 32 & 64-bit word type objects */
			if (arrayFmt >= (firstLongFormat(self))) {

				/* word-type objects */
				for (i = (start - 1); i < stop; i += 1) {
					/* begin storeLong32:ofObject:withValue: */
					long32Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 2))), long32At((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << 2)))));
				}
			}
			else {

				/* long type objects */
				for (i = (start - 1); i < stop; i += 1) {
					/* begin storeLong64:ofObject:withValue: */
					long64Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 3))), long64At((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << 3)))));
				}
			}
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	l16:	/* end primitiveSpurStringReplace */;
}

	/* InterpreterPrimitives>>#primitiveSubtract */
static void
primitiveSubtract(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1, self)) - (stackIntegerValue(0, self));
	if (!GIV(primFailCode)) {
		if ((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveSubtractLargeIntegers */
EXPORT(void)
primitiveSubtractLargeIntegers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr, self);
	bIsNegative = isNegativeIntegerValueOf(oopArg, self);
	a = magnitude64BitValueOf(oopRcvr, self);
	b = magnitude64BitValueOf(oopArg, self);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative != bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = !aIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative, self);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Suspend the receiver, aProcess such that it can be executed
	again by sending #resume. If the given process is not currently running,
	take it off
	its corresponding list. The primitive returns the list the receiver was
	previously on.
 */

	/* InterpreterPrimitives>>#primitiveSuspend */
static void
primitiveSuspend(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt lastLink;
    sqInt myList;
    sqInt nextLink;
    sqInt process;
    sqInt referent;
    char *sp;
    char *sp1;
    sqInt tempLink;
    sqInt valuePointer;

	process = longAt(GIV(stackPointer));
	if (process == (memoryActiveProcess(self))) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
		transferTo(wakeHighestPriority(self), self);
		return;
	}

	/* XXXX Fixme. We should really check whether myList is a kind of LinkedList or not
	   but we can't easily so just do a quick check for nil which is the most common case. */
	myList = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord(self))))));
	if (myList == GIV(nilObj)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (((longAt(myList)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(myList, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((myList + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		myList = referent;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(process, self)));
		if ((assert(isNonImmediate(process, self)),
		oopisGreaterThanOrEqualTo(process, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((myList & (tagMask(self))) == 0)
			 && (oopisLessThan(myList, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(process))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(process, self);
				}
			}
		}
		longAtput((process + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord(self))))), myList);
	}
	/* begin removeProcess:fromList: */
	assert(!((isForwarded(process, self))));
	assert(!((isForwarded(myList, self))));
	/* begin fetchPointer:ofObject: */
	firstLink = longAt((myList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	lastLink = longAt((myList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))));
	assert(!((isForwarded(firstLink, self))));
	assert(!((isForwarded(lastLink, self))));
	if (process == firstLink) {
		/* begin fetchPointer:ofObject: */
		nextLink = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))));
		assert(!((isForwarded(nextLink, self))));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(myList, self)));
		if ((assert(isNonImmediate(myList, self)),
		oopisGreaterThanOrEqualTo(myList, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((nextLink & (tagMask(self))) == 0)
			 && (oopisLessThan(nextLink, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(myList))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(myList, self);
				}
			}
		}
		longAtput((myList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))), nextLink);
		if (process == lastLink) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer = GIV(nilObj);
			assert(!(isOopForwarded(myList, self)));
			longAtput((myList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))), valuePointer);
		}
	}
	else {
		tempLink = firstLink;
		while (1) {
			assert(!((isForwarded(tempLink, self))));
			if (tempLink == GIV(nilObj)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				goto l18;
			}
			/* begin fetchPointer:ofObject: */
			nextLink = longAt((tempLink + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))));
			if (nextLink == process) break;
			/* begin fetchPointer:ofObject: */
			tempLink = longAt((tempLink + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))));
		}
		/* begin fetchPointer:ofObject: */
		nextLink = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(tempLink, self)));
		if ((assert(isNonImmediate(tempLink, self)),
		oopisGreaterThanOrEqualTo(tempLink, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((nextLink & (tagMask(self))) == 0)
			 && (oopisLessThan(nextLink, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(tempLink))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(tempLink, self);
				}
			}
		}
		longAtput((tempLink + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))), nextLink);
		if (process == lastLink) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(myList, self)));
			if ((assert(isNonImmediate(myList, self)),
			oopisGreaterThanOrEqualTo(myList, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((tempLink & (tagMask(self))) == 0)
				 && (oopisLessThan(tempLink, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(myList))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(myList, self);
					}
				}
			}
			longAtput((myList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))), tempLink);
		}
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(process, self)));
	if ((assert(isNonImmediate(process, self)),
	oopisGreaterThanOrEqualTo(process, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((GIV(nilObj) & (tagMask(self))) == 0)
		 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(process))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(process, self);
			}
		}
	}
	longAtput((process + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))), GIV(nilObj));
	l18:	/* end removeProcess:fromList: */;
	if (!GIV(primFailCode)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(process, self)));
		if ((assert(isNonImmediate(process, self)),
		oopisGreaterThanOrEqualTo(process, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((GIV(nilObj) & (tagMask(self))) == 0)
			 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(process))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(process, self);
				}
			}
		}
		longAtput((process + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord(self))))), GIV(nilObj));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), myList);
		GIV(stackPointer) = sp1;
	}
}


/*	Attempt to test-and-set the ownership of the critical section. If not
	owned, set the owner to the current process and answer false. If owned by
	the current process answer true. If owned by some other process answer
	nil. For simulation if there is an argument it is taken to be the
	effective activeProcess
	(see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveTestAndSetOwnershipOfCriticalSection */
static void
primitiveTestAndSetOwnershipOfCriticalSection(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt objOop;
    sqInt objOop1;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin memoryActiveProcess */
		objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
		objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord(self))))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection, self)));
		if ((assert(isNonImmediate(criticalSection, self)),
		oopisGreaterThanOrEqualTo(criticalSection, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((activeProc & (tagMask(self))) == 0)
			 && (oopisLessThan(activeProc, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(criticalSection))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(criticalSection, self);
				}
			}
		}
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord(self))))), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
	GIV(stackPointer) = sp2;
}


/*	Return true if the host OS does support the given display depth. */

	/* InterpreterPrimitives>>#primitiveTestDisplayDepth */
static void
primitiveTestDisplayDepth(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    char *sp;

	okay = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		bitsPerPixel = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bitsPerPixel = 0;
		goto l1;
	}
	l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Multiply the receiver by the power of the argument. */

	/* InterpreterPrimitives>>#primitiveTimesTwoPower */
static void
primitiveTimesTwoPower(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    double rcvr;
    double result;
    char *sp;
    int twiceMaxExponent;

	arg = longAt(GIV(stackPointer));
	if (!((((arg) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	arg = (arg >> 3);
	twiceMaxExponent = 2 * (1U << 11 /* floatExponentBits */);
	if (arg < (-twiceMaxExponent)) {
		arg = -twiceMaxExponent;
	}
	else {
		if (arg > twiceMaxExponent) {
			arg = twiceMaxExponent;
		}
	}
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	result = ldexp(rcvr, ((int) arg));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(result, self));
	GIV(stackPointer) = sp;
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveTruncated */
static void
primitiveTruncated(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double rcvr;
    double trunc;

	/* begin stackFloatValue: */
	rcvr = floatValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)), self);
	if (!GIV(primFailCode)) {
		modf(rcvr, (&trunc));
		if (((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) ))))) {
			longAtPointerput(GIV(stackPointer), (((usqInt)(((sqInt)trunc)) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive. Unload the module with the given name. */
/*	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is ensured by invalidating current
	sessionID. 
 */

	/* InterpreterPrimitives>>#primitiveUnloadModule */
static void
primitiveUnloadModule(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    sqInt i1;
    sqInt i2;
    usqInt limit;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = longAt(GIV(stackPointer));
	if (!(((moduleName & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName, self)), byteSizeOf(moduleName, self), self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin flushExternalPrimitives */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {

			/* This is a compiled method */
			flushExternalPrimitiveOf(objOop1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {

			/* This is a compiled method */
			flushExternalPrimitiveOf(objOop1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if (((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {

				/* This is a compiled method */
				flushExternalPrimitiveOf(objOop11, self);
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i2 = 0; i2 < MaxExternalPrimitiveTableSize; i2 += 1) {
		GIV(externalPrimitiveTable)[i2] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	forceInterruptCheck(self);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Update the VMs notion of the current timezone. The VM sets its notion
	of the timezone once at start-up. If one wants the VM to keep its notion
	up-to-date arrange to invoke this primitive periodically. */

	/* InterpreterPrimitives>>#primitiveUpdateTimezone */
static void
primitiveUpdateTimezone(struct foo * self)
{
	ioUpdateVMTimezone(self);
}


/*	Return the value of the microsecond clock in UTC as an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. This
	primitive accesses the time as answered by the OS. */

	/* InterpreterPrimitives>>#primitiveUTCMicrosecondClock */
static void
primitiveUTCMicrosecondClock(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioUTCMicrosecondsNow(self), self);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Smalltalk epoch and the
	current seconds offset from GMT in the local time zone. Any pointer object
	with two or more slots) may be supplied as a parameter. */

	/* InterpreterPrimitives>>#primitiveUtcAndTimezoneOffset */
static void
primitiveUtcAndTimezoneOffset(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((((resultArray & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(resultArray))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
			 && ((lengthOfformat(resultArray, (((usqInt) (longAt(resultArray))) >> (formatShift(self))) & (formatMask(self)), self)) >= 2))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	else {
		resultArray = instantiateClassindexableSize(splObj(ClassArray, self), 2, self);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((usqInt)(ioLocalSecondsOffset(self)) << 3) | 1);
	assert(!(isOopForwarded(resultArray, self)));
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord(self))), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	valuePointer1 = positive64BitIntegerFor(ioUTCMicroseconds(self), self);
	assert(!(isForwarded(resultArray, self)));
	if ((assert(isNonImmediate(resultArray, self)),
	oopisGreaterThanOrEqualTo(resultArray, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((valuePointer1 & (tagMask(self))) == 0)
		 && (oopisLessThan(valuePointer1, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(resultArray))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(resultArray, self);
			}
		}
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord(self))), valuePointer1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Posix epoch and the
	current seconds offset from GMT in the local time zone. An empty two
	element array (or any object with two or more slots) may be supplied
	as a parameter.
	This is a named (not numbered) primitive in the null module (ie the VM) */

	/* InterpreterPrimitives>>#primitiveUtcWithOffset */
EXPORT(sqInt)
primitiveUtcWithOffset(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static usqLong epochDelta = 2177452800000000ULL;
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrBadNumArgs);
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((((resultArray & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(resultArray))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
			 && ((lengthOfformat(resultArray, (((usqInt) (longAt(resultArray))) >> (formatShift(self))) & (formatMask(self)), self)) >= 2))) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
	}
	else {
		resultArray = instantiateClassindexableSize(splObj(ClassArray, self), 2, self);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((usqInt)(ioLocalSecondsOffset(self)) << 3) | 1);
	assert(!(isOopForwarded(resultArray, self)));
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord(self))), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	valuePointer1 = positive64BitIntegerFor((ioUTCMicroseconds(self)) - epochDelta, self);
	assert(!(isForwarded(resultArray, self)));
	if ((assert(isNonImmediate(resultArray, self)),
	oopisGreaterThanOrEqualTo(resultArray, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((valuePointer1 & (tagMask(self))) == 0)
		 && (oopisLessThan(valuePointer1, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(resultArray))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(resultArray, self);
			}
		}
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord(self))), valuePointer1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Return a string containing the path name of VM's directory. */

	/* InterpreterPrimitives>>#primitiveVMPath */
static void
primitiveVMPath(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	sz = vmPathSize(self);
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self)))))), sz, self);
	vmPathGetLength(s + BaseHeaderSize, sz);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

	/* InterpreterPrimitives>>#primitiveVMProfileSamplesInto */
static void
primitiveVMProfileSamplesInto(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt numSamples;
    sqInt running;
    sqInt sampleBuffer;
    char *sp;
    char *sp1;
    sqInt v;

	bufferSize = 0;
	running = 0;
	v = 0;
	ioNewProfileStatus((&running), (&bufferSize));
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (running
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	sampleBuffer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!(((sampleBuffer & (tagMask(self))) == 0)
		 && ((isPureBitsFormat((((usqInt) (longAt(sampleBuffer))) >> (formatShift(self))) & (formatMask(self)), self))
		 && ((numBytesOf(sampleBuffer, self)) >= (bufferSize * BytesPerWord))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	numSamples = ioNewProfileSamplesInto(firstFixedField(sampleBuffer, self));
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)numSamples << 3) | 1));
	GIV(stackPointer) = sp1;
}

	/* InterpreterPrimitives>>#primitiveWait */
static void
primitiveWait(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt excessSignals;
    sqInt objOop;
    sqInt objOop1;
    sqInt sema;


	/* rcvr */
	sema = longAt(GIV(stackPointer));
	excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema, self);
	if (excessSignals > 0) {
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt) (excessSignals - 1)) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(sema, self)));
			longAtput((sema + BaseHeaderSize) + (((sqInt)((usqInt)(ExcessSignalsIndex) << (shiftForWord(self))))), (((usqInt)(excessSignals - 1) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin memoryActiveProcess */
		objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
		objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
		addLastLinktoList(activeProc, sema, self);
		transferTo(wakeHighestPriority(self), self);
	}
}


/*	Primitively do the equivalent of Process>yield, avoiding the overhead of a
	fork and a wait in the standard implementation.
 */

	/* InterpreterPrimitives>>#primitiveYield */
static void
primitiveYield(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt objOop;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt scheduler;

	/* begin fetchPointer:ofObject: */
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	scheduler = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	activeProc = longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	priority = (oop >> 3);
	processLists = longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord(self))))));
	processList = longAt((processLists + BaseHeaderSize) + (((sqInt)((usqInt)((priority - 1)) << (shiftForWord(self))))));
	if (!((assert(!(isForwarded(processList, self))),
		(longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))))) == GIV(nilObj)))) {
		addLastLinktoList(activeProc, processList, self);
		transferTo(wakeHighestPriority(self), self);
	}
}


/*	Signal the given semaphore from within the interpreter. Used to serialize
	callbacks. 
 */

	/* InterpreterPrimitives>>#signalNoResume: */
sqInt
signalNoResume(sqInt aSemaphore, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt empty;

	assert(!(isForwarded(aSemaphore, self)));
	empty = (longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))))) == GIV(nilObj);
	if (!empty) {
		putToSleepyieldingIf(removeFirstLinkOfList(aSemaphore, self), 1, self);
	}
	return empty;
}


/*	Convert the given object into an integer value.
	The object may be either a SmallInteger or a four-byte LargeInteger. */

	/* InterpreterPrimitives>>#signed32BitValueOf: */
int
signed32BitValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt value64;

	if ((((oop) & 7) == 1)) {
		value64 = (oop >> 3);
		if ((((int) value64)) != value64) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value64 = 0;
		}
		return value64;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#signed64BitValueOf: */
sqLong
signed64BitValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    usqLong magnitude;
    sqInt negative;
    sqInt ok;
    sqInt sz;
    sqLong value;

	if ((((oop) & 7) == 1)) {
		return ((sqLong) ((oop >> 3)));
	}
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex1 = (longAt(oop)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;
	l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop, self)));
		/* begin classIndexOf: */
		ccIndex = (longAt(oop)) & (classIndexMask(self));
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	sz = ((numSlotsOf(oop, self)) << (shiftForWord(self))) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize) + (0U << 3))));
	}
	else {

		/* ] */
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	if ((negative
		? magnitude > 0x8000000000000000ULL
		: magnitude >= 0x8000000000000000ULL)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

	/* InterpreterPrimitives>>#signedMachineIntegerValueOf: */
sqIntptr_t
signedMachineIntegerValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    usqIntptr_t limit;
    usqIntptr_t magnitude;
    sqInt negative;
    usqInt numBytes;
    usqInt numSlots;
    sqInt ok;
    sqInt value;

	if ((((oop) & 7) == 1)) {
		return (oop >> 3);
	}
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex1 = (longAt(oop)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;
	l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop, self)));
		/* begin classIndexOf: */
		ccIndex = (longAt(oop)) & (classIndexMask(self));
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOf: */
	assert((classIndexOf(oop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(oop + 7);
	numBytes = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord(self));
	if (fmt >= (firstByteFormat(self))) {

		/* bytes (the common case), including CompiledMethod */
		bs = numBytes - (fmt & 7);
		goto l6;
	}
	if (fmt <= (sixtyFourBitIndexableFormat(self))) {
		bs = numBytes;
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		bs = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
		goto l6;
	}
	bs = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l6:	/* end numBytesOf: */;
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(sqIntptr_t)) == 8)
	 && (bs > 4)) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize) + (0U << 3))));
	}
	else {

		/* ] */
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	limit = (((usqIntptr_t)1)) << (((sizeof(sqIntptr_t)) * 8) - 1);
	if ((negative
		? magnitude > limit
		: magnitude >= limit)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#sizeOfAlienData: */
usqInt
sizeOfAlienData(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt size;

	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord(self)))))), self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	size = longAt(oop + BaseHeaderSize);
	return SQABS(size);
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#startOfAlienData: */
void *
startOfAlienData(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord(self)))))), self))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self success: false to exit. */

	/* InterpreterPrimitives>>#success: */
sqInt
success(sqInt successBoolean, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return 0;
}


/*	Initialize the stack pages. For testing I want stack addresses to be
	disjoint from
	normal memory addresses so stack addresses are negative. The first address
	is -pageSize bytes. So for example if there are 1024 bytes per page and 3
	pages then the pages are organized as
	
	byte address: -1024 <-> -2047 | -2048 <-> -3071 | -3072 <-> -4096 |
	page 3			page 2			page 1
	mem index: 769 <-> 513 | 512 <-> 257 | 256 <-> 1 |
	
	The byte address is the external address corresponding to a real address
	in the VM.
	mem index is the index in the memory Array holding the stack, an index
	internal to
	the stack pages. The first stack page allocated will be the last page in
	the array of pages
	at the highest effective address. Its base address be -1024 and grow down
	towards -2047. */
/*	The lFoo's are to get around the foo->variable scheme in the C call to
	allocStackPages below.
 */

	/* InterpreterStackPages>>#initializeStack:numSlots:pageSize: */
static sqInt NoDbgRegParms
initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt index;
    sqInt numPages;
    StackPage *page;
    char *pageStructBase;
    usqIntptr_t structStackPageSize;
    sqInt theIndex;


	/* For initialization in the C code. */
	GIV(stackMemory) = theStackPages;
	structStackPageSize = sizeof(CogStackPage);
	GIV(bytesPerPage) = slotsPerPage * BytesPerWord;

	/* Because stack pages grow down baseAddress is at the top of a stack page and so to avoid
	   subtracting BytesPerWord from baseAddress and lastAddress in the init loop below we simply
	   push the stackPage array up one word to avoid the overlap.  This word is extraStackBytes. */
	numPages = GIV(numStackPages);
	pageStructBase = (theStackPages + (numPages * GIV(bytesPerPage))) + BytesPerWord;

	/* Simulation only.  Since addresses are negative the offset is positive.  To make all
	   stack addresses negative we make the offset a page more than it needs to be so the
	   address of the last slot in memory (the highest address in the stack, or its start) is
	   - pageByteSize
	   and the address of the first slot (the lowest address, or its end) is
	   - pageByteSize * (numPages + 1) */
	GIV(pages) = (StackPage *)pageStructBase;
	assert((((stackPageByteSize(self)) - (stackLimitBytes(self))) - (stackLimitOffset(self))) >= (stackPageHeadroom(self)));
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages), self);
		(page->lastAddress = (char *)theStackPages + (index * GIV(bytesPerPage)));
		(page->baseAddress = ((page->lastAddress)) + GIV(bytesPerPage));
		(page->stackLimit = ((page->baseAddress)) - ((((stackPageFrameBytes(self)) < (((stackPageByteSize(self)) - ((FrameSlots + 64) * BytesPerWord)))) ? (stackPageFrameBytes(self)) : (((stackPageByteSize(self)) - ((FrameSlots + 64) * BytesPerWord))))));
		(page->realStackLimit = (page->stackLimit));
		(page->baseFP = 0);
		(page->nextPage = stackPageAt((index == (numPages - 1)
			? 0
			: index + 1), self));
		(page->prevPage = stackPageAt((index == 0
			? numPages - 1
			: index - 1), self));
	}
	/* begin stackPageAt: */
	page = stackPageAtpages(0, GIV(pages), self);
	GIV(overflowLimit) = ((((page->baseAddress)) - ((page->realStackLimit))) * 3) / 5;
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages), self);
		assert((pageIndexFor((page->baseAddress), self)) == index);
		assert((pageIndexFor(((page->baseAddress)) - ((slotsPerPage - 1) * BytesPerWord), self)) == index);
		assert((stackPageFor((page->baseAddress), self)) == page);
		assert((stackPageFor((page->stackLimit), self)) == page);
		/* begin initializePageTraceToInvalid: */
		(page->trace = StackPageTraceInvalid);
	}
	/* begin stackPageAt: */
	GIV(mostRecentlyUsedPage) = stackPageAtpages(0, GIV(pages), self);
	page = GIV(mostRecentlyUsedPage);
	count = 0;
	do {
		count += 1;
		theIndex = pageIndexForstackMemorybytesPerPage((page->baseAddress), GIV(stackMemory), GIV(bytesPerPage), self);
		assert((stackPageAt(theIndex, self)) == page);
		assert((pageIndexFor((page->baseAddress), self)) == theIndex);
		assert((pageIndexFor((page->stackLimit), self)) == theIndex);
		assert((pageIndexFor(((page->lastAddress)) + BytesPerWord, self)) == theIndex);
	} while(((page = (page->nextPage))) != GIV(mostRecentlyUsedPage));
	assert(count == numPages);
	assert(pageListIsWellFormed(self));
	return 0;
}


/*	<Integer> */
/*	Answer the page index for a pointer into stack memory, i.e. the index
	for the page the address is in. N.B. This is a zero-relative index. */

	/* InterpreterStackPages>>#pageIndexFor: */
static sqInt NoDbgRegParms
pageIndexFor(void *pointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage), self);
}


/*	Answer the address immediately following an object. */

	/* Spur64BitMemoryManager>>#addressAfter: */
static usqInt NoDbgRegParms
addressAfter(sqInt objOop, struct foo * self)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	if (numSlots == 0) {
		return (objOop + 8 /* allocationUnit */) + BaseHeaderSize;
	}
	if (numSlots == (numSlotsMask(self))) {
		numSlots = ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8;
	}
	return (objOop + BaseHeaderSize) + (((usqInt) numSlots << 3));
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. Try
	and allocate in a segment that already includes pinned objects. The header
	of the
	result will have been filled-in but not the contents. */

	/* Spur64BitMemoryManager>>#allocateSlotsForPinningInOldSpace:bytes:format:classIndex: */
static sqInt NoDbgRegParms
allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt acceptedChunk;
    sqInt acceptedNode;
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    usqInt index;
    usqInt initialIndex;
    sqInt next;
    sqInt next1;
    sqInt next2;
    sqInt next3;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    sqInt node;
    sqInt prev;

	/* begin allocateOldSpaceChunkOfBytes:suchThat: */

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= totalBytes;
	initialIndex = totalBytes / 8 /* allocationUnit */;
	if ((initialIndex < 64 /* numFreeLists */)
	 && ((1ULL << initialIndex) <= GIV(freeListsMask))) {
		if (GIV(freeListsMask) & (1ULL << initialIndex)) {
			if (((node = GIV(freeLists)[initialIndex])) == 0) {
				GIV(freeListsMask) -= 1ULL << initialIndex;
			}
			else {
				prev = 0;
				while (node != 0) {
					assert(node == (startOfObject(node, self)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node, self));
					/* begin fetchPointer:ofFreeChunk: */
					next = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))));
					if (((segmentContainingObj(node, self))->containsPinned)) {
						if (prev == 0) {
							/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
							assert(((bytesInObject(node, self)) == (initialIndex * (allocationUnit(self))))
							 && ((initialIndex > 1)
							 && ((startOfObject(node, self)) == node)));
							GIV(freeLists)[initialIndex] = ((next1 = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))))));
							if ((!((assert(totalBytes >= (BaseHeaderSize + (allocationUnit(self)))),
							totalBytes == (BaseHeaderSize + 8 /* allocationUnit */))))
							 && (next1 != 0)) {
								/* begin storePointer:ofFreeChunk:withValue: */
								fieldIndex = 1 /* freeChunkPrevIndex */;
								assert(isFreeObject(next1, self));
								assert(1);
								longAtput((next1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), 0);
							}
						}
						else {
							/* begin setNextFreeChunkOf:withValue:chunkBytes: */
							assert(isFreeObject(prev, self));
							assert((next == 0)
							 || (isFreeObject(next, self)));
							longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord(self))), next);
							if ((next != 0)
							 && (!((assert(totalBytes >= (BaseHeaderSize + (allocationUnit(self)))),
							totalBytes == (BaseHeaderSize + 8 /* allocationUnit */))))) {
								/* begin storePointer:ofFreeChunk:withValue: */
								assert(isFreeObject(next, self));
								assert((prev == 0)
								 || (isFreeObject(prev, self)));
								longAtput((next + BaseHeaderSize) + (1U << (shiftForWord(self))), prev);
							}
						}
						chunk = node;
						goto l27;
					}
					prev = node;
					node = next;
				}
			}
		}
		index = initialIndex;
		while ((((index += initialIndex)) < 64 /* numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1ULL << index)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1ULL << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node, self)));
						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node, self));
						/* begin fetchPointer:ofFreeChunk: */
						next = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))));
						if (((segmentContainingObj(node, self))->containsPinned)) {
							if (prev == 0) {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInObject(node, self)) == (index * (allocationUnit(self))))
								 && ((index > 1)
								 && ((startOfObject(node, self)) == node)));
								GIV(freeLists)[index] = ((next2 = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))))));
								if (next2 != 0) {
									/* begin storePointer:ofFreeChunk:withValue: */
									fieldIndex1 = 1 /* freeChunkPrevIndex */;
									assert(isFreeObject(next2, self));
									assert(1);
									longAtput((next2 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))), 0);
								}
							}
							else {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								assert(isFreeObject(prev, self));
								assert((next == 0)
								 || (isFreeObject(next, self)));
								longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord(self))), next);
								if ((next != 0)
								 && (!0)) {
									/* begin storePointer:ofFreeChunk:withValue: */
									assert(isFreeObject(next, self));
									assert((prev == 0)
									 || (isFreeObject(prev, self)));
									longAtput((next + BaseHeaderSize) + (1U << (shiftForWord(self))), prev);
								}
							}
							freeChunkWithBytesat((index * 8 /* allocationUnit */) - totalBytes, (((byteAt(node + 7)) == (numSlotsMask(self))
	? node - BaseHeaderSize
	: node)) + totalBytes, self);
							chunk = node;
							goto l27;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < 64 /* numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1ULL << index)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1ULL << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node, self)));
						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node, self));
						/* begin fetchPointer:ofFreeChunk: */
						next = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))));
						if (((segmentContainingObj(node, self))->containsPinned)) {
							if (prev == 0) {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInObject(node, self)) == (index * (allocationUnit(self))))
								 && ((index > 1)
								 && ((startOfObject(node, self)) == node)));
								GIV(freeLists)[index] = ((next3 = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))))));
								if (next3 != 0) {
									/* begin storePointer:ofFreeChunk:withValue: */
									fieldIndex2 = 1 /* freeChunkPrevIndex */;
									assert(isFreeObject(next3, self));
									assert(1);
									longAtput((next3 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))), 0);
								}
							}
							else {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								assert(isFreeObject(prev, self));
								assert((next == 0)
								 || (isFreeObject(next, self)));
								longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord(self))), next);
								if ((next != 0)
								 && (!0)) {
									/* begin storePointer:ofFreeChunk:withValue: */
									assert(isFreeObject(next, self));
									assert((prev == 0)
									 || (isFreeObject(prev, self)));
									longAtput((next + BaseHeaderSize) + (1U << (shiftForWord(self))), prev);
								}
							}
							freeChunkWithBytesat((index * 8 /* allocationUnit */) - totalBytes, (((byteAt(node + 7)) == (numSlotsMask(self))
	? node - BaseHeaderSize
	: node)) + totalBytes, self);
							chunk = node;
							goto l27;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
	}
	child = GIV(freeLists)[0];
	node = (acceptedChunk = (acceptedNode = 0));
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child, self));
		childBytes = bytesInObject(child, self);
		if (childBytes == totalBytes) {

			/* size match; try to remove from list at node. */
			node = child;
			while (1) {
				prev = node;
				/* begin fetchPointer:ofFreeChunk: */
				node = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))));
				if (!(node != 0)) break;
				if (((segmentContainingObj(node, self))->containsPinned)) {
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node, self));
					/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
					nextFreeChunk = longAt((node + BaseHeaderSize) + (0U << (shiftForWord(self))));
					/* begin storePointer:ofFreeChunk:withValue: */
					assert(isFreeObject(prev, self));
					assert((nextFreeChunk == 0)
					 || (isFreeObject(nextFreeChunk, self)));
					longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk);
					if ((nextFreeChunk != 0)
					 && (!0)) {
						/* begin storePointer:ofFreeChunk:withValue: */
						assert(isFreeObject(nextFreeChunk, self));
						assert((prev == 0)
						 || (isFreeObject(prev, self)));
						longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), prev);
					}
					chunk = ((byteAt(node + 7)) == (numSlotsMask(self))
						? node - BaseHeaderSize
						: node);
					goto l27;
				}
			}
			if (((segmentContainingObj(child, self))->containsPinned)) {
				/* begin fetchPointer:ofFreeChunk: */
				next = longAt((child + BaseHeaderSize) + (0U << (shiftForWord(self))));
				if (next == 0) {

					/* no list; remove the interior node */
					unlinkSolitaryFreeTreeNode(child, self);
				}
				else {

					/* list; replace node with it */
					inFreeTreeReplacewith(child, next, self);
				}
				chunk = ((byteAt(child + 7)) == (numSlotsMask(self))
					? child - BaseHeaderSize
					: child);
				goto l27;
			}
		}
		if (child != 0) {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (totalBytes + 8 /* allocationUnit */)) {

				/* node too small; walk down the larger size of the tree */
				/* begin fetchPointer:ofFreeChunk: */
				child = longAt((child + BaseHeaderSize) + (4U << (shiftForWord(self))));
			}
			else {
				flag("we can do better here; preferentially choosing the lowest node. That would be a form of best-fit since we are trying to compact down");
				node = child;
				/* begin fetchPointer:ofFreeChunk: */
				child = longAt((node + BaseHeaderSize) + (3U << (shiftForWord(self))));
				if (acceptedNode == 0) {

					/* first search the list. */
					acceptedChunk = node;
					do {
						/* begin fetchPointer:ofFreeChunk: */
						acceptedChunk = longAt((acceptedChunk + BaseHeaderSize) + (0U << (shiftForWord(self))));
						if ((acceptedChunk != 0)
						 && (((segmentContainingObj(acceptedChunk, self))->containsPinned))) {
							acceptedNode = node;
						}
					} while((acceptedChunk != 0)
						 && (acceptedNode == 0));
					if ((acceptedNode == 0)
					 && (((segmentContainingObj(node, self))->containsPinned))) {
						acceptedNode = node;
						child = 0;
					}
				}
			}
		}
	}
	if (acceptedNode != 0) {
		if (acceptedChunk != 0) {
			assert((bytesInObject(acceptedChunk, self)) >= (totalBytes + (allocationUnit(self))));
			while (1) {
				/* begin fetchPointer:ofFreeChunk: */
				next = longAt((acceptedNode + BaseHeaderSize) + (0U << (shiftForWord(self))));
				if (!(next != acceptedChunk)) break;
				acceptedNode = next;
			}
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			nextFreeChunk1 = longAt((acceptedChunk + BaseHeaderSize) + (0U << (shiftForWord(self))));
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(acceptedNode, self));
			assert((nextFreeChunk1 == 0)
			 || (isFreeObject(nextFreeChunk1, self)));
			longAtput((acceptedNode + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk1);
			if ((nextFreeChunk1 != 0)
			 && (!0)) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(nextFreeChunk1, self));
				assert((acceptedNode == 0)
				 || (isFreeObject(acceptedNode, self)));
				longAtput((nextFreeChunk1 + BaseHeaderSize) + (1U << (shiftForWord(self))), acceptedNode);
			}
			freeChunkWithBytesat((bytesInObject(acceptedChunk, self)) - totalBytes, (((byteAt(acceptedChunk + 7)) == (numSlotsMask(self))
	? acceptedChunk - BaseHeaderSize
	: acceptedChunk)) + totalBytes, self);
			chunk = ((byteAt(acceptedChunk + 7)) == (numSlotsMask(self))
				? acceptedChunk - BaseHeaderSize
				: acceptedChunk);
			goto l27;
		}
		/* begin fetchPointer:ofFreeChunk: */
		next = longAt((acceptedNode + BaseHeaderSize) + (0U << (shiftForWord(self))));
		if (next == 0) {

			/* no list; remove the interior node */
			unlinkSolitaryFreeTreeNode(acceptedNode, self);
		}
		else {

			/* list; replace node with it */
			inFreeTreeReplacewith(acceptedNode, next, self);
		}
		assert((bytesInObject(acceptedNode, self)) >= (totalBytes + (allocationUnit(self))));
		freeChunkWithBytesat((bytesInObject(acceptedNode, self)) - totalBytes, (((byteAt(acceptedNode + 7)) == (numSlotsMask(self))
	? acceptedNode - BaseHeaderSize
	: acceptedNode)) + totalBytes, self);
		chunk = ((byteAt(acceptedNode + 7)) == (numSlotsMask(self))
			? acceptedNode - BaseHeaderSize
			: acceptedNode);
		goto l27;
	}

	/* optimism was unfounded */
	GIV(totalFreeOldSpace) += totalBytes;
	chunk = null;
	l27:	/* end allocateOldSpaceChunkOfBytes:suchThat: */;
	if (!(chunk)) {
		chunk = allocateOldSpaceChunkOfBytes(totalBytes, self);
		if (!(chunk)) {
			return null;
		}
		((segmentContainingObj(chunk, self))->containsPinned = 1);
	}
	if (numSlots >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))));
		longAtput(chunk + BaseHeaderSize, (headerForSlotsformatclassIndex(numSlotsMask(self), formatField, classIndex, self)) | (1U << (pinnedBitShift(self))));
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
		}
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, ((((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + classIndex) | (1U << (pinnedBitShift(self))));
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	return chunk;
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. The
	header will have been filled-in but not the contents. If no memory is
	available answer nil. */

	/* Spur64BitMemoryManager>>#allocateSlotsInOldSpace:bytes:format:classIndex: */
static sqInt NoDbgRegParms
allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;

	chunk = allocateOldSpaceChunkOfBytes(totalBytes, self);
	if (!(chunk)) {
		return null;
	}
	if (numSlots >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))));
		longAtput(chunk + BaseHeaderSize, headerForSlotsformatclassIndex(numSlotsMask(self), formatField, classIndex, self));
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
		}
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + classIndex);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	return chunk;
}


/*	Answer the given integer with its bytes in the reverse order. */

	/* Spur64BitMemoryManager>>#byteSwapped: */
sqInt
byteSwapped(sqInt w, struct foo * self)
{
	return SQ_SWAP_8_BYTES(w);
}


/*	Answer the total number of bytes in an object including header and
	possible overflow size header.
 */

	/* Spur64BitMemoryManager>>#bytesInObject: */
static usqInt NoDbgRegParms
bytesInObject(sqInt objOop, struct foo * self)
{
    usqLong header;
    usqLong headerNumSlots;
    usqLong numSlots;

	flag("endianness");
	header = longAt(objOop);
	headerNumSlots = header >> (numSlotsFullShift(self));
	if (headerNumSlots == (numSlotsMask(self))) {
		numSlots = ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8;
	}
	else {
		numSlots = (headerNumSlots == 0
			? 1
			: headerNumSlots);
	}
	return (numSlots << (shiftForWord(self))) + ((headerNumSlots == (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize));
}


/*	Attempt to change the class of the receiver to the argument given that the
	format of the receiver matches the format of the argument. If successful,
	answer 0, otherwise answer an error code indicating the reason for
	failure. 
	Fail if the format of the receiver is incompatible with the format of the
	argument, or if the argument is a fixed class and the receiver's size
	differs from the size
	that an instance of the argument should have. */

	/* Spur64BitMemoryManager>>#changeClassOf:to: */
static sqInt NoDbgRegParms
changeClassOfto(sqInt rcvr, sqInt argClass, struct foo * self)
{
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hash;
    sqInt instBytes;
    sqInt instFormat;
    usqInt instSlots;
    sqInt newFormat;
    usqInt numBytes;
    usqInt numSlots;

	instBytes = 0;
	instSlots = 0;
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		return PrimErrNoModification;
	}
	classFormat = ((longAt((argClass + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	classFormat = (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));

	/* Fail for inability to access classIndex before making contexts snapshot-safe. */
	instFormat = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
	if (((assert(addressCouldBeClassObj(argClass, self)),
	(classIndex = (((hash = (long32At(argClass + 4)) & (identityHashHalfWordMask(self)))) != 0
			? hash
			: (objCouldBeClassObj(argClass, self)
					? (((err = enterIntoClassTable(argClass, self))) != 0
							? -err
							: (/* begin rawHashBitsOf: */
								(long32At(argClass + 4)) & (identityHashHalfWordMask(self))))
					: -PrimErrBadReceiver))))) < 0) {
		return -classIndex;
	}
	if (classFormat <= 5 /* lastPointerFormat */) {
		if (instFormat > 5 /* lastPointerFormat */) {
			return PrimErrInappropriate;
		}
		if ((((instSlots = numSlotsOf(rcvr, self))) < fixedFields)
		 || ((instSlots > fixedFields)
		 && ((classFormat <= 1 /* nonIndexablePointerFormat */)
		 || (classFormat == 5 /* ephemeronFormat */)))) {
			return PrimErrBadReceiver;
		}
		if ((instFormat == (indexablePointersFormat(self)))
		 && (((longAt(rcvr)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			makeContextSnapshotSafe(rcvr, self);
		}
		newFormat = classFormat;
	}
	else {

		/* Fail if the class's format is somehow invalid. */
		if (classFormat != (classFormatForInstanceFormat(classFormat, self))) {
			return PrimErrBadArgument;
		}
		/* begin numBytesOf: */
		fmt = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(rcvr + 7);
		numBytes = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		numBytes = numBytes << (shiftForWord(self));
		if (fmt >= (firstByteFormat(self))) {

			/* bytes (the common case), including CompiledMethod */
			instBytes = numBytes - (fmt & 7);
			goto l4;
		}
		if (fmt <= (sixtyFourBitIndexableFormat(self))) {
			instBytes = numBytes;
			goto l4;
		}
		if (fmt >= (firstShortFormat(self))) {
			instBytes = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
			goto l4;
		}
		instBytes = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l4:	/* end numBytesOf: */;
		
		switch (classFormat) {
		case sixtyFourBitIndexableFormat(self):
			if (instBytes & 7) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat;
			break;
		case firstLongFormat(self):
			if (instBytes & 3) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat + ((2 - (((usqInt) instBytes) >> 2)) & 1);
			break;
		case firstShortFormat(self):
			if (instBytes & 1) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat + ((4 - (((usqInt) instBytes) >> 1)) & 3);
			break;
		case firstByteFormat(self):
			newFormat = classFormat + ((8 - instBytes) & 7);
			break;
		case firstCompiledMethodFormat(self):
			if (classFormat != (firstCompiledMethodFormat(self))) {
				return PrimErrInappropriate;
			}
			newFormat = instFormat;
			break;
		default:
			
			/* bits instances cannot be adopted by pointer-like classes... */
			return PrimErrInappropriate;

		}
	}
	/* begin set:classIndexTo:formatTo: */
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
	assert(((newFormat >= 0) && (newFormat <= (formatMask(self)))));
	longAtput(rcvr, ((longAt(rcvr)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex + (((sqInt)((usqInt)(newFormat) << (formatShift(self)))))));
	assert((numBytesOf(rcvr, self)) == ((classFormat <= (lastPointerFormat(self))
		? instSlots * BytesPerOop
		: instBytes)));
	return 0;
}


/*	Answer the C double precision floating point value of the argument,
	or if it is not, answer 0. */

	/* Spur64BitMemoryManager>>#dbgFloatValueOf: */
static double NoDbgRegParms
dbgFloatValueOf(sqInt oop, struct foo * self)
{
    usqLong bits;
    double result;
    usqLong rot;
    sqInt tagBits;
    double value;

	if (((tagBits = oop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(oop, self));
			rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			return value;
		}
	}
	else {
		if (((longAt(oop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
			return result;
		}
	}
	return 0.0;
}


/*	Answer the default amount of memory to allocate for the eden space.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file.
	The shootout tests seem to plateau at 5 or 6Mb.
	
	Originally, both the 32-bit and 64-bit versions used the same 4Mb default.
	Measuring the simulator on image start-up, the 64-bit system's eden at the
	same point in start-up
	(the first copyBits) is only 8% larger in bytes because it allocates 26%
	fewer objects.
	Some 21% of the objects in the 32-bit version's eden are large integers
	and floats that
	are representable as 64-bit immediates.
	
	But when running benchmarks such as the computer language shootout's
	binary trees,
	using the same amount of memory for the 64-bit system causes a significant
	slow-down and a lot of compactions. So we now use 4Mb for 32-bits and 7Mb
	for 64-bits. */

	/* Spur64BitMemoryManager>>#defaultEdenBytes */
static sqInt
defaultEdenBytes(struct foo * self)
{
	return (7 * 1024) * 1024;
}

	/* Spur64BitMemoryManager>>#fetchClassTagOf: */
sqInt
fetchClassTagOf(sqInt oop, struct foo * self)
{
    sqInt tagBits;

	return (((tagBits = oop & (tagMask(self)))) != 0
		? tagBits
		: (longAt(oop)) & (classIndexMask(self)));
}


/*	index by word size, and return a pointer as long as the word size */

	/* Spur64BitMemoryManager>>#fetchLong32:ofFloatObject: */
static sqInt NoDbgRegParms
fetchLong32ofFloatObject(sqInt fieldIndex, sqInt oop, struct foo * self)
{
    usqLong bits;
    usqLong rot;

	if (!(oop & (smallFloatTag(self)))) {
		return long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
	}
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	return (((int *) ((&bits))))[fieldIndex];
}

	/* Spur64BitMemoryManager>>#floatObjectOf: */
sqInt
floatObjectOf(double aFloat, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newFloatObj;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    usqLong rawFloat;
    usqLong rot;

	rawFloat = 0;
	if (isSmallFloatValue(aFloat, self)) {
		/* begin smallFloatObjectOf: */
		assert(isSmallFloatValue(aFloat, self));
		memcpy((&rawFloat), (&aFloat), sizeof(rawFloat));
		/* begin rotateLeft: */
		rot = ((rawFloat >> 0x3F) & 1) + (rawFloat << 1);
		if (rot > 1) {

			/* a.k.a. ~= +/-0.0 */
			rot -= ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			assert(rot > 0);
		}
		return (rot << (numTagBits(self))) + (smallFloatTag(self));
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = firstLongFormat(self);
	numSlots = (sizeof(double)) / BytesPerOop;
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassFloatCompactIndex, self)) != GIV(nilObj)));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(ClassFloatCompactIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newFloatObj = 0;
			goto l2;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + ClassFloatCompactIndex);
	GIV(freeStart) += numBytes;
	newFloatObj = newObj;
	l2:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

	/* Spur64BitMemoryManager>>#floatValueOf: */
double
floatValueOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    double result;
    usqLong rot;
    sqInt tagBits;
    double value;

	if (((tagBits = oop & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(oop, self));
			rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			return value;
		}
	}
	else {
		if (((longAt(oop)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
			return result;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	A negative header selects the alternate bytecode set. */

	/* Spur64BitMemoryManager>>#headerIndicatesAlternateBytecodeSet: */
sqInt
headerIndicatesAlternateBytecodeSet(sqInt methodHeader, struct foo * self)
{
	return (((sqLong) methodHeader)) < 0;
}


/*	must have room for a header (single or double) plus the next free pointer */

	/* Spur64BitMemoryManager>>#initFreeChunkWithBytes:at: */
static sqInt NoDbgRegParms
initFreeChunkWithBytesat(usqLong numBytes, sqInt address, struct foo * self)
{
    sqLong numSlots;


	/* must have room for a header (single or double) plus the next free pointer */
	assert(((numBytes % (allocationUnit(self))) == 0)
	 && (numBytes >= (BaseHeaderSize + BytesPerOop)));
	if (numBytes >= ((((sqInt)((usqInt)((numSlotsMask(self))) << (shiftForWord(self))))) + BaseHeaderSize)) {
		numSlots = ((usqInt) ((numBytes - BaseHeaderSize) - BaseHeaderSize)) >> (shiftForWord(self));
		longAtput(address, (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
		longAtput(address + 8, ((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self)))));
		return address + 8;
	}
	numSlots = ((usqInt) (numBytes - BaseHeaderSize)) >> (shiftForWord(self));
	assert(numSlots < (numSlotsMask(self)));
	longAtput(address, ((sqLong)((usqLong)(numSlots) << (numSlotsFullShift(self)))));
	return address;
}


/*	must have room for a double header */

	/* Spur64BitMemoryManager>>#initSegmentBridgeWithBytes:at: */
static void NoDbgRegParms
initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address, struct foo * self)
{
    sqLong numSlots;


	/* must have room for a double header */
	assert(((numBytes % (allocationUnit(self))) == 0)
	 && (numBytes >= (BaseHeaderSize + BaseHeaderSize)));
	numSlots = ((usqInt) ((numBytes - BaseHeaderSize) - BaseHeaderSize)) >> (shiftForWord(self));
	if (numSlots == 0) {

		/* short bridge for adjacent segments */
		longAtput(address, (((1U << (pinnedBitShift(self))) + (1ULL << (markedBitFullShift(self)))) + (((sqInt)((usqInt)((sixtyFourBitIndexableFormat(self))) << (formatShift(self)))))) + (segmentBridgePun(self)));
	}
	else {

		/* long bridge */
		longAtput(address, (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
		longAtput(address + BaseHeaderSize, ((((((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + (1U << (pinnedBitShift(self)))) + (1ULL << (markedBitFullShift(self)))) + (((sqInt)((usqInt)((sixtyFourBitIndexableFormat(self))) << (formatShift(self)))))) + (segmentBridgePun(self)));
	}
}


/*	Allocate an instance of a variable class, excepting CompiledMethod. */

	/* Spur64BitMemoryManager>>#instantiateClass:indexableSize: */
sqInt
instantiateClassindexableSize(sqInt classObj, usqInt nElements, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt fillValue;
    sqInt hash;
    sqInt instSpec;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt p;

	classFormat = ((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	fillValue = 0;
	
	switch (instSpec) {
	case 2 /* arrayFormat */:
		numSlots = nElements;
		fillValue = GIV(nilObj);
		break;
	case indexablePointersFormat(self):
	case weakArrayFormat(self):
		numSlots = (classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1)) + nElements;
		fillValue = GIV(nilObj);
		break;
	case sixtyFourBitIndexableFormat(self):
		numSlots = nElements;
		break;
	case firstLongFormat(self):
		if ((classIndex == ClassFloatCompactIndex)
		 && (nElements != 2)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return null;
		}
		numSlots = (nElements + 1) / 2;
		instSpec += nElements & 1;
		break;
	case firstShortFormat(self):
		numSlots = (nElements + 3) / 4;
		instSpec += (4 - nElements) & 3;
		break;
	case firstByteFormat(self):
		numSlots = (nElements + 7) / 8;
		instSpec += (8 - nElements) & 7;
		break;
	default:
		
		/* Some Squeak images include funky fixed subclasses of abstract variable
		   superclasses. e.g. DirectoryEntry as a subclass of ArrayedCollection.
		   The (Threaded)FFIPlugin expects to be able to instantiate ExternalData via
		   this method.
		   Hence allow fixed classes to be instantiated here iff nElements = 0. */
		/* non-indexable */
		if ((nElements != 0)
		 || (instSpec > 5 /* lastPointerFormat */)) {
			return null;
		}
		numSlots = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
		fillValue = GIV(nilObj);

	}
	if (classIndex == 0) {
		assert(addressCouldBeClassObj(classObj, self));
		classIndex = (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask(self)))) != 0
			? hash
			: (objCouldBeClassObj(classObj, self)
					? (((err = enterIntoClassTable(classObj, self))) != 0
							? -err
							: (/* begin rawHashBitsOf: */
								(long32At(classObj + 4)) & (identityHashHalfWordMask(self))))
					: -PrimErrBadReceiver));
		if (classIndex < 0) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = -classIndex;
			return null;
		}
	}
	if (numSlots > ((1U << (fixedFieldsFieldWidth(self))) - 1)) {
		if (numSlots > (0x10000000000LL)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return null;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
			? 8 /* allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord(self))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), instSpec, classIndex, self);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask(self))) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				newObj = null;
				goto l6;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? /* begin allocationUnit */ 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck(self);
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex, self);
			goto l6;
		}
		if (numSlots >= (numSlotsMask(self))) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(self), instSpec, classIndex, self));
		}
		else {
			longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(instSpec) << (formatShift(self)))))) + classIndex);
		}
		assert((numBytes % (allocationUnit(self))) == 0);
		assert((newObj1 % (allocationUnit(self))) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l6:	/* end allocateSlots:format:classIndex: */;
	}
	if (newObj) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj, self), self));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
			longAtput(p, fillValue);
		}
	}
	return newObj;
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

	/* Spur64BitMemoryManager>>#integerObjectOf: */
sqInt
integerObjectOf(sqInt value, struct foo * self)
{
	return ((((usqInt)value)) << (numTagBits(self))) + 1;
}


/*	Translator produces 'oop >> 3' */

	/* Spur64BitMemoryManager>>#integerValueOf: */
sqInt
integerValueOf(sqInt oop, struct foo * self)
{
	return ((((usqInt) oop >> 63)) == 1
		? ((((((-(numTagBits(self))) < 0) ? ((usqInt) oop >> -(-(numTagBits(self)))) : ((usqInt) oop << (-(numTagBits(self)))))) & 0x1FFFFFFFFFFFFFFFLL) - 0x1FFFFFFFFFFFFFFFLL) - 1
		: (((-(numTagBits(self))) < 0) ? ((usqInt) oop >> -(-(numTagBits(self)))) : ((usqInt) oop << (-(numTagBits(self))))));
}

	/* Spur64BitMemoryManager>>#isImmediateFloat: */
static sqInt NoDbgRegParms
isImmediateFloat(sqInt oop, struct foo * self)
{
	return oop & (smallFloatTag(self));
}

	/* Spur64BitMemoryManager>>#isIntegerObject: */
sqInt
isIntegerObject(sqInt oop, struct foo * self)
{
	return oop & (smallIntegerTag(self));
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In 64-bits we use a 3 bit tag which leaves 61 bits for 2's complement
	signed integers. In C, use a shift add and mask to test if the top 4 bits
	are all the same.
	Since 16rFFFFFFFFFFFFFFFF >> 60 = 16rF the computation intValue >> 60 + 1
	bitAnd: 16rF
	maps in-range -ve values to 0 and in-range +ve values to 1. */

	/* Spur64BitMemoryManager>>#isIntegerValue: */
sqInt
isIntegerValue(sqInt intValue, struct foo * self)
{
	return (((((usqInt) intValue) >> 60) + 1) & 15) <= 1;
}


/*	To have a prev pointer, which follows the next pointer, we need at least
	two slots.
 */

	/* Spur64BitMemoryManager>>#isLilliputianSize: */
static sqInt NoDbgRegParms
isLilliputianSize(sqInt chunkBytes, struct foo * self)
{
	assert(chunkBytes >= (BaseHeaderSize + (allocationUnit(self))));
	return chunkBytes == (BaseHeaderSize + 8 /* allocationUnit */);
}

	/* Spur64BitMemoryManager>>#isMarked: */
sqInt
isMarked(sqInt objOop, struct foo * self)
{
	return ((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0;
}

	/* Spur64BitMemoryManager>>#isSmallFloatValue: */
static sqInt NoDbgRegParms
isSmallFloatValue(double aFloat, struct foo * self)
{
    usqLong exponent;
    usqLong rawFloat;

	rawFloat = 0;
	memcpy((&rawFloat), (&aFloat), sizeof(rawFloat));
	exponent = (rawFloat >> (smallFloatMantissaBits(self))) & 0x7FF;
	return (exponent > (smallFloatExponentOffset(self))
		? exponent <= (0xFF + (smallFloatExponentOffset(self)))
		: ((rawFloat & ((1ULL << (smallFloatMantissaBits(self))) - 1)) == 0
				? exponent == 0
				: exponent == (smallFloatExponentOffset(self))));
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes)
	should be subtracted from the result of this method. */

	/* Spur64BitMemoryManager>>#lengthOf:format: */
static sqInt NoDbgRegParms
lengthOfformat(sqInt objOop, sqInt fmt, struct foo * self)
{
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord(self))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		return numSlots;
	}
	return 0;
}


/*	Answer the maximum number of slots we are willing to attempt to allocate
	in an object.
	Must fit in 56-bits; c.f. bytesInObject: */

	/* Spur64BitMemoryManager>>#maxSlotsForAlloc */
static sqInt
maxSlotsForAlloc(struct foo * self)
{
	return 0x10000000000LL;
}


/*	Answer the number of free lists. We use freeListsMask, a bitmap, to avoid
	reading empty list heads. This should fit in a machine word to end up in a
	register during free chunk allocation. */

	/* Spur64BitMemoryManager>>#numFreeLists */
static sqInt
numFreeLists(struct foo * self)
{
	return 64;
}


/*	Reduce the number of indexable fields in objOop, a pointer object, to
	nSlots. Convert the
	unused residual to a free chunk. Without changes to
	numSlotsForShortening:toIndexableSize: this only works for arrayFormat and
	longFormat objects.
	Answer the number of bytes returned to free memory, which may be zero if
	no change
	was possible. */

	/* Spur64BitMemoryManager>>#shorten:toIndexableSize: */
sqInt
shortentoIndexableSize(sqInt objOop, sqInt indexableSize, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesBefore;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt copy;
    sqInt delta;
    sqInt format;
    sqInt formatField;
    sqInt freeChunk;
    sqInt i;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;

	
	switch ((((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self))) {
	case 2 /* arrayFormat */:
		numSlots = indexableSize;

		break;
	case firstLongFormat(self):
	case (firstLongFormat(self)) + 1:
		numSlots = ((indexableSize * 4) + (BytesPerWord - 1)) / BytesPerWord;

		break;
	default:
		error("Case not found and no otherwise clause");
		numSlots = -1;
	}
	if (numSlots == (numSlotsOf(objOop, self))) {
		return 0;
	}
	bytesBefore = bytesInObject(objOop, self);
	delta = bytesBefore - ((numSlots == 0
	? 8 /* allocationUnit */ + BaseHeaderSize
	: (((sqInt)((usqInt)(numSlots) << (shiftForWord(self))))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))));
	flag("this should update format for 32-bit indexable words; too lazy today.");
	if (delta == 0) {
		return 0;
	}
	if (delta <= 8 /* allocationUnit */) {
		/* begin allocateSlots:format:classIndex: */
		formatField = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
		classIndex1 = (longAt(objOop)) & (classIndexMask(self));
		if (numSlots >= (numSlotsMask(self))) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				copy = null;
				goto l4;
			}
			newObj = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? /* begin allocationUnit */ 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck(self);
			}
			copy = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, classIndex1, self);
			goto l4;
		}
		if (numSlots >= (numSlotsMask(self))) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
			longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(self), formatField, classIndex1, self));
		}
		else {
			longAtput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + classIndex1);
		}
		assert((numBytes % (allocationUnit(self))) == 0);
		assert((newObj % (allocationUnit(self))) == 0);
		GIV(freeStart) += numBytes;
		copy = newObj;
	l4:	/* end allocateSlots:format:classIndex: */;
		if (!(copy)) {
			error("shorten:toIndexableSize: attempted to shorten to allocationUnit!");
		}
		for (i = 0; i < numSlots; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(copy, self)));
			longAtput((copy + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))));
		}
		if (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0) {
			remember(copy, self);
		}
		/* begin forward:to: */
		classIndex2 = isForwardedObjectClassIndexPun(self);
		assert(((classIndex2 >= 0) && (classIndex2 <= (classIndexMask(self)))));
		assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex2 + (7U << (formatShift(self)))));
		
#    if IMMUTABILITY
		/* begin setIsImmutableOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#    endif /* IMMUTABILITY */
		/* begin storePointer:ofForwarder:withValue: */
		assert(isForwarded(objOop, self));
		assert(!(isOopForwarded(copy, self)));
		if ((assert(isNonImmediate(objOop, self)),
		oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((copy & (tagMask(self))) == 0)
			 && (oopisLessThan(copy, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(objOop, self);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))), copy);
		if ((byteAt(objOop + 7)) == 0) {
			byteAtput(objOop + 7, 1);
		}
		return 0;
	}
	if ((byteAt(objOop + 7)) == (numSlotsMask(self))) {
		/* begin rawOverflowSlotsOf:put: */
		longAtput(objOop - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask(self))) << 56))) + numSlots);
		if (numSlots < (numSlotsMask(self))) {
			delta -= 8 /* allocationUnit */;
		}
	}
	else {
		assert(numSlots < (numSlotsMask(self)));
		byteAtput(objOop + 7, numSlots);
	}
	freeChunk = initFreeChunkWithBytesat(delta, addressAfter(objOop, self), self);
	assert((addressAfter(freeChunk, self)) <= GIV(endOfMemory));
	if (oopisGreaterThanOrEqualToandLessThan(objOop, GIV(oldSpaceStart), GIV(endOfMemory), self)) {
		GIV(totalFreeOldSpace) += delta;
		addToFreeListbytes(freeChunk, delta, self);
	}
	else {
		/* begin setClassIndexOf:to: */
		classIndex = sixtyFourBitLongsClassIndexPun(self);
		assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
		longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(classIndexMask(self)))) + classIndex);
		/* begin setFormatOf:to: */
		format = firstLongFormat(self);
		assert(((format >= 0) && (format <= (formatMask(self)))));
		longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))))) + (((sqInt)((usqInt)(format) << (formatShift(self))))));
	}
	return delta;
}


/*	Answer the C double precision floating point value of the argument, a
	SmallFloat. See section 61-bit Immediate Floats in the SpurMemoryManager
	class comment.
	msb lsb 
	Decode:				[8expsubset][52mantissa][1s][3tags] 
	shift away tags:		[ 000 ][8expsubset][52mantissa][1s] 
	add exponent offset:	[ 11 exponent ][52mantissa][1s] 
	rot sign:				[1s][ 11 exponent ][52mantissa] */

	/* Spur64BitMemoryManager>>#smallFloatValueOf: */
static double NoDbgRegParms
smallFloatValueOf(sqInt oop, struct foo * self)
{
    usqLong bits;
    usqLong rot;
    double value;

	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop, self));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
	}
	/* begin rotateRight: */
	rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	return value;
}


/*	Answer the total number of bytes in an object without an overflow header,
	including header bytes.
 */

	/* Spur64BitMemoryManager>>#smallObjectBytesForSlots: */
usqInt
smallObjectBytesForSlots(sqInt numSlots, struct foo * self)
{
	return BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
}

	/* Spur64BitMemoryManager>>#wordIndexableFormat */
static sqInt
wordIndexableFormat(struct foo * self)
{
	return sixtyFourBitIndexableFormat(self);
}


/*	ephemeronCorpse is the corpse of an ephemeron that was copied and
	forwarded. Later on its surviving copy must be scanned to nil weak
	references. Thread the corpse onto the weakList. Later, the weakList can
	be followed, and
	the forwarding pointer followed to locate the survivor. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#addToEphemeronList: */
static void NoDbgRegParms NeverInline
addToEphemeronList(sqInt ephemeronCorpse, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeronListOffset;

	assert(!(isScavengeSurvivor(keyOfEphemeron(followForwarded(ephemeronCorpse, self), self), self)));
	ephemeronListOffset = (!(GIV(ephemeronList))
		? 0
		: GIV(ephemeronList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(ephemeronCorpse, self));
	assert(isForwarded(ephemeronCorpse, self));
	
	/* So we use the single assignment */
	long64Atput(ephemeronCorpse, headerForSlotshashformatclassIndex(byteAt(ephemeronCorpse + 7), ((usqInt) ephemeronListOffset) >> (formatFieldWidthShift(self)), ephemeronListOffset & (formatMask(self)), isForwardedObjectClassIndexPun(self), self));
	GIV(ephemeronList) = (((usqInt) (ephemeronCorpse - GIV(newSpaceStart))) >> 3 /* shiftForAllocationUnit */) + 1;
	assert((firstCorpse(GIV(ephemeronList), self)) == ephemeronCorpse);
}


/*	weakCorpse is the corpse of a weak array that was copied and forwarded.
	Later on its surviving copy must be scanned to nil weak references.
	Thread the corpse onto the weakList. Later, the weakList can be followed,
	and the forwarding pointer followed to locate the survivor. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#addToWeakList: */
static void NoDbgRegParms NeverInline
addToWeakList(sqInt weakCorpse, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt weakListOffset;

	weakListOffset = (!(GIV(weakList))
		? 0
		: GIV(weakList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(weakCorpse, self));
	assert(isForwarded(weakCorpse, self));
	
	/* So we use the single assignment */
	long64Atput(weakCorpse, headerForSlotshashformatclassIndex(byteAt(weakCorpse + 7), ((usqInt) weakListOffset) >> (formatFieldWidthShift(self)), weakListOffset & (formatMask(self)), isForwardedObjectClassIndexPun(self), self));
	GIV(weakList) = (((usqInt) (weakCorpse - GIV(newSpaceStart))) >> 3 /* shiftForAllocationUnit */) + 1;
	assert((firstCorpse(GIV(weakList), self)) == weakCorpse);
}

	/* SpurGenerationScavenger>>#allNewSpaceObjectsHaveZeroRTRefCount */
static sqInt
allNewSpaceObjectsHaveZeroRTRefCount(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;

	/* begin allNewSpaceObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (rememberedBitShift(self))) & MaxRTRefCount) > 0) {
			return 0;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (rememberedBitShift(self))) & MaxRTRefCount) > 0) {
			return 0;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	return 1;
}

	/* SpurGenerationScavenger>>#allWeakSurvivorsOnWeakList */
static sqInt
allWeakSurvivorsOnWeakList(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt limit;
    usqInt numSlots;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	/* begin allFutureSpaceEntitiesDo: */
	prevPrevObj = (prevObj = null);
	/* begin objectStartingAt: */
	address = (GIV(futureSpace).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(futureSurvivorStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (isWeakFormat((((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self)), self)) {
			if (!(isonWeaklingList(objOop, GIV(weakList), self))) {
				return 0;
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return 1;
}


/*	Some time in every scavenger's life there may come a time when someone
	writes code that stresses
	the remembered table. One might conclude that if the remembered table is
	full, then the right thing
	to do is simply to tenure everything, emptying the remembered table. Bt in
	some circumstances this
	can be counter-productive, and result in the same situation arising soon
	after tenuring everything.
	Instead, we can try and selectively prune the remembered table, tenuring
	only those objects that
	are referenced by many objects in the remembered table. That's what this
	algorithm does. It
	reference counts young objects referenced from the remembered set, and
	then sets a threshold
	used to tenure objects oft referenced from the remembered set, thereby
	allowing the remembered
	set to shrink, while not tenuring everything.
	
	Once in a network monitoring application in a galaxy not dissimilar from
	the one this code inhabits,
	a tree of nodes referring to large integers was in precisely this
	situation. The nodes were old, and
	the integers were in new space. Some of the nodes referred to shared
	numbers, some their own
	unique numbers. The numbers were updated frequently. Were new space simply
	tenured when the
	remembered table was full, the remembered table would soon fill up as new
	numbers were computed.
	Only by selectively pruning the remembered table of nodes that shared
	data, was a balance achieved
	whereby the remembered table population was kept small, and tenuring rates
	were low. */

	/* SpurGenerationScavenger>>#computeRefCountToShrinkRT */
static void NeverInline
computeRefCountToShrinkRT(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt elephant;
    sqInt entirePopulation;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt j;
    sqInt j1;
    long population[MaxRTRefCount + 1];
    sqInt refCount;
    sqInt referent;
    sqInt referent1;

	memset(population, 0, (sizeof(long)) * (MaxRTRefCount + 1));
	assert(allNewSpaceObjectsHaveZeroRTRefCount(self));
	/* begin referenceCountRememberedReferents: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		elephant = GIV(rememberedSet)[i1];
		if (((longAt(elephant)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(elephant, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent1 = longAt((elephant + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent1 & (tagMask(self))) == 0)
			 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			elephant = referent1;
			if (elephant & (tagMask(self))) {

				/* take care if elephant forwarded to an immediate */
				elephant = GIV(nilObj);
			}
		}
		for (j1 = 0, iLimiT = ((numPointerSlotsOf(elephant, self)) - 1); j1 <= iLimiT; j1 += 1) {
			referent = longAt((elephant + BaseHeaderSize) + (((sqInt)((usqInt)(j1) << (shiftForWord(self))))));
			if (((referent & (tagMask(self))) == 0)
			 && ((assert(isNonImmediate(referent, self)),
			oopisLessThan(referent, GIV(newSpaceLimit), self)))) {
				refCount = (((usqInt) (longAt(referent))) >> (rememberedBitShift(self))) & MaxRTRefCount;
				if (refCount < MaxRTRefCount) {
					if (refCount > 0) {
						population[refCount] = ((population[refCount]) - 1);
					}
					refCount += 1;
					/* begin rtRefCountOf:put: */
					assert(((refCount >= 0) && (refCount <= MaxRTRefCount)));
					header = longAt(referent);
					header = header & (~(usqIntptr_t)(7U << (rememberedBitShift(self))));
					header += ((sqInt)((usqInt)(refCount) << (rememberedBitShift(self))));
					longAtput(referent, header);
					population[refCount] = ((population[refCount]) + 1);
				}
			}
		}
	}
	/* begin setRefCountToShrinkRT: */
	assert((population[0]) == 0);
	entirePopulation = 0;
	for (j = 1; j <= MaxRTRefCount; j += 1) {
		entirePopulation += population[j];
	}
	count = 0;
	i = MaxRTRefCount + 1;
	while ((count < (entirePopulation / 2))
	 && (((i -= 1)) >= 0)) {
		count += population[i];
	}
	GIV(refCountToShrinkRT) = ((i < 0) ? 0 : i);
}


/*	A special version of copyAndForward: for objects in the mournQueue. If
	we're in the good times tenuring regime then copy to futureSpace,
	otherwise tenure.
	Also, don't repeat any of the ephemeron processing. */

	/* SpurGenerationScavenger>>#copyAndForwardMourner: */
static sqInt NoDbgRegParms
copyAndForwardMourner(sqInt mourner, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInObj;
    sqInt classIndex;
    sqInt format;
    sqInt header;
    sqInt newLocation;
    sqInt newStart;
    usqInt startOfSurvivor;
    sqInt tenure;

	assert((isInEden(mourner, self))
	 || (isInPastSpace(mourner, self)));
	bytesInObj = bytesInObject(mourner, self);
	format = (((usqInt) (longAt(mourner))) >> (formatShift(self))) & (formatMask(self));

	/* Allow Slang to inline. */
	tenure = !((GIV(tenureCriterion) == TenureByAge)
	 && (GIV(tenureThreshold) == 0));
	if (tenure
	 || ((GIV(futureSurvivorStart) + bytesInObj) > ((GIV(futureSpace).limit)))) {
		newLocation = copyToOldSpacebytesformat(mourner, bytesInObj, format, self);
	}
	else {
		/* begin copyToFutureSpace:bytes: */

		/* we hope writes are cheap... */
		GIV(statSurvivorCount) += 1;
		assert((GIV(futureSurvivorStart) + bytesInObj) <= ((GIV(futureSpace).limit)));
		startOfSurvivor = ((byteAt(mourner + 7)) == (numSlotsMask(self))
			? mourner - BaseHeaderSize
			: mourner);
		newStart = GIV(futureSurvivorStart);
		GIV(futureSurvivorStart) += bytesInObj;
		memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObj);
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newStart + (mourner - startOfSurvivor));
			header = header & (~(usqIntptr_t)(7U << (rememberedBitShift(self))));
			header += 0U << (rememberedBitShift(self));
			longAtput(newStart + (mourner - startOfSurvivor), header);
		}
		newLocation = newStart + (mourner - startOfSurvivor);
	}
	/* begin forwardSurvivor:to: */
	assert(isInNewSpace(mourner, self));
	assert((isInFutureSpace(newLocation, self))
	 || (isInOldSpace(newLocation, self)));
	assert(!(isOopForwarded(mourner, self)));
	longAtput((mourner + BaseHeaderSize) + (0U << (shiftForWord(self))), newLocation);
	/* begin set:classIndexTo:formatTo: */
	classIndex = isForwardedObjectClassIndexPun(self);
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
	assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
	longAtput(mourner, ((longAt(mourner)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex + (7U << (formatShift(self)))));
	if (format == (weakArrayFormat(self))) {
		addToWeakList(mourner, self);
	}
	return newLocation;
}


/*	copyAndForward: survivor copies a survivor object either to
	futureSurvivorSpace or, if it is to be promoted, to oldSpace.
	It leaves a forwarding pointer behind. If the object is weak
	then corpse is threaded onto the weakList for later treatment. */

	/* SpurGenerationScavenger>>#copyAndForward: */
static sqInt NoDbgRegParms
copyAndForward(sqInt survivor, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInObj;
    sqInt classIndex;
    sqInt format;
    sqInt header;
    sqInt newLocation;
    sqInt newStart;
    usqInt startOfSurvivor;
    sqInt tenure;

	assert((isInEden(survivor, self))
	 || (isInPastSpace(survivor, self)));
	bytesInObj = bytesInObject(survivor, self);
	format = (((usqInt) (longAt(survivor))) >> (formatShift(self))) & (formatMask(self));

	/* Allow Slang to inline. */
	
	switch (GIV(tenureCriterion)) {
	case TenureByAge:
		tenure = survivor < GIV(tenureThreshold);

		break;
	case TenureByClass:
		tenure = ((longAt(survivor)) & (classIndexMask(self))) == GIV(tenuringClassIndex);

		break;
	case TenureToShrinkRT:
		tenure = ((((usqInt) (longAt(survivor))) >> (rememberedBitShift(self))) & MaxRTRefCount) >= GIV(refCountToShrinkRT);

		break;
	default:
		tenure = 0;

	}
	if (tenure
	 || ((GIV(futureSurvivorStart) + bytesInObj) > ((GIV(futureSpace).limit)))) {
		newLocation = copyToOldSpacebytesformat(survivor, bytesInObj, format, self);
	}
	else {
		/* begin copyToFutureSpace:bytes: */

		/* we hope writes are cheap... */
		GIV(statSurvivorCount) += 1;
		assert((GIV(futureSurvivorStart) + bytesInObj) <= ((GIV(futureSpace).limit)));
		startOfSurvivor = ((byteAt(survivor + 7)) == (numSlotsMask(self))
			? survivor - BaseHeaderSize
			: survivor);
		newStart = GIV(futureSurvivorStart);
		GIV(futureSurvivorStart) += bytesInObj;
		memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObj);
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newStart + (survivor - startOfSurvivor));
			header = header & (~(usqIntptr_t)(7U << (rememberedBitShift(self))));
			header += 0U << (rememberedBitShift(self));
			longAtput(newStart + (survivor - startOfSurvivor), header);
		}
		newLocation = newStart + (survivor - startOfSurvivor);
	}
	/* begin forwardSurvivor:to: */
	assert(isInNewSpace(survivor, self));
	assert((isInFutureSpace(newLocation, self))
	 || (isInOldSpace(newLocation, self)));
	assert(!(isOopForwarded(survivor, self)));
	longAtput((survivor + BaseHeaderSize) + (0U << (shiftForWord(self))), newLocation);
	/* begin set:classIndexTo:formatTo: */
	classIndex = isForwardedObjectClassIndexPun(self);
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
	assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
	longAtput(survivor, ((longAt(survivor)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex + (7U << (formatShift(self)))));
	if (format == (weakArrayFormat(self))) {
		addToWeakList(survivor, self);
	}
	if ((format == 5 /* ephemeronFormat */)
	 && (!(isScavengeSurvivor((assert((isNonImmediate(newLocation, self))
		 && (isObjEphemeron(newLocation, self))),
	/* begin fetchPointer:ofObject: */
	longAt((newLocation + BaseHeaderSize) + (0U << (shiftForWord(self))))), self)))) {
		addToEphemeronList(survivor, self);
	}
	return newLocation;
}


/*	Copy survivor to oldSpace. Answer the new oop of the object. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#copyToOldSpace:bytes:format: */
static sqInt NoDbgRegParms NeverInline
copyToOldSpacebytesformat(sqInt survivor, sqInt bytesInObject, sqInt formatOfSurvivor, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt header;
    sqInt newOop;
    sqInt newStart;
    sqInt nTenures;
    sqInt p;
    usqInt startOfSurvivor;

	assert((formatOfSurvivor == (formatOf(survivor, self)))
	 && (((!(isMarked(survivor, self)))
	 || (GIV(tenureCriterion) == MarkOnTenure))
	 && ((GIV(tenureCriterion) == TenureToShrinkRT)
	 || ((!(isPinned(survivor, self)))
	 && (!(isRemembered(survivor, self)))))));
	nTenures = GIV(statTenures);
	startOfSurvivor = ((byteAt(survivor + 7)) == (numSlotsMask(self))
		? survivor - BaseHeaderSize
		: survivor);
	newStart = allocateOldSpaceChunkOfBytes(bytesInObject, self);
	if (!(newStart)) {
		growOldSpaceByAtLeast(0, self);
		newStart = allocateOldSpaceChunkOfBytes(bytesInObject, self);
		if (!(newStart)) {
			error("out of memory");
		}
	}
	memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObject);
	newOop = newStart + (survivor - startOfSurvivor);
	if (GIV(tenureCriterion) >= (((TenureToShrinkRT < MarkOnTenure) ? TenureToShrinkRT : MarkOnTenure))) {
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newOop);
			header = header & (~(usqIntptr_t)(7U << (rememberedBitShift(self))));
			header += 0U << (rememberedBitShift(self));
			longAtput(newOop, header);
		}
		if (GIV(tenureCriterion) == MarkOnTenure) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(newOop, self)));
			longAtput(newOop, (longAt(newOop)) | (1ULL << (markedBitFullShift(self))));
		}
	}
	GIV(statTenures) = nTenures + 1;
	if ((formatOfSurvivor <= 5 /* lastPointerFormat */)
	 || (formatOfSurvivor >= (firstCompiledMethodFormat(self)))) {

		/* A very quick and dirty scan to find young referents.  If we misidentify bytes
		   in a CompiledMethod as young we don't care; it's unlikely, and a subsequent
		   scan of the rt will filter the object out.  But it's good to filter here because
		   otherwise an attempt to shrink the RT may simply fill it up with new objects,
		   and here the data is likely in the cache. */
		for (p = BaseHeaderSize; p <= ((bytesInObject - (survivor - startOfSurvivor)) - BytesPerWord); p += BytesPerWord) {
			field = longAt(survivor + p);
			if (((field & (tagMask(self))) == 0)
			 && ((assert(isNonImmediate(field, self)),
			oopisLessThan(field, GIV(newSpaceLimit), self)))) {
				remember(newOop, self);
				return newOop;
			}
		}
	}
	return newOop;
}

	/* SpurGenerationScavenger>>#firstCorpse: */
static usqInt NoDbgRegParms
firstCorpse(sqInt headOfCorpseList, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin corpseForCorpseOffset: */
	return (((sqInt)((usqInt)((headOfCorpseList - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart);
}

	/* SpurGenerationScavenger>>#growRememberedSet */
static void
growRememberedSet(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt *base;
    sqInt fudge;
    sqInt i;
    sqInt newObj;
    sqInt nSlots;
    sqInt nSlots1;
    sqInt nSlots2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    sqInt obj3;
    usqInt p;
    usqInt p1;
    usqInt p2;

	/* begin fetchPointer:ofObject: */
	obj = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
	/* begin numSlotsOf: */
	assert((classIndexOf(obj, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(obj + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(obj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	assert(numSlots >= 1024);
	/* begin allocatePinnedSlots: */
	nSlots2 = numSlots * 2;
	obj3 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots2, (nSlots2 == 0
		? 8 /* allocationUnit */ + BaseHeaderSize
		: (((sqInt)((usqInt)(nSlots2) << (shiftForWord(self))))) + ((nSlots2 >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(self), sixtyFourBitLongsClassIndexPun(self), self);
	if (obj3) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj3 + BaseHeaderSize) + (nSlots2 * BytesPerOop)) - 1, addressAfter(obj3, self), self));
		for (p2 = (((usqInt)(obj3 + BaseHeaderSize))); p2 <= (((usqInt)(((obj3 + BaseHeaderSize) + (nSlots2 * BytesPerOop)) - 1))); p2 += 8 /* allocationUnit */) {
			longAtput(p2, 0);
		}
	}
	newObj = obj3;
	if (!(newObj)) {
		/* begin allocatePinnedSlots: */
		nSlots1 = numSlots + 1024;
		obj2 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots1, (nSlots1 == 0
			? 8 /* allocationUnit */ + BaseHeaderSize
			: (((sqInt)((usqInt)(nSlots1) << (shiftForWord(self))))) + ((nSlots1 >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(self), sixtyFourBitLongsClassIndexPun(self), self);
		if (obj2) {
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((obj2 + BaseHeaderSize) + (nSlots1 * BytesPerOop)) - 1, addressAfter(obj2, self), self));
			for (p1 = (((usqInt)(obj2 + BaseHeaderSize))); p1 <= (((usqInt)(((obj2 + BaseHeaderSize) + (nSlots1 * BytesPerOop)) - 1))); p1 += 8 /* allocationUnit */) {
				longAtput(p1, 0);
			}
		}
		newObj = obj2;
		if (!(newObj)) {
			if (!(growOldSpaceByAtLeast(numSlots + 1024, self))) {
				error("could not grow remembered set");
			}
			/* begin allocatePinnedSlots: */
			nSlots = numSlots + 1024;
			obj1 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, (nSlots == 0
				? 8 /* allocationUnit */ + BaseHeaderSize
				: (((sqInt)((usqInt)(nSlots) << (shiftForWord(self))))) + ((nSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(self), sixtyFourBitLongsClassIndexPun(self), self);
			if (obj1) {
				/* begin fillObj:numSlots:with: */
				assert(oopisLessThan(((obj1 + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj1, self), self));
				for (p = (((usqInt)(obj1 + BaseHeaderSize))); p <= (((usqInt)(((obj1 + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
					longAtput(p, 0);
				}
			}
			newObj = obj1;
		}
	}
	/* begin rememberedSetObj: */
	assert(isOldObject(newObj, self));
	assert(!(isOopForwarded(GIV(hiddenRootsObj), self)));
	longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))), newObj);
	base = firstIndexableField(newObj, self);
	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		base[i] = (GIV(rememberedSet)[i]);
	}
	if (((((usqInt) (longAt(obj))) >> (markedBitFullShift(self))) & 1) != 0) {
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(newObj, self)));
		longAtput(newObj, (longAt(newObj)) | (1ULL << (markedBitFullShift(self))));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(obj, self)));
		longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
	}
	freeObject(obj, self);
	GIV(rememberedSet) = base;
	/* begin numSlotsOf: */
	assert((classIndexOf(newObj, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots2 = byteAt(newObj + 7);
	GIV(rememberedSetLimit) = (numSlots2 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(newObj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 1024;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
}

	/* SpurGenerationScavenger>>#isInRememberedSet: */
static sqInt NoDbgRegParms
isInRememberedSet(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		if ((GIV(rememberedSet)[i]) == objOop) {
			return 1;
		}
	}
	return 0;
}


/*	Answer whether the oop has survived a scavenge. This version is
	for processing weak survivors and must cope with the scavenge in
	freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact. */

	/* SpurGenerationScavenger>>#isMaybeOldScavengeSurvivor: */
static sqInt NoDbgRegParms
isMaybeOldScavengeSurvivor(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt target;

	if (oop & (tagMask(self))) {
		return 1;
	}
	if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(oop, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		target = referent;
		if (oop & (tagMask(self))) {
			return 1;
		}
	}
	else {
		target = oop;
	}
	return ((assert(isNonImmediate(target, self)),
	oopisGreaterThanOrEqualTo(target, GIV(oldSpaceStart), self))
		? (GIV(tenureCriterion) != MarkOnTenure)
			 || (((((usqInt) (longAt(target))) >> (markedBitFullShift(self))) & 1) != 0)
		: oopisGreaterThanOrEqualToandLessThan(target, ((futureSpace(self)).start), futureSurvivorStart(self), self));
}


/*	Answer whether the oop has survived a scavenge. This is equivalent to
	| target |
	(manager isImmediate: oop) ifTrue:
	[^true].
	target := (manager isForwarded: oop)
	ifTrue: [manager followForwarded: oop]
	ifFalse: [oop].
	^((manager isInEden: target)
	or: [(manager isInPastSpace: target)]) not */

	/* SpurGenerationScavenger>>#isScavengeSurvivor: */
static sqInt NoDbgRegParms
isScavengeSurvivor(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt target;

	if (oop & (tagMask(self))) {
		return 1;
	}
	if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(oop, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		target = referent;
	}
	else {
		target = oop;
	}
	return (!(((target & (tagMask(self))) == 0)
	 && ((assert(isNonImmediate(target, self)),
	oopisLessThan(target, GIV(newSpaceLimit), self)))))
	 || (oopisGreaterThanOrEqualToandLessThan(target, ((futureSpace(self)).start), futureSurvivorStart(self), self));
}

	/* SpurGenerationScavenger>>#is:onWeaklingList: */
static sqInt NoDbgRegParms
isonWeaklingList(sqInt oop, sqInt listHead, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt corpse;
    sqInt listOffset;

	/* begin firstCorpse: */
	corpse = (((sqInt)((usqInt)((listHead - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart);
	while (corpse != null) {
		if (oop == (followForwarded(corpse, self))) {
			return 1;
		}
		/* begin nextCorpseOrNil: */
		assert(isYoung(corpse, self));
		listOffset = (((sqInt)((usqInt)(((long32At(corpse + 4)) & (identityHashHalfWordMask(self)))) << (formatFieldWidthShift(self))))) + ((((usqInt) (longAt(corpse))) >> (formatShift(self))) & (formatMask(self)));
		corpse = (listOffset != 0
			? (/* begin corpseForCorpseOffset: */
				(((sqInt)((usqInt)((listOffset - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart))
			: 0);
	}
	return 0;
}

	/* SpurGenerationScavenger>>#newSpaceCapacity */
static usqInt
newSpaceCapacity(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(eden).limit)) - (((((GIV(futureSpace).start)) < ((GIV(pastSpace).start))) ? ((GIV(futureSpace).start)) : ((GIV(pastSpace).start))));
}


/*	For assert checking only. */

	/* SpurGenerationScavenger>>#noUnfiredEphemeronsAtEndOfRememberedSet */
static sqInt
noUnfiredEphemeronsAtEndOfRememberedSet(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt referrer;

	for (i = GIV(numRememberedEphemerons); i < GIV(rememberedSetSize); i += 1) {
		referrer = GIV(rememberedSet)[i];
		if ((assert(isNonImmediate(referrer, self)),
		isEphemeronFormat((((usqInt) (longAt(referrer))) >> (formatShift(self))) & (formatMask(self)), self))) {
			if (!(isScavengeSurvivor((assert((isNonImmediate(referrer, self))
					 && (isObjEphemeron(referrer, self))),
				/* begin fetchPointer:ofObject: */
				longAt((referrer + BaseHeaderSize) + (0U << (shiftForWord(self))))), self))) {
				return 0;
			}
		}
	}
	return 1;
}

	/* SpurGenerationScavenger>>#openScavengeLog */
void
openScavengeLog(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(scavengeLog) = fopen("scavenge.log", "a+");
}


/*	Print the objects in the remembered set. */

	/* SpurGenerationScavenger>>#printRememberedSet */
void
printRememberedSet(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		printNum(i, self);
		/* begin space */
		putchar(' ');
		shortPrintOop(GIV(rememberedSet)[i], self);
	}
}


/*	There are ephemerons to be scavenged. Scavenge them and fire any whose
	keys are
	still in pastSpace and/or eden. The unscavenged ephemerons in this cycle
	can only be
	fired if all the unscavenged ephemerons in this cycle are firable, because
	references to ephemeron keys from unfired ephemerons should prevent the
	ephemerons with
	those keys from firing. So scavenge ephemerons with surviving keys, and
	only if none
	are found, fire ephemerons with unreferenced keys, and scavenge them. Read
	the class comment for a more in-depth description of the algorithm. */

	/* SpurGenerationScavenger>>#processEphemerons */
static void
processEphemerons(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt ephemeron1;
    usqInt ephemeronCorpse;
    sqInt hasNewReferents;
    sqInt i;
    sqInt i1;
    sqInt key;
    sqInt key1;
    sqInt listOffset;
    sqInt oldCorpse;
    sqInt oldList;
    sqInt referent;
    sqInt referrer;
    sqInt unfiredEphemeronsScavenged;
    sqInt unfiredEphemeronsScavenged1;
    sqInt valuePointer;
    sqInt valuePointer1;

	/* begin scavengeUnfiredEphemeronsInRememberedSet */
	unfiredEphemeronsScavenged1 = 0;
	i1 = 0;
	while (i1 < GIV(numRememberedEphemerons)) {
		referrer = GIV(rememberedSet)[i1];
		assert(isEphemeron(referrer, self));
		if (isScavengeSurvivor((assert((isNonImmediate(referrer, self))
			 && (isObjEphemeron(referrer, self))),
		/* begin fetchPointer:ofObject: */
		longAt((referrer + BaseHeaderSize) + (0U << (shiftForWord(self))))), self)) {
			unfiredEphemeronsScavenged1 = 1;

			/* remove from unscanned ephemerons in set by swapping with last ephemeron */
			hasNewReferents = scavengeReferentsOf(referrer, self);
			GIV(numRememberedEphemerons) -= 1;
			GIV(rememberedSet)[i1] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			if (hasNewReferents) {

				/* keep in set */
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			}
			else {

				/* remove from set by overwriting with next-to-be scanned */
				GIV(previousRememberedSetSize) -= 1;
				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
				/* begin setIsRememberedOf:to: */
				longAtput(referrer, (longAt(referrer)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
			}
		}
		else {
			i1 += 1;
		}
	}
	unfiredEphemeronsScavenged = unfiredEphemeronsScavenged1;
	if (scavengeUnfiredEphemeronsOnEphemeronList(self)) {
		unfiredEphemeronsScavenged = 1;
	}
	if (!unfiredEphemeronsScavenged) {
		/* begin fireEphemeronsInRememberedSet */
		assert(noUnfiredEphemeronsAtEndOfRememberedSet(self));
		i = 0;
		while (i < GIV(numRememberedEphemerons)) {
			ephemeron = GIV(rememberedSet)[i];
			assert(isEphemeron(ephemeron, self));
			assert((isNonImmediate(ephemeron, self))
			 && (isObjEphemeron(ephemeron, self)));
			/* begin fetchPointer:ofObject: */
			key = longAt((ephemeron + BaseHeaderSize) + (0U << (shiftForWord(self))));
			if (!(isScavengeSurvivor(key, self))) {
				/* begin fireEphemeron: */
				queueMourner(ephemeron, self);
				/* begin setFormatOf:to: */
				assert(((1 /* nonIndexablePointerFormat */ >= 0) && (1 /* nonIndexablePointerFormat */ <= (formatMask(self)))));
				longAtput(ephemeron, ((longAt(ephemeron)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))))) + (1U << (formatShift(self))));
				/* begin signalFinalization: */
				forceInterruptCheck(self);
				GIV(pendingFinalizationSignals) += 1;
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer = copyAndForward(key, self);
				assert(!(isOopForwarded(ephemeron, self)));
				longAtput((ephemeron + BaseHeaderSize) + (0U << (shiftForWord(self))), valuePointer);
			}
			assert(!(((isScavengeSurvivor(key, self))
 && (isEphemeron(ephemeron, self)))));
			if (scavengeReferentsOf(ephemeron, self)) {

				/* keep in set */
				i += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(ephemeron, (longAt(ephemeron)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
				GIV(numRememberedEphemerons) -= 1;
				GIV(previousRememberedSetSize) -= 1;

				/* First overwrite with last firable ephemeron (could be a noop if this is the last one).
				   Then overwrite last firable entry with next unscanned rememberedSet entry (could also be a noop).
				   Then overwrite next unscanned entry with last unscanned rememberedSet entry (could also be a noop). */
				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
			}
		}
		GIV(numRememberedEphemerons) = 0;
		/* begin fireEphemeronsOnEphemeronList */
		if (!(GIV(ephemeronList))) {
			goto l10;
		}
		oldCorpse = null;
		/* begin corpseForCorpseOffset: */
		ephemeronCorpse = (((sqInt)((usqInt)((GIV(ephemeronList) - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart);
		oldList = GIV(ephemeronList);
		GIV(ephemeronList) = null;
		while (ephemeronCorpse != null) {
			assert((isYoung(ephemeronCorpse, self))
			 && (isForwarded(ephemeronCorpse, self)));
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(ephemeronCorpse, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((ephemeronCorpse + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent & (tagMask(self))) == 0)
			 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			ephemeron1 = referent;
			assert((isNonImmediate(ephemeron1, self))
			 && (isMaybeFiredEphemeron(ephemeron1, self)));
			/* begin fetchPointer:ofObject: */
			key1 = longAt((ephemeron1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			if (!(isScavengeSurvivor(key1, self))) {
				/* begin fireEphemeron: */
				queueMourner(ephemeron1, self);
				/* begin setFormatOf:to: */
				assert(((1 /* nonIndexablePointerFormat */ >= 0) && (1 /* nonIndexablePointerFormat */ <= (formatMask(self)))));
				longAtput(ephemeron1, ((longAt(ephemeron1)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))))) + (1U << (formatShift(self))));
				/* begin signalFinalization: */
				forceInterruptCheck(self);
				GIV(pendingFinalizationSignals) += 1;
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer1 = copyAndForward(key1, self);
				assert(!(isOopForwarded(ephemeron1, self)));
				longAtput((ephemeron1 + BaseHeaderSize) + (0U << (shiftForWord(self))), valuePointer1);
			}
			assert(!(((isScavengeSurvivor(key1, self))
 && (isEphemeron(ephemeron1, self)))));
			((void) (scavengeReferentsOf(ephemeron1, self)));
			oldCorpse = ephemeronCorpse;
			/* begin nextCorpseOrNil: */
			assert(isYoung(ephemeronCorpse, self));
			listOffset = (((sqInt)((usqInt)(((long32At(ephemeronCorpse + 4)) & (identityHashHalfWordMask(self)))) << (formatFieldWidthShift(self))))) + ((((usqInt) (longAt(ephemeronCorpse))) >> (formatShift(self))) & (formatMask(self)));
			ephemeronCorpse = (listOffset != 0
				? (/* begin corpseForCorpseOffset: */
					(((sqInt)((usqInt)((listOffset - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart))
				: 0);
		}
	l10:	/* end fireEphemeronsOnEphemeronList */;
	}
}


/*	Go through the remembered set and the weak list, nilling references to
	any objects that didn't survive the scavenge. Read the class comment
	for a more in-depth description of the algorithm. */

	/* SpurGenerationScavenger>>#processWeaklings */
static void
processWeaklings(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt listOffset;
    sqInt referent;
    sqInt rootObj;
    usqInt weakCorpse;
    sqInt weakObj;

	assert(allWeakSurvivorsOnWeakList(self));
	i = 0;
	while (i < GIV(rememberedSetSize)) {
		rootObj = GIV(rememberedSet)[i];
		if (isWeakFormat((((usqInt) (longAt(rootObj))) >> (formatShift(self))) & (formatMask(self)), self)) {

			/* If no more referents, remove by overwriting with the last element in the set. */
			if (processWeakSurvivor(rootObj, self)) {
				i += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(rootObj, (longAt(rootObj)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
				if ((i + 1) < GIV(rememberedSetSize)) {
					GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
				}
				GIV(rememberedSetSize) -= 1;
			}
		}
		else {
			i += 1;
		}
	}
	if (GIV(weakList)) {
		/* begin firstCorpse: */
		weakCorpse = (((sqInt)((usqInt)((GIV(weakList) - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart);
		while (weakCorpse != null) {
			assert(isForwarded(weakCorpse, self));
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(weakCorpse, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((weakCorpse + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent & (tagMask(self))) == 0)
			 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			weakObj = referent;
			if ((processWeakSurvivor(weakObj, self))
			 && (((assert(isNonImmediate(weakObj, self)),
			oopisGreaterThanOrEqualTo(weakObj, GIV(oldSpaceStart), self)))
			 && (!(((((usqInt) (longAt(weakObj))) >> (rememberedBitShift(self))) & 1) != 0)))) {
				remember(weakObj, self);
			}
			/* begin nextCorpseOrNil: */
			assert(isYoung(weakCorpse, self));
			listOffset = (((sqInt)((usqInt)(((long32At(weakCorpse + 4)) & (identityHashHalfWordMask(self)))) << (formatFieldWidthShift(self))))) + ((((usqInt) (longAt(weakCorpse))) >> (formatShift(self))) & (formatMask(self)));
			weakCorpse = (listOffset != 0
				? (/* begin corpseForCorpseOffset: */
					(((sqInt)((usqInt)((listOffset - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart))
				: 0);
		}
		GIV(weakList) = null;
	}
}


/*	Process a weak survivor on the weakList. Those of its fields
	which have not survived the scavenge should be nilled, and if any
	are, the coInterpreter should be informed via fireFinalization:.
	Answer if the weakObj has any young referents. */

	/* SpurGenerationScavenger>>#processWeakSurvivor: */
static sqInt NoDbgRegParms
processWeakSurvivor(sqInt weakObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classPointer;
    sqInt hasYoungReferents;
    sqInt i;
    sqInt iLimiT;
    sqInt numStrongSlots;
    sqInt referent;
    sqInt referent1;
    sqInt weakObjShouldMourn;


	/* N.B. generateToByDoLimitExpression:negative:on: guards against (unsigned)0 - 1 going +ve */
	weakObjShouldMourn = (hasYoungReferents = 0);
	/* begin fixedFieldsOfClassFormat: */
	classPointer = fetchClassOfNonImm(weakObj, self);
	classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	numStrongSlots = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	for (i = 0; i < numStrongSlots; i += 1) {
		referent = longAt((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if (((referent & (tagMask(self))) == 0)
		 && ((assert(isNonImmediate(referent, self)),
		oopisLessThan(referent, GIV(newSpaceLimit), self)))) {
			hasYoungReferents = 1;
		}
	}
	for (i = numStrongSlots, iLimiT = ((numSlotsOf(weakObj, self)) - 1); i <= iLimiT; i += 1) {

		/* Referent could be forwarded due to scavenging or a become:, don't assume. */
		referent = longAt((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if ((referent & (tagMask(self))) == 0) {
			if (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(referent, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent1 = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent1 & (tagMask(self))) == 0)
				 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				referent = referent1;
				assert((isReallyYoungObject(weakObj, self))
				 || (isRemembered(weakObj, self)));
				assert(!(isOopForwarded(weakObj, self)));
				longAtput((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), referent);
			}
			if (isMaybeOldScavengeSurvivor(referent, self)) {
				if ((assert(isNonImmediate(referent, self)),
				oopisLessThan(referent, GIV(newSpaceLimit), self))) {
					hasYoungReferents = 1;
				}
			}
			else {
				weakObjShouldMourn = 1;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(weakObj, self)));
				longAtput((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), GIV(nilObj));
			}
		}
	}
	if (weakObjShouldMourn) {
		/* begin fireFinalization: */
		if (GIV(newFinalization)) {
			queueMourner(weakObj, self);
		}
		/* begin signalFinalization: */
		forceInterruptCheck(self);
		GIV(pendingFinalizationSignals) += 1;
	}
	return hasYoungReferents;
}


/*	Add the argument to the remembered set and set its isRemembered bit to
	true. Answer the argument for the benefit of the Cogit. */

	/* SpurGenerationScavenger>>#remember: */
sqInt
remember(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop, self));
	assert(!((isYoungObject(objOop, self))));
	assert(!((isRemembered(objOop, self))));
	assert(!((isInRememberedSet(objOop, self))));
	/* begin setIsRememberedOf:to: */
	longAtput(objOop, (longAt(objOop)) | (1U << (rememberedBitShift(self))));
	if (GIV(rememberedSetSize) >= GIV(rememberedSetLimit)) {
		growRememberedSet(self);
	}
	GIV(rememberedSet)[GIV(rememberedSetSize)] = objOop;
	if (((GIV(rememberedSetSize) += 1)) >= GIV(rememberedSetRedZone)) {
		/* begin scheduleScavenge */
		GIV(needGCFlag) = 1;
		forceInterruptCheck(self);
	}
	return objOop;
}


/*	scavengeFutureSurvivorSpaceStartingAt: does a depth-first traversal of the
	new objects starting at the one at initialAddress in futureSurvivorSpace. */

	/* SpurGenerationScavenger>>#scavengeFutureSurvivorSpaceStartingAt: */
static void NoDbgRegParms
scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    sqInt obj;
    usqInt ptr;

	ptr = initialAddress;
	while (ptr < GIV(futureSurvivorStart)) {
		/* begin objectStartingAt: */
		numSlots = byteAt(ptr + 7);
		obj = (numSlots == (numSlotsMask(self))
			? ptr + BaseHeaderSize
			: ptr);
		ptr = addressAfter(obj, self);
		((void) (scavengeReferentsOf(obj, self)));
	}
}


/*	This is the inner loop of the main routine, scavenge. It first scavenges
	the new objects immediately
	reachable from old ones. Then it scavenges those that are transitively
	reachable. If this results in a
	promotion, the promotee gets remembered, and it first scavenges objects
	adjacent to the promotee,
	then scavenges the ones reachable from the promoted. This loop continues
	until no more reachable
	objects are left. At that point, pastSurvivorSpace is exchanged with
	futureSurvivorSpace. 
	Notice that each pointer in a live object is inspected once and only once.
	The previousRememberedSetSize
	and previousFutureSurvivorSpaceLimit variables ensure that no object is
	scanned twice, as well as
	detecting closure. If this were not true, some pointers might get
	forwarded twice.
	
	An extension of the algorithm presented in David's original paper is to
	handle weak arrays and ephemerons.
	Weak arrays should not have their weak referents scavenged unless there
	are strong references to them.
	Ephemerons should fire if their key is not reachable other than from
	ephemerons and weak arrays.
	Handle this by maintaining a list for weak arrays and a list for
	ephemerons, which allow scavenging these
	objects once all other objects in new space have been scavenged, hence
	allowing the scavenger to
	detect which referents in new space of weak arrays are dead and of
	ephemeron keys are only live due to
	ephemerons. Read the class comment for a more in-depth description of the
	algorithm.  */

	/* SpurGenerationScavenger>>#scavengeLoop */
static void
scavengeLoop(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstTime;
    sqInt i;
    sqInt previousFutureSurvivorStart;
    StackPage *thePage;

	assert(GIV(futureSurvivorStart) == ((GIV(futureSpace).start)));
	GIV(weakList) = (GIV(ephemeronList) = null);
	GIV(numRememberedEphemerons) = 0;
	firstTime = 1;
	GIV(previousRememberedSetSize) = 0;
	previousFutureSurvivorStart = GIV(futureSurvivorStart);
	/* begin initStackPageGC */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
	}
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		(thePage->trace = StackPageUnreached);
	}
	while(1) {
		scavengeRememberedSetStartingAt(GIV(previousRememberedSetSize), self);
		GIV(previousRememberedSetSize) = GIV(rememberedSetSize);
		if (firstTime) {
			mapInterpreterOops(self);
			mapMournQueue(self);
			mapExtraRoots(self);
			firstTime = 0;
		}
		if ((GIV(previousRememberedSetSize) == GIV(rememberedSetSize))
		 && ((previousFutureSurvivorStart == GIV(futureSurvivorStart))
		 && ((GIV(numRememberedEphemerons) == 0)
		 && (GIV(ephemeronList) == null)))) {
			return;
		}
		scavengeFutureSurvivorSpaceStartingAt(previousFutureSurvivorStart, self);

		/* no more roots created to scavenge... */
		previousFutureSurvivorStart = GIV(futureSurvivorStart);
		if (GIV(previousRememberedSetSize) == GIV(rememberedSetSize)) {
			if ((GIV(numRememberedEphemerons) == 0)
			 && (GIV(ephemeronList) == null)) {
				return;
			}
			processEphemerons(self);
		}
	}
}


/*	scavengeReferentsOf: referrer inspects all the pointers in referrer. If
	any are new objects, it has them moved to FutureSurvivorSpace, and
	answers truth. If there are no new referents, it answers falsity. To
	handle weak arrays, if the referrer is weak only scavenge strong slots and
	answer true so that it won't be removed from the remembered set until
	later.  */
/*	forwarding objects should be followed by callers,
	unless the forwarder is a root in the remembered table. */

	/* SpurGenerationScavenger>>#scavengeReferentsOf: */
static sqInt NoDbgRegParms
scavengeReferentsOf(sqInt referrer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt contextSize;
    sqInt fmt;
    sqInt foundNewReferentOrIsWeakling;
    sqInt header;
    sqInt i;
    sqInt newLocation;
    sqInt numLiterals;
    sqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop1;
    sqInt referent;
    sqInt referent1;
    sqInt sp;


	/* forwarding objects should be followed by callers,
	   unless the forwarder is a root in the remembered table. */
	assert((!(isForwarded(referrer, self)))
	 || (isRemembered(referrer, self)));
	assert((!(isEphemeron(referrer, self)))
	 || ((isScavengeSurvivor(keyOfEphemeron(referrer, self), self))
	 || (isonWeaklingList(referrer, GIV(ephemeronList), self))));
	fmt = (((usqInt) (longAt(referrer))) >> (formatShift(self))) & (formatMask(self));
	foundNewReferentOrIsWeakling = fmt == (weakArrayFormat(self));
	/* begin numStrongSlotsOf:format:ephemeronInactiveIf: */
	if (fmt <= 5 /* lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(referrer, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(referrer + 7);
		numSlots2 = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(referrer - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 2 /* arrayFormat */) {
			numSlots = numSlots2;
			goto l8;
		}
		if (fmt == (indexablePointersFormat(self))) {
			if (((longAt(referrer)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(referrer, self);
				/* begin fetchStackPointerOf: */
				sp = longAt((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l4;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(referrer, self)));
				contextSize = (sp >> 3);
	l4:	/* end fetchStackPointerOf: */;
				numSlots = CtxtTempFrameStart + contextSize;
				goto l8;
			}
			numSlots = numSlots2;
			goto l8;
		}
		if (fmt == (weakArrayFormat(self))) {
			/* begin fixedFieldsOfClass: */
			objOop1 = fetchClassOfNonImm(referrer, self);
			/* begin fixedFieldsOfClassFormat: */
			classFormat = ((longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
			numSlots = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
			goto l8;
		}
		assert(fmt == (ephemeronFormat(self)));
		numSlots = (isScavengeSurvivor((keyOfEphemeron(referrer, self)), self)
			? numSlots2
			: 0);
		goto l8;
	}
	if (fmt == 7 /* forwardedFormat */) {
		numSlots = 1;
		goto l8;
	}
	if (fmt < (firstCompiledMethodFormat(self))) {
		numSlots = 0;
		goto l8;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(referrer, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	numSlots = numLiterals + LiteralStart;
	l8:	/* end numStrongSlotsOf:format:ephemeronInactiveIf: */;
	for (i = 0; i < numSlots; i += 1) {
		referent = longAt((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if ((referent & (tagMask(self))) == 0) {

			/* a forwarding pointer could be because of become: or scavenging. */
			if (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(referent, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent1 = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent1 & (tagMask(self))) == 0)
				 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				referent = referent1;
			}
			if ((assert(isNonImmediate(referent, self)),
			oopisLessThan(referent, GIV(newSpaceLimit), self))) {

				/* if target is already in future space forwarding pointer was due to a become:. */
				if (oopisGreaterThanOrEqualToandLessThan(referent, ((futureSpace(self)).start), futureSurvivorStart(self), self)) {
					newLocation = referent;
					foundNewReferentOrIsWeakling = 1;
				}
				else {
					newLocation = copyAndForward(referent, self);
					if (((newLocation & (tagMask(self))) == 0)
					 && (oopisLessThan(newLocation, GIV(newSpaceLimit), self))) {
						foundNewReferentOrIsWeakling = 1;
					}
				}
				longAtput((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), newLocation);
			}
			else {
				longAtput((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), referent);
			}
		}
	}
	return foundNewReferentOrIsWeakling;
}


/*	scavengeRememberedSetStartingAt: n traverses objects in the remembered
	set starting at the nth one. If the object does not refer to any new
	objects, it
	is removed from the set. Otherwise, its new referents are scavenged. Defer
	scavenging ephemerons until after a complete scavenge has been performed,
	so that triggered ephemerons can be fired. Move them to the front of the
	set and count them in numRememberedEphemerons for later scanning. */

	/* SpurGenerationScavenger>>#scavengeRememberedSetStartingAt: */
static void NoDbgRegParms
scavengeRememberedSetStartingAt(sqInt n, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt destIndex;
    sqInt format;
    sqInt referrer;
    sqInt sourceIndex;

	sourceIndex = (destIndex = n);
	while (sourceIndex < GIV(rememberedSetSize)) {

		/* *Don't* follow forwarding pointers here. oldSpace objects may refer
		   to these roots, and so they can't be removed in the scavenge. */

		/* Any potential firing ephemerons should not be scanned yet.
		   Move any to the front of the set to save time in later scanning. */
		referrer = GIV(rememberedSet)[sourceIndex];
		if (((assert(isNonImmediate(referrer, self)),
		/* begin isEphemeronFormat: */
		(format = (((usqInt) (longAt(referrer))) >> (formatShift(self))) & (formatMask(self))),
		format == 5 /* ephemeronFormat */))
		 && (!(isScavengeSurvivor((assert((isNonImmediate(referrer, self))
			 && (isObjEphemeron(referrer, self))),
		/* begin fetchPointer:ofObject: */
		longAt((referrer + BaseHeaderSize) + (0U << (shiftForWord(self))))), self)))) {
			assert(destIndex >= GIV(numRememberedEphemerons));
			GIV(rememberedSet)[destIndex] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			GIV(numRememberedEphemerons) += 1;
			destIndex += 1;
		}
		else {
			if (scavengeReferentsOf(referrer, self)) {
				GIV(rememberedSet)[destIndex] = referrer;
				destIndex += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(referrer, (longAt(referrer)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
			}
		}
		sourceIndex += 1;
	}
	GIV(rememberedSetSize) = destIndex;
	assert(noUnfiredEphemeronsAtEndOfRememberedSet(self));
}


/*	(Slang flattens so need unique selectors) */

	/* SpurGenerationScavenger>>#scavengerTenuringThreshold */
static float
scavengerTenuringThreshold(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(tenureThreshold) >= ((GIV(pastSpace).start))
		? (((double) (GIV(tenureThreshold) - ((GIV(pastSpace).start))) )) / (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))
		: 0);
}


/*	There may be ephemerons to be scavenged on the ephemeronList.
	Scavenge any with unfired (live) keys, removing them from the
	list, and answer if any with unfired keys were found. */

	/* SpurGenerationScavenger>>#scavengeUnfiredEphemeronsOnEphemeronList */
static sqInt
scavengeUnfiredEphemeronsOnEphemeronList(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt corpseOffset;
    sqInt ephemeron;
    usqInt ephemeronCorpse;
    sqInt nextCorpseOffset;
    usqInt previousCorpse;
    sqInt referent;
    sqInt unfiredEphemeronsScavenged;

	previousCorpse = 0;
	if (!(GIV(ephemeronList))) {
		return 0;
	}
	unfiredEphemeronsScavenged = 0;
	corpseOffset = GIV(ephemeronList);
	while (corpseOffset != 0) {
		/* begin corpseForCorpseOffset: */
		ephemeronCorpse = (((sqInt)((usqInt)((corpseOffset - 1)) << 3 /* shiftForAllocationUnit */))) + GIV(newSpaceStart);
		assert(isForwarded(ephemeronCorpse, self));
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(ephemeronCorpse, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((ephemeronCorpse + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		ephemeron = referent;
		nextCorpseOffset = (((sqInt)((usqInt)(((long32At(ephemeronCorpse + 4)) & (identityHashHalfWordMask(self)))) << (formatFieldWidthShift(self))))) + ((((usqInt) (longAt(ephemeronCorpse))) >> (formatShift(self))) & (formatMask(self)));
		if (isScavengeSurvivor((assert((isNonImmediate(ephemeron, self))
			 && (isObjEphemeron(ephemeron, self))),
		/* begin fetchPointer:ofObject: */
		longAt((ephemeron + BaseHeaderSize) + (0U << (shiftForWord(self))))), self)) {
			if (corpseOffset == GIV(ephemeronList)) {
				GIV(ephemeronList) = (nextCorpseOffset != 0
					? nextCorpseOffset
					: 0);
			}
			else {
				/* begin setCorpseOffsetOf:to: */
				assert(isYoung(previousCorpse, self));
				assert(isForwarded(previousCorpse, self));
				
				/* So we use the single assignment */
				long64Atput(previousCorpse, headerForSlotshashformatclassIndex(byteAt(previousCorpse + 7), ((usqInt) nextCorpseOffset) >> (formatFieldWidthShift(self)), nextCorpseOffset & (formatMask(self)), isForwardedObjectClassIndexPun(self), self));
			}
			unfiredEphemeronsScavenged = 1;
			((void) (scavengeReferentsOf(ephemeron, self)));
		}
		else {
			previousCorpse = ephemeronCorpse;
		}
		corpseOffset = nextCorpseOffset;
	}
	return unfiredEphemeronsScavenged;
}


/*	Output the entire record. */

	/* SpurGenerationScavenger>>#writeScavengeLog */
static void NeverInline
writeScavengeLog(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static char *policyNames[] = {"", "by age", "by class", "to shrink rt", "don't tenure", "mark on tenure"};

	fprintf(GIV(scavengeLog), "scavenge %" PRIdSQINT " eden bytes: 0x%" PRIxSQINT "/%" PRIdSQINT " past bytes: 0x%" PRIxSQINT "/%" PRIdSQINT "\n\trem set: %" PRIdSQINT " redzone: %" PRIdSQINT " size: %" PRIdSQINT "\n", GIV(statScavenges), (GIV(scavengeLogRecord).sEdenBytes), (GIV(scavengeLogRecord).sEdenBytes), (GIV(scavengeLogRecord).sPastBytes), (GIV(scavengeLogRecord).sPastBytes), (GIV(scavengeLogRecord).sRememberedSetSize), (GIV(scavengeLogRecord).sRememberedSetRedZone), (GIV(scavengeLogRecord).sRememberedSetLimit));
	fprintf(GIV(scavengeLog), (((GIV(scavengeLogRecord).tTenureCriterion)) == TenureToShrinkRT
		? "\ttenure below 0x%" PRIxSQINT "/%" PRIdSQINT " %s refct %" PRIdSQINT "\n"
		: "\ttenure below 0x%" PRIxSQINT "/%" PRIdSQINT " %s\n"), (GIV(scavengeLogRecord).tTenureThreshold), (GIV(scavengeLogRecord).tTenureThreshold), policyNames[(GIV(scavengeLogRecord).tTenureCriterion)], (GIV(scavengeLogRecord).tRefCountToShrinkRT));
	fprintf(GIV(scavengeLog), "\tsurvivor bytes: 0x%" PRIxSQINT "/%" PRIdSQINT " rem set: %" PRIdSQINT " tenured: %" PRIdSQINT " usecs: %" PRIdSQINT "\n", (GIV(scavengeLogRecord).eSurvivorBytes), (GIV(scavengeLogRecord).eSurvivorBytes), (GIV(scavengeLogRecord).eRememberedSetSize), ((GIV(scavengeLogRecord).eStatTenures)) - ((GIV(scavengeLogRecord).sStatTenures)), GIV(statSGCDeltaUsecs));
	fflush(GIV(scavengeLog));
}


/*	Answer the accessible object following the given object or 
	free chunk in the heap. Return nil when heap is exhausted.
	This is for primitiveNextObject subsequent to primtiiveSomeObject.
	It also tries to handle more general use by ordering objects as
	eden
	past
	old
	but this is tricky becaus ethe order in memory is
	past
	eden
	old */

	/* SpurMemoryManager>>#accessibleObjectAfter: */
static sqInt NoDbgRegParms
accessibleObjectAfter(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt numSlots;
    sqInt objAfter;

	objAfter = objOop;
	if (oopisLessThan(objAfter, GIV(nilObj), self)) {

		/* object in new space */
		assert((isInEden(objOop, self))
		 || (isInPastSpace(objOop, self)));
		if (oopisGreaterThan(objAfter, GIV(pastSpaceStart), self)) {

			/* Obj is in eden.  Answer next normal object in eden, if there is one. */
			while (1) {
				/* begin objectAfter:limit: */
				followingWordAddress = addressAfter(objAfter, self);
				if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart), self)) {
					objAfter = GIV(freeStart);
					goto l1;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				objAfter = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
				if (!(oopisLessThan(objAfter, GIV(freeStart), self))) break;
				if (((longAt(objAfter)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
					return objAfter;
				}
			}
			if (GIV(pastSpaceStart) <= (((pastSpace(self)).start))) {
				return GIV(nilObj);
			}
			/* begin objectStartingAt: */
			address = ((pastSpace(self)).start);
			numSlots = byteAt(address + 7);
			objAfter = (numSlots == (numSlotsMask(self))
				? address + BaseHeaderSize
				: address);
			if (((longAt(objAfter)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				return objAfter;
			}
		}
		while (1) {
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objAfter, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart), self)) {
				objAfter = GIV(pastSpaceStart);
				goto l3;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objAfter = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l3:	/* end objectAfter:limit: */;
			if (!(oopisLessThan(objAfter, GIV(pastSpaceStart), self))) break;
			if (((longAt(objAfter)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				return objAfter;
			}
		}
		return GIV(nilObj);
	}
	while(1) {
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objAfter, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objAfter = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objAfter = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l4:	/* end objectAfter:limit: */;
		if (objAfter == GIV(endOfMemory)) {
			return null;
		}
		if (((longAt(objAfter)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
			return objAfter;
		}
	}
	return 0;
}


/*	Answer whether an ephemeron is active (has an unmarked
	key) and was pushed on the unscanned ephemerons stack. */

	/* SpurMemoryManager>>#activeAndDeferredScan: */
static sqInt NoDbgRegParms NeverInline
activeAndDeferredScan(sqInt anEphemeron, struct foo * self)
{
    sqInt key;

	assert(isEphemeron(anEphemeron, self));
	if ((isImmediate((assert((isNonImmediate(anEphemeron, self))
		 && (isObjEphemeron(anEphemeron, self))),
	/* begin fetchPointer:ofObject: */
	(key = longAt((anEphemeron + BaseHeaderSize) + (0U << (shiftForWord(self)))))), self))
	 || (((((usqInt) (longAt(key))) >> (markedBitFullShift(self))) & 1) != 0)) {
		return 0;
	}
	return pushOnUnscannedEphemeronsStack(anEphemeron, self);
}


/*	Add a freeChunk sub tree back into the large free chunk tree.
	This is for allocateOldSpaceChunkOf[Exactly]Bytes:[suchThat:]. */
/*	N.B. *can't* use numSlotsOfAny: because of rounding up of odd slots
	and/or step in size at 1032 bytes in 32-bits or 2048 bytes in 64-bits. */

	/* SpurMemoryManager>>#addFreeSubTree: */
static void NoDbgRegParms
addFreeSubTree(sqInt freeTree, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInArg;
    usqInt bytesInNode;
    sqInt subNode;
    sqInt treeNode;


	/* N.B. *can't* use numSlotsOfAny: because of rounding up of odd slots
	   and/or step in size at 1032 bytes in 32-bits or 2048 bytes in 64-bits. */
	assert(isFreeObject(freeTree, self));
	bytesInArg = bytesInObject(freeTree, self);
	assert(bytesInArg >= ((numFreeLists(self)) * (allocationUnit(self))));
	treeNode = GIV(freeLists)[0];
	assert(treeNode != 0);
	while(1) {

		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		bytesInNode = bytesInObject(treeNode, self);
		assert((oopisLessThanOrEqualTo((freeTree + bytesInArg) - BaseHeaderSize, treeNode, self))
		 || (oopisGreaterThanOrEqualTo(freeTree, (treeNode + bytesInNode) - BaseHeaderSize, self)));
		assert(bytesInNode >= ((numFreeLists(self)) * (allocationUnit(self))));
		assert(bytesInArg != bytesInNode);
		if (bytesInNode > bytesInArg) {
			/* begin fetchPointer:ofFreeChunk: */
			subNode = longAt((treeNode + BaseHeaderSize) + (3U << (shiftForWord(self))));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode, self));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree, self)));
				longAtput((treeNode + BaseHeaderSize) + (3U << (shiftForWord(self))), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree, self));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode, self)));
				longAtput((freeTree + BaseHeaderSize) + (2U << (shiftForWord(self))), treeNode);
				return;
			}
		}
		else {
			/* begin fetchPointer:ofFreeChunk: */
			subNode = longAt((treeNode + BaseHeaderSize) + (4U << (shiftForWord(self))));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode, self));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree, self)));
				longAtput((treeNode + BaseHeaderSize) + (4U << (shiftForWord(self))), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree, self));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode, self)));
				longAtput((freeTree + BaseHeaderSize) + (2U << (shiftForWord(self))), treeNode);
				return;
			}
		}
		treeNode = subNode;
	}
}


/*	Add the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#addGCRoot: */
sqInt
addGCRoot(sqInt *varLoc, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootsSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}

	/* SpurMemoryManager>>#addressCouldBeObj: */
sqInt
addressCouldBeObj(sqInt address, struct foo * self)
{
	return (address & (BaseHeaderSize - 1)) == 0;
}


/*	Answer if address appears to be that of either an immediate or an object.
	For code disassembly and assertions. */

	/* SpurMemoryManager>>#addressCouldBeOop: */
sqInt
addressCouldBeOop(sqInt address, struct foo * self)
{
	return (address & (tagMask(self)))
	 || (addressCouldBeObj(address, self));
}


/*	Add freeChunk to the relevant freeList.
	For the benefit of sortedFreeObject:, if freeChunk is large, answer the
	treeNode it
	is added to, if it is added to the next list of a freeTreeNode, otherwise
	answer 0. */
/*	coInterpreter transcript ensureCr. coInterpreter print: 'freeing '. self
	printFreeChunk: freeChunk.
 */

	/* SpurMemoryManager>>#addToFreeList:bytes: */
static sqInt NoDbgRegParms
addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    sqInt parent;


	/* coInterpreter transcript ensureCr. coInterpreter print: 'freeing '. self printFreeChunk: freeChunk. */
	assert(isFreeObject(freeChunk, self));
	assert(chunkBytes == (bytesInObject(freeChunk, self)));
	index = chunkBytes / 8 /* allocationUnit */;
	if (index < 64 /* numFreeLists */) {
		/* begin setNextFreeChunkOf:withValue:chunkBytes: */
		nextFreeChunk = GIV(freeLists)[index];
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		assert(isFreeObject(freeChunk, self));
		assert((nextFreeChunk == 0)
		 || (isFreeObject(nextFreeChunk, self)));
		longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk);
		if ((nextFreeChunk != 0)
		 && (!((assert(chunkBytes >= (BaseHeaderSize + (allocationUnit(self)))),
		chunkBytes == (BaseHeaderSize + 8 /* allocationUnit */))))) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk, self));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk, self)));
			longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), freeChunk);
		}
		if (!((assert(chunkBytes >= (BaseHeaderSize + (allocationUnit(self)))),
			chunkBytes == (BaseHeaderSize + 8 /* allocationUnit */)))) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(freeChunk, self));
			assert(1);
			longAtput((freeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), 0);
		}
		GIV(freeLists)[index] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | (1ULL << index);
		return 0;
	}
	/* begin addToFreeTree:bytes: */
	assert(isFreeObject(freeChunk, self));
	assert(chunkBytes == (bytesInObject(freeChunk, self)));
	assert(chunkBytes >= ((numFreeLists(self)) * (allocationUnit(self))));
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk, self));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk, self));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk, self));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (2U << (shiftForWord(self))), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk, self));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (3U << (shiftForWord(self))), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk, self));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (4U << (shiftForWord(self))), 0);
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {

		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		childBytes = bytesInObject(child, self);
		assert((oopisLessThanOrEqualTo((freeChunk + chunkBytes) - BaseHeaderSize, child, self))
		 || (oopisGreaterThanOrEqualTo(freeChunk, (child + childBytes) - BaseHeaderSize, self)));
		if (childBytes == chunkBytes) {

			/* size match; add to list at node. */
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			nextFreeChunk1 = longAt((child + BaseHeaderSize) + (0U << (shiftForWord(self))));
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(freeChunk, self));
			assert((nextFreeChunk1 == 0)
			 || (isFreeObject(nextFreeChunk1, self)));
			longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk1);
			if ((nextFreeChunk1 != 0)
			 && (!0)) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(nextFreeChunk1, self));
				assert((freeChunk == 0)
				 || (isFreeObject(freeChunk, self)));
				longAtput((nextFreeChunk1 + BaseHeaderSize) + (1U << (shiftForWord(self))), freeChunk);
			}
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			assert(isFreeObject(child, self));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk, self)));
			longAtput((child + BaseHeaderSize) + (0U << (shiftForWord(self))), freeChunk);
			if ((freeChunk != 0)
			 && (!0)) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeChunk, self));
				assert((child == 0)
				 || (isFreeObject(child, self)));
				longAtput((freeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), child);
			}
			return child;
		}
		parent = child;
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex = (childBytes > chunkBytes
			? 3 /* freeChunkSmallerIndex */
			: 4 /* freeChunkLargerIndex */);
		child = longAt((child + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	}
	if (parent == 0) {
		assert((GIV(freeLists)[0]) == 0);
		GIV(freeLists)[0] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | 1;
		return 0;
	}
	assert(GIV(freeListsMask) & 1);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk, self));
	assert((parent == 0)
	 || (isFreeObject(parent, self)));
	longAtput((freeChunk + BaseHeaderSize) + (2U << (shiftForWord(self))), parent);
	/* begin storePointer:ofFreeChunk:withValue: */
	fieldIndex1 = (childBytes > chunkBytes
		? 3 /* freeChunkSmallerIndex */
		: 4 /* freeChunkLargerIndex */);
	assert(isFreeObject(parent, self));
	assert((freeChunk == 0)
	 || (isFreeObject(freeChunk, self)));
	longAtput((parent + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))), freeChunk);
	return 0;
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of instances as a
	SmallInteger. Since objects are at least 16 bytes big, and the largest
	SmallInteger covers
	1/4 of the address space, the count can never overflow. */

	/* SpurMemoryManager>>#allInstancesOf: */
static sqInt NoDbgRegParms
allInstancesOf(sqInt aClass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualIndex;
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    usqInt bytes;
    sqInt classIndex;
    sqInt classOrNil;
    sqInt count;
    sqInt count1;
    sqInt count2;
    sqInt expectedIndex;
    sqInt expectedIndex1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord11;
    sqInt followingWord2;
    sqInt followingWord21;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress11;
    usqInt followingWordAddress2;
    usqInt followingWordAddress21;
    usqInt followingWordAddress3;
    sqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt index;
    sqInt j;
    usqInt limit;
    usqInt limit1;
    usqInt limit11;
    usqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt page;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj11;
    sqInt prevObj2;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj11;
    sqInt prevPrevObj2;
    sqInt ptr;
    sqInt ptr1;
    sqInt ptr2;
    sqInt smallObj;
    usqInt start;

	classIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask(self));
	if (classIndex == 0) {
		/* begin allocateSlots:format:classIndex: */
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (/* begin allocationUnit */ 8);
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck(self);
			}
			freeChunk = allocateSlotsInOldSpacebytesformatclassIndex(0, numBytes, 2 /* arrayFormat */, ClassArrayCompactIndex, self);
			goto l4;
		}
		longAtput(newObj, (((((usqLong) 0)) << (numSlotsFullShift(self))) + (2U << (formatShift(self)))) + ClassArrayCompactIndex);
		assert((numBytes % (allocationUnit(self))) == 0);
		assert((newObj % (allocationUnit(self))) == 0);
		GIV(freeStart) += numBytes;
		freeChunk = newObj;
	l4:	/* end allocateSlots:format:classIndex: */;
		return freeChunk;
	}
	
	/* N.B. Does /not/ update totalFreeOldSpace */
	freeChunk = allocateLargestFreeChunk(self);
	start = freeChunk + BaseHeaderSize;
	limit = addressAfter(freeChunk, self);
	if (isClassAtUniqueIndex(aClass, self)) {
		/* begin uniqueIndex:allInstancesInto:limit:resultsInto: */
		count1 = 0;
		ptr1 = start;
		/* begin allHeapEntitiesDo: */
		assert(isOldObject(GIV(nilObj), self));
		prevPrevObj1 = (prevObj1 = null);
		objOop1 = GIV(nilObj);
		while (1) {
			assert((objOop1 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
			assert((long64At(objOop1)) != 0);
			
			/* continue enumerating even if no room so as to unmark all objects. */
			if (((longAt(objOop1)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				if (((longAt(objOop1)) & (classIndexMask(self))) == classIndex) {
					count1 += 1;
					if (ptr1 < limit) {
						longAtput(ptr1, objOop1);
						ptr1 += BytesPerOop;
					}
				}
			}
			else {
							}
			prevPrevObj1 = prevObj1;
			prevObj1 = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress2 = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
				objOop1 = GIV(endOfMemory);
				goto l9;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
	l9:	/* end objectAfter:limit: */;
		}
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((pastSpace(self)).start)) < (((eden(self)).start)));
		/* begin objectStartingAt: */
		address = ((pastSpace(self)).start);
		numSlots = byteAt(address + 7);
		objOop = (numSlots == (numSlotsMask(self))
			? address + BaseHeaderSize
			: address);
		limit1 = GIV(pastSpaceStart);
		while (oopisLessThan(objOop, limit1, self)) {
			
			/* continue enumerating even if no room so as to unmark all objects. */
			if (((longAt(objOop)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				if (((longAt(objOop)) & (classIndexMask(self))) == classIndex) {
					count1 += 1;
					if (ptr1 < limit) {
						longAtput(ptr1, objOop);
						ptr1 += BytesPerOop;
					}
				}
			}
			else {
							}
			prevPrevObj = prevObj;
			prevObj = objOop;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, limit1, self)) {
				objOop = limit1;
				goto l11;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l11:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address1 = ((eden(self)).start);
		numSlots1 = byteAt(address1 + 7);
		objOop = (numSlots1 == (numSlotsMask(self))
			? address1 + BaseHeaderSize
			: address1);
		while (oopisLessThan(objOop, GIV(freeStart), self)) {
			
			/* continue enumerating even if no room so as to unmark all objects. */
			if (((longAt(objOop)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				if (((longAt(objOop)) & (classIndexMask(self))) == classIndex) {
					count1 += 1;
					if (ptr1 < limit) {
						longAtput(ptr1, objOop);
						ptr1 += BytesPerOop;
					}
				}
			}
			else {
							}
			prevPrevObj = prevObj;
			prevObj = objOop;
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
				objOop = GIV(freeStart);
				goto l8;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l8:	/* end objectAfter:limit: */;
		}
		count = count1;
		ptr = ptr1;
	}
	else {
		/* begin ambiguousClass:allInstancesInto:limit:resultsInto: */
		count2 = 0;
		ptr2 = start;
		expectedIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask(self));
		/* begin allHeapEntitiesDo: */
		assert(isOldObject(GIV(nilObj), self));
		prevPrevObj11 = (prevObj11 = null);
		objOop11 = GIV(nilObj);
		while (1) {
			assert((objOop11 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
			assert((long64At(objOop11)) != 0);
			if (((longAt(objOop11)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				actualIndex = (longAt(objOop11)) & (classIndexMask(self));
				if ((classOrNilAtIndex(actualIndex, self)) == aClass) {
					if (actualIndex != expectedIndex) {
						/* begin setClassIndexOf:to: */
						assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask(self)))));
						longAtput(objOop11, ((longAt(objOop11)) & (~(usqIntptr_t)(classIndexMask(self)))) + expectedIndex);
					}
					count2 += 1;
					if (ptr2 < limit) {
						longAtput(ptr2, objOop11);
						ptr2 += BytesPerOop;
					}
				}
			}
			else {
							}
			prevPrevObj11 = prevObj11;
			prevObj11 = objOop11;
			/* begin objectAfter:limit: */
			followingWordAddress21 = addressAfter(objOop11, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress21, GIV(endOfMemory), self)) {
				objOop11 = GIV(endOfMemory);
				goto l14;
			}
			flag("endianness");
			followingWord21 = longAt(followingWordAddress21);
			objOop11 = ((((usqInt) followingWord21) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress21 + BaseHeaderSize
				: followingWordAddress21);
	l14:	/* end objectAfter:limit: */;
		}
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj2 = (prevObj2 = null);
		assert((((pastSpace(self)).start)) < (((eden(self)).start)));
		/* begin objectStartingAt: */
		address2 = ((pastSpace(self)).start);
		numSlots2 = byteAt(address2 + 7);
		objOop2 = (numSlots2 == (numSlotsMask(self))
			? address2 + BaseHeaderSize
			: address2);
		limit11 = GIV(pastSpaceStart);
		while (oopisLessThan(objOop2, limit11, self)) {
			if (((longAt(objOop2)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				actualIndex = (longAt(objOop2)) & (classIndexMask(self));
				if ((classOrNilAtIndex(actualIndex, self)) == aClass) {
					if (actualIndex != expectedIndex) {
						/* begin setClassIndexOf:to: */
						assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask(self)))));
						longAtput(objOop2, ((longAt(objOop2)) & (~(usqIntptr_t)(classIndexMask(self)))) + expectedIndex);
					}
					count2 += 1;
					if (ptr2 < limit) {
						longAtput(ptr2, objOop2);
						ptr2 += BytesPerOop;
					}
				}
			}
			else {
							}
			prevPrevObj2 = prevObj2;
			prevObj2 = objOop2;
			/* begin objectAfter:limit: */
			followingWordAddress3 = addressAfter(objOop2, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress3, limit11, self)) {
				objOop2 = limit11;
				goto l16;
			}
			flag("endianness");
			followingWord3 = longAt(followingWordAddress3);
			objOop2 = ((((usqInt) followingWord3) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress3 + BaseHeaderSize
				: followingWordAddress3);
	l16:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address11 = ((eden(self)).start);
		numSlots11 = byteAt(address11 + 7);
		objOop2 = (numSlots11 == (numSlotsMask(self))
			? address11 + BaseHeaderSize
			: address11);
		while (oopisLessThan(objOop2, GIV(freeStart), self)) {
			if (((longAt(objOop2)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				actualIndex = (longAt(objOop2)) & (classIndexMask(self));
				if ((classOrNilAtIndex(actualIndex, self)) == aClass) {
					if (actualIndex != expectedIndex) {
						/* begin setClassIndexOf:to: */
						assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask(self)))));
						longAtput(objOop2, ((longAt(objOop2)) & (~(usqIntptr_t)(classIndexMask(self)))) + expectedIndex);
					}
					count2 += 1;
					if (ptr2 < limit) {
						longAtput(ptr2, objOop2);
						ptr2 += BytesPerOop;
					}
				}
			}
			else {
							}
			prevPrevObj2 = prevObj2;
			prevObj2 = objOop2;
			/* begin objectAfter:limit: */
			followingWordAddress11 = addressAfter(objOop2, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress11, GIV(freeStart), self)) {
				objOop2 = GIV(freeStart);
				goto l13;
			}
			flag("endianness");
			followingWord11 = longAt(followingWordAddress11);
			objOop2 = ((((usqInt) followingWord11) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress11 + BaseHeaderSize
				: followingWordAddress11);
	l13:	/* end objectAfter:limit: */;
		}
		/* begin purgeDuplicateClassTableEntriesFor: */
		expectedIndex1 = (long32At(aClass + 4)) & (identityHashHalfWordMask(self));
		/* begin classTableEntriesDo: */
		for (i1 = 0; i1 < GIV(numClassTablePages); i1 += 1) {
			page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
			for (j = 0, iLimiT = ((1U << (classTableMajorIndexShift(self))) - 1); j <= iLimiT; j += 1) {
				classOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))));
				if (classOrNil != GIV(nilObj)) {
					index = (((sqInt)((usqInt)(i1) << (classTableMajorIndexShift(self))))) + j;
					if ((classOrNil == aClass)
					 && ((index != expectedIndex1)
					 && (index > (lastClassIndexPun(self))))) {
						classAtIndexput(index, GIV(nilObj), self);
						if (index < GIV(classTableIndex)) {
							GIV(classTableIndex) = index;
						}
					}
				}
			}
		}
		assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift(self))));
		count = count2;
		ptr = ptr2;
	}
	assert(isEmptyObjStack(GIV(markStack), self));
	assert(isEmptyObjStack(GIV(weaklingStack), self));
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8 /* allocationUnit */))) {

		/* can't split a single word */
		freeObject(freeChunk, self);
		return (((usqInt)count << 3) | 1);
	}
	if (count < (numSlotsMask(self))) {
		/* begin allocateSlots:format:classIndex: */
		if (count >= (numSlotsMask(self))) {
			if ((((usqInt) count) >> 56) > 0) {
				smallObj = null;
				goto l6;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes1 = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes1 = BaseHeaderSize + ((count < 1
	? /* begin allocationUnit */ 8
	: count * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck(self);
			}
			smallObj = allocateSlotsInOldSpacebytesformatclassIndex(count, numBytes1, 2 /* arrayFormat */, ClassArrayCompactIndex, self);
			goto l6;
		}
		if (count >= (numSlotsMask(self))) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + count);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(self), 2 /* arrayFormat */, ClassArrayCompactIndex, self));
		}
		else {
			longAtput(newObj1, (((((usqLong) count)) << (numSlotsFullShift(self))) + (2U << (formatShift(self)))) + ClassArrayCompactIndex);
		}
		assert((numBytes1 % (allocationUnit(self))) == 0);
		assert((newObj1 % (allocationUnit(self))) == 0);
		GIV(freeStart) += numBytes1;
		smallObj = newObj1;
	l6:	/* end allocateSlots:format:classIndex: */;
		for (i = 0; i < count; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(smallObj, self)));
			longAtput((smallObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), longAt((freeChunk + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))));
		}
		freeChunkWithBytesat(bytesInObject(freeChunk, self), ((byteAt(freeChunk + 7)) == (numSlotsMask(self))
			? freeChunk - BaseHeaderSize
			: freeChunk), self);
		beRootIfOld(smallObj, self);
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
		}
		return smallObj;
	}
	bytes = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
	start = ((byteAt(freeChunk + 7)) == (numSlotsMask(self))
		? freeChunk - BaseHeaderSize
		: freeChunk);
	freeChunkWithBytesat((limit - start) - bytes, start + bytes, self);
	GIV(totalFreeOldSpace) -= bytes;
	/* begin rawOverflowSlotsOf:put: */
	longAtput(freeChunk - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask(self))) << 56))) + count);
	/* begin set:classIndexTo:formatTo: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask(self)))));
	assert(((2 /* arrayFormat */ >= 0) && (2 /* arrayFormat */ <= (formatMask(self)))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (ClassArrayCompactIndex + (2U << (formatShift(self)))));
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt) (longAt(freeChunk))) >> (rememberedBitShift(self))) & 1) != 0)) {
		remember(freeChunk, self);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	runLeakCheckerFor(GCModeFull, self);
	return freeChunk;
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of objects as a SmallInteger.
	Since objects are at least 16 bytes big, and the largest SmallInteger
	covers 1/4 of the address space, the count can never overflow. */

	/* SpurMemoryManager>>#allObjects */
static sqInt
allObjects(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    usqInt bytes;
    sqInt count;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt freeChunk;
    usqInt limit;
    usqInt limit1;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt ptr;
    usqInt start;

	
	/* N.B. Does /not/ update totalFreeOldSpace */
	freeChunk = allocateLargestFreeChunk(self);
	ptr = (start = freeChunk + BaseHeaderSize);
	limit = addressAfter(freeChunk, self);
	count = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		
		/* continue enumerating even if no room so as to unmark all objects. */
		if (((longAt(objOop1)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
			count += 1;
			if (ptr < limit) {
				longAtput(ptr, objOop1);
				ptr += BytesPerOop;
			}
		}
		else {
					}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit1 = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit1, self)) {
		
		/* continue enumerating even if no room so as to unmark all objects. */
		if (((longAt(objOop)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
			count += 1;
			if (ptr < limit) {
				longAtput(ptr, objOop);
				ptr += BytesPerOop;
			}
		}
		else {
					}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit1, self)) {
			objOop = limit1;
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		
		/* continue enumerating even if no room so as to unmark all objects. */
		if (((longAt(objOop)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
			count += 1;
			if (ptr < limit) {
				longAtput(ptr, objOop);
				ptr += BytesPerOop;
			}
		}
		else {
					}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	assert(isEmptyObjStack(GIV(markStack), self));
	assert(isEmptyObjStack(GIV(weaklingStack), self));
	assert(count >= (numSlotsMask(self)));
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8 /* allocationUnit */))) {

		/* can't split a single word */
		freeChunkWithBytesat(bytesInObject(freeChunk, self), ((byteAt(freeChunk + 7)) == (numSlotsMask(self))
			? freeChunk - BaseHeaderSize
			: freeChunk), self);
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
		}
		return (((usqInt)count << 3) | 1);
	}
	bytes = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
	start = ((byteAt(freeChunk + 7)) == (numSlotsMask(self))
		? freeChunk - BaseHeaderSize
		: freeChunk);
	freeChunkWithBytesat((limit - start) - bytes, start + bytes, self);
	GIV(totalFreeOldSpace) -= bytes;
	/* begin rawOverflowSlotsOf:put: */
	longAtput(freeChunk - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask(self))) << 56))) + count);
	/* begin set:classIndexTo:formatTo: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask(self)))));
	assert(((2 /* arrayFormat */ >= 0) && (2 /* arrayFormat */ <= (formatMask(self)))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (ClassArrayCompactIndex + (2U << (formatShift(self)))));
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt) (longAt(freeChunk))) >> (rememberedBitShift(self))) & 1) != 0)) {
		remember(freeChunk, self);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	runLeakCheckerFor(GCModeFull, self);
	return freeChunk;
}

	/* SpurMemoryManager>>#allObjectsUnmarked */
static sqInt
allObjectsUnmarked(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0) {
			GIV(bogon) = objOop1;
			return 0;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0) {
			GIV(bogon) = objOop1;
			return 0;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if (((((usqInt) (longAt(objOop11))) >> (markedBitFullShift(self))) & 1) != 0) {
				GIV(bogon) = objOop11;
				return 0;
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	return 1;
}

	/* SpurMemoryManager>>#allOldMarkedWeakObjectsOnWeaklingStack */
static sqInt
allOldMarkedWeakObjectsOnWeaklingStack(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory), self))) break;
		assert((long64At(objOop)) != 0);
		if ((isWeakFormat((((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self)), self))
		 && (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0)) {
			if (!(isonObjStack(objOop, GIV(weaklingStack), self))) {
				return 0;
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return 1;
}


/*	Answer the largest free chunk in the free lists. */
/*	would like to use ifNotNil: but the ^next inside the ^blah ifNotNil:
	confused Slang
 */

	/* SpurMemoryManager>>#allocateLargestFreeChunk */
static sqInt
allocateLargestFreeChunk(struct foo * self)
{
    sqInt freeChunk;
    sqInt next;
    sqInt nextFreeChunk;


	/* would like to use ifNotNil: but the ^next inside the ^blah ifNotNil: confused Slang */
	freeChunk = findLargestFreeChunk(self);
	if (!(freeChunk)) {
		return null;
	}
	/* begin fetchPointer:ofFreeChunk: */
	next = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))));
	if (next != 0) {
		assert((bytesInObject(freeChunk, self)) >= (numFreeLists(self)));
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		nextFreeChunk = longAt((next + BaseHeaderSize) + (0U << (shiftForWord(self))));
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(freeChunk, self));
		assert((nextFreeChunk == 0)
		 || (isFreeObject(nextFreeChunk, self)));
		longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk);
		if ((nextFreeChunk != 0)
		 && (!0)) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk, self));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk, self)));
			longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), freeChunk);
		}
		return next;
	}
	unlinkSolitaryFreeTreeNode(freeChunk, self);
	return freeChunk;
}


/*	Allocate an object with numSlots in newSpace. This is for the `ee'
	execution engine allocations,
	and must be satisfied. If no memory is available, abort. If the allocation
	pushes freeStart past
	scavengeThreshold and a scavenge is not already scheduled, schedule a
	scavenge.  */
/*	Object headers are 8 bytes in length if the slot size fits in the num
	slots field (max implies overflow),
	16 bytes otherwise (num slots in preceding word).
	Objects always have at least one slot, for the forwarding pointer,
	and are multiples of 8 bytes in length. */

	/* SpurMemoryManager>>#allocateNewSpaceSlots:format:classIndex: */
static sqInt NoDbgRegParms
allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newObj;
    usqInt numBytes;


	/* Object headers are 8 bytes in length if the slot size fits in the num slots field (max implies overflow),
	   16 bytes otherwise (num slots in preceding word).
	   Objects always have at least one slot, for the forwarding pointer,
	   and are multiples of 8 bytes in length. */
	if (numSlots >= (numSlotsMask(self))) {
		if (numSlots > 0xFFFFFFFFU) {
			return null;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateNewSpaceSlots:format:classIndex:");
			return 0;
		}
	}
	if (numSlots >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, ((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsHalfShift(self)))));
		long64Atput(newObj, headerForSlotsformatclassIndex(numSlotsMask(self), formatField, classIndex, self));
	}
	else {
		long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + classIndex);
	}
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	GIV(freeStart) += numBytes;
	return newObj;
}


/*	Answer a chunk of oldSpace from the free lists, if available,
	otherwise answer nil. Break up a larger chunk if one of the
	exact size does not exist. N.B. the chunk is simply a pointer, it
	has no valid header. The caller *must* fill in the header correctly. */
/*	for debugging: */
/*	totalFreeOldSpace := self totalFreeListBytes */

	/* SpurMemoryManager>>#allocateOldSpaceChunkOfBytes: */
static sqInt NoDbgRegParms
allocateOldSpaceChunkOfBytes(usqInt chunkBytes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    usqInt index;
    usqInt initialIndex;
    sqInt next;
    sqInt next1;
    sqInt next2;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    usqInt nodeBytes;
    sqInt parent;


	/* for debugging: */
	/* totalFreeOldSpace := self totalFreeListBytes */
	nodeBytes = 0;

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= chunkBytes;
	initialIndex = chunkBytes / 8 /* allocationUnit */;
	if ((initialIndex < 64 /* numFreeLists */)
	 && ((1ULL << initialIndex) <= GIV(freeListsMask))) {
		if (GIV(freeListsMask) & (1ULL << initialIndex)) {
			if (((chunk = GIV(freeLists)[initialIndex])) != 0) {
				assert(chunk == (startOfObject(chunk, self)));
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk, self));
				/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
				assert(((bytesInObject(chunk, self)) == (initialIndex * (allocationUnit(self))))
				 && ((initialIndex > 1)
				 && ((startOfObject(chunk, self)) == chunk)));
				GIV(freeLists)[initialIndex] = ((next = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord(self))))));
				if ((!((assert(chunkBytes >= (BaseHeaderSize + (allocationUnit(self)))),
				chunkBytes == (BaseHeaderSize + 8 /* allocationUnit */))))
				 && (next != 0)) {
					/* begin storePointer:ofFreeChunk:withValue: */
					fieldIndex = 1 /* freeChunkPrevIndex */;
					assert(isFreeObject(next, self));
					assert(1);
					longAtput((next + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), 0);
				}
				return chunk;
			}
			GIV(freeListsMask) -= 1ULL << initialIndex;
		}
		index = initialIndex;
		while ((((index += index)) < 64 /* numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1ULL << index)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk, self)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk, self));
					/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
					assert(((bytesInObject(chunk, self)) == (index * (allocationUnit(self))))
					 && ((index > 1)
					 && ((startOfObject(chunk, self)) == chunk)));
					GIV(freeLists)[index] = ((next1 = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord(self))))));
					if (next1 != 0) {
						/* begin storePointer:ofFreeChunk:withValue: */
						fieldIndex1 = 1 /* freeChunkPrevIndex */;
						assert(isFreeObject(next1, self));
						assert(1);
						longAtput((next1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))), 0);
					}
					assert((bytesInObject(chunk, self)) == (index * (allocationUnit(self))));
					freeChunkWithBytesat((index * 8 /* allocationUnit */) - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask(self))
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes, self);
					return chunk;
				}
				GIV(freeListsMask) -= 1ULL << index;
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < 64 /* numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1ULL << index)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk, self)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk, self));
					/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
					assert(((bytesInObject(chunk, self)) == (index * (allocationUnit(self))))
					 && ((index > 1)
					 && ((startOfObject(chunk, self)) == chunk)));
					GIV(freeLists)[index] = ((next2 = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord(self))))));
					if (next2 != 0) {
						/* begin storePointer:ofFreeChunk:withValue: */
						fieldIndex2 = 1 /* freeChunkPrevIndex */;
						assert(isFreeObject(next2, self));
						assert(1);
						longAtput((next2 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))), 0);
					}
					assert((bytesInObject(chunk, self)) == (index * (allocationUnit(self))));
					freeChunkWithBytesat((index * 8 /* allocationUnit */) - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask(self))
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes, self);
					return chunk;
				}
				GIV(freeListsMask) -= 1ULL << index;
			}
		}
	}
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child, self));
		childBytes = bytesInObject(child, self);
		if (childBytes == chunkBytes) {

			/* break out of loop to remove interior node */
			/* size match; try to remove from list at node. */
			/* begin fetchPointer:ofFreeChunk: */
			chunk = longAt((child + BaseHeaderSize) + (0U << (shiftForWord(self))));
			if (chunk != 0) {
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk, self));
				/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
				nextFreeChunk = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord(self))));
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(child, self));
				assert((nextFreeChunk == 0)
				 || (isFreeObject(nextFreeChunk, self)));
				longAtput((child + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk);
				if ((nextFreeChunk != 0)
				 && (!0)) {
					/* begin storePointer:ofFreeChunk:withValue: */
					assert(isFreeObject(nextFreeChunk, self));
					assert((child == 0)
					 || (isFreeObject(child, self)));
					longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), child);
				}
				return ((byteAt(chunk + 7)) == (numSlotsMask(self))
					? chunk - BaseHeaderSize
					: chunk);
			}
			nodeBytes = childBytes;
			parent = child;
			child = 0;
		}
		else {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (chunkBytes + 8 /* allocationUnit */)) {

				/* node too small; walk down the larger size of the tree */
				/* begin fetchPointer:ofFreeChunk: */
				child = longAt((child + BaseHeaderSize) + (4U << (shiftForWord(self))));
			}
			else {

				/* parent will be smallest node >= chunkBytes + allocationUnit */
				parent = child;
				nodeBytes = childBytes;
				/* begin fetchPointer:ofFreeChunk: */
				child = longAt((child + BaseHeaderSize) + (3U << (shiftForWord(self))));
			}
		}
	}
	if (parent == 0) {

		/* optimism was unfounded */
		GIV(totalFreeOldSpace) += chunkBytes;
		return null;
	}
	assert((nodeBytes == chunkBytes)
	 || (nodeBytes >= (chunkBytes + (2 * (allocationUnit(self))))));
	assert((bytesInObject(parent, self)) == nodeBytes);
	/* begin fetchPointer:ofFreeChunk: */
	chunk = longAt((parent + BaseHeaderSize) + (0U << (shiftForWord(self))));
	if (chunk != 0) {
		assert((chunkBytes == nodeBytes)
		 || ((chunkBytes + (allocationUnit(self))) < nodeBytes));
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		nextFreeChunk1 = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord(self))));
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(parent, self));
		assert((nextFreeChunk1 == 0)
		 || (isFreeObject(nextFreeChunk1, self)));
		longAtput((parent + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk1);
		if ((nextFreeChunk1 != 0)
		 && (!0)) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk1, self));
			assert((parent == 0)
			 || (isFreeObject(parent, self)));
			longAtput((nextFreeChunk1 + BaseHeaderSize) + (1U << (shiftForWord(self))), parent);
		}
		if (chunkBytes != nodeBytes) {
			freeChunkWithBytesat(nodeBytes - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask(self))
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes, self);
		}
		return ((byteAt(chunk + 7)) == (numSlotsMask(self))
			? chunk - BaseHeaderSize
			: chunk);
	}
	chunk = parent;
	unlinkSolitaryFreeTreeNode(chunk, self);
	if (chunkBytes != nodeBytes) {
		freeChunkWithBytesat(nodeBytes - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask(self))
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes, self);
	}
	return ((byteAt(chunk + 7)) == (numSlotsMask(self))
		? chunk - BaseHeaderSize
		: chunk);
}

	/* SpurMemoryManager>>#allocatePinnedSlots: */
sqInt
allocatePinnedSlots(sqInt nSlots, struct foo * self)
{
    sqInt obj;
    usqInt p;

	obj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, (nSlots == 0
		? 8 /* allocationUnit */ + BaseHeaderSize
		: (((sqInt)((usqInt)(nSlots) << (shiftForWord(self))))) + ((nSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(self), sixtyFourBitLongsClassIndexPun(self), self);
	if (obj) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj, self), self));
		for (p = (((usqInt)(obj + BaseHeaderSize))); p <= (((usqInt)(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
			longAtput(p, 0);
		}
	}
	return obj;
}


/*	All objects are a multiple of 8 bytes in length */

	/* SpurMemoryManager>>#allocationUnit */
static sqInt
allocationUnit(struct foo * self)
{
	return 8;
}


/*	N.B. generateToByDoLimitExpression:negative:on: guards against (unsigned)0
	- 1 going +ve
 */

	/* SpurMemoryManager>>#allStrongSlotsOfWeaklingAreMarked: */
static sqInt NoDbgRegParms
allStrongSlotsOfWeaklingAreMarked(sqInt aWeakling, struct foo * self)
{
    sqInt classFormat;
    sqInt i;
    sqInt iLimiT;
    sqInt objOop;
    sqInt referent;

	for (i = 0, iLimiT = (((assert((formatOf(aWeakling, self)) == (weakArrayFormat(self))),
/* begin fixedFieldsOfClass: */
(objOop = fetchClassOfNonImm(aWeakling, self)),
/* begin fixedFieldsOfClassFormat: */
(classFormat = ((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)),
classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1))) - 1); i <= iLimiT; i += 1) {
		referent = longAt((aWeakling + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if ((referent & (tagMask(self))) == 0) {
			if (!(((((usqInt) (longAt(referent))) >> (markedBitFullShift(self))) & 1) != 0)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#allUnscannedEphemeronsAreActive */
static sqInt
allUnscannedEphemeronsAreActive(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt key;
    sqInt p;

	for (p = ((GIV(unscannedEphemerons).start)); p <= (((GIV(unscannedEphemerons).top)) - BytesPerOop); p += BytesPerOop) {
		assert((isNonImmediate(longAt(p), self))
		 && (isMaybeFiredEphemeron(longAt(p), self)));
		/* begin fetchPointer:ofObject: */
		key = longAt(((longAt(p)) + BaseHeaderSize) + (0U << (shiftForWord(self))));
		if ((key & (tagMask(self)))
		 || (((((usqInt) (longAt(key))) >> (markedBitFullShift(self))) & 1) != 0)) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#arrayFormat */
sqInt
arrayFormat(struct foo * self)
{
	return 2;
}


/*	we don't want to inline so we can nest that in an assertion with the
	return true so the production VM does not generate any code here, while in
	simulation, the code breaks on the assertion we want to.
 */

	/* SpurMemoryManager>>#assertInnerValidFreeObject: */
static sqInt NoDbgRegParms NeverInline
assertInnerValidFreeObject(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    sqInt chunk;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    usqInt index;
    sqInt largeChild;
    sqInt smallChild;
    sqInt treeNode;

	assert(oopisLessThanOrEqualTo(addressAfter(objOop, self), GIV(endOfMemory), self));
	/* begin fetchPointer:ofFreeChunk: */
	chunk = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
	assert((chunk == 0)
	 || (isFreeOop(chunk, self)));
	if (!(isLilliputianSize(bytesInObject(objOop, self), self))) {

		/* double linkedlist assertions */
		/* begin fetchPointer:ofFreeChunk: */
		chunk = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
		if (!(chunk == 0)) {
			assert(isFreeOop(chunk, self));
			assert(objOop == (fetchPointerofFreeChunk(freeChunkPrevIndex(self), chunk, self)));
		}
		/* begin fetchPointer:ofFreeChunk: */
		chunk = longAt((objOop + BaseHeaderSize) + (1U << (shiftForWord(self))));
		index = (bytesInObject(objOop, self)) / 8 /* allocationUnit */;
		if ((index < 64 /* numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if ((GIV(freeLists)[index]) == objOop) {
				assert(chunk == 0);
			}
		}
		else {
			/* begin freeTreeNodesDo: */
			treeNode = GIV(freeLists)[0];
			if (treeNode == 0) {
				goto l4;
			}
			cameFrom = -1;
			do {
				assert((bytesInObject(treeNode, self)) >= ((numFreeLists(self)) * (allocationUnit(self))));
				/* begin fetchPointer:ofFreeChunk: */
				fieldIndex1 = 3 /* freeChunkSmallerIndex */;
				smallChild = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
				/* begin fetchPointer:ofFreeChunk: */
				fieldIndex2 = 4 /* freeChunkLargerIndex */;
				largeChild = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))));
				assert((smallChild == 0)
				 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(self), smallChild, self))));
				assert((largeChild == 0)
				 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(self), largeChild, self))));
				if (((smallChild == 0)
				 && (largeChild == 0))
				 || ((largeChild == 0
					? cameFrom == smallChild
					: cameFrom == largeChild))) {

					/* and since we've applied we must move on up */
					if (treeNode == objOop) {
						assert(chunk == 0);
					}
					treeNode = treeNode;
					cameFrom = treeNode;
					/* begin fetchPointer:ofFreeChunk: */
					fieldIndex = 2 /* freeChunkParentIndex */;
					treeNode = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
				}
				else {
					if ((smallChild != 0)
					 && (cameFrom != smallChild)) {
						treeNode = smallChild;
					}
					else {
						assert(largeChild != 0);
						treeNode = largeChild;
					}
					cameFrom = -1;
				}
			} while(treeNode != 0);
	l4:	/* end freeTreeNodesDo: */;
		}
		if (!(chunk == 0)) {
			assert(isFreeOop(chunk, self));
			assert(objOop == (fetchPointerofFreeChunk(freeChunkNextIndex(self), chunk, self)));
		}
	}
	if ((bytesInObject(objOop, self)) >= (64 /* numFreeLists */ * 8 /* allocationUnit */)) {

		/* Tree assertions */
		/* begin fetchPointer:ofFreeChunk: */
		chunk = longAt((objOop + BaseHeaderSize) + (2U << (shiftForWord(self))));
		assert((chunk == 0)
		 || ((isFreeOop(chunk, self))
		 && (isLargeFreeObject(chunk, self))));
		/* begin fetchPointer:ofFreeChunk: */
		chunk = longAt((objOop + BaseHeaderSize) + (3U << (shiftForWord(self))));
		assert((chunk == 0)
		 || ((isFreeOop(chunk, self))
		 && (isLargeFreeObject(chunk, self))));
		/* begin fetchPointer:ofFreeChunk: */
		chunk = longAt((objOop + BaseHeaderSize) + (4U << (shiftForWord(self))));
		assert((chunk == 0)
		 || ((isFreeOop(chunk, self))
		 && (isLargeFreeObject(chunk, self))));
	}
	return 1;
}


/*	Answer the appropriate become effect flags for objOop, or 0 if none.
	The effect flags determine how much work is done after the become
	in following forwarding pointers, voiding method caches, etc. */

	/* SpurMemoryManager>>#becomeEffectFlagsFor: */
static sqInt NoDbgRegParms
becomeEffectFlagsFor(sqInt objOop, struct foo * self)
{
    sqInt hash;

	return (((((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */
		? ((((hash = (long32At(objOop + 4)) & (identityHashHalfWordMask(self)))) != 0)
			 && ((classAtIndex(hash, self)) == objOop)
				? BecamePointerObjectFlag + BecameActiveClassFlag
				: BecamePointerObjectFlag)
		: (((((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))
				? BecameCompiledMethodFlag
				: 0));
}

	/* SpurMemoryManager>>#become:with: */
sqInt
becomewith(sqInt array1, sqInt array2, struct foo * self)
{
	return becomewithtwoWaycopyHash(array1, array2, 1, 1, self);
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced
	with with pointers to the other. The arguments must be arrays of the same
	length. 
	Answers PrimNoErr if the primitive succeeds, otherwise a relevant error
	code. 
 */
/*	Implementation: Uses lazy forwarding to defer updating references until
	message send.
 */

	/* SpurMemoryManager>>#become:with:twoWay:copyHash: */
static sqInt NoDbgRegParms
becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt contextSize;
    sqInt ec;
    sqInt effectsFlags;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt hash;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt newObj1;
    sqInt newObj2;
    sqInt o1ClassIndex;
    sqInt o2ClassIndex;
    sqInt obj1;
    sqInt obj11;
    sqInt obj2;
    sqInt obj21;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop21;
    sqInt objOop3;
    sqInt objOop4;
    sqInt oop1;
    sqInt oop2;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent2;
    sqInt referent3;
    sqInt size;
    sqInt sp;

	assert(GIV(becomeEffectsFlags) == 0);
	runLeakCheckerFor(GCModeBecome, self);
	if (!(((array1 & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(array1))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))) {
		return PrimErrBadReceiver;
	}
	if (!((((array2 & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(array2))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && ((numSlotsOf(array1, self)) == (numSlotsOf(array2, self))))) {
		return PrimErrBadArgument;
	}
	/* begin containsOnlyValidBecomeObjects:and:twoWay:copyHash: */
	fmt = (((usqInt) (longAt(array1))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt != (forwardedFormat(self)));
	if (fmt <= 5 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat(self)))
		 && (((longAt(array1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l33;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array1, self)));
			contextSize = (sp >> 3);
	l33:	/* end fetchStackPointerOf: */;
			fieldOffset = (((CtxtTempFrameStart - 1) + contextSize) * BytesPerOop) + BaseHeaderSize;
			goto l34;
		}
		fieldOffset = (((numSlotsOf(array1, self)) - 1) * BytesPerOop) + BaseHeaderSize;
		goto l34;
	}
	if (fmt < (firstCompiledMethodFormat(self))) {
		fieldOffset = 0;
		goto l34;
	}
	assert(isCompiledMethod(array1, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	fieldOffset = (((((assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
	l34:	/* end lastPointerOf: */;

	/* array1 is known to be the same size as array2 */
	effectsFlags = (size = 0);
	while (fieldOffset >= BaseHeaderSize) {
		oop1 = longAt(array1 + fieldOffset);
		if (((oop1 & (tagMask(self))) == 0)
		 && (((longAt(oop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop1, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent3 = longAt((oop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent3 & (tagMask(self))) == 0)
			 && (((longAt(referent3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			oop1 = referent3;
			longAtput(array1 + fieldOffset, oop1);
		}
		/* begin ifOopInvalidForBecome:errorCodeInto: */
		if (oop1 & (tagMask(self))) {
			ec = PrimErrInappropriate;
			goto l40;
			goto l26;
		}
		if (((((usqInt) (longAt(oop1))) >> (pinnedBitShift(self))) & 1) != 0) {
			ec = PrimErrObjectIsPinned;
			goto l40;
			goto l26;
		}
		if (
#    if IMMUTABILITY
			(/* begin isImmutable: */
					((((usqInt) (longAt(oop1))) >> (immutableBitShift(self))) & 1) != 0)
#    else /* IMMUTABILITY */
			0
#    endif /* IMMUTABILITY */
			) {
			ec = PrimErrNoModification;
			goto l40;
			goto l26;
		}
	l26:	/* end ifOopInvalidForBecome:errorCodeInto: */;
		effectsFlags = effectsFlags | (becomeEffectFlagsFor(oop1, self));
		oop2 = longAt(array2 + fieldOffset);
		if (((oop2 & (tagMask(self))) == 0)
		 && (((longAt(oop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop2, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent11 = longAt((oop2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent11 & (tagMask(self))) == 0)
			 && (((longAt(referent11)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent11 = longAt((referent11 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			oop2 = referent11;
			longAtput(array2 + fieldOffset, oop2);
		}
		if (twoWayFlag) {
			/* begin ifOopInvalidForBecome:errorCodeInto: */
			if (oop2 & (tagMask(self))) {
				ec = PrimErrInappropriate;
				goto l40;
				goto l30;
			}
			if (((((usqInt) (longAt(oop2))) >> (pinnedBitShift(self))) & 1) != 0) {
				ec = PrimErrObjectIsPinned;
				goto l40;
				goto l30;
			}
			if (
#      if IMMUTABILITY
				(/* begin isImmutable: */
							((((usqInt) (longAt(oop2))) >> (immutableBitShift(self))) & 1) != 0)
#      else /* IMMUTABILITY */
				0
#      endif /* IMMUTABILITY */
				) {
				ec = PrimErrNoModification;
				goto l40;
				goto l30;
			}
	l30:	/* end ifOopInvalidForBecome:errorCodeInto: */;
			size = (size + (bytesInObject(oop1, self))) + (bytesInObject(oop2, self));
			effectsFlags = effectsFlags | (becomeEffectFlagsFor(oop2, self));
		}
		else {
			if (copyHashFlag
			 && ((oop2 & (tagMask(self)))
			 || (((((usqInt) (longAt(oop2))) >> (immutableBitShift(self))) & 1) != 0))) {
				ec = PrimErrInappropriate;
				goto l40;
			}
		}
		fieldOffset -= BytesPerOop;
	}
	if (size >= (GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart)))) {
		ec = PrimErrNoMemory;
		goto l40;
	}
	GIV(becomeEffectsFlags) = effectsFlags;
	ec = 0;
	l40:	/* end containsOnlyValidBecomeObjects:and:twoWay:copyHash: */;
	if (ec != 0) {
		GIV(becomeEffectsFlags) = 0;
		return ec;
	}
	/* begin preBecomeAction */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
	}
	if (twoWayFlag) {
		/* begin innerBecomeObjectsIn:and:copyHash: */
		for (i = 0, iLimiT = ((numSlotsOf(array1, self)) - 1); i <= iLimiT; i += 1) {
			/* begin followField:ofObject: */
			objOop2 = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			if (((objOop2 & (tagMask(self))) == 0)
			 && (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop2 = fixFollowedFieldofObjectwithInitialValue(i, array1, objOop2, self);
			}
			obj1 = objOop2;
			/* begin followField:ofObject: */
			objOop3 = longAt((array2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			if (((objOop3 & (tagMask(self))) == 0)
			 && (((longAt(objOop3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop3 = fixFollowedFieldofObjectwithInitialValue(i, array2, objOop3, self);
			}
			obj2 = objOop3;
			if (obj1 != obj2) {
				/* begin doBecome:and:copyHash: */
				o1ClassIndex = (long32At(obj1 + 4)) & (identityHashHalfWordMask(self));
				if ((o1ClassIndex != 0)
				 && ((classAtIndex(o1ClassIndex, self)) != obj1)) {
					o1ClassIndex = 0;
				}
				o2ClassIndex = (long32At(obj2 + 4)) & (identityHashHalfWordMask(self));
				if ((o2ClassIndex != 0)
				 && ((classAtIndex(o2ClassIndex, self)) != obj2)) {
					o2ClassIndex = 0;
				}
				if (((numSlotsOf(obj1, self)) == (numSlotsOf(obj2, self)))
				 && ((o1ClassIndex == 0)
				 && (o2ClassIndex == 0))) {
					inPlaceBecomeandcopyHashFlag(obj1, obj2, copyHashFlag, self);
					goto l15;
				}
				outOfPlaceBecomeandcopyHashFlag(obj1, obj2, copyHashFlag, self);
				if (copyHashFlag) {
					goto l15;
				}
				if (o1ClassIndex != 0) {
					if (o2ClassIndex != 0) {
						classAtIndexput(o1ClassIndex, obj2, self);
						classAtIndexput(o2ClassIndex, obj1, self);
					}
					else {

						/* o2 wasn't in the table; set its hash */
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(obj1, self));
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent2 = longAt((obj1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
						while (((referent2 & (tagMask(self))) == 0)
						 && (((longAt(referent2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
							/* begin fetchPointer:ofMaybeForwardedObject: */
							referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
						}
						newObj2 = referent2;
						assert((rawHashBitsOf(newObj2, self)) == 0);
						/* begin setHashBitsOf:to: */
						assert(((o1ClassIndex >= 0) && (o1ClassIndex <= (identityHashHalfWordMask(self)))));
						long32Atput(newObj2 + 4, ((((long32At(newObj2 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + o1ClassIndex);
					}
				}
				else {
					if (o2ClassIndex != 0) {

						/* o1 wasn't in the table; set its hash */
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(obj2, self));
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent1 = longAt((obj2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
						while (((referent1 & (tagMask(self))) == 0)
						 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
							/* begin fetchPointer:ofMaybeForwardedObject: */
							referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
						}
						newObj1 = referent1;
						assert((rawHashBitsOf(newObj1, self)) == 0);
						/* begin setHashBitsOf:to: */
						assert(((o2ClassIndex >= 0) && (o2ClassIndex <= (identityHashHalfWordMask(self)))));
						long32Atput(newObj1 + 4, ((((long32At(newObj1 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + o2ClassIndex);
					}
				}
	l15:	/* end doBecome:and:copyHash: */;
				/* begin followField:ofObject: */
				objOop = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
				if (((objOop & (tagMask(self))) == 0)
				 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop = fixFollowedFieldofObjectwithInitialValue(i, array1, objOop, self);
				}
				/* begin followField:ofObject: */
				objOop1 = longAt((array2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
				if (((objOop1 & (tagMask(self))) == 0)
				 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(i, array2, objOop1, self);
				}
			}
		}
	}
	else {
		/* begin innerBecomeObjectsIn:to:copyHash: */
		for (i1 = 0, iLimiT1 = ((numSlotsOf(array1, self)) - 1); i1 <= iLimiT1; i1 += 1) {
			/* begin followField:ofObject: */
			objOop11 = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
			if (((objOop11 & (tagMask(self))) == 0)
			 && (((longAt(objOop11)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop11 = fixFollowedFieldofObjectwithInitialValue(i1, array1, objOop11, self);
			}
			obj11 = objOop11;
			/* begin followField:ofObject: */
			objOop21 = longAt((array2 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
			if (((objOop21 & (tagMask(self))) == 0)
			 && (((longAt(objOop21)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop21 = fixFollowedFieldofObjectwithInitialValue(i1, array2, objOop21, self);
			}
			obj21 = objOop21;
			if (obj11 != obj21) {
				/* begin doBecome:to:copyHash: */
				classIndex = isForwardedObjectClassIndexPun(self);
				assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
				assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
				longAtput(obj11, ((longAt(obj11)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex + (7U << (formatShift(self)))));
				
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(obj11, (longAt(obj11)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#        endif /* IMMUTABILITY */
				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(obj11, self));
				assert(!(isOopForwarded(obj21, self)));
				if ((assert(isNonImmediate(obj11, self)),
				oopisGreaterThanOrEqualTo(obj11, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((obj21 & (tagMask(self))) == 0)
					 && (oopisLessThan(obj21, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(obj11))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(obj11, self);
						}
					}
				}
				longAtput((obj11 + BaseHeaderSize) + (0U << (shiftForWord(self))), obj21);
				if ((byteAt(obj11 + 7)) == 0) {
					byteAtput(obj11 + 7, 1);
				}
				if (copyHashFlag) {
					/* begin setHashBitsOf:to: */
					hash = (long32At(obj11 + 4)) & (identityHashHalfWordMask(self));
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask(self)))));
					long32Atput(obj21 + 4, ((((long32At(obj21 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash);
				}
				if (((assert(isNonImmediate(obj11, self)),
				oopisGreaterThanOrEqualTo(obj11, GIV(oldSpaceStart), self)))
				 && (((obj21 & (tagMask(self))) == 0)
				 && (oopisLessThan(obj21, GIV(newSpaceLimit), self)))) {
					GIV(becomeEffectsFlags) = GIV(becomeEffectsFlags) | OldBecameNewFlag;
				}
				assert(!((isOopForwarded(obj21, self))));
				/* begin followField:ofObject: */
				objOop4 = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
				if (((objOop4 & (tagMask(self))) == 0)
				 && (((longAt(objOop4)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop4 = fixFollowedFieldofObjectwithInitialValue(i1, array1, objOop4, self);
				}
				assert(!(isOopForwarded(obj21, self)));
			}
		}
	}
	/* begin followSpecialObjectsOop */
	if (((longAt(GIV(specialObjectsOop))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(specialObjectsOop), self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		GIV(specialObjectsOop) = referent;
	}
	followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0, self);
	/* begin postBecomeAction: */
	spurPostBecomeAction(GIV(becomeEffectsFlags), self);
	postBecomeScanClassTable(GIV(becomeEffectsFlags), self);
	GIV(becomeEffectsFlags) = 0;
	assert(validClassTableHashes(self));
	runLeakCheckerFor(GCModeBecome, self);
	return PrimNoErr;
}


/*	If this object is old, mark it as a root (because a new object
	may be stored into it). */

	/* SpurMemoryManager>>#beRootIfOld: */
void
beRootIfOld(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((assert(isNonImmediate(oop, self)),
	oopisGreaterThanOrEqualTo(oop, GIV(oldSpaceStart), self))) {

		/* No, oop is an old object */
		/* begin possibleRootStoreInto: */
		if (!(((((usqInt) (longAt(oop))) >> (rememberedBitShift(self))) & 1) != 0)) {
			remember(oop, self);
		}
	}
}

	/* SpurMemoryManager>>#bitsSetInFreeSpaceMaskForAllFreeLists */
static sqInt
bitsSetInFreeSpaceMaskForAllFreeLists(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;

	for (i = 0, iLimiT = (64 /* numFreeLists */ - 1); i <= iLimiT; i += 1) {
		if (((GIV(freeLists)[i]) != 0)
		 && (((1ULL << i) & GIV(freeListsMask)) == 0)) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#bridgeSize */
static sqInt
bridgeSize(struct foo * self)
{
	return 2 * BaseHeaderSize;
}

	/* SpurMemoryManager>>#byteFormatMask */
static sqInt
byteFormatMask(struct foo * self)
{
	return 24;
}

	/* SpurMemoryManager>>#byteSizeOf: */
sqInt
byteSizeOf(sqInt oop, struct foo * self)
{
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;

	if (oop & (tagMask(self))) {
		return 0;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOf: */
	assert((classIndexOf(oop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(oop + 7);
	numBytes = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord(self));
	if (fmt >= (firstByteFormat(self))) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat(self))) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat(self))) {
		return numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
	}
	return numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
}

	/* SpurMemoryManager>>#characterObjectOf: */
sqInt
characterObjectOf(sqInt characterCode, struct foo * self)
{
	return (((sqInt)((usqInt)(characterCode) << (numTagBits(self))))) + (characterTag(self));
}

	/* SpurMemoryManager>>#characterTable */
void
characterTable(struct foo * self)
{
	error("shouldNotImplement");
}


/*	Immediate characters are unsigned */

	/* SpurMemoryManager>>#characterValueOf: */
usqInt
characterValueOf(sqInt oop, struct foo * self)
{
	return ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
}


/*	Assumes zero-based array indexing. */

	/* SpurMemoryManager>>#checkedLongAt: */
sqInt
checkedLongAt(sqInt byteAddress, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isInMemory(byteAddress, self))) {
		warning("checkedLongAt bad address");
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return longAt(byteAddress);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleFreeSpace has set a bit at each free chunk's
	header. Scan all objects in the heap checking that no pointer points
	to a free chunk and that all free chunks that refer to others refer to
	marked chunks. Answer if all checks pass. */

	/* SpurMemoryManager>>#checkHeapFreeSpaceIntegrity */
static sqInt
checkHeapFreeSpaceIntegrity(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt fi;
    sqInt fieldOop;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    sqInt iLimiT;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt total;

	ok = 1;
	total = 0;
	for (i = 0, iLimiT = (64 /* numFreeLists */ - 1); i <= iLimiT; i += 1) {
		if ((GIV(freeLists)[i]) != 0) {
			if ((heapMapAtWord(pointerForOop(GIV(freeLists)[i]), self)) == 0) {
				print("leak in free list ", self);
				printNum(i, self);
				print(" to non-free ", self);
				printHex(GIV(freeLists)[i], self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			print("young object ", self);
			printHex(objOop, self);
			print(" is free", self);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			for (fi = 0, iLimiT = ((numPointerSlotsOf(objOop, self)) - 1); fi <= iLimiT; fi += 1) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
				if ((fieldOop & (tagMask(self))) == 0) {
					if ((heapMapAtWord(pointerForOop(fieldOop), self)) != 0) {
						print("object leak in ", self);
						printHex(objOop, self);
						print(" @ ", self);
						printNum(fi, self);
						print(" = ", self);
						printHex(fieldOop, self);
						print(" is free", self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			print("young object ", self);
			printHex(objOop, self);
			print(" is free", self);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			for (fi = 0, iLimiT = ((numPointerSlotsOf(objOop, self)) - 1); fi <= iLimiT; fi += 1) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
				if ((fieldOop & (tagMask(self))) == 0) {
					if ((heapMapAtWord(pointerForOop(fieldOop), self)) != 0) {
						print("object leak in ", self);
						printHex(objOop, self);
						print(" @ ", self);
						printNum(fi, self);
						print(" = ", self);
						printHex(fieldOop, self);
						print(" is free", self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l5;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			if ((heapMapAtWord(pointerForOop(objOop1), self)) == 0) {
				print("leak in free chunk ", self);
				printHex(objOop1, self);
				print(" is unmapped?! ", self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			/* begin fetchPointer:ofFreeChunk: */
			fieldOop = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0)) {
				print("leak in free chunk ", self);
				printHex(objOop1, self);
				print(" @ 0 = ", self);
				printHex(fieldOop, self);
				print(" is unmapped", self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			if (!(isLilliputianSize(bytesInObject(objOop1, self), self))) {
				/* begin fetchPointer:ofFreeChunk: */
				fieldOop = longAt((objOop1 + BaseHeaderSize) + (1U << (shiftForWord(self))));
				if ((fieldOop != 0)
				 && ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0)) {
					print("leak in free chunk ", self);
					printHex(objOop1, self);
					print(" @ 0 = ", self);
					printHex(fieldOop, self);
					print(" is unmapped", self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			if ((bytesInObject(objOop1, self)) >= (64 /* numFreeLists */ * 8 /* allocationUnit */)) {
				for (fi = 2 /* freeChunkParentIndex */, iLimiT = 4 /* freeChunkLargerIndex */; fi <= iLimiT; fi += 1) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0)) {
						print("leak in free chunk ", self);
						printHex(objOop1, self);
						print(" @ ", self);
						printNum(fi, self);
						print(" = ", self);
						printHex(fieldOop, self);
						print(" is unmapped", self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
			total += bytesInObject(objOop1, self);
		}
		else {
			for (fi = 0, iLimiT = ((numPointerSlotsOf(objOop1, self)) - 1); fi <= iLimiT; fi += 1) {
				if (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					assert(fi == 0);
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
				}
				else {

					/* We keep #fetchPointer:ofObject: API here for assertions */
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
				}
				if ((fieldOop & (tagMask(self))) == 0) {
					if ((heapMapAtWord(pointerForOop(fieldOop), self)) != 0) {
						print("object leak in ", self);
						printHex(objOop1, self);
						print(" @ ", self);
						printNum(fi, self);
						print(" = ", self);
						printHex(fieldOop, self);
						print(" is free", self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l7;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l7:	/* end objectAfter:limit: */;
	}
	if (total != GIV(totalFreeOldSpace)) {
		print("incorrect totalFreeOldSpace; expected ", self);
		printNum(GIV(totalFreeOldSpace), self);
		print(" found ", self);
		printNum(total, self);
		/* begin cr */
		printf("\n");
		ok = 0;
	}
	return ok;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each (non-free)
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rememberedSet, remapBuffer and
	extraRootTable checking
	that every entry is a pointer to a header. Check that the number of roots
	is correct and that all
	rememberedSet entries have their isRemembered: flag set. Answer if all
	checks pass. */

	/* SpurMemoryManager>>#checkHeapIntegrity:classIndicesShouldBeValid: */
static sqInt NoDbgRegParms
checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt classIndex3;
    sqInt classOop;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt classTablePage2;
    sqInt containsYoung;
    sqInt fi;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex11;
    sqInt fieldIndex12;
    sqInt fieldIndex2;
    sqInt fieldIndex3;
    sqInt fieldOop;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    usqInt limit;
    sqInt numOnThisPage;
    sqInt numRememberedObjectsInHeap;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objStackPage;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ri;

	ok = 1;
	numRememberedObjectsInHeap = 0;
	for (i = 0, iLimiT = (64 /* numFreeLists */ - 1); i <= iLimiT; i += 1) {
		if ((GIV(freeLists)[i]) != 0) {
			if ((heapMapAtWord(pointerForOop(GIV(freeLists)[i]), self)) != 0) {
				print("leak in free list ", self);
				printNum(i, self);
				print(" to non-free ", self);
				printHex(GIV(freeLists)[i], self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			print("young object ", self);
			printHex(objOop, self);
			print(" is free", self);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if (!((!(((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0))
				 && (excludeUnmarkedObjs))) {
				if (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0) {
					print("young object ", self);
					printHex(objOop, self);
					print(" is remembered", self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				if ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0) {
					print("object leak in forwarder ", self);
					printHex(objOop, self);
					print(" to unmapped ", self);
					printHex(fieldOop, self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			else {
				/* begin classOrNilAtIndex: */
				classIndex1 = (classIndex = (longAt(objOop)) & (classIndexMask(self)));
				assert((classIndex1 <= (tagMask(self)))
				 || (classIndex1 >= (arrayClassIndexPun(self))));
				/* begin fetchPointer:ofObject: */
				fieldIndex = ((usqInt) classIndex1) >> (classTableMajorIndexShift(self));
				classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
				if (classTablePage == GIV(nilObj)) {
					classOop = GIV(nilObj);
					goto l17;
				}
				/* begin fetchPointer:ofObject: */
				fieldIndex1 = classIndex1 & ((1U << (classTableMajorIndexShift(self))) - 1);
				classOop = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
	l17:	/* end classOrNilAtIndex: */;
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (!(((longAt(objOop)) & (classIndexMask(self))) <= (lastClassIndexPun(self)))))) {
					print("object leak in ", self);
					printHex(objOop, self);
					print(" invalid class index ", self);
					printHex(classIndex, self);
					print(" -> ", self);
					print((classOop == null
						? "nil"
						: "nilObj"), self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
				for (fi = 0, iLimiT = ((numPointerSlotsOf(objOop, self)) - 1); fi <= iLimiT; fi += 1) {
					fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
					if ((fieldOop & (tagMask(self))) == 0) {
						if ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0) {
							print("object leak in ", self);
							printHex(objOop, self);
							print(" @ ", self);
							printNum(fi, self);
							print(" = ", self);
							printHex(fieldOop, self);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			print("young object ", self);
			printHex(objOop, self);
			print(" is free", self);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if (!((!(((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0))
				 && (excludeUnmarkedObjs))) {
				if (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0) {
					print("young object ", self);
					printHex(objOop, self);
					print(" is remembered", self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				if ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0) {
					print("object leak in forwarder ", self);
					printHex(objOop, self);
					print(" to unmapped ", self);
					printHex(fieldOop, self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			else {
				/* begin classOrNilAtIndex: */
				classIndex2 = (classIndex = (longAt(objOop)) & (classIndexMask(self)));
				assert((classIndex2 <= (tagMask(self)))
				 || (classIndex2 >= (arrayClassIndexPun(self))));
				/* begin fetchPointer:ofObject: */
				fieldIndex2 = ((usqInt) classIndex2) >> (classTableMajorIndexShift(self));
				classTablePage1 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))));
				if (classTablePage1 == GIV(nilObj)) {
					classOop = GIV(nilObj);
					goto l18;
				}
				/* begin fetchPointer:ofObject: */
				fieldIndex11 = classIndex2 & ((1U << (classTableMajorIndexShift(self))) - 1);
				classOop = longAt((classTablePage1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex11) << (shiftForWord(self))))));
	l18:	/* end classOrNilAtIndex: */;
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (!(((longAt(objOop)) & (classIndexMask(self))) <= (lastClassIndexPun(self)))))) {
					print("object leak in ", self);
					printHex(objOop, self);
					print(" invalid class index ", self);
					printHex(classIndex, self);
					print(" -> ", self);
					print((classOop == null
						? "nil"
						: "nilObj"), self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
				for (fi = 0, iLimiT = ((numPointerSlotsOf(objOop, self)) - 1); fi <= iLimiT; fi += 1) {
					fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
					if ((fieldOop & (tagMask(self))) == 0) {
						if ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0) {
							print("object leak in ", self);
							printHex(objOop, self);
							print(" @ ", self);
							printNum(fi, self);
							print(" = ", self);
							printHex(fieldOop, self);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l5;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			if ((heapMapAtWord(pointerForOop(objOop1), self)) != 0) {
				print("leak in free chunk ", self);
				printHex(objOop1, self);
				print(" is mapped?! ", self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			/* begin fetchPointer:ofFreeChunk: */
			fieldOop = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop), self)) != 0)) {
				print("leak in free chunk ", self);
				printHex(objOop1, self);
				print(" @ 0 = ", self);
				printHex(fieldOop, self);
				print(" is mapped", self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			if (!(isLilliputianSize(bytesInObject(objOop1, self), self))) {
				/* begin fetchPointer:ofFreeChunk: */
				fieldOop = longAt((objOop1 + BaseHeaderSize) + (1U << (shiftForWord(self))));
				if ((fieldOop != 0)
				 && ((heapMapAtWord(pointerForOop(fieldOop), self)) != 0)) {
					print("leak in free chunk ", self);
					printHex(objOop1, self);
					print(" @ 1 = ", self);
					printHex(fieldOop, self);
					print(" is mapped", self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			if ((bytesInObject(objOop1, self)) >= (64 /* numFreeLists */ * 8 /* allocationUnit */)) {
				for (fi = 2 /* freeChunkParentIndex */, iLimiT = 4 /* freeChunkLargerIndex */; fi <= iLimiT; fi += 1) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(fieldOop), self)) != 0)) {
						print("leak in free chunk ", self);
						printHex(objOop1, self);
						print(" @ ", self);
						printNum(fi, self);
						print(" = ", self);
						printHex(fieldOop, self);
						print(" is mapped", self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		else {
			if (!(excludeUnmarkedObjs
				 && (!(((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0)))) {
				containsYoung = 0;
				if (((((usqInt) (longAt(objOop1))) >> (rememberedBitShift(self))) & 1) != 0) {
					numRememberedObjectsInHeap += 1;
					if (!(isInRememberedSet(objOop1, self))) {
						print("remembered object ", self);
						printHex(objOop1, self);
						print(" is not in remembered table", self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
				if (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
					if ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0) {
						print("object leak in forwarder ", self);
						printHex(objOop1, self);
						print(" to unmapped ", self);
						printHex(fieldOop, self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
					if (((fieldOop & (tagMask(self))) == 0)
					 && ((assert(isNonImmediate(fieldOop, self)),
					oopisLessThan(fieldOop, GIV(newSpaceLimit), self)))) {
						containsYoung = 1;
					}
				}
				else {
					/* begin classOrNilAtIndex: */
					classIndex3 = (classIndex = (longAt(objOop1)) & (classIndexMask(self)));
					assert((classIndex3 <= (tagMask(self)))
					 || (classIndex3 >= (arrayClassIndexPun(self))));
					/* begin fetchPointer:ofObject: */
					fieldIndex3 = ((usqInt) classIndex3) >> (classTableMajorIndexShift(self));
					classTablePage2 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex3) << (shiftForWord(self))))));
					if (classTablePage2 == GIV(nilObj)) {
						classOop = GIV(nilObj);
						goto l19;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex12 = classIndex3 & ((1U << (classTableMajorIndexShift(self))) - 1);
					classOop = longAt((classTablePage2 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex12) << (shiftForWord(self))))));
	l19:	/* end classOrNilAtIndex: */;
					if (classIndicesShouldBeValid
					 && ((classOop == GIV(nilObj))
					 && (classIndex > (lastClassIndexPun(self))))) {
						print("object leak in ", self);
						printHex(objOop1, self);
						print(" invalid class index ", self);
						printHex(classIndex, self);
						print(" -> ", self);
						print((classOop == null
							? "nil"
							: "nilObj"), self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
					for (fi = 0, iLimiT = ((numPointerSlotsOf(objOop1, self)) - 1); fi <= iLimiT; fi += 1) {
						fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord(self))))));
						if ((fieldOop & (tagMask(self))) == 0) {
							if ((heapMapAtWord(pointerForOop(fieldOop), self)) == 0) {
								print("object leak in ", self);
								printHex(objOop1, self);
								print(" @ ", self);
								printNum(fi, self);
								print(" = ", self);
								printHex(fieldOop, self);
								/* begin cr */
								printf("\n");
								ok = 0;
							}
							if (((fieldOop & (tagMask(self))) == 0)
							 && ((assert(isNonImmediate(fieldOop, self)),
							oopisLessThan(fieldOop, GIV(newSpaceLimit), self)))) {
								containsYoung = 1;
							}
						}
					}
				}
				if (containsYoung) {
					if (!(((((usqInt) (longAt(objOop1))) >> (rememberedBitShift(self))) & 1) != 0)) {
						print("unremembered object ", self);
						printHex(objOop1, self);
						print(" contains young oop(s)", self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l16;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l16:	/* end objectAfter:limit: */;
	}
	if (numRememberedObjectsInHeap != (rememberedSetSize(self))) {
		print("root count mismatch. #heap roots ", self);
		printNum(numRememberedObjectsInHeap, self);
		print("; #roots ", self);
		printNum(rememberedSetSize(self), self);
		/* begin cr */
		printf("\n");
		flag("no support for remembered set overflow yet");
	}
	/* begin rememberedSetWithIndexDo: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		obj = GIV(rememberedSet)[i1];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned oop in remembered set @ ", self);
			printNum(i1, self);
			print(" = ", self);
			printHex(obj, self);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj), self)) == 0) {
				print("object leak in remembered set @ ", self);
				printNum(i1, self);
				print(" = ", self);
				printHex(obj, self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			else {
				if (((obj & (tagMask(self))) == 0)
				 && (oopisLessThan(obj, GIV(newSpaceLimit), self))) {
					print("non-root in remembered set @ ", self);
					printNum(i1, self);
					print(" = ", self);
					printHex(obj, self);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
		}
	}
	/* begin objStack:do: */
	if (GIV(mournQueue) == GIV(nilObj)) {
		goto l9;
	}
	eassert(isValidObjStack(GIV(mournQueue), self));
	objStackPage = GIV(mournQueue);
	while (objStackPage != 0) {
		/* begin fetchPointer:ofObject: */
		numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
		for (i2 = ((numOnThisPage + ObjStackFixedSlots) - 1); i2 >= ObjStackFixedSlots; i2 += -1) {
			obj = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord(self))))));
			if ((obj & (BytesPerWord - 1)) != 0) {
				print("misaligned oop in mournQueue @ ", self);
				printNum(i2, self);
				print(" in ", self);
				printHex(objStackPage, self);
				print(" = ", self);
				printHex(obj, self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			else {
				if (!(excludeUnmarkedObjs
					 && (!(((((usqInt) (longAt(obj))) >> (markedBitFullShift(self))) & 1) != 0)))) {
					if ((heapMapAtWord(pointerForOop(obj), self)) == 0) {
						print("object leak in mournQueue @ ", self);
						printNum(i2, self);
						print(" in ", self);
						printHex(objStackPage, self);
						print(" = ", self);
						printHex(obj, self);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		/* begin fetchPointer:ofObject: */
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	}
	l9:	/* end objStack:do: */;
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned remapRoot @ ", self);
			printNum(ri, self);
			print(" = ", self);
			printHex(obj, self);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj), self)) == 0) {
				print("object leak in remapRoots @ ", self);
				printNum(ri, self);
				print(" = ", self);
				printHex(obj, self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned extraRoot @ ", self);
			printNum(ri, self);
			print(" => ", self);
			printHex(obj, self);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj), self)) == 0) {
				print("object leak in extraRoots @ ", self);
				printNum(ri, self);
				print(" => ", self);
				printHex(obj, self);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */

	/* SpurMemoryManager>>#checkOkayOop: */
sqInt
checkOkayOop(usqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;

	if (oop & (tagMask(self))) {
		return 1;
	}
	if (!(addressCouldBeObj(oop, self))) {
		print("oop ", self);
		printHex(oop, self);
		print(" is not a valid address", self);
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop, self), GIV(endOfMemory), self))) {
		print("oop ", self);
		printHex(oop, self);
		print(" size would make it extend beyond the end of memory", self);
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & (classIndexMask(self)))) >= (firstClassIndexPun(self)))) {
		print("oop ", self);
		printHex(oop, self);
		print(" is a free chunk, or bridge, not an object", self);
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask(self)))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask(self)))) {
		print("oop ", self);
		printHex(oop, self);
		print(" header has overflow header word, but overflow word does not have a saturated numSlots field", self);
		return 0;
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	if ((fmt == 6) || (fmt == 8)) {
		print("oop ", self);
		printHex(oop, self);
		print(" has an unknown format type", self);
		return 0;
	}
	if ((fmt == 7 /* forwardedFormat */) != (classIndex == (isForwardedObjectClassIndexPun(self)))) {
		print("oop ", self);
		printHex(oop, self);
		print(" has mis-matched format/classIndex fields; only one of them is the isForwarded value", self);
		return 0;
	}
	unusedBits = (1U << 22 /* classIndexFieldWidth */) | (1ULL << (22 /* identityHashFieldWidth */ + 32));
	if (((long64At(oop)) & unusedBits) != 0) {
		print("oop ", self);
		printHex(oop, self);
		print(" has some unused header bits set; should be zero", self);
		return 0;
	}
	unusedBitsInYoungObjects = (1U << (greyBitShift(self))) | ((1U << (pinnedBitShift(self))) | (1U << (rememberedBitShift(self))));
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		print("oop ", self);
		printHex(oop, self);
		print(" has some header bits unused in young objects set; should be zero", self);
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */

	/* SpurMemoryManager>>#checkOopHasOkayClass: */
sqInt
checkOopHasOkayClass(usqInt obj, struct foo * self)
{
    usqInt objClass;
    sqInt objFormat;

	if (!(checkOkayOop(obj, self))) {
		return 0;
	}
	objClass = ((usqInt) (fetchClassOfNonImm(obj, self)));
	if (objClass & (tagMask(self))) {
		print("obj ", self);
		printHex(obj, self);
		print(" an immediate is not a valid class or behavior", self);
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!(okayOop(objClass, self))) {
		print("obj ", self);
		printHex(obj, self);
		print(" class obj is not ok", self);
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!((((((usqInt) (longAt(objClass))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
		 && ((numSlotsOf(objClass, self)) >= 3))) {
		print("obj ", self);
		printHex(obj, self);
		print(" a class (behavior) must be a pointers object of size >= 3", self);
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (((obj & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(obj))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))) {

		/* ignore extra bytes size bits */
		objFormat = ((((((usqInt) (longAt(obj))) >> (formatShift(self))) & (formatMask(self))) | 7) - 7);
	}
	else {
		objFormat = (((usqInt) (longAt(obj))) >> (formatShift(self))) & (formatMask(self));
	}
	if ((instSpecOfClassFormat(((longAt((objClass + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3), self)) != objFormat) {
		print("obj ", self);
		printHex(obj, self);
		print(" and its class (behavior) formats differ", self);
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

	/* SpurMemoryManager>>#checkOopIntegrity:named: */
static sqInt NoDbgRegParms
checkOopIntegritynamed(sqInt obj, char *name, struct foo * self)
{
	if ((heapMapAtWord(pointerForOop(obj), self)) != 0) {
		return 1;
	}
	print(name, self);
	print(" leak ", self);
	printHex(obj, self);
	/* begin cr */
	printf("\n");
	return 0;
}

	/* SpurMemoryManager>>#checkOopIntegrity:named:index: */
static sqInt NoDbgRegParms
checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i, struct foo * self)
{
	if ((heapMapAtWord(pointerForOop(obj), self)) != 0) {
		return 1;
	}
	print(name, self);
	print(" leak @ ", self);
	printNum(i, self);
	print(" = ", self);
	printHex(obj, self);
	/* begin cr */
	printf("\n");
	return 0;
}

	/* SpurMemoryManager>>#classAlien */
sqInt
classAlien(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classArray */
sqInt
classArray(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classAtIndex: */
sqInt
classAtIndex(sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex >= 0)
	 && ((classIndex <= (tagMask(self)))
	 || ((classIndex >= (arrayClassIndexPun(self)))
	 && (classIndex <= (classIndexMask(self))))));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
}


/*	for become & GC of classes */

	/* SpurMemoryManager>>#classAtIndex:put: */
static sqInt NoDbgRegParms
classAtIndexput(sqInt classIndex, sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex <= (tagMask(self)))
	 || (classIndex >= (arrayClassIndexPun(self))));
	assert((objOop == GIV(nilObj))
	 || ((((rawHashBitsOf(objOop, self)) == classIndex)
	 || ((classAtIndex(rawHashBitsOf(objOop, self), self)) == objOop))
	 && (objCouldBeClassObj(objOop, self))));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (classTablePage == GIV(nilObj)) {
		error("attempt to add class to empty page");
	}
	/* begin storePointer:ofObject:withValue: */
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	assert(!(isForwarded(classTablePage, self)));
	if ((assert(isNonImmediate(classTablePage, self)),
	oopisGreaterThanOrEqualTo(classTablePage, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((objOop & (tagMask(self))) == 0)
		 && (oopisLessThan(objOop, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(classTablePage))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(classTablePage, self);
			}
		}
	}
	return longAtput((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))), objOop);
}

	/* SpurMemoryManager>>#classBitmap */
sqInt
classBitmap(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBitmap) << (shiftForWord(self))))));
}


/*	a.k.a. self fetchPointer: ClassByteArrayCompactIndex ofObject:
	classTableFirstPage 
 */

	/* SpurMemoryManager>>#classByteArray */
sqInt
classByteArray(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteArray) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classCharacter */
sqInt
classCharacter(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassCharacter) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classExternalAddress */
sqInt
classExternalAddress(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classExternalData */
sqInt
classExternalData(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalData) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classExternalFunction */
sqInt
classExternalFunction(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalFunction) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classExternalLibrary */
sqInt
classExternalLibrary(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalLibrary) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classExternalStructure */
sqInt
classExternalStructure(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalStructure) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classFloat */
sqInt
classFloat(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloat) << (shiftForWord(self))))));
}


/*	Clear any odd bits from the format so that it matches its class's format */

	/* SpurMemoryManager>>#classFormatForInstanceFormat: */
static sqInt NoDbgRegParms
classFormatForInstanceFormat(sqInt aFormat, struct foo * self)
{
	if (aFormat < (firstLongFormat(self))) {
		return aFormat;
	}
	if (aFormat >= (firstByteFormat(self))) {
		return aFormat & -8;
	}
	return (aFormat >= (firstShortFormat(self))
		? aFormat & -4
		: aFormat & -2);
}


/*	22-bit class mask => ~ 4M classes */

	/* SpurMemoryManager>>#classIndexFieldWidth */
static sqInt
classIndexFieldWidth(struct foo * self)
{
	return 22;
}


/*	Answer objOop's classIndex from the object header.
	A note on performance:
	This routine uses longAt:, which does a 32-bit load on the 32-bit system,
	and a 64-bit load
	on the 64-bit system. Since the only 64-bit implementation(s) is/are
	little-endian, and
	since all of isGrey,isPinned,isRemembered,format,isUmmutable and
	classIndex fit within
	the least significant 32-bits we could use long32At: to access these, in
	the hope that the
	32-bit access will be quicker on 64-bits by virtue of fetching half the
	bits. But experiments
	show that doing this does not produce any increase; at least any signal is
	lost in the noise. */

	/* SpurMemoryManager>>#classIndexOf: */
sqInt
classIndexOf(sqInt objOop, struct foo * self)
{
	return (longAt(objOop)) & (classIndexMask(self));
}

	/* SpurMemoryManager>>#classLargeNegativeInteger */
sqInt
classLargeNegativeInteger(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize(self))))),
		/* begin fetchPointer:ofObject: */
		longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeIntegerCompactIndex) << (shiftForWord(self)))))));
}

	/* SpurMemoryManager>>#classLargePositiveInteger */
sqInt
classLargePositiveInteger(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize(self))))),
		/* begin fetchPointer:ofObject: */
		longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveIntegerCompactIndex) << (shiftForWord(self)))))));
}

	/* SpurMemoryManager>>#classOrNilAtIndex: */
sqInt
classOrNilAtIndex(sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex <= (tagMask(self)))
	 || (classIndex >= (arrayClassIndexPun(self))));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classPoint */
sqInt
classPoint(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classSemaphore */
sqInt
classSemaphore(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classSmallInteger */
sqInt
classSmallInteger(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSmallInteger) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#classString */
sqInt
classString(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord(self))))));
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTableMinorIndexMask */

	/* SpurMemoryManager>>#classTableMinorIndexMask */
sqInt
classTableMinorIndexMask(struct foo * self)
{
	return (1U << (classTableMajorIndexShift(self))) - 1;
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTablePageSize */

	/* SpurMemoryManager>>#classTablePageSize */
sqInt
classTablePageSize(struct foo * self)
{
	return 1U << (classTableMajorIndexShift(self));
}


/*	For Cogit & bootstrap */

	/* SpurMemoryManager>>#classTableRootObj */
sqInt
classTableRootObj(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	Answer the number of slots for class table pages in the hidden root
	object. 
 */

	/* SpurMemoryManager>>#classTableRootSlots */
static sqInt
classTableRootSlots(struct foo * self)
{
	return 1U << (22 /* classIndexFieldWidth */ - (classTableMajorIndexShift(self)));
}


/*	Answer the classObj's identityHash to use as a tag in the first-level
	method lookup cache.
 */

	/* SpurMemoryManager>>#classTagForClass: */
sqInt
classTagForClass(sqInt classObj, struct foo * self)
{
    sqInt err;
    sqInt hash;

	return (assert(addressCouldBeClassObj(classObj, self)),
		(((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask(self)))) != 0
				? hash
				: (objCouldBeClassObj(classObj, self)
						? (((err = enterIntoClassTable(classObj, self))) != 0
								? -err
								: (/* begin rawHashBitsOf: */
									(long32At(classObj + 4)) & (identityHashHalfWordMask(self))))
						: -PrimErrBadReceiver)));
}

	/* SpurMemoryManager>>#classUnsafeAlien */
sqInt
classUnsafeAlien(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassUnsafeAlien) << (shiftForWord(self))))));
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each free
	chunk's header. */

	/* SpurMemoryManager>>#clearLeakMapAndMapAccessibleFreeSpace */
static void
clearLeakMapAndMapAccessibleFreeSpace(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;

	clearHeapMap(self);
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj = (prevObj = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			heapMapAtWordPut(pointerForOop(objOop1), 1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

	/* SpurMemoryManager>>#clearLeakMapAndMapAccessibleObjects */
static void
clearLeakMapAndMapAccessibleObjects(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	clearHeapMap(self);
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		heapMapAtWordPut(pointerForOop(objOop1), 1, self);
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		heapMapAtWordPut(pointerForOop(objOop1), 1, self);
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			heapMapAtWordPut(pointerForOop(objOop11), 1, self);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#cloneInOldSpace:forPinning: */
static sqInt NoDbgRegParms
cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt hash;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt referent;

	/* begin numSlotsOf: */
	assert((classIndexOf(objOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	if (forPinning) {
		newObj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
			? 8 /* allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord(self))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), fmt, (longAt(objOop)) & (classIndexMask(self)), self);
	}
	else {
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
			? 8 /* allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord(self))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), fmt, (longAt(objOop)) & (classIndexMask(self)), self);
	}
	if (!(newObj)) {
		return 0;
	}
	if (fmt <= 5 /* lastPointerFormat */) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			if (((oop & (tagMask(self))) == 0)
			 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent & (tagMask(self))) == 0)
				 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				oop = referent;
			}
			if (((oop & (tagMask(self))) == 0)
			 && ((assert(isNonImmediate(oop, self)),
			oopisLessThan(oop, GIV(newSpaceLimit), self)))) {
				hasYoung = 1;
			}
			assert(!(isOopForwarded(newObj, self)));
			longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), oop);
		}
		if (hasYoung) {
			remember(newObj, self);
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(newObj, self)));
			longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))));
		}
		if (fmt >= (firstCompiledMethodFormat(self))) {
			if (((assert(isNonImmediate(objOop, self)),
			oopisLessThan(objOop, GIV(newSpaceLimit), self)))
			 || (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(newObj, self);
			}
		}
	}
	if (((hash = (long32At(objOop + 4)) & (identityHashHalfWordMask(self)))) != 0) {
		/* begin setHashBitsOf:to: */
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask(self)))));
		long32Atput(newObj + 4, ((((long32At(newObj + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash);
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(objOop))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin setIsImmutableOf:to: */
		longAtput(newObj, (longAt(newObj)) | (1U << (immutableBitShift(self))));
	}
	return newObj;
}

	/* SpurMemoryManager>>#clone: */
sqInt
clone(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt fmt;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt referent;

	/* begin numSlotsOf: */
	assert((classIndexOf(objOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	if (numSlots > ((1U << (fixedFieldsFieldWidth(self))) - 1)) {
		/* begin allocateSlotsInOldSpace:format:classIndex: */
		classIndex = (longAt(objOop)) & (classIndexMask(self));
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
			? 8 /* allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord(self))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), fmt, classIndex, self);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		classIndex1 = (longAt(objOop)) & (classIndexMask(self));
		if (numSlots >= (numSlotsMask(self))) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				newObj = null;
				goto l5;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? /* begin allocationUnit */ 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck(self);
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, fmt, classIndex1, self);
			goto l5;
		}
		if (numSlots >= (numSlotsMask(self))) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(self), fmt, classIndex1, self));
		}
		else {
			longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(fmt) << (formatShift(self)))))) + classIndex1);
		}
		assert((numBytes % (allocationUnit(self))) == 0);
		assert((newObj1 % (allocationUnit(self))) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l5:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj)) {
		return 0;
	}
	if (fmt <= 5 /* lastPointerFormat */) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			if ((oop & (tagMask(self))) == 0) {
				if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(oop, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					oop = referent;
				}
				if (((oop & (tagMask(self))) == 0)
				 && ((assert(isNonImmediate(oop, self)),
				oopisLessThan(oop, GIV(newSpaceLimit), self)))) {
					hasYoung = 1;
				}
			}
			assert(!(isOopForwarded(newObj, self)));
			longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), oop);
		}
		if (hasYoung
		 && (!((assert(isNonImmediate(newObj, self)),
		oopisLessThan(newObj, GIV(newSpaceLimit), self))))) {
			remember(newObj, self);
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(newObj, self)));
			longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))));
		}
		if (fmt >= (firstCompiledMethodFormat(self))) {
			if (((assert(isNonImmediate(newObj, self)),
			oopisGreaterThanOrEqualTo(newObj, GIV(oldSpaceStart), self)))
			 && (((assert(isNonImmediate(objOop, self)),
			oopisLessThan(objOop, GIV(newSpaceLimit), self)))
			 || (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0))) {
				remember(newObj, self);
			}
		}
	}
	return newObj;
}

	/* SpurMemoryManager>>#compactClassIndexOf: */
sqInt
compactClassIndexOf(sqInt objOop, struct foo * self)
{
	/* begin classIndexOf: */
	return (longAt(objOop)) & (classIndexMask(self));
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Copy objOop into the segment beginning at segAddr, and forward it to the
	copy, saving its first field in savedFirstField, and setting its marked
	bit to indicate it has
	been copied. If it is a class in the class table, set the copy's hash to 0
	for reassignment
	on load, and mark it as a class by setting its isRemembered bit.
	Answer the next segmentAddr if successful. Answer an appropriate error
	code if not */
/*	Copy the object... */

	/* SpurMemoryManager>>#copyObj:toAddr:stopAt:savedFirstFields:index: */
static sqInt NoDbgRegParms
copyObjtoAddrstopAtsavedFirstFieldsindex(sqInt objOop, sqInt segAddr, sqInt endSeg, sqInt savedFirstFields, sqInt i, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bodySize;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt copy;
    sqInt fmt;
    sqInt hash;
    sqInt header;
    sqInt i1;
    sqInt iLimiT;
    sqInt numLiterals;
    usqInt numMediatedSlots;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt sp;

	assert(!((isCopiedIntoSegment(objOop, self))));
	bodySize = bytesInObject(objOop, self);
	if (oopisGreaterThanOrEqualTo(segAddr + bodySize, endSeg, self)) {
		return PrimErrWritePastObject;
	}
	memcpy(((void *)segAddr), ((void *)(((byteAt(objOop + 7)) == (numSlotsMask(self))
	? objOop - BaseHeaderSize
	: objOop))), bodySize);
	/* begin objectStartingAt: */
	numSlots = byteAt(segAddr + 7);
	copy = (numSlots == (numSlotsMask(self))
		? segAddr + BaseHeaderSize
		: segAddr);
	/* begin setIsRememberedOf:to: */
	longAtput(copy, (longAt(copy)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(copy, self)));
	longAtput(copy, (longAt(copy)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
	/* begin ifAProxy:updateCopy: */
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		if (((((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {

			/* Since the context is here via objectsReachableFromRoots: we know it cannot be divorced.
			   I'd like to assert coInterpreter checkIsStillMarriedContext: objOop currentFP: framePointer,
			   here but that requires access to framePointer. */
			/* begin numSlotsOfMarriedContext: */
			contextSize = stackPointerIndexForFrame(frameOfMarriedContext(objOop, self), self);
			numMediatedSlots = CtxtTempFrameStart + contextSize;
			for (i1 = 0; i1 < numMediatedSlots; i1 += 1) {
				oop = fetchPointerofMarriedContext(i1, objOop, self);
				assert(!(isOopForwarded(copy, self)));
				longAtput((copy + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), oop);
			}
		}
		else {
			/* begin numPointerSlotsOf: */
			fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
			if (fmt <= 5 /* lastPointerFormat */) {
				if ((fmt == (indexablePointersFormat(self)))
				 && (((longAt(objOop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
					if (!((((sp) & 7) == 1))) {
						contextSize1 = 0;
						goto l3;
					}
					assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop, self)));
					contextSize1 = (sp >> 3);
	l3:	/* end fetchStackPointerOf: */;
					numMediatedSlots = CtxtTempFrameStart + contextSize1;
					goto l5;
				}
				/* begin numSlotsOf: */
				assert((classIndexOf(objOop, self)) > (isForwardedObjectClassIndexPun(self)));
				numSlots1 = byteAt(objOop + 7);
				numMediatedSlots = (numSlots1 == (numSlotsMask(self))
					? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1);
				goto l5;
			}
			if (fmt == 7 /* forwardedFormat */) {
				numMediatedSlots = 1;
				goto l5;
			}
			if (fmt < (firstCompiledMethodFormat(self))) {
				numMediatedSlots = 0;
				goto l5;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objOop, self));
			/* begin fetchPointer:ofObject: */
			header = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			numMediatedSlots = numLiterals + LiteralStart;
	l5:	/* end numPointerSlotsOf: */;
		}
		for (i1 = numMediatedSlots, iLimiT = ((numSlotsOf(objOop, self)) - 1); i1 <= iLimiT; i1 += 1) {
			assert(!(isOopForwarded(copy, self)));
			longAtput((copy + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), GIV(nilObj));
		}
	}
	hash = (long32At(objOop + 4)) & (identityHashHalfWordMask(self));
	if ((hash > (lastClassIndexPun(self)))
	 && ((classOrNilAtIndex(hash, self)) == objOop)) {
		/* begin setHashBitsOf:to: */
		assert(((0 >= 0) && (0 <= (identityHashHalfWordMask(self)))));
		long32Atput(copy + 4, ((((long32At(copy + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))));
		/* begin setIsRememberedOf:to: */
		longAtput(copy, (longAt(copy)) | (1U << (rememberedBitShift(self))));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(savedFirstFields, self)));
	longAtput((savedFirstFields + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self)))));
	assert(!(isOopForwarded(objOop, self)));
	longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))), copy);
	/* begin markAsCopiedIntoSegment: */
	assert(!(isFreeObject(objOop, self)));
	longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift(self))));
	return segAddr + bodySize;
}


/*	print the count of marked and unmarked objects.
	In addition if 1 is set in printFlags, short-print marked objects,
	and/or if 2 is set, short-print unmarked obejcts. */

	/* SpurMemoryManager>>#countMarkedAndUnmarkdObjects: */
void
countMarkedAndUnmarkdObjects(sqInt printFlags, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    sqInt nm;
    sqInt nu;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	nm = (nu = 0);
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0) {
			nm += 1;
			if (printFlags & 1) {
				shortPrintOop(objOop1, self);
			}
		}
		else {
			nu += 1;
			if (printFlags & 2) {
				shortPrintOop(objOop1, self);
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0) {
			nm += 1;
			if (printFlags & 1) {
				shortPrintOop(objOop1, self);
			}
		}
		else {
			nu += 1;
			if (printFlags & 2) {
				shortPrintOop(objOop1, self);
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if (((((usqInt) (longAt(objOop11))) >> (markedBitFullShift(self))) & 1) != 0) {
				nm += 1;
				if (printFlags & 1) {
					shortPrintOop(objOop11, self);
				}
			}
			else {
				nu += 1;
				if (printFlags & 2) {
					shortPrintOop(objOop11, self);
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	print("n marked: ", self);
	printNum(nm, self);
	/* begin cr */
	printf("\n");
	print("n unmarked: ", self);
	printNum(nu, self);
	/* begin cr */
	printf("\n");
}


/*	Compute the current allocated bytes since last set.
	This is the cumulative total in statAllocatedBytes plus the allocation
	since the last scavenge. */
/*	Slang infers the type of the difference between two unsigned variables as
	signed. In this case we want it to be unsigned. */

	/* SpurMemoryManager>>#currentAllocatedBytes */
static usqLong
currentAllocatedBytes(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt use;


	/* Slang infers the type of the difference between two unsigned variables as signed.
	   In this case we want it to be unsigned. */
	use = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);
	return (GIV(statAllocatedBytes) + (GIV(freeStart) - (((eden(self)).start)))) + (use - GIV(oldSpaceUsePriorToScavenge));
}

	/* SpurMemoryManager>>#displayObject */
sqInt
displayObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheDisplay) << (shiftForWord(self))))));
}


/*	The inner shell for scavenge, abstrascted out so globalGarbageCollect can
	use it.
 */

	/* SpurMemoryManager>>#doScavenge: */
static void NoDbgRegParms
doScavenge(sqInt tenuringCriterion, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurNewSpaceSpace *aNewSpace;
    float fractionSurvived;
    sqInt oldStart;
    sqInt p;
    SpurNewSpaceSpace temp;
    usqInt use;

	/* begin doAllocationAccountingForScavenge */
	use = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);
	GIV(statAllocatedBytes) = (GIV(statAllocatedBytes) + (GIV(freeStart) - (((eden(self)).start)))) + (use - GIV(oldSpaceUsePriorToScavenge));
	GIV(gcPhaseInProgress) = ScavengeInProgress;
	/* begin scavenge: */
	GIV(statSurvivorCount) = 0;
	GIV(tenureCriterion) = tenuringCriterion;
	/* begin logStartScavenge */
	(GIV(scavengeLogRecord).sEdenBytes = (freeStart(self)) - ((GIV(eden).start)));
	(GIV(scavengeLogRecord).sPastBytes = (pastSpaceStart(self)) - ((GIV(pastSpace).start)));
	(GIV(scavengeLogRecord).sRememberedSetSize = GIV(rememberedSetSize));
	(GIV(scavengeLogRecord).sRememberedSetRedZone = GIV(rememberedSetRedZone));
	(GIV(scavengeLogRecord).sRememberedSetLimit = GIV(rememberedSetLimit));
	(GIV(scavengeLogRecord).sStatTenures = GIV(statTenures));
	/* begin strategizeToLimitRememberedTable */
	if ((GIV(tenureCriterion) == TenureByAge)
	 && (GIV(rememberedSetSize) >= GIV(rememberedSetRedZone))) {
		GIV(tenureCriterion) = TenureToShrinkRT;
		computeRefCountToShrinkRT(self);
	}
	/* begin logTenuringPolicy */
	(GIV(scavengeLogRecord).tTenureCriterion = GIV(tenureCriterion));
	(GIV(scavengeLogRecord).tTenureThreshold = ((GIV(tenureCriterion) == TenureByAge)
	 && (GIV(tenureThreshold) > ((GIV(pastSpace).start)))
		? GIV(tenureThreshold) - ((GIV(pastSpace).start))
		: 0));
	(GIV(scavengeLogRecord).tRefCountToShrinkRT = GIV(refCountToShrinkRT));
	scavengeLoop(self);
	processWeaklings(self);
	/* begin computeTenuringThreshold */
	fractionSurvived = (((GIV(futureSpace).limit)) == ((GIV(futureSpace).start))
		? 0.0
		: (((double) (GIV(futureSurvivorStart) - ((GIV(futureSpace).start))) )) / (((GIV(futureSpace).limit)) - ((GIV(futureSpace).start))));
	GIV(tenureThreshold) = (fractionSurvived > 0.9
		? (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - GIV(tenuringProportion))))) + ((GIV(pastSpace).start))
		: 0);
	/* begin exchangeSurvivorSpaces */
	temp = GIV(pastSpace);
	GIV(pastSpace) = GIV(futureSpace);
	GIV(futureSpace) = temp;
	/* begin logEndScavenge */
	(GIV(scavengeLogRecord).eSurvivorBytes = GIV(futureSurvivorStart) - ((GIV(pastSpace).start)));
	(GIV(scavengeLogRecord).eRememberedSetSize = GIV(rememberedSetSize));
	(GIV(scavengeLogRecord).eStatTenures = GIV(statTenures));
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	GIV(pastSpaceStart) = oldStart;
	assert(oopisGreaterThanOrEqualToandLessThanOrEqualTo(GIV(pastSpaceStart), ((pastSpace(self)).start), ((pastSpace(self)).limit), self));
	GIV(freeStart) = ((eden(self)).start);
	/* begin initSpaceForAllocationCheck:limit: */
	aNewSpace = ((SpurNewSpaceSpace *) ((&(eden(self)))));
	if (GIV(memory)) {
		if (checkAllocFiller(self)) {
			for (p = ((aNewSpace->start)); p < GIV(scavengeThreshold); p += BytesPerWord) {
				longAtput(p, p);
			}
		}
	}
	GIV(gcPhaseInProgress) = 0;
	/* begin resetAllocationAccountingAfterGC */
	GIV(oldSpaceUsePriorToScavenge) = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

	/* SpurMemoryManager>>#eeInstantiateClassIndex:format:numSlots: */
sqInt
eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
	return allocateNewSpaceSlotsformatclassIndex(numSlots, objFormat, knownClassIndex, self);
}


/*	Remove all the entries on the stack. Do so by setting Topx to 0
	on the first page, and adding all subsequent pages to the free list. */

	/* SpurMemoryManager>>#emptyObjStack: */
static void NoDbgRegParms
emptyObjStack(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nextNextPage;
    sqInt nextPage;

	if (objStack == GIV(nilObj)) {
		return;
	}
	eassert(isValidObjStack(objStack, self));
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack, self)) == (wordIndexableFormat(self)));
	longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))), 0);
	nextPage = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	while (nextPage != 0) {
		nextNextPage = longAt((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage, self)) == (wordIndexableFormat(self)));
		longAtput((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))), longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self)))))));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage, self)) == (wordIndexableFormat(self)));
		longAtput((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))), 0);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack, self)) == (wordIndexableFormat(self)));
		longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))), nextPage);
		nextPage = nextNextPage;
	}
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack, self)) == (wordIndexableFormat(self)));
	longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))), 0);
	eassert(isValidObjStack(objStack, self));
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such as
	the markStack or the ephemeronQueue. It is a linked list of segments,
	with the hot end at the head of the list. It is a word object. The stack
	pointer is in ObjStackTopx and 0 means empty. The list goes through
	ObjStackNextx. We don't want to shrink objStacks, since they're used
	in GC and its good to keep their memory around. So unused pages
	created by popping emptying pages are kept on the ObjStackFreex list. */

	/* SpurMemoryManager>>#ensureRoomOnObjStackAt: */
static sqInt NoDbgRegParms
ensureRoomOnObjStackAt(sqInt objStackRootIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt formatField;
    sqInt formatField1;
    sqInt freeOrNewPage;
    sqInt stackOrNil;
    sqInt thang;

	stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord(self))))));
	if ((stackOrNil == GIV(nilObj))
	 || ((longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))))) >= ObjStackLimit)) {
		if (stackOrNil == GIV(nilObj)) {
			freeOrNewPage = 0;
		}
		else {
			freeOrNewPage = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
		}
		if (freeOrNewPage != 0) {

			/* the free page list is always on the new page. */
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(stackOrNil, self)) == (wordIndexableFormat(self)));
			longAtput((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))), 0);
			assert((!GIV(marking))
			 || (isMarked(freeOrNewPage, self)));
		}
		else {
			/* begin allocateSlotsInOldSpace:format:classIndex: */
			formatField1 = sixtyFourBitIndexableFormat(self);
			classIndex1 = sixtyFourBitLongsClassIndexPun(self);
			freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, (((sqInt)((usqInt)(ObjStackPageSlots) << (shiftForWord(self))))) + (BaseHeaderSize + BaseHeaderSize), formatField1, classIndex1, self);
			if (!(freeOrNewPage)) {

				/* Allocate a new segment an retry. This is very uncommon. But it happened to me (Clement). */
				growOldSpaceByAtLeast(ObjStackPageSlots, self);
				/* begin allocateSlotsInOldSpace:format:classIndex: */
				formatField = sixtyFourBitIndexableFormat(self);
				classIndex = sixtyFourBitLongsClassIndexPun(self);
				freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, (((sqInt)((usqInt)(ObjStackPageSlots) << (shiftForWord(self))))) + (BaseHeaderSize + BaseHeaderSize), formatField, classIndex, self);
				if (!(freeOrNewPage)) {
					error("no memory to allocate or extend obj stack");
				}
			}
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(freeOrNewPage, self)) == (wordIndexableFormat(self)));
			longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))), 0);
			if (GIV(marking)) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(freeOrNewPage, self)));
				longAtput(freeOrNewPage, (longAt(freeOrNewPage)) | (1ULL << (markedBitFullShift(self))));
			}
		}
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage, self)) == (wordIndexableFormat(self)));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord(self))))), objStackRootIndex);
		/* begin storePointer:ofObjStack:withValue: */
		thang = (stackOrNil == GIV(nilObj)
			? 0
			: stackOrNil);
		assert((formatOf(freeOrNewPage, self)) == (wordIndexableFormat(self)));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))), thang);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage, self)) == (wordIndexableFormat(self)));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))), 0);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj), self)));
		if ((assert(isNonImmediate(GIV(hiddenRootsObj), self)),
		oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((freeOrNewPage & (tagMask(self))) == 0)
			 && (oopisLessThan(freeOrNewPage, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(GIV(hiddenRootsObj), self);
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord(self))))), freeOrNewPage);
		assert(isValidObjStackAt(objStackRootIndex, self));
		/* begin updateRootOfObjStackAt:with: */
		assert(!(isForwarded(GIV(hiddenRootsObj), self)));
		if ((assert(isNonImmediate(GIV(hiddenRootsObj), self)),
		oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((freeOrNewPage & (tagMask(self))) == 0)
			 && (oopisLessThan(freeOrNewPage, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(GIV(hiddenRootsObj), self);
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord(self))))), freeOrNewPage);
		
		switch (objStackRootIndex) {
		case MarkStackRootIndex:
			GIV(markStack) = freeOrNewPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = freeOrNewPage;
			break;
		case MournQueueRootIndex:
			GIV(mournQueue) = freeOrNewPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		stackOrNil = freeOrNewPage;
	}
	assert(isValidObjStackAt(objStackRootIndex, self));
	return stackOrNil;
}


/*	Enter aBehavior into the class table and answer 0. Otherwise answer a
	primitive failure code. */

	/* SpurMemoryManager>>#enterIntoClassTable: */
static sqInt NoDbgRegParms
enterIntoClassTable(sqInt aBehavior, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt hash;
    sqInt i;
    sqInt iLimiT;
    sqInt initialMajorIndex;
    sqInt majorIndex;
    sqInt minorIndex;
    sqInt numSlots;
    sqInt numSlots1;
    usqInt p;
    sqInt page;

	majorIndex = ((usqInt) GIV(classTableIndex)) >> (classTableMajorIndexShift(self));

	/* classTableIndex should never index the first page; it's reserved for known classes */
	initialMajorIndex = majorIndex;
	assert(initialMajorIndex > 0);
	minorIndex = GIV(classTableIndex) & ((1U << (classTableMajorIndexShift(self))) - 1);
	while(1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(majorIndex) << (shiftForWord(self))))));
		if (page == GIV(nilObj)) {
			/* begin allocateSlotsInOldSpace:format:classIndex: */
			numSlots = 1U << (classTableMajorIndexShift(self));
			classIndex = arrayClassIndexPun(self);
			page = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
				? 8 /* allocationUnit */ + BaseHeaderSize
				: (((sqInt)((usqInt)(numSlots) << (shiftForWord(self))))) + ((numSlots >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), 2 /* arrayFormat */, classIndex, self);
			if (!(page)) {
				return PrimErrNoMemory;
			}
			/* begin fillObj:numSlots:with: */
			numSlots1 = 1U << (classTableMajorIndexShift(self));
			assert(oopisLessThan(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1, addressAfter(page, self), self));
			for (p = (((usqInt)(page + BaseHeaderSize))); p <= (((usqInt)(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
				longAtput(p, GIV(nilObj));
			}
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(hiddenRootsObj), self)));
			if ((assert(isNonImmediate(GIV(hiddenRootsObj), self)),
			oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((page & (tagMask(self))) == 0)
				 && (oopisLessThan(page, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(GIV(hiddenRootsObj), self);
					}
				}
			}
			longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(majorIndex) << (shiftForWord(self))))), page);
			GIV(numClassTablePages) += 1;
			minorIndex = 0;
		}
		for (i = minorIndex, iLimiT = ((1U << (classTableMajorIndexShift(self))) - 1); i <= iLimiT; i += 1) {
			if ((longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))))) == GIV(nilObj)) {

				/* classTableIndex must never index the first page, which is reserved for classes known to the VM. */
				GIV(classTableIndex) = (((sqInt)((usqInt)(majorIndex) << (classTableMajorIndexShift(self))))) + i;
				assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift(self))));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(page, self)));
				if ((assert(isNonImmediate(page, self)),
				oopisGreaterThanOrEqualTo(page, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((aBehavior & (tagMask(self))) == 0)
					 && (oopisLessThan(aBehavior, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(page))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(page, self);
						}
					}
				}
				longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), aBehavior);
				/* begin setHashBitsOf:to: */
				hash = GIV(classTableIndex);
				assert(((hash >= 0) && (hash <= (identityHashHalfWordMask(self)))));
				long32Atput(aBehavior + 4, ((((long32At(aBehavior + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash);
				assert((classAtIndex(rawHashBitsOf(aBehavior, self), self)) == aBehavior);
				return 0;
			}
		}
		majorIndex = ((((majorIndex + 1) & (classIndexMask(self))) < 1) ? 1 : ((majorIndex + 1) & (classIndexMask(self))));
		if (majorIndex == initialMajorIndex) {

			/* wrapped; table full */
			return PrimErrLimitExceeded;
		}
	}
	return 0;
}

	/* SpurMemoryManager>>#ephemeronFormat */
static sqInt
ephemeronFormat(struct foo * self)
{
	return 5;
}

	/* SpurMemoryManager>>#existInstancesInNewSpaceOf: */
static sqInt NoDbgRegParms
existInstancesInNewSpaceOf(sqInt classObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;

	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	/* begin allNewSpaceObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((longAt(objOop1)) & (classIndexMask(self))) == classIndex) {
			return 1;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((longAt(objOop1)) & (classIndexMask(self))) == classIndex) {
			return 1;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	return 0;
}


/*	Remove aBehavior from the class table. */

	/* SpurMemoryManager>>#expungeFromClassTable: */
static void NoDbgRegParms
expungeFromClassTable(sqInt aBehavior, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt majorIndex;
    sqInt minorIndex;

	assert(isInClassTable(aBehavior, self));
	classIndex = (long32At(aBehavior + 4)) & (identityHashHalfWordMask(self));
	majorIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	minorIndex = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(majorIndex) << (shiftForWord(self))))));
	assert(classTablePage != GIV(classTableFirstPage));
	assert((numSlotsOf(classTablePage, self)) == (classTablePageSize(self)));
	assert((fetchPointerofObject(minorIndex, classTablePage, self)) == aBehavior);
	assert(!(isOopForwarded(classTablePage, self)));
	longAtput((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(minorIndex) << (shiftForWord(self))))), GIV(nilObj));
	if (classIndex < GIV(classTableIndex)) {
		GIV(classTableIndex) = classIndex;
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift(self))));
}

	/* SpurMemoryManager>>#falseObject */
sqInt
falseObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}

	/* SpurMemoryManager>>#fetchByte:ofObject: */
sqInt
fetchByteofObject(sqInt byteIndex, sqInt objOop, struct foo * self)
{
	return byteAt((objOop + BaseHeaderSize) + byteIndex);
}

	/* SpurMemoryManager>>#fetchClassOfNonImm: */
static sqInt NoDbgRegParms NeverInline
fetchClassOfNonImm(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	/* begin classIndexOf: */
	classIndex = (longAt(objOop)) & (classIndexMask(self));
	if (classIndex <= (classIsItselfClassIndexPun(self))) {
		if (classIndex == (classIsItselfClassIndexPun(self))) {
			return objOop;
		}
		if (classIndex == (isForwardedObjectClassIndexPun(self))) {
			return GIV(nilObj);
		}
	}
	assert(classIndex >= (arrayClassIndexPun(self)));
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask(self)))
	 || (classIndex >= (arrayClassIndexPun(self))));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#fetchClassOf: */
sqInt
fetchClassOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt tagBits;

	return (((tagBits = oop & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(oop, self));
}


/*	In Spur an object's classIndex is the tag in all method caches. */

	/* SpurMemoryManager>>#fetchClassTagOfNonImm: */
static sqInt NoDbgRegParms
fetchClassTagOfNonImm(sqInt obj, struct foo * self)
{
	/* begin classIndexOf: */
	return (longAt(obj)) & (classIndexMask(self));
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

	/* SpurMemoryManager>>#fetchLong32:ofObject: */
sqInt
fetchLong32ofObject(sqInt fieldIndex, sqInt oop, struct foo * self)
{
	return long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
}

	/* SpurMemoryManager>>#fetchPointer:ofFreeChunk: */
static sqInt NoDbgRegParms
fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop, struct foo * self)
{
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#fetchPointer:ofObject: */
sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt objOop, struct foo * self)
{
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
}


/*	Answer, but do not remove, the largest free chunk in the free lists. */

	/* SpurMemoryManager>>#findLargestFreeChunk */
static sqInt
findLargestFreeChunk(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt childNode;
    sqInt fieldIndex;
    sqInt treeNode;

	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		return null;
	}
	while (1) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(treeNode, self));
		assert((bytesInObject(treeNode, self)) >= ((numFreeLists(self)) * (allocationUnit(self))));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex = 4 /* freeChunkLargerIndex */;
		childNode = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
		if (!(childNode != 0)) break;
		treeNode = childNode;
	}
	return treeNode;
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */

	/* SpurMemoryManager>>#findStringBeginningWith: */
void
findStringBeginningWith(char *aCString, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt cssz;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	cssz = strlen(aCString);
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self)), self)) >= cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printNum(lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self)), self), self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self)), self)) >= cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printNum(lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self)), self), self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))
			 && (((lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self)), self)) >= cssz)
			 && ((strncmp(aCString, pointerForOop(objOop11 + BaseHeaderSize), cssz)) == 0))) {
				printHex(objOop11, self);
				/* begin space */
				putchar(' ');
				printNum(lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self)), self), self);
				/* begin space */
				putchar(' ');
				printOopShort(objOop11, self);
				/* begin cr */
				printf("\n");
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

	/* SpurMemoryManager>>#findString: */
void
findString(char *aCString, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt cssz;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	cssz = strlen(aCString);
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self)), self)) == cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self)), self)) == cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))
			 && (((lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self)), self)) == cssz)
			 && ((strncmp(aCString, pointerForOop(objOop11 + BaseHeaderSize), cssz)) == 0))) {
				printHex(objOop11, self);
				/* begin space */
				putchar(' ');
				printOopShort(objOop11, self);
				/* begin cr */
				printf("\n");
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#firstAccessibleObject */
static sqInt
firstAccessibleObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;

	assert(GIV(nilObj) == GIV(oldSpaceStart));
	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge, self);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize(self)) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace(self)).start)));
	assert(GIV(freeStart) == (((eden(self)).start)));
	return GIV(nilObj);
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* SpurMemoryManager>>#firstFixedFieldOfMaybeImmediate: */
static void * NoDbgRegParms
firstFixedFieldOfMaybeImmediate(sqInt oop, struct foo * self)
{
	return (oop & (tagMask(self))
		? ((void *)oop)
		: (/* begin firstFixedField: */
			pointerForOop(oop + BaseHeaderSize)));
}

	/* SpurMemoryManager>>#firstFixedField: */
void *
firstFixedField(sqInt objOop, struct foo * self)
{
	return pointerForOop(objOop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes.
	There are only two important cases, both for objects with named inst vars,
	i.e. formats 2,3 & 5.
	The first indexable field for formats 2 & 5 is the slot count (by
	convention, even though that's off the end
	of the object). For 3 we must go to the class. */

	/* SpurMemoryManager>>#firstIndexableField: */
void *
firstIndexableField(sqInt objOop, struct foo * self)
{
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	if (fmt <= (weakArrayFormat(self))) {
		if (fmt == 2 /* arrayFormat */) {

			/* array starts at 0. */
			return pointerForOop(objOop + BaseHeaderSize);
		}
		if (fmt >= (indexablePointersFormat(self))) {

			/* indexable with inst vars; need to delve into the class format word */
			/* begin formatOfClass: */
			classPointer = fetchClassOfNonImm(objOop, self);
			classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
			return pointerForOop((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1))) << (shiftForWord(self))))));
		}
		return 0;
	}
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 && (fmt < (firstCompiledMethodFormat(self)))) {
		return pointerForOop(objOop + BaseHeaderSize);
	}
	return 0;
}


/*	A fake format for the interpreter used to mark indexable strings in
	the interpreter's at cache. This is larger than any format. */

	/* SpurMemoryManager>>#firstStringyFakeFormat */
static sqInt
firstStringyFakeFormat(struct foo * self)
{
	return 32;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormatMask */
sqInt
fixedFieldsOfClassFormatMask(struct foo * self)
{
	return (1U << (fixedFieldsFieldWidth(self))) - 1;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormat: */
sqInt
fixedFieldsOfClassFormat(sqInt classFormat, struct foo * self)
{
	return classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
}

	/* SpurMemoryManager>>#fixedFieldsOfClass: */
static sqInt NoDbgRegParms
fixedFieldsOfClass(sqInt objOop, struct foo * self)
{
    sqInt classFormat;

	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	return classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
}

	/* SpurMemoryManager>>#fixedFieldsOf:format:length: */
static sqInt NoDbgRegParms
fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength, struct foo * self)
{
    sqInt class;
    sqInt classFormat;

	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		return 0;
	}
	if (fmt < 2 /* arrayFormat */) {
		return wordLength;
	}
	class = fetchClassOfNonImm(objOop, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	return classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
}


/*	Private helper for followField:ofObject: to avoid code duplication for
	rare case.
 */

	/* SpurMemoryManager>>#fixFollowedField:ofObject:withInitialValue: */
static sqInt NoDbgRegParms NeverInline
fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	assert(isOopForwarded(initialValue, self));
	objOop = initialValue;
	do {
		/* begin fetchPointer:ofMaybeForwardedObject: */
		objOop = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
	} while(((objOop & (tagMask(self))) == 0)
		 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(anObject, self)));
	if ((assert(isNonImmediate(anObject, self)),
	oopisGreaterThanOrEqualTo(anObject, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((objOop & (tagMask(self))) == 0)
		 && (oopisLessThan(objOop, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(anObject))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(anObject, self);
			}
		}
	}
	longAtput((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), objOop);
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#followField:ofObject: */
static sqInt NoDbgRegParms
followFieldofObject(sqInt fieldIndex, sqInt anObject, struct foo * self)
{
    sqInt objOop;

	/* begin fetchPointer:ofObject: */
	objOop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop, self);
	}
	return objOop;
}


/*	Follow pointers in the object to depth.
	Answer if any forwarders were found.
	How to avoid cyclic structures?? A temproary mark bit? */

	/* SpurMemoryManager>>#followForwardedObjectFields:toDepth: */
sqInt
followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt found;
    sqInt i;
    sqInt iLimiT;
    sqInt oop;
    sqInt referent;

	found = 0;
	assert((isPointers(objOop, self))
	 || (isOopCompiledMethod(objOop, self)));
	for (i = 0, iLimiT = ((numPointerSlotsOf(objOop, self)) - 1); i <= iLimiT; i += 1) {
		/* begin fetchPointer:ofObject: */
		oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if ((oop & (tagMask(self))) == 0) {
			if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				found = 1;
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent & (tagMask(self))) == 0)
				 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				oop = referent;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(objOop, self)));
				if ((assert(isNonImmediate(objOop, self)),
				oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((oop & (tagMask(self))) == 0)
					 && (oopisLessThan(oop, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(objOop, self);
						}
					}
				}
				longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), oop);
			}
			if ((depth > 0)
			 && ((((oop & (tagMask(self))) == 0)
			 && (isAnyPointerFormat((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)))
			 && (followForwardedObjectFieldstoDepth(oop, depth - 1, self)))) {
				found = 1;
			}
		}
	}
	return found;
}


/*	Follow a forwarding pointer. THis must be a loop because we cannot prevent
	forwarders to
	forwarders being created by lazy become. Consider the following example by
	Igor Stasenko:
	array := { a. b. c }.
	- array at: 1 points to &a. array at: 2 points to &b. array at: 3 points
	to &c
	a becomeForward: b
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	b becomeForward: c.
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	- when accessing array first one has to follow a forwarding chain:
	&a -> &b -> c */

	/* SpurMemoryManager>>#followForwarded: */
sqInt
followForwarded(sqInt objOop, struct foo * self)
{
    sqInt referent;

	assert(isUnambiguouslyForwarder(objOop, self));
	/* begin fetchPointer:ofMaybeForwardedObject: */
	referent = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
	while (((referent & (tagMask(self))) == 0)
	 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
	}
	return referent;
}


/*	Make sure the obj at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) obj at
	fieldIndex.  */

	/* SpurMemoryManager>>#followObjField:ofObject: */
static sqInt NoDbgRegParms
followObjFieldofObject(sqInt fieldIndex, sqInt anObject, struct foo * self)
{
    sqInt objOop;

	/* begin fetchPointer:ofObject: */
	objOop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	assert(isNonImmediate(objOop, self));
	if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop, self);
	}
	return objOop;
}

	/* SpurMemoryManager>>#formatOfClass: */
sqInt
formatOfClass(sqInt classPointer, struct foo * self)
{
	return ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 64-bit indexable
	10 - 11 32-bit indexable	(11 unused in 32 bits)
	12 - 15 16-bit indexable	(14 & 15 unused in 32-bits)
	16 - 23 byte indexable		(20-23 unused in 32-bits)
	24 - 31 compiled method	(28-31 unused in 32-bits) */
/*	A note on performance. Since the format field is, by design, aligned on a
	byte boundary
	in the fourth byte of the header we could access it via
	^(self byteAt: objOop + 3) bitAnd: self formatMask
	but al least on e.g. Core i7 x86-64 using the clang 6 compiler, this makes
	no difference,
	or at least any change is in the noise. */

	/* SpurMemoryManager>>#formatOf: */
static sqInt NoDbgRegParms
formatOf(sqInt objOop, struct foo * self)
{
	return (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
}


/*	A special format used by the GC to follow only the first pointer. */

	/* SpurMemoryManager>>#forwardedFormat */
static sqInt
forwardedFormat(struct foo * self)
{
	return 7;
}


/*	Answer if anObject is itself forwarded, or is a pointer object containing
	any references to forwarded objects.
 */

	/* SpurMemoryManager>>#forwardersIn: */
static sqInt NoDbgRegParms
forwardersIn(sqInt anObject, struct foo * self)
{
    sqInt i;
    sqInt iLimiT;
    sqInt oop;

	if (((longAt(anObject)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		return 1;
	}
	for (i = 0, iLimiT = ((numPointerSlotsOf(anObject, self)) - 1); i <= iLimiT; i += 1) {
		/* begin fetchPointer:ofMaybeForwardedObject: */
		oop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if (((oop & (tagMask(self))) == 0)
		 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			return 1;
		}
	}
	return 0;
}


/*	for linking objecs on each free list, or, during pigCompact, doubly-
	linking the free objects in address order using the xor link hack. */

	/* SpurMemoryManager>>#freeChunkNextIndex */
static sqInt
freeChunkNextIndex(struct foo * self)
{
	return 0;
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkParentIndex */
static sqInt
freeChunkParentIndex(struct foo * self)
{
	return 2;
}


/*	For linking objecs on each free list, doubly-linking the free objects.
	Free chunks of size 1 do not have a prev index. */

	/* SpurMemoryManager>>#freeChunkPrevIndex */
static sqInt
freeChunkPrevIndex(struct foo * self)
{
	return 1;
}

	/* SpurMemoryManager>>#freeChunkWithBytes:at: */
static sqInt NoDbgRegParms
freeChunkWithBytesat(sqInt bytes, sqInt address, struct foo * self)
{
    sqInt freeChunk;

	assert(isInOldSpace(address, self));
	assert((segmentContainingObj(address, self)) == (segmentContainingObj(address + bytes, self)));
	freeChunk = initFreeChunkWithBytesat(bytes, address, self);
	addToFreeListbytes(freeChunk, bytes, self);
	assert(freeChunk == (objectStartingAt(address, self)));
	return freeChunk;
}


/*	Free an object in oldSpace. Coalesce if possible to reduce fragmentation. */

	/* SpurMemoryManager>>#freeObject: */
sqInt
freeObject(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt bytes;
    usqInt chunkBytes;
    sqInt index;
    sqInt next;
    usqInt numSlots;
    usqInt start;

	assert(isInOldSpace(objOop, self));
	if (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0) {
		/* begin forgetObject: */
		assert(GIV(rememberedSetSize) > 0);
		assert(isRemembered(objOop, self));
		/* begin setIsRememberedOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
		if (!(objOop == (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]))) {
			index = 0;
			while (index < GIV(rememberedSetSize)) {
				if (objOop == (GIV(rememberedSet)[index])) {
					GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
					index = GIV(rememberedSetSize);
				}
				else {
					index += 1;
				}
			}
		}
		GIV(rememberedSetSize) -= 1;
		assert(GIV(rememberedSetSize) >= 0);
	}
	bytes = bytesInObject(objOop, self);
	start = ((byteAt(objOop + 7)) == (numSlotsMask(self))
		? objOop - BaseHeaderSize
		: objOop);
	/* begin objectStartingAt: */
	address = start + bytes;
	numSlots = byteAt(address + 7);
	next = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	if (((longAt(next)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
		/* begin detachFreeObject: */
		chunkBytes = bytesInObject(next, self);
		GIV(totalFreeOldSpace) -= chunkBytes;
		unlinkFreeChunkchunkBytes(next, chunkBytes, self);
		bytes += bytesInObject(next, self);
	}
	GIV(totalFreeOldSpace) += bytes;
	return freeChunkWithBytesat(bytes, start, self);
}


/*	Perform a full eager compacting GC. Answer the size of the largest free
	chunk. 
 */
/*	for profiling */

	/* SpurMemoryManager>>#fullGC */
usqLong NeverInline
fullGC(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqLong compactionStartUsecs;
    usqLong gcMarkEndUsecs;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt index;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;

	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow(self);
	GIV(statMarkCount) = 0;
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
	}
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin globalGarbageCollect */
	assert(validObjStacks(self));
	assert(isEmptyObjStack(GIV(markStack), self));
	assert(isEmptyObjStack(GIV(weaklingStack), self));
	markObjects(1, self);
	gcMarkEndUsecs = ioUTCMicrosecondsNow(self);
	/* begin forgetUnmarkedRememberedObjects */
	index = 0;
	while (index < GIV(rememberedSetSize)) {
		obj = GIV(rememberedSet)[index];
		if (((((usqInt) (longAt(obj))) >> (markedBitFullShift(self))) & 1) != 0) {
			index += 1;
		}
		else {

			/* unmarked; remove by overwriting with last element. */
			/* begin setIsRememberedOf:to: */
			longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
			GIV(rememberedSetSize) -= 1;
			GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
		}
	}
	assert(GIV(rememberedSetSize) >= 0);
	doScavenge(MarkOnTenure, self);
	runLeakCheckerForexcludeUnmarkedObjsclassIndicesShouldBeValid(GCModeFull, 1, 1, self);
	compactionStartUsecs = ioUTCMicrosecondsNow(self);
	/* begin prepareForGlobalSweep */
	GIV(sweepIndex) = 0;
	for (i2 = 0; i2 < GIV(numSegments); i2 += 1) {
		((GIV(segments)[i2]).containsPinned = 0);
	}
	/* begin setIsMarkedOf:to: */
	address = (((((&(GIV(segments)[GIV(numSegments) - 1])))->segSize)) + ((((&(GIV(segments)[GIV(numSegments) - 1])))->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	assert(!(isFreeObject(objOop, self)));
	longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift(self))));
	compact(self);
	/* begin attemptToShrink */
	if ((GIV(totalFreeOldSpace) > GIV(shrinkThreshold))
	 && ((GIV(totalFreeOldSpace) > GIV(growHeadroom))
	 && (shrinkObjectMemory((((GIV(totalFreeOldSpace) - GIV(growHeadroom)) < GIV(growHeadroom)) ? GIV(growHeadroom) : (GIV(totalFreeOldSpace) - GIV(growHeadroom))), self)))) {
		GIV(statShrinkMemory) += 1;
	}
	/* begin setHeapSizeAtPreviousGC */
	GIV(heapSizeAtPreviousGC) = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);
	/* begin resetAllocationAccountingAfterGC */
	GIV(oldSpaceUsePriorToScavenge) = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);
	assert(validObjStacks(self));
	assert(isEmptyObjStack(GIV(markStack), self));
	assert(isEmptyObjStack(GIV(weaklingStack), self));
	assert(allObjectsUnmarked(self));
	runLeakCheckerFor(GCModeFull, self);
	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	postGCUpdateDisplayBits(self);
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow(self);
	/* begin updateFullGCStats */
	GIV(statFullGCs) += 1;
	GIV(statFullGCUsecs) += GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statCompactionUsecs) += GIV(statGCEndUsecs) - compactionStartUsecs;
	if (!(GIV(gcSweepEndUsecs) == 0)) {
		GIV(statSweepUsecs) += GIV(gcSweepEndUsecs) - compactionStartUsecs;
	}
	GIV(statMarkUsecs) += gcMarkEndUsecs - GIV(gcStartUsecs);
	return ((GIV(freeLists)[0]) != 0
		? bytesInObject(findLargestFreeChunk(self), self)
		: 0);
}

	/* SpurMemoryManager>>#getHeapGrowthToSizeGCRatio */
static float
getHeapGrowthToSizeGCRatio(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(heapGrowthToSizeGCRatio);
}

	/* SpurMemoryManager>>#goodContextSize: */
static sqInt NoDbgRegParms
goodContextSize(sqInt oop, struct foo * self)
{
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOf: */
	assert((classIndexOf(oop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	return (numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots);
}


/*	Attempt to grow memory by at least minAmmount.
	Answer the size of the new segment, or nil if the attempt failed. */

	/* SpurMemoryManager>>#growOldSpaceByAtLeast: */
static sqInt NoDbgRegParms
growOldSpaceByAtLeast(sqInt minAmmount, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt ammount;
    sqInt bytes;
    sqInt headroom;
    sqInt i;
    sqInt interval;
    SpurSegmentInfo *segInfo;
    sqInt start;
    usqInt total;
    usqInt total1;


	/* we need to include overhead for a new object header plus the segment bridge. */
	GIV(statGrowMemory) += 1;

	/* round up to the nearest power of two. */
	ammount = minAmmount + ((BaseHeaderSize * 2) + (2 * BaseHeaderSize));

	/* and grow by at least growHeadroom. */
	ammount = 1ULL << (highBit(ammount - 1, self));

	/* Now apply the maxOldSpaceSize limit, if one is in effect. */
	ammount = ((ammount < GIV(growHeadroom)) ? GIV(growHeadroom) : ammount);
	if (maxOldSpaceSize > 0) {
		/* begin totalBytesInSegments */
		total1 = 0;
		for (i = 0; i < GIV(numSegments); i += 1) {
			total1 += ((GIV(segments)[i]).segSize);
		}
		assert(GIV(totalHeapSizeIncludingBridges) == total1);
		total = total1;
		if (total >= maxOldSpaceSize) {
			return null;
		}
		headroom = maxOldSpaceSize - total;
		if (headroom < ammount) {
			if (headroom < (minAmmount + ((BaseHeaderSize * 2) + (2 * BaseHeaderSize)))) {
				return null;
			}
			ammount = headroom;
		}
	}
	start = ioUTCMicrosecondsNow(self);
	return ((segInfo = addSegmentOfSize(ammount, self)),
		(!(segInfo == null)
				? (/* begin assimilateNewSegment: */
					((((segInfo->segSize)) + ((segInfo->segStart))) >= GIV(endOfMemory)
							? (GIV(freeOldSpaceStart) = (GIV(endOfMemory) = (((segInfo->segSize)) + ((segInfo->segStart))) - (2 * BaseHeaderSize)))
							: 0),
					/* begin addFreeChunkWithBytes:at: */
					(bytes = ((segInfo->segSize)) - (2 * BaseHeaderSize)),
					(address = (segInfo->segStart)),
					(GIV(totalFreeOldSpace) += bytes),
					freeChunkWithBytesat(bytes, address, self),
					assert((addressAfter(objectStartingAt((segInfo->segStart), self), self)) == ((segLimit(segInfoself)) - (bridgeSize(self)))),
					/* begin checkFreeSpace: */
					assert(bitsSetInFreeSpaceMaskForAllFreeLists(self)),
					assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self))),
					(((checkForLeaks & (GCModeFreeSpace | GCModeFreeSpace)) == (GCModeFreeSpace | GCModeFreeSpace))
							? runLeakCheckerForFreeSpace(GCModeFreeSpace, self)
							: 0),
					checkSegments(self),
					(interval = (ioUTCMicrosecondsNow(self)) - start),
					(interval > GIV(statMaxAllocSegmentTime)
							? (GIV(statMaxAllocSegmentTime) = interval)
							: 0),
					(segInfo->segSize))
				: 0));
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,?})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:format:classIndex: */
usqLong
headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex, struct foo * self)
{
	return (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + classIndex;
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,?})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:hash:format:classIndex: */
static usqLong NoDbgRegParms
headerForSlotshashformatclassIndex(sqInt numSlots, sqInt hash, sqInt formatField, sqInt classIndex, struct foo * self)
{
	return ((((((usqLong) numSlots)) << (numSlotsFullShift(self))) + ((((usqLong) hash)) << (identityHashFullWordShift(self)))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + classIndex;
}


/*	Answer the number of extra root slots in the root of the hidden root
	object. 
 */

	/* SpurMemoryManager>>#hiddenRootSlots */
static sqInt
hiddenRootSlots(struct foo * self)
{
	return 8;
}

	/* SpurMemoryManager>>#hiddenRootsObject */
static sqInt
hiddenRootsObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	a more complex version that tells both the word reversal and the
	endianness of the machine
	it came from. Low half of word is e.g. 6521. Top byte is top byte of
	#doesNotUnderstand: on
	this machine. ($d on the Mac or $s on the PC) */

	/* SpurMemoryManager>>#imageSegmentVersion */
static sqInt
imageSegmentVersion(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int wholeWord;


	/* a more complex version that tells both the word reversal and the endianness of the machine
	   it came from.  Low half of word is e.g. 6521.  Top byte is top byte of #doesNotUnderstand: on
	   this machine. ($d on the Mac or $s on the PC) */

	/* first data word, 'does' */
	wholeWord = long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord(self))))))) + BaseHeaderSize);
	return 68021 /* imageFormatVersion */ | (wholeWord & 0xFF000000U);
}


/*	mask the immutable bit in the base header word */

	/* SpurMemoryManager>>#immutableBitMask */
#if IMMUTABILITY
sqInt
immutableBitMask(struct foo * self)
{
	return 1U << (immutableBitShift(self));
}
#endif /* IMMUTABILITY */

	/* SpurMemoryManager>>#incrementalGC */
void
incrementalGC(struct foo * self)
{
	error("shouldNotImplement");
}

	/* SpurMemoryManager>>#indexOf:in: */
sqInt
indexOfin(sqInt anElement, sqInt anObject, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt fmt1;
    sqInt i;
    usqInt numSlots;
    usqInt numSlots1;

	fmt = (((usqInt) (longAt(anObject))) >> (formatShift(self))) & (formatMask(self));
	if (fmt <= 5 /* lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(anObject, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(anObject + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(anObject - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		for (i = 0; i <= numSlots; i += 1) {
			if (anElement == (longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
				return i;
			}
		}
	}
	if (fmt >= (firstByteFormat(self))) {
		if (fmt >= (firstCompiledMethodFormat(self))) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrUnsupported);
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(anObject))) >> (formatShift(self))) & (formatMask(self));
		assert(fmt1 >= (firstByteFormat(self)));
		numSlots = ((numSlotsOf(anObject, self)) << (shiftForWord(self))) - (fmt1 & 7);
		for (i = 0; i <= numSlots; i += 1) {
			if (byteAt((anObject + BaseHeaderSize) + i)) {
				return i;
			}
		}
	}
	if (fmt >= (firstShortFormat(self))) {
		numSlots = ((usqInt) (numBytesOf(anObject, self))) >> 1;
		for (i = 0; i <= numSlots; i += 1) {
			if (anElement == (((unsigned short) (shortAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 1)))))))) {
				return i;
			}
		}
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		numSlots = ((usqInt) (numBytesOf(anObject, self))) >> 3;
		for (i = 0; i <= numSlots; i += 1) {
			if (anElement == (long64At((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 3)))))) {
				return i;
			}
		}
	}
	if (fmt >= (firstLongFormat(self))) {
		numSlots = ((usqInt) (numBytesOf(anObject, self))) >> 2;
		for (i = 0; i <= numSlots; i += 1) {
			if (anElement == (long32At((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 2)))))) {
				return i;
			}
		}
	}
	return -1;
}


/*	Part of reorderReversedTreeList:. Switch treeNode with newNode in
	the tree, but do nothing to the list linked through freeChunkNextIndex. */

	/* SpurMemoryManager>>#inFreeTreeReplace:with: */
static void NoDbgRegParms
inFreeTreeReplacewith(sqInt treeNode, sqInt newNode, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt i;
    sqInt iLimiT;
    sqInt relative;

	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(newNode, self));
	assert(1);
	longAtput((newNode + BaseHeaderSize) + (1U << (shiftForWord(self))), 0);
	for (i = 2 /* freeChunkParentIndex */, iLimiT = 4 /* freeChunkLargerIndex */; i <= iLimiT; i += 1) {
		/* begin fetchPointer:ofFreeChunk: */
		relative = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if (i == 2 /* freeChunkParentIndex */) {
			if (relative == 0) {

				/* update root to point to newNode */
				assert((GIV(freeLists)[0]) == treeNode);
				GIV(freeLists)[0] = newNode;
			}
			else {

				/* replace link from parent to treeNode with link to newNode. */
				/* begin storePointer:ofFreeChunk:withValue: */
				if (treeNode == (longAt((relative + BaseHeaderSize) + (3U << (shiftForWord(self)))))) {
					/* begin freeChunkSmallerIndex */
					fieldIndex = 3;
				}
				else {
					/* begin freeChunkLargerIndex */
					fieldIndex = 4;
				}
				assert(isFreeObject(relative, self));
				assert((newNode == 0)
				 || (isFreeObject(newNode, self)));
				longAtput((relative + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), newNode);
			}
		}
		else {
			if (relative != 0) {
				assert((fetchPointerofFreeChunk(freeChunkParentIndex(self), relative, self)) == treeNode);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(relative, self));
				assert((newNode == 0)
				 || (isFreeObject(newNode, self)));
				longAtput((relative + BaseHeaderSize) + (2U << (shiftForWord(self))), newNode);
			}
		}
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(newNode, self));
		assert((relative == 0)
		 || (isFreeObject(relative, self)));
		longAtput((newNode + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), relative);
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(treeNode, self));
		assert(1);
		longAtput((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), 0);
	}
}

	/* SpurMemoryManager>>#initialInstanceOf: */
static sqInt NoDbgRegParms
initialInstanceOf(sqInt classObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	if (classIndex == 0) {
		return null;
	}
	/* begin flushNewSpaceInstancesOf: */
	classIndex1 = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	if (classIndex1 == 0) {

		/* no instances; nothing to do */
		goto l1;
	}
	/* begin tenuringClassIndex: */
	GIV(tenuringClassIndex) = classIndex1;
	scavengingGCTenuringIf(TenureByClass, self);
	assert(!(existInstancesInNewSpaceOf(classObj, self)));
	l1:	/* end flushNewSpaceInstancesOf: */;
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (classIndex == ((longAt(objOop1)) & (classIndexMask(self)))) {
			return objOop1;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (classIndex == ((longAt(objOop1)) & (classIndexMask(self)))) {
			return objOop1;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if (classIndex == ((longAt(objOop11)) & (classIndexMask(self)))) {
				return objOop11;
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	return null;
}

	/* SpurMemoryManager>>#initializeNewSpaceVariables */
static void NeverInline
initializeNewSpaceVariables(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurNewSpaceSpace *aNewSpace;
    sqInt p;

	GIV(freeStart) = ((eden(self)).start);
	GIV(pastSpaceStart) = ((pastSpace(self)).start);
	GIV(scavengeThreshold) = ((((eden(self)).limit)) - ((((GIV(eden).limit)) - ((GIV(eden).start))) / 64)) - (interpreterAllocationReserveBytes(self));
	GIV(newSpaceStart) = (((((pastSpace(self)).start)) < (((futureSpace(self)).start))) ? (((pastSpace(self)).start)) : (((futureSpace(self)).start)));
	assert(GIV(newSpaceStart) < (((eden(self)).start)));
	/* begin initSpaceForAllocationCheck:limit: */
	aNewSpace = ((SpurNewSpaceSpace *) ((&(eden(self)))));
	if (GIV(memory)) {
		if (checkAllocFiller(self)) {
			for (p = ((aNewSpace->start)); p < GIV(scavengeThreshold); p += BytesPerWord) {
				longAtput(p, p);
			}
		}
	}
}


/*	Initialize object memory variables at startup time. Assume endOfMemory at
	al are
	initialised by the image-reading code via
	setHeapBase:memoryLimit:endOfMemory:. endOfMemory is assumed to point to
	the end of the last object in the image.
	Assume: image reader also initializes the following variables:
	specialObjectsOop
	lastHash */
/*	Catch mis-initializations leading to bad translations to C */

	/* SpurMemoryManager>>#initializeObjectMemory: */
static void NoDbgRegParms
initializeObjectMemory(sqInt bytesToShift, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anOop;
    sqInt cameFrom;
    usqInt chunkBytes;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classTableRoot;
    sqInt field;
    sqInt fieldAddr;
    sqInt fieldIndex;
    sqInt fieldIndex11;
    sqInt fieldIndex21;
    sqInt fieldIndex3;
    sqInt fieldIndex4;
    sqInt fieldOop;
    sqInt firstObj;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt format;
    sqInt freeChunk;
    sqInt freeListObj;
    usqInt freeOldStart;
    sqInt fudge;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt iLimiT2;
    sqInt index;
    sqInt largeChild;
    usqInt limit;
    sqInt min;
    sqInt nilObjPreSwizzle;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    usqInt p;
    sqInt smallChild;
    sqInt treeNode;
    sqInt valuePointer;
    sqInt valuePointer2;


	/* Catch mis-initializations leading to bad translations to C */
	assert(BaseHeaderSize == BaseHeaderSize);
	assert((((sqInt)((maxSlotsForAlloc(self)) * BytesPerWord))) > 0);
	initSegmentBridgeWithBytesat(2 * BaseHeaderSize, GIV(endOfMemory) - (2 * BaseHeaderSize), self);
	adjustSegmentSwizzlesBy(bytesToShift, self);
	/* begin adjustAllOopsBy: */
	assert(newSpaceIsEmpty(self));
	/* begin countNumClassPagesPreSwizzle: */
	numSlots2 = byteAt(GIV(oldSpaceStart) + 7);
	firstObj = (numSlots2 == (numSlotsMask(self))
		? GIV(oldSpaceStart) + BaseHeaderSize
		: GIV(oldSpaceStart));
	classTableRoot = noInlineObjectAfterlimit(noInlineObjectAfterlimit(noInlineObjectAfterlimit(noInlineObjectAfterlimit(firstObj, GIV(endOfMemory), self), GIV(endOfMemory), self), GIV(endOfMemory), self), GIV(endOfMemory), self);
	nilObjPreSwizzle = GIV(oldSpaceStart) - bytesToShift;
	/* begin numSlotsOf: */
	assert((classIndexOf(classTableRoot, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(classTableRoot + 7);
	GIV(numClassTablePages) = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classTableRoot - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	assert(GIV(numClassTablePages) == ((classTableRootSlots(self)) + (hiddenRootSlots(self))));
	for (i = 2; i < GIV(numClassTablePages); i += 1) {
		if ((longAt((classTableRoot + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))))) == nilObjPreSwizzle) {
			GIV(numClassTablePages) = i;
			goto l11;
		}
	}
	l11:	/* end countNumClassPagesPreSwizzle: */;
	if ((bytesToShift != 0)
	 || ((numSegments(self)) > 1)) {
		/* begin objectStartingAt: */
		numSlots = byteAt(GIV(oldSpaceStart) + 7);
		obj = (numSlots == (numSlotsMask(self))
			? GIV(oldSpaceStart) + BaseHeaderSize
			: GIV(oldSpaceStart));
		while (oopisLessThan(obj, GIV(freeOldSpaceStart), self)) {
			classIndex = (longAt(obj)) & (classIndexMask(self));
			if (classIndex >= (isForwardedObjectClassIndexPun(self))) {
				/* begin swizzleFieldsOfObject: */
				fieldAddr = obj + (lastPointerOfWhileSwizzling(obj, self));
				while (oopisGreaterThanOrEqualTo(fieldAddr, obj + BaseHeaderSize, self)) {
					fieldOop = longAt(fieldAddr);
					if ((fieldOop & (tagMask(self))) == 0) {
						longAtput(fieldAddr, swizzleObj(fieldOop, self));
					}
					fieldAddr -= BytesPerOop;
				}
			}
			else {
				if (classIndex == (isFreeObjectClassIndexPun(self))) {
					/* begin swizzleFieldsOfFreeChunk: */
					fieldIndex3 = 0 /* freeChunkNextIndex */;
					field = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex3) << (shiftForWord(self))))));
					if (field != 0) {
						/* begin storePointerNoAssert:ofFreeChunk:withValue: */
						fieldIndex = 0 /* freeChunkNextIndex */;
						valuePointer = swizzleObj(field, self);
						longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), valuePointer);
					}
					chunkBytes = bytesInObject(obj, self);
					if (chunkBytes >= (64 /* numFreeLists */ * 8 /* allocationUnit */)) {
						for (index = 2 /* freeChunkParentIndex */, iLimiT = 4 /* freeChunkLargerIndex */; index <= iLimiT; index += 1) {
							/* begin fetchPointer:ofFreeChunk: */
							field = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
							if (field != 0) {
								/* begin storePointerNoAssert:ofFreeChunk:withValue: */
								valuePointer2 = swizzleObj(field, self);
								longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))), valuePointer2);
							}
						}
					}
				}
			}
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(obj, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
				obj = GIV(endOfMemory);
				goto l14;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			obj = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l14:	/* end objectAfter:limit: */;
		}
	}

	/* heavily used special objects */
	GIV(specialObjectsOop) = swizzleObj(GIV(specialObjectsOop), self);
	/* begin fetchPointer:ofObject: */
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(NilObject) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(FalseObject) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	GIV(trueObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TrueObject) << (shiftForWord(self))))));
	assert(GIV(nilObj) == GIV(oldSpaceStart));
	assert(GIV(falseObj) == (oldSpaceObjectAfter(GIV(nilObj), self)));
	assert(GIV(trueObj) == (oldSpaceObjectAfter(GIV(falseObj), self)));
	freeListObj = oldSpaceObjectAfter(GIV(trueObj), self);
	/* begin setHiddenRootsObj: */
	anOop = oldSpaceObjectAfter(freeListObj, self);
	GIV(hiddenRootsObj) = anOop;
	assert(validClassTableRootPages(self));
	/* begin fetchPointer:ofObject: */
	GIV(classTableFirstPage) = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (0U << (shiftForWord(self))));
	assert(((numSlotsOf(GIV(classTableFirstPage), self)) - 1) == (classTableMinorIndexMask(self)));
	flag("remove at some stage");
	if (((longAt(GIV(classTableFirstPage))) & (classIndexMask(self))) != (arrayClassIndexPun(self))) {
		/* begin setClassIndexOf:to: */
		classIndex1 = arrayClassIndexPun(self);
		assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask(self)))));
		longAtput(GIV(classTableFirstPage), ((longAt(GIV(classTableFirstPage))) & (~(usqIntptr_t)(classIndexMask(self)))) + classIndex1);
	}
	/* begin classTableRootSlots */
	GIV(numClassTablePages) = 1U << (22 /* classIndexFieldWidth */ - (classTableMajorIndexShift(self)));
	for (i1 = 2; i1 < GIV(numClassTablePages); i1 += 1) {
		if ((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))))) == GIV(nilObj)) {
			GIV(numClassTablePages) = i1;
			GIV(classTableIndex) = ((sqInt)((usqInt)(((((GIV(numClassTablePages) - 1) < 1) ? 1 : (GIV(numClassTablePages) - 1)))) << (classTableMajorIndexShift(self))));
			goto l17;
		}
	}
	GIV(classTableIndex) = 1U << (classTableMajorIndexShift(self));
	l17:	/* end setHiddenRootsObj: */;
	GIV(markStack) = swizzleObjStackAt(MarkStackRootIndex, self);
	GIV(weaklingStack) = swizzleObjStackAt(WeaklingStackRootIndex, self);
	GIV(mournQueue) = swizzleObjStackAt(MournQueueRootIndex, self);
	assert(validObjStacks(self));
	assert(isEmptyObjStack(GIV(markStack), self));
	assert(isEmptyObjStack(GIV(weaklingStack), self));
	/* begin initializeFreeSpacePostLoad: */
	assert((numSlotsOf(freeListObj, self)) == (numFreeLists(self)));
	assert((formatOf(freeListObj, self)) == (wordIndexableFormat(self)));
	GIV(freeLists) = firstIndexableField(freeListObj, self);
	GIV(freeListsMask) = 0;
	for (i2 = 0, iLimiT1 = (64 /* numFreeLists */ - 1); i2 <= iLimiT1; i2 += 1) {
		if ((GIV(freeLists)[i2]) != 0) {
			GIV(freeListsMask) = GIV(freeListsMask) | (1ULL << i2);
			GIV(freeLists)[i2] = (swizzleObj(GIV(freeLists)[i2], self));
		}
	}
	collapseSegmentsPostSwizzle(self);
	/* begin updateFreeLists */
	min = 3;
	for (i3 = min, iLimiT2 = (64 /* numFreeLists */ - 1); i3 <= iLimiT2; i3 += 1) {
		updateListStartingAt(GIV(freeLists)[i3], self);
	}
	/* begin freeTreeNodesDo: */
	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		goto l20;
	}
	cameFrom = -1;
	do {
		assert((bytesInObject(treeNode, self)) >= ((numFreeLists(self)) * (allocationUnit(self))));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex11 = 3 /* freeChunkSmallerIndex */;
		smallChild = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex11) << (shiftForWord(self))))));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex21 = 4 /* freeChunkLargerIndex */;
		largeChild = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex21) << (shiftForWord(self))))));
		assert((smallChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(self), smallChild, self))));
		assert((largeChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(self), largeChild, self))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */
			updateListStartingAt(treeNode, self);
			treeNode = treeNode;
			cameFrom = treeNode;
			/* begin fetchPointer:ofFreeChunk: */
			fieldIndex4 = 2 /* freeChunkParentIndex */;
			treeNode = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex4) << (shiftForWord(self))))));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode != 0);
	l20:	/* end freeTreeNodesDo: */;
	/* begin computeFreeSpacePostSwizzle */
	GIV(totalFreeOldSpace) = totalFreeListBytes(self);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	/* begin initializeOldSpaceFirstFree: */
	limit = GIV(endOfMemory) - (2 * BaseHeaderSize);
	if (limit > GIV(freeOldSpaceStart)) {
		GIV(totalFreeOldSpace) += limit - GIV(freeOldSpaceStart);
		freeOldStart = GIV(freeOldSpaceStart);
		while ((limit - freeOldStart) >= (1ULL << 32)) {
			freeChunk = freeChunkWithBytesat(1ULL << 32, freeOldStart, self);
			freeOldStart += 1ULL << 32;
			assert(freeOldStart == (addressAfter(freeChunk, self)));
		}
		if (freeOldStart < limit) {
			freeChunk = freeChunkWithBytesat(limit - freeOldStart, freeOldStart, self);
			assert((addressAfter(freeChunk, self)) == limit);
		}
	}
	GIV(endOfMemory) -= 2 * BaseHeaderSize;
	GIV(freeOldSpaceStart) = GIV(endOfMemory);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFreeSpace)) == (GCModeFreeSpace | GCModeFreeSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	initializeNewSpaceVariables(self);
	/* begin initializeRememberedSet */
	obj2 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
	if (obj2 == GIV(nilObj)) {
		/* begin allocatePinnedSlots: */
		obj1 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(1024, (1024U << (shiftForWord(self))) + (BaseHeaderSize + BaseHeaderSize), sixtyFourBitIndexableFormat(self), sixtyFourBitLongsClassIndexPun(self), self);
		if (obj1) {
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((obj1 + BaseHeaderSize) + (1024 * BytesPerOop)) - 1, addressAfter(obj1, self), self));
			for (p = (((usqInt)(obj1 + BaseHeaderSize))); p <= (((usqInt)(((obj1 + BaseHeaderSize) + (1024 * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
				longAtput(p, 0);
			}
		}
		obj2 = obj1;
		/* begin rememberedSetObj: */
		assert(isOldObject(obj2, self));
		assert(!(isOopForwarded(GIV(hiddenRootsObj), self)));
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))), obj2);
	}
	else {

		/* The Spur32to64BitBootstrap failed to set the type of rememberedSetObj to 64-bit indexability.
		   This is unimportant except for simulation; rememberedSet is declared as sqInt *, but in to have
		   firstIndexableField: below answer a suitable type the format must be wordIndexableFormat. */
		/* begin setFormatOf:to: */
		format = sixtyFourBitIndexableFormat(self);
		assert(((format >= 0) && (format <= (formatMask(self)))));
		longAtput(obj2, ((longAt(obj2)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))))) + (((sqInt)((usqInt)(format) << (formatShift(self))))));
	}
	assert((formatOf(obj2, self)) == (wordIndexableFormat(self)));
	assert(isPinned(obj2, self));
	GIV(rememberedSet) = firstIndexableField(obj2, self);
	GIV(rememberedSetSize) = 0;
	/* begin numSlotsOf: */
	assert((classIndexOf(obj2, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots3 = byteAt(obj2 + 7);
	GIV(rememberedSetLimit) = (numSlots3 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(obj2 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots3);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 1024;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
	checkSegments(self);
	/* begin biasForGC */
	GIV(biasForGC) = 1;

	/* headroom when growing */
	GIV(growHeadroom) = (16 * 1024) * 1024;

	/* free space before shrinking */
	GIV(shrinkThreshold) = (32 * 1024) * 1024;
	/* begin setHeapSizeAtPreviousGC */
	GIV(heapSizeAtPreviousGC) = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);
	/* begin resetAllocationAccountingAfterGC */
	GIV(oldSpaceUsePriorToScavenge) = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);

	/* By default GC after scavenge if heap has grown by a third since the last GC */
	GIV(heapGrowthToSizeGCRatio) = 0.333333;
}


/*	print free chunks in freeTree in order. */

	/* SpurMemoryManager>>#inOrderPrintFreeTree:printList: */
void
inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList, struct foo * self)
{
    sqInt next;

	if (((next = longAt((freeChunk + BaseHeaderSize) + (3U << (shiftForWord(self)))))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList, self);
	}
	printFreeChunkprintAsTreeNode(freeChunk, 1, self);
	if (printNextList) {
		next = freeChunk;
		while (((next = longAt((next + BaseHeaderSize) + (0U << (shiftForWord(self)))))) != 0) {
			/* begin tab */
			putchar('	');
			printFreeChunkprintAsTreeNode(next, 0, self);
		}
	}
	if (((next = longAt((freeChunk + BaseHeaderSize) + (4U << (shiftForWord(self)))))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList, self);
	}
}


/*	in an effort to fix a compiler bug with two-way become post r3427 */
/*	Do become in place by swapping object contents. */

	/* SpurMemoryManager>>#inPlaceBecome:and:copyHashFlag: */
static void NoDbgRegParms NeverInline
inPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqLong hashBits;
    sqLong header1;
    sqLong header2;
    sqInt i;
    sqInt iLimiT;
    sqInt o1HasYoung;
    sqInt o2HasYoung;
    sqLong remembered;
    sqInt temp1;
    sqInt temp2;

	assert((numSlotsOf(obj1, self)) == (numSlotsOf(obj2, self)));
	assert(((rawHashBitsOf(obj1, self)) == 0)
	 || ((classOrNilAtIndex(rawHashBitsOf(obj1, self), self)) != obj1));
	assert(((rawHashBitsOf(obj2, self)) == 0)
	 || ((classOrNilAtIndex(rawHashBitsOf(obj2, self), self)) != obj2));
	/* begin cleverSwapHeaders:and:copyHashFlag: */
	header1 = long64At(obj1);
	header2 = long64At(obj2);
	remembered = (header1 ^ header2) & (1U << (rememberedBitShift(self)));
	if (remembered != 0) {
		header1 = header1 ^ remembered;
		header2 = header2 ^ remembered;
	}
	if (!copyHashFlag) {
		hashBits = (header1 ^ header2) & 0x3FFFFF00000000LL /* identityHashFullWordMask */;
		if (hashBits != 0) {
			header1 = header1 ^ hashBits;
			header2 = header2 ^ hashBits;
		}
	}
	long64Atput(obj1, header2);
	long64Atput(obj2, header1);
	o1HasYoung = (o2HasYoung = 0);
	for (i = 0, iLimiT = ((numSlotsOf(obj1, self)) - 1); i <= iLimiT; i += 1) {
		/* begin fetchPointer:ofObject: */
		temp1 = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		/* begin fetchPointer:ofObject: */
		temp2 = longAt((obj2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		assert(!(isOopForwarded(obj1, self)));
		longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), temp2);
		assert(!(isOopForwarded(obj2, self)));
		longAtput((obj2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), temp1);
		if (((temp2 & (tagMask(self))) == 0)
		 && (oopisLessThan(temp2, GIV(newSpaceLimit), self))) {
			o1HasYoung = 1;
		}
		if (((temp1 & (tagMask(self))) == 0)
		 && (oopisLessThan(temp1, GIV(newSpaceLimit), self))) {
			o2HasYoung = 1;
		}
	}
	if (o1HasYoung
	 && ((assert(isNonImmediate(obj1, self)),
	oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart), self)))) {
		fmt = (((usqInt) (longAt(obj1))) >> (formatShift(self))) & (formatMask(self));
		if (!((fmt >= (sixtyFourBitIndexableFormat(self)))
			 && (fmt < (firstCompiledMethodFormat(self))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj1))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(obj1, self);
			}
		}
	}
	if (o2HasYoung
	 && ((assert(isNonImmediate(obj2, self)),
	oopisGreaterThanOrEqualTo(obj2, GIV(oldSpaceStart), self)))) {
		fmt = (((usqInt) (longAt(obj2))) >> (formatShift(self))) & (formatMask(self));
		if (!((fmt >= (sixtyFourBitIndexableFormat(self)))
			 && (fmt < (firstCompiledMethodFormat(self))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj2))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(obj2, self);
			}
		}
	}
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

	/* SpurMemoryManager>>#instanceSizeOf: */
sqInt
instanceSizeOf(sqInt classObj, struct foo * self)
{
	assert(addressCouldBeClassObj(classObj, self));
	return (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1);
}

	/* SpurMemoryManager>>#instantiateClass: */
static sqInt NoDbgRegParms
instantiateClass(sqInt classObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt hash;
    sqInt instSpec;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    sqInt numSlots;
    usqInt p;

	classFormat = ((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	if (!((instSpec <= 1 /* nonIndexablePointerFormat */)
		 || (instSpec == 5 /* ephemeronFormat */))) {
		return null;
	}
	assert(addressCouldBeClassObj(classObj, self));
	classIndex = (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask(self)))) != 0
		? hash
		: (objCouldBeClassObj(classObj, self)
				? (((err = enterIntoClassTable(classObj, self))) != 0
						? -err
						: (long32At(classObj + 4)) & (identityHashHalfWordMask(self)))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -classIndex;
		return null;
	}
	/* begin fixedFieldsOfClassFormat: */
	numSlots = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask(self))) {
		if ((((usqInt) numSlots) >> 56) > 0) {
			newObj = null;
			goto l4;
		}
		newObj1 = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj1 = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? /* begin allocationUnit */ 8
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex, self);
		goto l4;
	}
	if (numSlots >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
		longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(self), instSpec, classIndex, self));
	}
	else {
		longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(instSpec) << (formatShift(self)))))) + classIndex);
	}
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj1 % (allocationUnit(self))) == 0);
	GIV(freeStart) += numBytes;
	newObj = newObj1;
	l4:	/* end allocateSlots:format:classIndex: */;
	if (newObj) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj, self), self));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
			longAtput(p, GIV(nilObj));
		}
	}
	return newObj;
}

	/* SpurMemoryManager>>#instSpecOfClassFormat: */
sqInt
instSpecOfClassFormat(sqInt classFormat, struct foo * self)
{
	return (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
}


/*	This field in a class's format inst var corresponds to the 5-bit format
	field stored in every object header
 */

	/* SpurMemoryManager>>#instSpecOfClass: */
static sqInt NoDbgRegParms
instSpecOfClass(sqInt classPointer, struct foo * self)
{
    sqInt classFormat;

	/* begin instSpecOfClassFormat: */
	classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	return (((usqInt) classFormat) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
}


/*	the inverse of isPureBitsFormat: */

	/* SpurMemoryManager>>#isAnyPointerFormat: */
static sqInt NoDbgRegParms
isAnyPointerFormat(sqInt format, struct foo * self)
{
	return (format <= 5 /* lastPointerFormat */)
	 || (format >= (firstCompiledMethodFormat(self)));
}


/*	Answer if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArrayNonImm: */
sqInt
isArrayNonImm(sqInt oop, struct foo * self)
{
	return ((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */;
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArray: */
sqInt
isArray(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */);
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

	/* SpurMemoryManager>>#isBytes: */
sqInt
isBytes(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)));
}

	/* SpurMemoryManager>>#isCharacterObject: */
sqInt
isCharacterObject(sqInt oop, struct foo * self)
{
	return oop & (characterTag(self));
}

	/* SpurMemoryManager>>#isCharacterValue: */
sqInt
isCharacterValue(sqInt anInteger, struct foo * self)
{
	return ((anInteger >= 0) && (anInteger <= ((1U << 30) - 1)));
}


/*	Answer if aClass exists at only one index in the class table. Be careful
	not to
	be misled by classes that have puns, such as Array. */

	/* SpurMemoryManager>>#isClassAtUniqueIndex: */
static sqInt NoDbgRegParms
isClassAtUniqueIndex(sqInt aClass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt expectedIndex;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt j;
    sqInt page;

	expectedIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask(self));
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		for (j = 0, iLimiT = ((1U << (classTableMajorIndexShift(self))) - 1); j <= iLimiT; j += 1) {
			classOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))));
			if (classOrNil != GIV(nilObj)) {
				index = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift(self))))) + j;
				if ((classOrNil == aClass)
				 && ((index != expectedIndex)
				 && (index > (lastClassIndexPun(self))))) {
					return 0;
				}
			}
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#isCompiledMethodFormat: */
static sqInt NoDbgRegParms
isCompiledMethodFormat(sqInt format, struct foo * self)
{
	return format >= (firstCompiledMethodFormat(self));
}


/*	Answer whether the argument object is of compiled method format */

	/* SpurMemoryManager>>#isCompiledMethod: */
sqInt
isCompiledMethod(sqInt objOop, struct foo * self)
{
	return ((((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self));
}

	/* SpurMemoryManager>>#isContextHeader: */
static sqInt NoDbgRegParms
isContextHeader(sqInt aHeader, struct foo * self)
{
	return (aHeader & (classIndexMask(self))) == ClassMethodContextCompactIndex;
}

	/* SpurMemoryManager>>#isContextNonImm: */
static sqInt NoDbgRegParms
isContextNonImm(sqInt oop, struct foo * self)
{
	return ((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex;
}

	/* SpurMemoryManager>>#isContext: */
static sqInt NoDbgRegParms
isContext(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex);
}


/*	This is part of storeImageSegmentInto:outPointers:roots:. */

	/* SpurMemoryManager>>#isCopiedIntoSegment: */
static sqInt NoDbgRegParms
isCopiedIntoSegment(sqInt anObjectInTheHeap, struct foo * self)
{
	return ((((usqInt) (longAt(anObjectInTheHeap))) >> (markedBitFullShift(self))) & 1) != 0;
}

	/* SpurMemoryManager>>#isEmptyObjStack: */
static sqInt NoDbgRegParms
isEmptyObjStack(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		return 1;
	}
	eassert(isValidObjStack(objStack, self));
	return (0 == (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))))))
	 && (0 == (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))))));
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	This is for assert-checking only. */

	/* SpurMemoryManager>>#isEnumerableObjectNoAssert: */
static sqInt NoDbgRegParms
isEnumerableObjectNoAssert(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	/* begin classIndexOf: */
	classIndex = (longAt(objOop)) & (classIndexMask(self));
	return (classIndex >= (isForwardedObjectClassIndexPun(self)))
	 && (classIndex < (GIV(numClassTablePages) * (1U << (classTableMajorIndexShift(self)))));
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	Non-objects should be excluded; these are bridges and free chunks. */

	/* SpurMemoryManager>>#isEnumerableObject: */
static sqInt NoDbgRegParms
isEnumerableObject(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	/* begin classIndexOf: */
	classIndex = (longAt(objOop)) & (classIndexMask(self));
	assert(((long64At(objOop)) != 0)
	 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize(self)))));
	return classIndex >= (isForwardedObjectClassIndexPun(self));
}

	/* SpurMemoryManager>>#isEphemeronFormat: */
static sqInt NoDbgRegParms
isEphemeronFormat(sqInt format, struct foo * self)
{
	return format == 5 /* ephemeronFormat */;
}

	/* SpurMemoryManager>>#isEphemeron: */
static sqInt NoDbgRegParms
isEphemeron(sqInt objOop, struct foo * self)
{
    sqInt format;

	assert(isNonImmediate(objOop, self));
	/* begin isEphemeronFormat: */
	format = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	return format == 5 /* ephemeronFormat */;
}

	/* SpurMemoryManager>>#isFixedSizePointerFormat: */
sqInt
isFixedSizePointerFormat(sqInt format, struct foo * self)
{
	return (format <= 1 /* nonIndexablePointerFormat */)
	 || (format == 5 /* ephemeronFormat */);
}

	/* SpurMemoryManager>>#isForwardedClassTag: */
static sqInt NoDbgRegParms
isForwardedClassTag(sqInt classIndex, struct foo * self)
{
	return classIndex == (isForwardedObjectClassIndexPun(self));
}


/*	Answer if objOop is that if a forwarder. Take advantage of
	isForwardedObjectClassIndexPun being a power of two to generate a more
	efficient test than the straight-forward
	(self classIndexOf: objOop) = self isForwardedObjectClassIndexPun
	at the cost of this being ambiguous with free chunks. So either never
	apply this to free chunks
	or guard with (self isFreeObject: foo) not. So far the idiom has been to
	guard with isFreeObject: */
/*	self assert: (self isFreeObject: objOop) not. */

	/* SpurMemoryManager>>#isForwarded: */
sqInt
isForwarded(sqInt objOop, struct foo * self)
{
	return ((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0;
}

	/* SpurMemoryManager>>#isFreeObject: */
static sqInt NoDbgRegParms
isFreeObject(sqInt objOop, struct foo * self)
{
	return ((longAt(objOop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self));
}

	/* SpurMemoryManager>>#isFreeOop: */
static sqInt NoDbgRegParms
isFreeOop(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)));
}

	/* SpurMemoryManager>>#isImmediate: */
sqInt
isImmediate(sqInt oop, struct foo * self)
{
	return oop & (tagMask(self));
}

	/* SpurMemoryManager>>#isInClassTable: */
static sqInt NoDbgRegParms
isInClassTable(sqInt objOop, struct foo * self)
{
    sqInt hash;

	hash = (long32At(objOop + 4)) & (identityHashHalfWordMask(self));
	return (hash != 0)
	 && ((classAtIndex(hash, self)) == objOop);
}

	/* SpurMemoryManager>>#isIndexable: */
sqInt
isIndexable(sqInt objOop, struct foo * self)
{
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	return (fmt >= 2 /* arrayFormat */)
	 && ((fmt <= (weakArrayFormat(self)))
	 || (fmt >= (sixtyFourBitIndexableFormat(self))));
}

	/* SpurMemoryManager>>#isInEden: */
static sqInt NoDbgRegParms
isInEden(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(objOop, ((eden(self)).start), GIV(freeStart), self);
}

	/* SpurMemoryManager>>#isInFutureSpace: */
static sqInt NoDbgRegParms
isInFutureSpace(sqInt address, struct foo * self)
{
	return oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace(self)).start), futureSurvivorStart(self), self);
}


/*	Answer if the given address is in ST object memory. */

	/* SpurMemoryManager>>#isInMemory: */
sqInt
isInMemory(sqInt address, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	if ((oopisLessThan(address, GIV(newSpaceLimit), self))
	 && (oopisGreaterThanOrEqualTo(address, GIV(newSpaceStart), self))) {
		return (oopisGreaterThanOrEqualToandLessThan(address, ((eden(self)).start), GIV(freeStart), self))
		 || ((oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace(self)).start), GIV(pastSpaceStart), self))
		 || ((GIV(gcPhaseInProgress) == ScavengeInProgress)
		 && (oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace(self)).start), futureSurvivorStart(self), self))));
	}
	/* begin isInSegments: */
	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < ((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart)))) {
			return 1;
		}
	}
	return 0;
}

	/* SpurMemoryManager>>#isInNewSpace: */
static sqInt NoDbgRegParms
isInNewSpace(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisLessThan(objOop, GIV(newSpaceLimit), self))
	 && (oopisGreaterThanOrEqualTo(objOop, GIV(newSpaceStart), self));
}

	/* SpurMemoryManager>>#isInOldSpace: */
sqInt
isInOldSpace(sqInt address, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, GIV(oldSpaceStart), GIV(endOfMemory), self);
}

	/* SpurMemoryManager>>#isInPastSpace: */
static sqInt NoDbgRegParms
isInPastSpace(sqInt address, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace(self)).start), GIV(pastSpaceStart), self);
}

	/* SpurMemoryManager>>#isLargeFreeObject: */
static sqInt NoDbgRegParms
isLargeFreeObject(sqInt objOop, struct foo * self)
{
	return (bytesInObject(objOop, self)) >= (64 /* numFreeLists */ * 8 /* allocationUnit */);
}

	/* SpurMemoryManager>>#isMaybeFiredEphemeron: */
static sqInt NoDbgRegParms
isMaybeFiredEphemeron(sqInt objOop, struct foo * self)
{
    sqInt format;

	/* begin isMaybeFiredEphemeronFormat: */
	format = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	return (format <= 5 /* lastPointerFormat */)
	 && (odd(format));
}

	/* SpurMemoryManager>>#isNonImmediate: */
sqInt
isNonImmediate(sqInt oop, struct foo * self)
{
	return (oop & (tagMask(self))) == 0;
}

	/* SpurMemoryManager>>#isObjEphemeron: */
static sqInt NoDbgRegParms
isObjEphemeron(sqInt objOop, struct foo * self)
{
    sqInt format;

	/* begin isEphemeronFormat: */
	format = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	return format == 5 /* ephemeronFormat */;
}

	/* SpurMemoryManager>>#isObjImmutable: */
static sqInt NoDbgRegParms
isObjImmutable(sqInt anOop, struct foo * self)
{
	return 
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(anOop))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		;
}


/*	Answer if obj is old. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isOldObject: */
sqInt
isOldObject(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop, self));
	return oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self);
}


/*	Answer whether the oop is an object of compiled method format */

	/* SpurMemoryManager>>#isOopCompiledMethod: */
sqInt
isOopCompiledMethod(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)));
}

	/* SpurMemoryManager>>#isOopForwarded: */
sqInt
isOopForwarded(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0);
}

	/* SpurMemoryManager>>#isOopImmutable: */
sqInt
isOopImmutable(sqInt oop, struct foo * self)
{
	return (oop & (tagMask(self)))
	 || (((((usqInt) (longAt(oop))) >> (immutableBitShift(self))) & 1) != 0);
}

	/* SpurMemoryManager>>#isOopMutable: */
sqInt
isOopMutable(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (!(((((usqInt) (longAt(oop))) >> (immutableBitShift(self))) & 1) != 0));
}

	/* SpurMemoryManager>>#isPinned: */
sqInt
isPinned(sqInt objOop, struct foo * self)
{
	return ((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0;
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isPointers: */
sqInt
isPointers(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */);
}


/*	the inverse of isAnyPointerFormat: */

	/* SpurMemoryManager>>#isPureBitsFormat: */
static sqInt NoDbgRegParms
isPureBitsFormat(sqInt format, struct foo * self)
{
	return (format >= (sixtyFourBitIndexableFormat(self)))
	 && (format < (firstCompiledMethodFormat(self)));
}


/*	Answer if obj is young. This for compatibility with SqueakV3 where
	the GC makes all objects young during full GC. Spur doesn't do so. */

	/* SpurMemoryManager>>#isReallyYoungObject: */
sqInt
isReallyYoungObject(sqInt obj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (assert(isNonImmediate(obj, self)),
		oopisLessThan(obj, GIV(newSpaceLimit), self));
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isReallyYoung: */
sqInt
isReallyYoung(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((oop & (tagMask(self))) == 0)
	 && ((assert(isNonImmediate(oop, self)),
	oopisLessThan(oop, GIV(newSpaceLimit), self)));
}

	/* SpurMemoryManager>>#isRemembered: */
static sqInt NoDbgRegParms
isRemembered(sqInt objOop, struct foo * self)
{
	return ((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0;
}


/*	Maybe this should be in SpurSegmentManager only */

	/* SpurMemoryManager>>#isSegmentBridge: */
static sqInt NoDbgRegParms
isSegmentBridge(sqInt objOop, struct foo * self)
{
	return ((longAt(objOop)) & (classIndexMask(self))) == (segmentBridgePun(self));
}


/*	This version is private to SpurMemoryManager (for asserts, etc). It does
	not take advantage of the power-of0two optimization in isForwarded:. */

	/* SpurMemoryManager>>#isUnambiguouslyForwarder: */
sqInt
isUnambiguouslyForwarder(sqInt objOop, struct foo * self)
{
	return ((longAt(objOop)) & (classIndexMask(self))) == (isForwardedObjectClassIndexPun(self));
}


/*	For debugging using printOopsSuchThat: */

	/* SpurMemoryManager>>#isUnmarked: */
sqInt
isUnmarked(sqInt objOop, struct foo * self)
{
	return !(((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0);
}

	/* SpurMemoryManager>>#isValidClassTag: */
sqInt
isValidClassTag(sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert(((classIndex >= 0) && (classIndex <= ((1U << (classIndexFieldWidth(self))) - 1))));
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask(self)))
	 || (classIndex >= (arrayClassIndexPun(self))));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (classTablePage == GIV(nilObj)) {
		classOrNil = GIV(nilObj);
		goto l2;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	classOrNil = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
	l2:	/* end classOrNilAtIndex: */;
	return (classOrNil != GIV(nilObj))
	 && (((long32At(classOrNil + 4)) & (identityHashHalfWordMask(self))) == classIndex);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackAt: */
static sqInt NoDbgRegParms
isValidObjStackAt(sqInt objStackRootIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackOrNil;

	/* begin fetchPointer:ofObject: */
	stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord(self))))));
	return (stackOrNil == GIV(nilObj))
	 || (isValidObjStackPagemyIndexfirstPage(stackOrNil, objStackRootIndex, 1, self));
}


/*	Just check the page itself. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex: */
static sqInt NoDbgRegParms
isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(((longAt(objStackPage)) & (classIndexMask(self))) == (sixtyFourBitLongsClassIndexPun(self)))) {
		GIV(objStackInvalidBecause) = "wrong class index";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(((((usqInt) (longAt(objStackPage))) >> (formatShift(self))) & (formatMask(self))) == (sixtyFourBitIndexableFormat(self)))) {
		GIV(objStackInvalidBecause) = "wrong format";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((numSlotsOfAny(objStackPage, self)) == ObjStackPageSlots)) {
		GIV(objStackInvalidBecause) = "wrong num slots";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(myx == (longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord(self))))))))) {
		GIV(objStackInvalidBecause) = "wrong myx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (GIV(marking)
	 && (!(((((usqInt) (longAt(objStackPage))) >> (markedBitFullShift(self))) & 1) != 0))) {
		GIV(objStackInvalidBecause) = "marking but page is unmarked";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return 1;
}


/*	Answer if the obj stack at stackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex:firstPage: */
static sqInt NoDbgRegParms
isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNextPage;
    sqInt index;
    char *ns;
    sqInt page;

	if (!(isValidObjStackPagemyIndex(objStackPage, myx, self))) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
	while (freeOrNextPage != 0) {
		if (!isFirstPage) {
			GIV(objStackInvalidBecause) = "free page on other than first page";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (freeOrNextPage == (longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self)))))))) {
			GIV(objStackInvalidBecause) = "free page = next page";
			GIV(invalidObjStackPage) = freeOrNextPage;
			return 0;
		}
		if (!(isValidObjStackPagemyIndex(freeOrNextPage, myx, self))) {
			ns = malloc(((strlen(GIV(objStackInvalidBecause))) + (strlen(", on next page"))) + 2);
			strcpy(ns, GIV(objStackInvalidBecause));
			GIV(objStackInvalidBecause) = strcat(ns, ", on next page");
			return 0;
		}
		/* begin fetchPointer:ofObject: */
		page = longAt((freeOrNextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
		if ((page == freeOrNextPage)
		 || (page == objStackPage)) {
			GIV(objStackInvalidBecause) = "circularity in free page list";
			GIV(invalidObjStackPage) = page;
			return 0;
		}
		freeOrNextPage = page;
	}
	if (isFirstPage) {
		if (!(((myx >= (1U << (22 /* classIndexFieldWidth */ - (classTableMajorIndexShift(self))))) && (myx <= (((1U << (22 /* classIndexFieldWidth */ - (classTableMajorIndexShift(self)))) + 8 /* hiddenRootSlots */) - 1))))) {
			GIV(objStackInvalidBecause) = "myx out of range";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (!((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(myx) << (shiftForWord(self))))))) == objStackPage)) {
			GIV(objStackInvalidBecause) = "firstPage is not root";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
	}
	/* begin fetchPointer:ofObject: */
	index = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
	if (!(((index >= 0) && (index <= ObjStackLimit)))) {
		GIV(objStackInvalidBecause) = "bad topx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	if (freeOrNextPage == 0) {
		return 1;
	}
	if (freeOrNextPage == objStackPage) {
		GIV(objStackInvalidBecause) = "circularity in objStack page list";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(freeOrNextPage, myx, 0, self);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStack: */
static sqInt NoDbgRegParms
isValidObjStack(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((addressCouldBeObj(objStack, self))
		 && ((numSlotsOfAny(objStack, self)) == ObjStackPageSlots))) {
		GIV(objStackInvalidBecause) = "first page not obj or wrong size";
		GIV(invalidObjStackPage) = objStack;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(objStack, longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord(self)))))), 1, self);
}

	/* SpurMemoryManager>>#isWeakFormat: */
static sqInt NoDbgRegParms
isWeakFormat(sqInt format, struct foo * self)
{
	return format == (weakArrayFormat(self));
}

	/* SpurMemoryManager>>#isWeakNonImm: */
static sqInt NoDbgRegParms
isWeakNonImm(sqInt objOop, struct foo * self)
{
    sqInt format;

	/* begin isWeakFormat: */
	format = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	return format == (weakArrayFormat(self));
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWeak: */
sqInt
isWeak(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (isWeakFormat((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytes: */
sqInt
isWordsOrBytes(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWords: */
sqInt
isWords(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstLongFormat(self))) && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= ((firstShortFormat(self)) - 1))));
}


/*	Answer if obj is young. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isYoungObject: */
sqInt
isYoungObject(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop, self));
	return oopisLessThan(objOop, GIV(newSpaceLimit), self);
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isYoung: */
sqInt
isYoung(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((oop & (tagMask(self))) == 0)
	 && (oopisLessThan(oop, GIV(newSpaceLimit), self));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

	/* SpurMemoryManager>>#is:instanceOf:compactClassIndex: */
static sqInt NoDbgRegParms
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex, struct foo * self)
{
    sqInt ccIndex;

	if (oop & (tagMask(self))) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(oop)) & (classIndexMask(self));
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	else {
		return classOop == (classAtIndex(ccIndex, self));
	}
}

	/* SpurMemoryManager>>#is:onObjStack: */
static sqInt NoDbgRegParms
isonObjStack(sqInt oop, sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt nextPage;

	if (objStack == GIV(nilObj)) {
		return 0;
	}
	assert((numSlotsOfAny(objStack, self)) == ObjStackPageSlots);
	index = (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))))) + ObjStackNextx;
	while (index >= ObjStackFixedSlots) {
		if (oop == (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self)))))))) {
			return 1;
		}
		index -= 1;
	}
	/* begin fetchPointer:ofObject: */
	nextPage = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	if (nextPage != 0) {
		if (isonObjStack(oop, nextPage, self)) {
			return 1;
		}
	}
	return 0;
}


/*	Answer the object the ephemeron guards. This is its first element. */

	/* SpurMemoryManager>>#keyOfEphemeron: */
static sqInt NoDbgRegParms
keyOfEphemeron(sqInt objOop, struct foo * self)
{
	assert((isNonImmediate(objOop, self))
	 && (isObjEphemeron(objOop, self)));
	/* begin fetchPointer:ofObject: */
	return longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
}

	/* SpurMemoryManager>>#knownClassAtIndex: */
static sqInt NoDbgRegParms
knownClassAtIndex(sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(((classIndex >= 1) && (classIndex <= (classTablePageSize(self)))));
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(classIndex) << (shiftForWord(self))))));
}

	/* SpurMemoryManager>>#lastPointerFormat */
static sqInt
lastPointerFormat(struct foo * self)
{
	return 5;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects.
	Does not examine the stack pointer of contexts to be sure to swizzle
	the nils that fill contexts on snapshot.
	It is invariant that on image load no object contains a forwarding
	pointer, and the image contains no forwarders (see class comment). */

	/* SpurMemoryManager>>#lastPointerOfWhileSwizzling: */
sqInt
lastPointerOfWhileSwizzling(sqInt objOop, struct foo * self)
{
    sqInt fmt;
    sqInt header;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt != (forwardedFormat(self)));
	if (fmt <= 5 /* lastPointerFormat */) {
		return (((numSlotsOf(objOop, self)) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat(self))) {
		return 0;
	}
	assert(isCompiledMethod(objOop, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (((((assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#lastPointerOf: */
sqInt
lastPointerOf(sqInt objOop, struct foo * self)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt != (forwardedFormat(self)));
	if (fmt <= 5 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat(self)))
		 && (((longAt(objOop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l3;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop, self)));
			contextSize = (sp >> 3);
	l3:	/* end fetchStackPointerOf: */;
			return (((CtxtTempFrameStart - 1) + contextSize) * BytesPerOop) + BaseHeaderSize;
		}
		return (((numSlotsOf(objOop, self)) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat(self))) {
		return 0;
	}
	assert(isCompiledMethod(objOop, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (((((assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}

	/* SpurMemoryManager>>#leakCheckBecome */
sqInt
leakCheckBecome(struct foo * self)
{
	return (checkForLeaks & GCModeBecome) != 0;
}

	/* SpurMemoryManager>>#leakCheckFullGC */
sqInt
leakCheckFullGC(struct foo * self)
{
	return (checkForLeaks & GCModeFull) != 0;
}

	/* SpurMemoryManager>>#leakCheckIncremental */
sqInt
leakCheckIncremental(struct foo * self)
{
	return (checkForLeaks & GCModeIncremental) != 0;
}

	/* SpurMemoryManager>>#leakCheckNewSpaceGC */
sqInt
leakCheckNewSpaceGC(struct foo * self)
{
	return (checkForLeaks & GCModeNewSpace) != 0;
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* SpurMemoryManager>>#lengthOfMaybeImmediate: */
static sqInt NoDbgRegParms
lengthOfMaybeImmediate(sqInt oop, struct foo * self)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	if (oop & (tagMask(self))) {
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord(self))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		return numSlots;
	}
	return 0;
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes) should
	be subtracted from the result. */

	/* SpurMemoryManager>>#lengthOf: */
sqInt
lengthOf(sqInt objOop, struct foo * self)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord(self))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		return numSlots;
	}
	return 0;
}

	/* SpurMemoryManager>>#literalCountOfMethodHeader: */
sqInt
literalCountOfMethodHeader(sqInt header, struct foo * self)
{
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}

	/* SpurMemoryManager>>#literalCountOf: */
sqInt
literalCountOf(sqInt methodPointer, struct foo * self)
{
    sqInt header;

	/* begin literalCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}


/*	This primitive is called from Smalltalk as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed.
	It will return as its value the original array of roots, and the
	segmentWordArray will become an
	array of the loaded objects. If this primitive should fail, the
	segmentWordArray will, sadly, have
	been reduced to an unrecognizable and unusable jumble. But what more could
	you have done
	with it anyway?
	
	The primitive, if it succeeds, also becomes the segmentWordArray into the
	array of loaded objects.
	This allows fixing up of loaded objects directly, without nextObject,
	which Spur doesn't support. */

	/* SpurMemoryManager>>#loadImageSegmentFrom:outPointers: */
static sqInt NoDbgRegParms NeverInline
loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex11;
    sqInt classIndex2;
    sqInt classIndex3;
    sqInt classOop;
    sqInt classRef;
    sqInt clone;
    sqInt err;
    sqInt errorCode;
    sqInt errorCode1;
    sqInt fillIdx;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt followingWordAddress3;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt loadedObjectsArray;
    usqInt mappedOop;
    usqInt newObj;
    usqInt numBytes;
    sqInt numLoadedObjects;
    usqInt numOutPointers;
    sqInt numSegObjs;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oldClone;
    sqInt oop;
    sqInt oop1;
    usqInt oop2;
    sqInt scanClassTable;
    usqInt segmentLimit;
    sqInt segmentStart;
    sqInt segVersion;

	/* begin numSlotsOf: */
	assert((classIndexOf(segmentWordArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(segmentWordArray + 7);
	segmentLimit = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(segmentWordArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (((segmentLimit == 0
		? 8 /* allocationUnit */ + BaseHeaderSize
		: (segmentLimit << (shiftForWord(self))) + ((segmentLimit >= (numSlotsMask(self))
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)))) < (8 /* allocationUnit */ + BaseHeaderSize)) {
		return PrimErrBadArgument;
	}
	segVersion = longAt(segmentWordArray + BaseHeaderSize);
	if (!(((segVersion & 0xFFFFFF) == 68021 /* imageFormatVersion */)
		 || (0))) {
		reverseBytesIn32BitWordsIn(segmentWordArray, self);
		segVersion = longAt(segmentWordArray + BaseHeaderSize);
		if (!(((segVersion & 0xFFFFFF) == 68021 /* imageFormatVersion */)
			 || (0))) {
			reverseBytesIn32BitWordsIn(segmentWordArray, self);
			return PrimErrBadArgument;
		}
	}
	segmentStart = (segmentWordArray + BaseHeaderSize) + 8 /* allocationUnit */;

	/* Notionally reverse the Byte type objects if the data is from opposite endian machine.
	   Test top byte.  $d on the Mac or $s on the PC.  Rest of word is equal.  If Spur is ever
	   ported to big-endian machines then the segment may have to be byte/word swapped,
	   but so far it only runs on little-endian machines, so for now just fail if endianness is wrong. */
	segmentLimit = ((segmentLimit * BytesPerOop) + segmentWordArray) + BaseHeaderSize;
	flag("endianness");
	if (((((usqInt) segVersion) >> 24) & 0xFF) != ((((usqInt) (imageSegmentVersion(self))) >> 24) & 0xFF)) {

		/* Reverse the byte-type objects once */
		return PrimErrBadArgument;
	}
	if ((assert(isNonImmediate(segmentWordArray, self)),
	oopisGreaterThanOrEqualTo(segmentWordArray, GIV(oldSpaceStart), self))) {
		/* begin ensureNoNewObjectsIn: */
		scanClassTable = 0;
		for (i = 0, iLimiT = ((numSlotsOf(outPointerArray, self)) - 1); i <= iLimiT; i += 1) {
			oop1 = longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			if (((oop1 & (tagMask(self))) == 0)
			 && (oopisLessThan(oop1, GIV(newSpaceLimit), self))) {
				clone = cloneInOldSpaceforPinning(oop1, 0, self);
				if (clone == 0) {
					errorCode = PrimErrNoMemory;
					goto l11;
				}
				if ((((hash = (long32At(oop1 + 4)) & (identityHashHalfWordMask(self)))) != 0)
				 && ((classOrNilAtIndex(hash, self)) == oop1)) {
					scanClassTable = 1;
				}
				/* begin forward:to: */
				classIndex1 = isForwardedObjectClassIndexPun(self);
				assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask(self)))));
				assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
				longAtput(oop1, ((longAt(oop1)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex1 + (7U << (formatShift(self)))));
				
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(oop1, (longAt(oop1)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#        endif /* IMMUTABILITY */
				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(oop1, self));
				assert(!(isOopForwarded(clone, self)));
				if ((assert(isNonImmediate(oop1, self)),
				oopisGreaterThanOrEqualTo(oop1, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((clone & (tagMask(self))) == 0)
					 && (oopisLessThan(clone, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(oop1))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(oop1, self);
						}
					}
				}
				longAtput((oop1 + BaseHeaderSize) + (0U << (shiftForWord(self))), clone);
				if ((byteAt(oop1 + 7)) == 0) {
					byteAtput(oop1 + 7, 1);
				}
				assert(!(isOopForwarded(outPointerArray, self)));
				longAtput((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), clone);
			}
		}
		if (scanClassTable) {
			postBecomeScanClassTable(BecamePointerObjectFlag, self);
		}
		errorCode = 0;
	l11:	/* end ensureNoNewObjectsIn: */;
		if (errorCode != 0) {
			return errorCode;
		}
	}
	/* begin mapOopsAndValidateClassRefsFrom:to:outPointers: */
	assert((classIndexOf(outPointerArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots3 = byteAt(outPointerArray + 7);
	numOutPointers = (numSlots3 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(outPointerArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots3);
	numSegObjs = 0;
	/* begin objectStartingAt: */
	numSlots11 = byteAt(segmentStart + 7);
	objOop2 = (numSlots11 == (numSlotsMask(self))
		? segmentStart + BaseHeaderSize
		: segmentStart);
	while (oopisLessThan(objOop2, segmentLimit, self)) {

		/* No object in the segment should be marked.  If is is something is wrong. */
		numSegObjs += 1;
		if (((((usqInt) (longAt(objOop2))) >> (markedBitFullShift(self))) & 1) != 0) {
			errorCode = PrimErrInappropriate;
			goto l24;
		}
		/* begin classIndexOf: */
		classIndex3 = (longAt(objOop2)) & (classIndexMask(self));
		if (classIndex3 & TopHashBit) {
			classIndex3 -= TopHashBit;
			if (classIndex3 >= numOutPointers) {
				errorCode = PrimErrBadIndex;
				goto l24;
			}
			/* begin fetchPointer:ofObject: */
			mappedOop = longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(classIndex3) << (shiftForWord(self))))));
			hash2 = (long32At(mappedOop + 4)) & (identityHashHalfWordMask(self));
			if (!((hash2 == 0)
				 || ((hash2 > (lastClassIndexPun(self)))
				 && ((classOrNilAtIndex(hash2, self)) == mappedOop)))) {
				errorCode = PrimErrInappropriate;
				goto l24;
			}
		}
		else {

			/* The class is contained within the segment. */
			if (((oop2 = ((classIndex3 - (firstClassIndexPun(self))) * 8 /* allocationUnit */) + segmentStart)) >= segmentLimit) {
				errorCode = PrimErrBadIndex;
				goto l24;
			}
			if (((long32At(oop2 + 4)) & (identityHashHalfWordMask(self))) != 0) {
				errorCode = PrimErrInappropriate;
				goto l24;
			}
		}
		for (i1 = 0, iLimiT1 = ((numPointerSlotsOf(objOop2, self)) - 1); i1 <= iLimiT1; i1 += 1) {
			/* begin fetchPointer:ofObject: */
			oop2 = longAt((objOop2 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
			if ((oop2 & (tagMask(self))) == 0) {
				if (oop2 & TopOopBit) {
					if (((oop2 = (oop2 - TopOopBit) / BytesPerOop)) >= numOutPointers) {
						errorCode = PrimErrBadIndex;
						goto l24;
					}
					/* begin fetchPointer:ofObject: */
					mappedOop = longAt((outPointerArray + BaseHeaderSize) + (oop2 << (shiftForWord(self))));
				}
				else {
					if ((oop2 & (8 /* allocationUnit */ - 1)) != 0) {
						errorCode = PrimErrInappropriate;
						goto l24;
					}
					if (((mappedOop = oop2 + segmentStart)) >= segmentLimit) {
						errorCode = PrimErrBadIndex;
						goto l24;
					}
				}
				assert(!(isOopForwarded(objOop2, self)));
				longAtput((objOop2 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), mappedOop);
			}
		}
		/* begin objectAfter:limit: */
		followingWordAddress3 = addressAfter(objOop2, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress3, segmentLimit, self)) {
			objOop2 = segmentLimit;
			goto l20;
		}
		flag("endianness");
		followingWord3 = longAt(followingWordAddress3);
		objOop2 = ((((usqInt) followingWord3) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress3 + BaseHeaderSize
			: followingWordAddress3);
	l20:	/* end objectAfter:limit: */;
	}
	errorCode = -numSegObjs;
	l24:	/* end mapOopsAndValidateClassRefsFrom:to:outPointers: */;
	if (errorCode > 0) {
		return errorCode;
	}
	numLoadedObjects = -errorCode;
	/* begin allocateSlots:format:classIndex: */
	if (numLoadedObjects >= (numSlotsMask(self))) {
		if ((((usqInt) numLoadedObjects) >> 56) > 0) {
			loadedObjectsArray = null;
			goto l8;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numLoadedObjects * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numLoadedObjects < 1
	? /* begin allocationUnit */ 8
	: numLoadedObjects * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		loadedObjectsArray = allocateSlotsInOldSpacebytesformatclassIndex(numLoadedObjects, numBytes, 2 /* arrayFormat */, ClassArrayCompactIndex, self);
		goto l8;
	}
	if (numLoadedObjects >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numLoadedObjects);
		longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(self), 2 /* arrayFormat */, ClassArrayCompactIndex, self));
	}
	else {
		longAtput(newObj, (((((usqLong) numLoadedObjects)) << (numSlotsFullShift(self))) + (2U << (formatShift(self)))) + ClassArrayCompactIndex);
	}
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	GIV(freeStart) += numBytes;
	loadedObjectsArray = newObj;
	l8:	/* end allocateSlots:format:classIndex: */;
	if (!(loadedObjectsArray)) {
		return PrimErrNoMemory;
	}
	/* begin enterClassesIntoClassTableFrom:to: */
	objOop = objectAfter(objectStartingAt(segmentStart, self), self);
	while ((oopisLessThan(objOop, segmentLimit, self))
	 && (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
		/* begin setIsRememberedOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (rememberedBitShift(self)))));
		if (((errorCode1 = enterIntoClassTable(objOop, self))) != 0) {
			oop = objOop;
			objOop = objectAfter(objectStartingAt(segmentStart, self), self);
			while (oopisLessThan(objOop, oop, self)) {
				expungeFromClassTable(objOop, self);
				/* begin objectAfter:limit: */
				followingWordAddress = addressAfter(objOop, self);
				if (oopisGreaterThanOrEqualTo(followingWordAddress, segmentLimit, self)) {
					objOop = segmentLimit;
					goto l5;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
	l5:	/* end objectAfter:limit: */;
			}
			errorCode = errorCode1;
			goto l6;
		}
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, segmentLimit, self)) {
			objOop = segmentLimit;
			goto l4;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
	}
	errorCode = 0;
	l6:	/* end enterClassesIntoClassTableFrom:to: */;
	if (errorCode != 0) {
		return errorCode;
	}
	/* begin assignClassIndicesAndPinFrom:to:outPointers:filling: */
	numSlots2 = byteAt(segmentStart + 7);
	objOop1 = (numSlots2 == (numSlotsMask(self))
		? segmentStart + BaseHeaderSize
		: segmentStart);
	fillIdx = 0;
	while (oopisLessThan(objOop1, segmentLimit, self)) {
		assert(!(isOopForwarded(loadedObjectsArray, self)));
		longAtput((loadedObjectsArray + BaseHeaderSize) + (((sqInt)((usqInt)(fillIdx) << (shiftForWord(self))))), objOop1);

		/* In the segment, class indices are offset indexes into the segment data,
		   or into outPointers.  See mapOopsFrom:to:outPointers:outHashes: and
		   newOutPointer:at:in:hashes:. */
		fillIdx += 1;
		classRef = (longAt(objOop1)) & (classIndexMask(self));
		if (classRef & TopHashBit) {
			classOop = longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)((classRef - TopHashBit)) << (shiftForWord(self))))));
		}
		else {
			classOop = ((classRef - (firstClassIndexPun(self))) * 8 /* allocationUnit */) + segmentStart;
		}
		classIndex2 = (long32At(classOop + 4)) & (identityHashHalfWordMask(self));
		if (classIndex2 == 0) {
			assert(addressCouldBeClassObj(classOop, self));
			classIndex2 = (((hash1 = (long32At(classOop + 4)) & (identityHashHalfWordMask(self)))) != 0
				? hash1
				: (objCouldBeClassObj(classOop, self)
						? (((err = enterIntoClassTable(classOop, self))) != 0
								? -err
								: (/* begin rawHashBitsOf: */
									(long32At(classOop + 4)) & (identityHashHalfWordMask(self))))
						: -PrimErrBadReceiver));
			if (classIndex2 < 0) {

				/* Error code e.g. - PrimErrNoMemory */
				-classIndex2;
				goto l16;
			}
		}
		assert((classIndex2 > (lastClassIndexPun(self)))
		 && ((classOrNilAtIndex(classIndex2, self)) == classOop));
		/* begin setClassIndexOf:to: */
		assert(((classIndex2 >= 0) && (classIndex2 <= (classIndexMask(self)))));
		longAtput(objOop1, ((longAt(objOop1)) & (~(usqIntptr_t)(classIndexMask(self)))) + classIndex2);
		if (((oopisLessThan(objOop1, GIV(newSpaceLimit), self))
		 && (oopisGreaterThanOrEqualTo(objOop1, GIV(newSpaceStart), self)))
		 && (((((usqInt) (longAt(objOop1))) >> (pinnedBitShift(self))) & 1) != 0)) {
			oldClone = cloneInOldSpaceforPinning(objOop1, 1, self);
			if (oldClone != 0) {
				/* begin setIsPinnedOf:to: */
				longAtput(oldClone, (longAt(oldClone)) | (1U << (pinnedBitShift(self))));
				/* begin forward:to: */
				classIndex11 = isForwardedObjectClassIndexPun(self);
				assert(((classIndex11 >= 0) && (classIndex11 <= (classIndexMask(self)))));
				assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
				longAtput(objOop1, ((longAt(objOop1)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex11 + (7U << (formatShift(self)))));
				
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#        endif /* IMMUTABILITY */
				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(objOop1, self));
				assert(!(isOopForwarded(oldClone, self)));
				if ((assert(isNonImmediate(objOop1, self)),
				oopisGreaterThanOrEqualTo(objOop1, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((oldClone & (tagMask(self))) == 0)
					 && (oopisLessThan(oldClone, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(objOop1))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(objOop1, self);
						}
					}
				}
				longAtput((objOop1 + BaseHeaderSize) + (0U << (shiftForWord(self))), oldClone);
				if ((byteAt(objOop1 + 7)) == 0) {
					byteAtput(objOop1 + 7, 1);
				}
			}
		}
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, segmentLimit, self)) {
			objOop1 = segmentLimit;
			goto l12;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l12:	/* end objectAfter:limit: */;
	}
	l16:	/* end assignClassIndicesAndPinFrom:to:outPointers:filling: */;
	if ((byteAt(segmentWordArray + 7)) == (numSlotsMask(self))) {
		/* begin rawOverflowSlotsOf:put: */
		longAtput(segmentWordArray - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask(self))) << 56))) + (8 /* allocationUnit */ / BytesPerOop));
		8 /* allocationUnit */ / BytesPerOop;
	}
	else {
		/* begin rawNumSlotsOf:put: */
		byteAtput(segmentWordArray + 7, 8 /* allocationUnit */ / BytesPerOop);
	}
	/* begin forward:to: */
	classIndex = isForwardedObjectClassIndexPun(self);
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
	assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
	longAtput(segmentWordArray, ((longAt(segmentWordArray)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex + (7U << (formatShift(self)))));
	
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(segmentWordArray, (longAt(segmentWordArray)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#  endif /* IMMUTABILITY */
	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(segmentWordArray, self));
	assert(!(isOopForwarded(loadedObjectsArray, self)));
	if ((assert(isNonImmediate(segmentWordArray, self)),
	oopisGreaterThanOrEqualTo(segmentWordArray, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((loadedObjectsArray & (tagMask(self))) == 0)
		 && (oopisLessThan(loadedObjectsArray, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(segmentWordArray))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(segmentWordArray, self);
			}
		}
	}
	longAtput((segmentWordArray + BaseHeaderSize) + (0U << (shiftForWord(self))), loadedObjectsArray);
	if ((byteAt(segmentWordArray + 7)) == 0) {
		byteAtput(segmentWordArray + 7, 1);
	}
	runLeakCheckerFor(GCModeImageSegment, self);
	/* begin objectStartingAt: */
	numSlots1 = byteAt(segmentStart + 7);
	return (numSlots1 == (numSlotsMask(self))
		? segmentStart + BaseHeaderSize
		: segmentStart);
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

	/* SpurMemoryManager>>#longPrintInstancesOf: */
void
longPrintInstancesOf(sqInt aClassOop, struct foo * self)
{
    sqInt classIndex;

	classIndex = (long32At(aClassOop + 4)) & (identityHashHalfWordMask(self));
	if (classIndex != (isFreeObjectClassIndexPun(self))) {
		longPrintInstancesWithClassIndex(classIndex, self);
	}
}


/*	Scan the heap printing any and all objects whose classIndex equals the
	argument. 
 */

	/* SpurMemoryManager>>#longPrintInstancesWithClassIndex: */
void
longPrintInstancesWithClassIndex(sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask(self))) == classIndex) {
			longPrintOop(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == classIndex) {
			longPrintOop(objOop, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == classIndex) {
			longPrintOop(objOop, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */

	/* SpurMemoryManager>>#longPrintReferencesTo: */
void
longPrintReferencesTo(sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prntObj;

	prntObj = 0;
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots2 = byteAt(address + 7);
	objOop1 = (numSlots2 == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
		 || (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
				i = ((assert((((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart;
			}
			else {
				if (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1, self));
				}
				else {
					/* begin numSlotsOf: */
					assert((classIndexOf(objOop1, self)) > (isForwardedObjectClassIndexPun(self)));
					numSlots = byteAt(objOop1 + 7);
					i = (numSlots == (numSlotsMask(self))
						? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop1 - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots);
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					printHex(objOop1, self);
					print(" @ ", self);
					printNum(i, self);
					/* begin cr */
					printf("\n");
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(objOop1, self);
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l7;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l7:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
		 || (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
				i = ((assert((((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart;
			}
			else {
				if (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1, self));
				}
				else {
					/* begin numSlotsOf: */
					assert((classIndexOf(objOop1, self)) > (isForwardedObjectClassIndexPun(self)));
					numSlots = byteAt(objOop1 + 7);
					i = (numSlots == (numSlotsMask(self))
						? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop1 - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots);
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					printHex(objOop1, self);
					print(" @ ", self);
					printNum(i, self);
					/* begin cr */
					printf("\n");
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(objOop1, self);
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l6;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
			 || (((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))) {
				if (((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
					i = ((assert((((((assert(isCompiledMethod(objOop11, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop11, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart;
				}
				else {
					if (((longAt(objOop11)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
						i = CtxtTempFrameStart + (fetchStackPointerOf(objOop11, self));
					}
					else {
						/* begin numSlotsOf: */
						assert((classIndexOf(objOop11, self)) > (isForwardedObjectClassIndexPun(self)));
						numSlots = byteAt(objOop11 + 7);
						i = (numSlots == (numSlotsMask(self))
							? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop11 - BaseHeaderSize))) << 8)))))) >> 8
							: numSlots);
					}
				}
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
						printHex(objOop11, self);
						print(" @ ", self);
						printNum(i, self);
						/* begin cr */
						printf("\n");
						prntObj = 1;
						i = 0;
					}
				}
				if (prntObj) {
					prntObj = 0;
					longPrintOop(objOop11, self);
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#mapExtraRoots */
static void
mapExtraRoots(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;

	if (shouldRemapObj(GIV(specialObjectsOop), self)) {
		GIV(specialObjectsOop) = remapObj(GIV(specialObjectsOop), self);
	}
	assert(GIV(remapBufferCount) == 0);
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!((oop & (tagMask(self)))
			 || (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))))) {
			if (shouldRemapObj(oop, self)) {
				(GIV(extraRoots)[i])[0] = (remapObj(oop, self));
			}
		}
	}
}

	/* SpurMemoryManager>>#mapMournQueue */
static void NeverInline
mapMournQueue(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i1;
    sqInt mourner;
    sqInt numOnThisPage;
    sqInt objStackPage;
    sqInt referent;

	/* begin objStack:do: */
	if (GIV(mournQueue) == GIV(nilObj)) {
		goto l7;
	}
	eassert(isValidObjStack(GIV(mournQueue), self));
	objStackPage = GIV(mournQueue);
	while (objStackPage != 0) {
		/* begin fetchPointer:ofObject: */
		numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
		for (i1 = ((numOnThisPage + ObjStackFixedSlots) - 1); i1 >= ObjStackFixedSlots; i1 += -1) {
			/* begin fetchPointer:ofObject: */
			mourner = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
			if ((mourner & (tagMask(self))) == 0) {

				/* someone could try and become weaklings into immediates... */
				if (((longAt(mourner)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(mourner, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((mourner + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					mourner = referent;
				}
				if (!(isScavengeSurvivor(mourner, self))) {
					mourner = copyAndForwardMourner(mourner, self);
				}
				assert(!(isOopForwarded(objStackPage, self)));
				longAtput((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), mourner);
			}
		}
		/* begin fetchPointer:ofObject: */
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	}
	l7:	/* end objStack:do: */;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Now scan, adding out pointers to the outPointersArray; all objects in
	arrayOfObjects have had their first fields set to point to their copies in
	segmentWordArray. Answer
	the outIndex if the scan succeded. Fail if outPointers is too small and
	answer -1.
	
	As established by copyObj:toAddr:startAt:stopAt:savedFirstFields:index:,
	the marked bit is set for all objects in the segment
	the remembered bit is set for all classes in the segment.
	
	Class indices should be set as follows (see
	assignClassIndicesAndPinFrom:to:outPointers:filling:) - class indices for
	classes in the segment */

	/* SpurMemoryManager>>#mapOopsFrom:to:outPointers:outHashes: */
static sqInt NoDbgRegParms
mapOopsFromtooutPointersoutHashes(sqInt segStart, sqInt segAddr, sqInt outPointerArray, sqInt savedOutHashes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt heapOop;
    sqInt i;
    sqInt iLimiT;
    sqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objIndex;
    sqInt objOop;
    sqInt oop;
    sqInt outIndex;
    usqInt p;
    sqInt segIndex;
    sqInt valueWord;
    sqInt valueWord1;


	/* objIndex is for debugging; it mirrors indices in the sender's arrayOfObjects. */
	outIndex = (objIndex = 0);
	/* begin fillObj:numSlots:with: */
	assert((classIndexOf(outPointerArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots2 = byteAt(outPointerArray + 7);
	numSlots = (numSlots2 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(outPointerArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2);
	assert(oopisLessThan(((outPointerArray + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(outPointerArray, self), self));
	for (p = (((usqInt)(outPointerArray + BaseHeaderSize))); p <= (((usqInt)(((outPointerArray + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
		longAtput(p, GIV(nilObj));
	}
	/* begin objectStartingAt: */
	numSlots1 = byteAt(segStart + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? segStart + BaseHeaderSize
		: segStart);
	while (oopisLessThan(objOop, segAddr, self)) {

		/* Set the classIndex of the instance.  This is a segment offset (segAddr - segStart / allocationUnit) for instances of
		   classes within the segment, and an outPointer index (index in outPointers + TopHashBit) for classes outside the segment. */
		heapOop = fetchClassOfNonImm(objOop, self);
		if (((((usqInt) (longAt(heapOop))) >> (markedBitFullShift(self))) & 1) != 0) {

			/* oop is a class in the segment; storeImageSegmentInto:outPointers:roots: established offset is within range. */
			/* begin fetchPointer:ofObject: */
			oop = longAt((heapOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
			assert(oopisGreaterThanOrEqualToandLessThan(oop, segStart, segAddr, self));
			segIndex = ((oop - segStart) / 8 /* allocationUnit */) + (firstClassIndexPun(self));
			if (segIndex & TopHashBit) {

				/* Too many classes in the segment */
				return -1;
			}
		}
		else {

			/* oop is an outPointer; locate or allocate its oop */
			hash = (long32At(heapOop + 4)) & (identityHashHalfWordMask(self));
			if ((hash & TopHashBit)
			 && (((hash - TopHashBit) <= outIndex)
			 && (heapOop == (longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)((hash - TopHashBit)) << (shiftForWord(self)))))))))) {
				segIndex = hash;
			}
			else {

				/* oop is a new outPointer; allocate its oop */
				/* begin newOutPointer:at:in:hashes: */
				if (outIndex >= (numSlotsOf(outPointerArray, self))) {

					/* no room in outPointers; fail */
					outIndex = 0;
					goto l9;
				}
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(outPointerArray, self)));
				if ((assert(isNonImmediate(outPointerArray, self)),
				oopisGreaterThanOrEqualTo(outPointerArray, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((heapOop & (tagMask(self))) == 0)
					 && (oopisLessThan(heapOop, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(outPointerArray))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(outPointerArray, self);
						}
					}
				}
				longAtput((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << (shiftForWord(self))))), heapOop);
				/* begin storeLong32:ofObject:withValue: */
				valueWord = (long32At(heapOop + 4)) & (identityHashHalfWordMask(self));
				long32Atput((savedOutHashes + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << 2))), valueWord);
				/* begin setHashBitsOf:to: */
				hash1 = outIndex + TopHashBit;
				assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask(self)))));
				long32Atput(heapOop + 4, ((((long32At(heapOop + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash1);
				outIndex += 1;
	l9:	/* end newOutPointer:at:in:hashes: */;
				if (outIndex == 0) {

					/* no room in outPointers; fail */
					return -1;
				}
				segIndex = (long32At(heapOop + 4)) & (identityHashHalfWordMask(self));
			}
			assert(segIndex & TopHashBit);
		}
		/* begin setClassIndexOf:to: */
		assert(((segIndex >= 0) && (segIndex <= (classIndexMask(self)))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(classIndexMask(self)))) + segIndex);
		for (i = 0, iLimiT = ((numPointerSlotsOf(objOop, self)) - 1); i <= iLimiT; i += 1) {
			/* begin fetchPointer:ofObject: */
			heapOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			if ((heapOop & (tagMask(self))) == 0) {
				if (((((usqInt) (longAt(heapOop))) >> (markedBitFullShift(self))) & 1) != 0) {

					/* oop is an object in the segment. */
					/* begin fetchPointer:ofObject: */
					oop = longAt((heapOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
					assert(oopisGreaterThanOrEqualToandLessThan(oop, segStart, segAddr, self));
					oop -= segStart;
				}
				else {

					/* oop is an outPointer; locate or allocate its oop */
					hash = (long32At(heapOop + 4)) & (identityHashHalfWordMask(self));
					if ((hash & TopHashBit)
					 && (((hash - TopHashBit) <= outIndex)
					 && (heapOop == (longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)((hash - TopHashBit)) << (shiftForWord(self)))))))))) {
						oop = ((hash - TopHashBit) * BytesPerOop) + TopOopBit;
					}
					else {

						/* oop is a new outPointer; allocate its oop */
						/* begin newOutPointer:at:in:hashes: */
						if (outIndex >= (numSlotsOf(outPointerArray, self))) {

							/* no room in outPointers; fail */
							outIndex = 0;
							goto l12;
						}
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(outPointerArray, self)));
						if ((assert(isNonImmediate(outPointerArray, self)),
						oopisGreaterThanOrEqualTo(outPointerArray, GIV(oldSpaceStart), self))) {

							/* most stores into young objects */
							if (((heapOop & (tagMask(self))) == 0)
							 && (oopisLessThan(heapOop, GIV(newSpaceLimit), self))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(outPointerArray))) >> (rememberedBitShift(self))) & 1) != 0)) {
									remember(outPointerArray, self);
								}
							}
						}
						longAtput((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << (shiftForWord(self))))), heapOop);
						/* begin storeLong32:ofObject:withValue: */
						valueWord1 = (long32At(heapOop + 4)) & (identityHashHalfWordMask(self));
						long32Atput((savedOutHashes + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << 2))), valueWord1);
						/* begin setHashBitsOf:to: */
						hash2 = outIndex + TopHashBit;
						assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask(self)))));
						long32Atput(heapOop + 4, ((((long32At(heapOop + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash2);
						outIndex += 1;
	l12:	/* end newOutPointer:at:in:hashes: */;
						if (outIndex == 0) {

							/* no room in outPointers; fail */
							return -1;
						}
						assert((rawHashBitsOf(heapOop, self)) & TopHashBit);
						oop = ((((long32At(heapOop + 4)) & (identityHashHalfWordMask(self))) - TopHashBit) * BytesPerOop) + TopOopBit;
					}
				}
				assert(!(isOopForwarded(objOop, self)));
				longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), oop);
			}
		}
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, segAddr, self)) {
			objOop = segAddr;
			goto l4;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l4:	/* end objectAfter:limit: */;
		objIndex += 1;
	}
	return outIndex;
}


/*	Ensure the class of the argument is marked, pushing it on the markStack if
	not already marked.
	And for one-way become, which can create duplicate entries in the class
	table, make sure
	objOop's classIndex refers to the classObj's actual classIndex.
	Note that this is recursive, but the metaclass chain should terminate
	quickly. 
 */

	/* SpurMemoryManager>>#markAndTraceClassOf: */
static void NoDbgRegParms
markAndTraceClassOf(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classObj;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt objStack;
    sqInt realClassIndex;

	/* begin classIndexOf: */
	classIndex = (longAt(objOop)) & (classIndexMask(self));
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask(self)))
	 || (classIndex >= (arrayClassIndexPun(self))));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (classTablePage == GIV(nilObj)) {
		classObj = GIV(nilObj);
		goto l4;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	classObj = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
	l4:	/* end classOrNilAtIndex: */;
	assert(objCouldBeClassObj(classObj, self));
	realClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	if ((classIndex != realClassIndex)
	 && (classIndex > (lastClassIndexPun(self)))) {
		/* begin setClassIndexOf:to: */
		assert(((realClassIndex >= 0) && (realClassIndex <= (classIndexMask(self)))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(classIndexMask(self)))) + realClassIndex);
	}
	if (!(((((usqInt) (longAt(classObj))) >> (markedBitFullShift(self))) & 1) != 0)) {
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(classObj, self)));
		longAtput(classObj, (longAt(classObj)) | (1ULL << (markedBitFullShift(self))));
		markAndTraceClassOf(classObj, self);
		/* begin push:onObjStack: */
		objStack = GIV(markStack);
		assert(addressCouldBeOop(classObj, self));
		if (classObj & (tagMask(self))) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack, self))
				? fetchPointerofObject(ObjStackNextx, objStack, self)
				: objStack), self), self));
		}
		else {

			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(classObj, self))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(classObj, self)));
		}
		noCheckPushonObjStack(classObj, objStack, self);
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such
	as the markStack or the ephemeronQueue. It is a linked list of
	segments, with the hot end at the head of the list. It is a word object.
	The stack pointer is in ObjStackTopx and 0 means empty. */

	/* SpurMemoryManager>>#markAndTraceObjStack:andContents: */
static void NoDbgRegParms
markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt index;
    sqInt objOop;

	if (stackOrNil == GIV(nilObj)) {
		return;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(stackOrNil, self)));
	longAtput(stackOrNil, (longAt(stackOrNil)) | (1ULL << (markedBitFullShift(self))));
	assert((numSlotsOfAny(stackOrNil, self)) == ObjStackPageSlots);
	/* begin fetchPointer:ofObject: */
	field = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	if (field != 0) {
		markAndTraceObjStackandContents(field, markAndTraceContents, self);
	}
	field = stackOrNil;
	while (1) {
		/* begin fetchPointer:ofObject: */
		field = longAt((field + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
		if (!(field != 0)) break;
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(field, self)));
		longAtput(field, (longAt(field)) | (1ULL << (markedBitFullShift(self))));
	}
	if (!markAndTraceContents) {
		return;
	}
	index = (longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))))) + ObjStackNextx;
	while (index >= ObjStackFixedSlots) {
		/* begin followObjField:ofObject: */
		objOop = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
		assert(isNonImmediate(objOop, self));
		if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(index, stackOrNil, objOop, self);
		}
		field = objOop;
		if (!(field & (tagMask(self)))) {
			markAndTrace(field, self);
		}
		index -= 1;
	}
}


/*	Mark the argument, and all objects reachable from it, and any remaining
	objects on the mark stack. Follow forwarding pointers in the scan. */
/*	if markAndTrace: is to follow and eliminate forwarding pointers
	in its scan it cannot be handed an r-value which is forwarded.
	The assert for this is in markAndShouldScan: */

	/* SpurMemoryManager>>#markAndTrace: */
void NeverInline
markAndTrace(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt contextSize;
    sqInt field;
    sqInt fmt;
    sqInt format1;
    sqInt format11;
    sqInt header;
    sqInt index;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt numStrongSlots;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objStack;
    sqInt objStack1;
    sqInt objStack2;
    sqInt objStack3;
    sqInt objStack4;
    sqInt objStack5;
    sqInt objStack6;
    sqInt objToScan;
    sqInt scanLargeObject;
    sqInt sp;

	numStrongSlots = 0;

	/* inline markAndShouldScan: */
	if (objOop & (tagMask(self))) {
		return;
	}
	assert(!(isForwarded(objOop, self)));
	if (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0) {
		return;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop, self)));
	longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift(self))));
	format1 = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	if ((format1 >= (sixtyFourBitIndexableFormat(self)))
	 && (format1 < (firstCompiledMethodFormat(self)))) {

		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		/* avoid pushing non-pointer objects on the markStack. */
		if (((longAt(objOop)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
			markAndTraceClassOf(objOop, self);
		}
		return;
	}
	if (format1 == (weakArrayFormat(self))) {

		/* push weaklings on the weakling stack to scan later */
		/* begin push:onObjStack: */
		objStack = GIV(weaklingStack);
		assert(addressCouldBeOop(objOop, self));
		if (objOop & (tagMask(self))) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack, self))
				? fetchPointerofObject(ObjStackNextx, objStack, self)
				: objStack), self), self));
		}
		else {

			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(objOop, self))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(objOop, self)));
		}
		noCheckPushonObjStack(objOop, objStack, self);
		return;
	}
	if ((format1 == 5 /* ephemeronFormat */)
	 && (activeAndDeferredScan(objOop, self))) {
		return;
	}
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan = objOop;
	do {
		if (objToScan & (tagMask(self))) {
			scanLargeObject = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt = (((usqInt) (longAt(objToScan))) >> (formatShift(self))) & (formatMask(self));
			assert((fmt != (ephemeronFormat(self)))
			 || (isMarked(keyOfEphemeron(objToScan, self), self)));
			if (fmt <= 5 /* lastPointerFormat */) {
				/* begin numSlotsOf: */
				assert((classIndexOf(objToScan, self)) > (isForwardedObjectClassIndexPun(self)));
				numSlots1 = byteAt(objToScan + 7);
				numSlots = (numSlots1 == (numSlotsMask(self))
					? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objToScan - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1);
				if (fmt <= 2 /* arrayFormat */) {
					numStrongSlots = numSlots;
					goto l15;
				}
				if (fmt == (indexablePointersFormat(self))) {
					if (((longAt(objToScan)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan, self);
						/* begin fetchStackPointerOf: */
						sp = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
						if (!((((sp) & 7) == 1))) {
							contextSize = 0;
							goto l13;
						}
						assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan, self)));
						contextSize = (sp >> 3);
	l13:	/* end fetchStackPointerOf: */;
						numStrongSlots = CtxtTempFrameStart + contextSize;
						goto l15;
					}
					numStrongSlots = numSlots;
					goto l15;
				}
				if (fmt == (weakArrayFormat(self))) {
					/* begin fixedFieldsOfClass: */
					objOop11 = fetchClassOfNonImm(objToScan, self);
					/* begin fixedFieldsOfClassFormat: */
					classFormat = ((longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
					numStrongSlots = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
					goto l15;
				}
			}
			if (fmt == 7 /* forwardedFormat */) {
				numStrongSlots = 1;
				goto l15;
			}
			if (fmt < (firstCompiledMethodFormat(self))) {
				numStrongSlots = 0;
				goto l15;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan, self));
			/* begin fetchPointer:ofObject: */
			header = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots = numLiterals + LiteralStart;
	l15:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject = numStrongSlots > 64 /* traceImmediatelySlotLimit */;
		}
		if (scanLargeObject) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if (objToScan & (tagMask(self))) {
				index = (objToScan >> 3);
				objToScan = topOfObjStack(GIV(markStack), self);
			}
			else {
				index = numStrongSlots;
				markAndTraceClassOf(objToScan, self);
			}
			while (index > 0) {
				index -= 1;
				/* begin fetchPointer:ofObject: */
				field = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
				if ((field & (tagMask(self))) == 0) {
					if (((longAt(field)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field, self);
					}
					if (field & (tagMask(self))) {
						goto l3;
					}
					assert(!(isForwarded(field, self)));
					if (((((usqInt) (longAt(field))) >> (markedBitFullShift(self))) & 1) != 0) {
						goto l3;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field, self)));
					longAtput(field, (longAt(field)) | (1ULL << (markedBitFullShift(self))));
					format11 = (((usqInt) (longAt(field))) >> (formatShift(self))) & (formatMask(self));
					if ((format11 >= (sixtyFourBitIndexableFormat(self)))
					 && (format11 < (firstCompiledMethodFormat(self)))) {

						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						/* avoid pushing non-pointer objects on the markStack. */
						if (((longAt(field)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
							markAndTraceClassOf(field, self);
						}
						goto l3;
					}
					if (format11 == (weakArrayFormat(self))) {

						/* push weaklings on the weakling stack to scan later */
						/* begin push:onObjStack: */
						objStack6 = GIV(weaklingStack);
						assert(addressCouldBeOop(field, self));
						if (field & (tagMask(self))) {
							assert(objStack6 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack6, self))
								? fetchPointerofObject(ObjStackNextx, objStack6, self)
								: objStack6), self), self));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack6 == GIV(markStack))
							 && (isWeakNonImm(field, self))));
							assert((objStack6 != GIV(weaklingStack))
							 || (isWeakNonImm(field, self)));
						}
						noCheckPushonObjStack(field, objStack6, self);
						goto l3;
					}
					if ((format11 == 5 /* ephemeronFormat */)
					 && (activeAndDeferredScan(field, self))) {
						goto l3;
					}
					if (index > 0) {
						if ((topOfObjStack(GIV(markStack), self)) != objToScan) {
							/* begin push:onObjStack: */
							objStack1 = GIV(markStack);
							assert(addressCouldBeOop(objToScan, self));
							if (objToScan & (tagMask(self))) {
								assert(objStack1 == GIV(markStack));
								assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1, self))
									? fetchPointerofObject(ObjStackNextx, objStack1, self)
									: objStack1), self), self));
							}
							else {

								/* There should be no weaklings on the mark stack. */
								assert(!((objStack1 == GIV(markStack))
								 && (isWeakNonImm(objToScan, self))));
								assert((objStack1 != GIV(weaklingStack))
								 || (isWeakNonImm(objToScan, self)));
							}
							noCheckPushonObjStack(objToScan, objStack1, self);
						}
						/* begin push:onObjStack: */
						objOop1 = (((usqInt)index << 3) | 1);
						objStack2 = GIV(markStack);
						assert(addressCouldBeOop(objOop1, self));
						if (objOop1 & (tagMask(self))) {
							assert(objStack2 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack2, self))
								? fetchPointerofObject(ObjStackNextx, objStack2, self)
								: objStack2), self), self));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack2 == GIV(markStack))
							 && (isWeakNonImm(objOop1, self))));
							assert((objStack2 != GIV(weaklingStack))
							 || (isWeakNonImm(objOop1, self)));
						}
						noCheckPushonObjStack(objOop1, objStack2, self);
					}
					objToScan = field;
					index = -1;
	l3:	;
				}
			}
			if (index >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan = popObjStack(GIV(markStack), self);
				if (objToScan == objOop) {
					objToScan = popObjStack(GIV(markStack), self);
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index = numStrongSlots;
			markAndTraceClassOf(objToScan, self);
			while (index > 0) {
				index -= 1;
				/* begin fetchPointer:ofObject: */
				field = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
				if ((field & (tagMask(self))) == 0) {
					if (((longAt(field)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field, self);
					}
					if (field & (tagMask(self))) {
						goto l4;
					}
					assert(!(isForwarded(field, self)));
					if (((((usqInt) (longAt(field))) >> (markedBitFullShift(self))) & 1) != 0) {
						goto l4;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field, self)));
					longAtput(field, (longAt(field)) | (1ULL << (markedBitFullShift(self))));
					format11 = (((usqInt) (longAt(field))) >> (formatShift(self))) & (formatMask(self));
					if ((format11 >= (sixtyFourBitIndexableFormat(self)))
					 && (format11 < (firstCompiledMethodFormat(self)))) {

						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						/* avoid pushing non-pointer objects on the markStack. */
						if (((longAt(field)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
							markAndTraceClassOf(field, self);
						}
						goto l4;
					}
					if (format11 == (weakArrayFormat(self))) {

						/* push weaklings on the weakling stack to scan later */
						/* begin push:onObjStack: */
						objStack3 = GIV(weaklingStack);
						assert(addressCouldBeOop(field, self));
						if (field & (tagMask(self))) {
							assert(objStack3 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack3, self))
								? fetchPointerofObject(ObjStackNextx, objStack3, self)
								: objStack3), self), self));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack3 == GIV(markStack))
							 && (isWeakNonImm(field, self))));
							assert((objStack3 != GIV(weaklingStack))
							 || (isWeakNonImm(field, self)));
						}
						noCheckPushonObjStack(field, objStack3, self);
						goto l4;
					}
					if ((format11 == 5 /* ephemeronFormat */)
					 && (activeAndDeferredScan(field, self))) {
						goto l4;
					}
					/* begin push:onObjStack: */
					objStack5 = GIV(markStack);
					assert(addressCouldBeOop(field, self));
					if (field & (tagMask(self))) {
						assert(objStack5 == GIV(markStack));
						assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack5, self))
							? fetchPointerofObject(ObjStackNextx, objStack5, self)
							: objStack5), self), self));
					}
					else {

						/* There should be no weaklings on the mark stack. */
						assert(!((objStack5 == GIV(markStack))
						 && (isWeakNonImm(field, self))));
						assert((objStack5 != GIV(weaklingStack))
						 || (isWeakNonImm(field, self)));
					}
					noCheckPushonObjStack(field, objStack5, self);
					if (((byteAt(field + 7)) > 64 /* traceImmediatelySlotLimit */)
					 && (((numStrongSlots = numStrongSlotsOfInephemeral(field, self))) > 64 /* traceImmediatelySlotLimit */)) {
						/* begin push:onObjStack: */
						objOop2 = (((usqInt)numStrongSlots << 3) | 1);
						objStack4 = GIV(markStack);
						assert(addressCouldBeOop(objOop2, self));
						if (objOop2 & (tagMask(self))) {
							assert(objStack4 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack4, self))
								? fetchPointerofObject(ObjStackNextx, objStack4, self)
								: objStack4), self), self));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack4 == GIV(markStack))
							 && (isWeakNonImm(objOop2, self))));
							assert((objStack4 != GIV(weaklingStack))
							 || (isWeakNonImm(objOop2, self)));
						}
						noCheckPushonObjStack(objOop2, objStack4, self);
					}
	l4:	;
				}
			}
			objToScan = popObjStack(GIV(markStack), self);
		}
	} while(objToScan != null);
}


/*	Go through the unscanned ephemerons, marking the inactive ones, and
	removing them from the unscanned ephemerons. Answer if any inactive
	ones were found. We cannot fire the ephemerons until all are found to
	be active since scan-marking an inactive ephemeron later in the set may
	render a previously-observed active ephemeron as inactive. */

	/* SpurMemoryManager>>#markInactiveEphemerons */
static sqInt
markInactiveEphemerons(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt foundInactive;
    sqInt key;
    sqInt objOop;
    sqInt oop;
    usqInt ptr;

	foundInactive = 0;
	ptr = (GIV(unscannedEphemerons).start);
	while (ptr < ((GIV(unscannedEphemerons).top))) {
		/* begin followedKeyOfEphemeron: */
		objOop = (ephemeron = longAt(ptr));
		assert((isNonImmediate(objOop, self))
		 && (isEphemeron(objOop, self)));
		/* begin followOopField:ofObject: */
		oop = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
		if (((oop & (tagMask(self))) == 0)
		 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			oop = fixFollowedFieldofObjectwithInitialValue(0, objOop, oop, self);
		}
		key = oop;
		if ((key & (tagMask(self)))
		 || (((((usqInt) (longAt(key))) >> (markedBitFullShift(self))) & 1) != 0)) {

			/* Now remove the inactive ephemeron from the set, and scan-mark it.
			   Scan-marking it may add more ephemerons to the set. */
			foundInactive = 1;
			(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) - BytesPerOop);
			if (((GIV(unscannedEphemerons).top)) > ptr) {
				longAtput(ptr, longAt((GIV(unscannedEphemerons).top)));
			}
			markAndTrace(ephemeron, self);
		}
		else {
			ptr += BytesPerOop;
		}
	}
	return foundInactive;
}


/*	for profiling */
/*	Mark all accessible objects.
	objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged is true if all
	objects are unmarked and/or if unmarked classes shoud be removed from the
	class table. */
/*	If the incremental collector is running mark bits may be set; stop it and
	clear them if necessary.
 */

	/* SpurMemoryManager>>#markObjects: */
static void NoDbgRegParms NeverInline
markObjects(sqInt objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classOrNil;
    sqInt classTablePage;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt j;
    sqInt largestFree;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    usqInt oop1;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;
    sqInt referent4;
    sqInt sizeOfUnusedEden;
    StackPage *thePage;

	runLeakCheckerFor(GCModeFull, self);
	/* begin shutDownIncrementalGC: */
	if (objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged) {
		assert(allObjectsUnmarked(self));
	}
	/* begin initializeUnscannedEphemerons */
	largestFree = findLargestFreeChunk(self);
	sizeOfUnusedEden = (((eden(self)).limit)) - GIV(freeStart);
	if ((largestFree != null)
	 && ((numSlotsOfAny(largestFree, self)) > (sizeOfUnusedEden / BytesPerWord))) {
		(GIV(unscannedEphemerons).start = (largestFree + BaseHeaderSize) + ((4 /* freeChunkLargerIndex */ + 1) * BytesPerWord));
		(GIV(unscannedEphemerons).limit = addressAfter(largestFree, self));
	}
	else {
		(GIV(unscannedEphemerons).start = GIV(freeStart));
		(GIV(unscannedEphemerons).limit = ((eden(self)).limit));
	}
	(GIV(unscannedEphemerons).top = (GIV(unscannedEphemerons).start));
	/* begin initializeMarkStack */
	ensureRoomOnObjStackAt(MarkStackRootIndex, self);
	/* begin initializeWeaklingStack */
	ensureRoomOnObjStackAt(WeaklingStackRootIndex, self);
	GIV(marking) = 1;
	/* begin markAccessibleObjectsAndFireEphemerons */
	assert(GIV(marking));
	assert(validClassTableRootPages(self));
	assert(allBridgesMarked(self));
	/* begin initStackPageGC */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
	}
	for (i1 = 0; i1 < GIV(numStackPages); i1 += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i1, GIV(pages), self);
		(thePage->trace = StackPageUnreached);
	}
	/* begin markAndTraceHiddenRoots */
	markAndTraceObjStackandContents(GIV(markStack), 0, self);
	markAndTraceObjStackandContents(GIV(weaklingStack), 0, self);
	markAndTraceObjStackandContents(GIV(mournQueue), 1, self);
	/* begin setIsMarkedOf:to: */
	objOop1 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
	assert(!(isFreeObject(objOop1, self)));
	longAtput(objOop1, (longAt(objOop1)) | (1ULL << (markedBitFullShift(self))));
	/* begin setIsMarkedOf:to: */
	assert((firstIndexableField(oldSpaceObjectAfter(GIV(trueObj), self), self)) == GIV(freeLists));
	objOop2 = oldSpaceObjectAfter(GIV(trueObj), self);
	assert(!(isFreeObject(objOop2, self)));
	longAtput(objOop2, (longAt(objOop2)) | (1ULL << (markedBitFullShift(self))));
	if (isWeakFormat((((usqInt) (longAt(GIV(classTableFirstPage)))) >> (formatShift(self))) & (formatMask(self)), self)) {
		markAndTrace(GIV(hiddenRootsObj), self);
		goto l2;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(GIV(hiddenRootsObj), self)));
	longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1ULL << (markedBitFullShift(self))));
	markAndTrace(GIV(classTableFirstPage), self);
	for (i2 = 1; i2 < GIV(numClassTablePages); i2 += 1) {
		/* begin setIsMarkedOf:to: */
		objOop = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord(self))))));
		assert(!(isFreeObject(objOop, self)));
		longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift(self))));
	}
	l2:	/* end markAndTraceHiddenRoots */;
	/* begin markAndTraceExtraRoots */
	assert(GIV(remapBufferCount) == 0);
	for (i4 = 1; i4 <= GIV(extraRootCount); i4 += 1) {
		oop = (GIV(extraRoots)[i4])[0];
		if (!((oop & (tagMask(self)))
			 || (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))))) {
			markAndTrace(oop, self);
		}
	}
	assert(validClassTableRootPages(self));
	/* begin markAndTraceInterpreterOops: */
	markAndTraceStackPages(1, self);
	markAndTrace(GIV(specialObjectsOop), self);
	if (!(GIV(newMethod) & (tagMask(self)))) {
		markAndTrace(GIV(newMethod), self);
	}
	/* begin traceProfileState */
	/* begin followForwardingPointersInProfileState */
	if (((longAt(GIV(profileProcess))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileProcess), self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((GIV(profileProcess) + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		GIV(profileProcess) = referent;
	}
	if (((longAt(GIV(profileMethod))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileMethod), self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent1 = longAt((GIV(profileMethod) + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent1 & (tagMask(self))) == 0)
		 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		GIV(profileMethod) = referent1;
	}
	if (((longAt(GIV(profileProcess))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileSemaphore), self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent2 = longAt((GIV(profileSemaphore) + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent2 & (tagMask(self))) == 0)
		 && (((longAt(referent2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		GIV(profileSemaphore) = referent2;
	}
	markAndTrace(GIV(profileProcess), self);
	markAndTrace(GIV(profileMethod), self);
	markAndTrace(GIV(profileSemaphore), self);
	sqLowLevelMFence(self);
	if ((GIV(longRunningPrimitiveCheckMethod) != null)
	 && (GIV(longRunningPrimitiveCheckSequenceNumber) != GIV(statCheckForEvents))) {
		if (((longAt(GIV(longRunningPrimitiveCheckMethod))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(longRunningPrimitiveCheckMethod), self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent3 = longAt((GIV(longRunningPrimitiveCheckMethod) + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent3 & (tagMask(self))) == 0)
			 && (((longAt(referent3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			GIV(longRunningPrimitiveCheckMethod) = referent3;
		}
		markAndTrace(GIV(longRunningPrimitiveCheckMethod), self);
	}
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		if (((longAt(GIV(longRunningPrimitiveCheckSemaphore))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(longRunningPrimitiveCheckSemaphore), self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent4 = longAt((GIV(longRunningPrimitiveCheckSemaphore) + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent4 & (tagMask(self))) == 0)
			 && (((longAt(referent4)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent4 = longAt((referent4 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			GIV(longRunningPrimitiveCheckSemaphore) = referent4;
		}
		markAndTrace(GIV(longRunningPrimitiveCheckSemaphore), self);
	}
	if (!(GIV(tempOop) == 0)) {
		markAndTrace(GIV(tempOop), self);
	}
	if (!(GIV(tempOop2) == 0)) {
		markAndTrace(GIV(tempOop2), self);
	}
	for (i3 = 1, iLimiT1 = (remapBufferCount(self)); i3 <= iLimiT1; i3 += 1) {
		oop1 = GIV(remapBuffer)[i3];
		if (!(oop1 & (tagMask(self)))) {
			markAndTrace(oop1, self);
		}
	}
	for (i3 = 1; i3 <= GIV(jmpDepth); i3 += 1) {
		oop1 = GIV(suspendedCallbacks)[i3];
		if (!(oop1 & (tagMask(self)))) {
			markAndTrace(oop1, self);
		}
		oop1 = GIV(suspendedMethods)[i3];
		if (!(oop1 & (tagMask(self)))) {
			markAndTrace(oop1, self);
		}
	}
	assert(validObjStacks(self));
	markWeaklingsAndMarkAndFireEphemerons(self);
	assert(validObjStacks(self));
	/* begin expungeDuplicateAndUnmarkedClasses: */
	for (i = 1; i < GIV(numClassTablePages); i += 1) {

		/* Avoid expunging the puns by not scanning the 0th page. */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		for (j = 0, iLimiT = ((1U << (classTableMajorIndexShift(self))) - 1); j <= iLimiT; j += 1) {
			classOrNil = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))));
			classIndex = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift(self))))) + j;
			assert((classOrNil == GIV(nilObj))
			 || (addressCouldBeClassObj(classOrNil, self)));
			if (classOrNil == GIV(nilObj)) {
				if (classIndex < GIV(classTableIndex)) {
					GIV(classTableIndex) = classIndex;
				}
			}
			else {
				if ((objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged
				 && (!(((((usqInt) (longAt(classOrNil))) >> (markedBitFullShift(self))) & 1) != 0)))
				 || (((long32At(classOrNil + 4)) & (identityHashHalfWordMask(self))) != classIndex)) {
					assert(!(isOopForwarded(classTablePage, self)));
					longAtput((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))), GIV(nilObj));
					assert((objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged
					 && (!(isMarked(classOrNil, self))))
					 || ((classAtIndex(rawHashBitsOf(classOrNil, self), self)) == classOrNil));
					if (classIndex < GIV(classTableIndex)) {
						GIV(classTableIndex) = classIndex;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift(self))));
	nilUnmarkedWeaklingSlots(self);
	GIV(marking) = 0;
}


/*	After the initial scan-mark is complete ephemerons can be processed.
	Weaklings have accumulated on the weaklingStack, but more may be
	uncovered during ephemeron processing. So trace the strong slots
	of the weaklings, and as ephemerons are processed ensure any newly
	reached weaklings are also traced. */

	/* SpurMemoryManager>>#markWeaklingsAndMarkAndFireEphemerons */
static void
markWeaklingsAndMarkAndFireEphemerons(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt ephemeron;
    sqInt field;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt key;
    sqInt lastptr;
    sqInt numOnThisPage;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt numTracedWeaklings;
    sqInt objOop;
    sqInt objStackPage;
    sqInt oop;
    sqInt oop1;
    sqInt p;
    sqInt size;
    sqInt topIndex;
    sqInt weakling;

	numTracedWeaklings = 0;
	while(1) {
		markAndTraceUntracedReachableStackPages(self);
		do {
			/* begin objStack:from:do: */
			eassert(isValidObjStack(GIV(weaklingStack), self));
			/* begin fetchPointer:ofObject: */
			size = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
			/* begin fetchPointer:ofObject: */
			objStackPage = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
			while (objStackPage != 0) {
				size += ObjStackLimit;
				assert((fetchPointerofObject(ObjStackTopx, objStackPage, self)) == ObjStackLimit);
				/* begin fetchPointer:ofObject: */
				objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
			}
			numToEnumerate = size - numTracedWeaklings;
			objStackPage = GIV(weaklingStack);
			while (numToEnumerate > 0) {
				/* begin fetchPointer:ofObject: */
				numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
				numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
				topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
				for (i1 = topIndex; i1 >= ((topIndex - numToEnumerateOnThisPage) + 1); i1 += -1) {
					assert(isWeak(fetchPointerofObject(i1, objStackPage, self), self));
					weakling = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
					assert(!((isForwarded(weakling, self))));
					markAndTraceClassOf(weakling, self);
					for (i = 0, iLimiT = (((assert((formatOf(weakling, self)) == (weakArrayFormat(self))),
/* begin fixedFieldsOfClass: */
(objOop = fetchClassOfNonImm(weakling, self)),
/* begin fixedFieldsOfClassFormat: */
(classFormat = ((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)),
classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1))) - 1); i <= iLimiT; i += 1) {
						/* begin followOopField:ofObject: */
						oop = longAt((weakling + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
						if (((oop & (tagMask(self))) == 0)
						 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
							oop = fixFollowedFieldofObjectwithInitialValue(i, weakling, oop, self);
						}
						field = oop;
						if (!((field & (tagMask(self)))
							 || (((((usqInt) (longAt(field))) >> (markedBitFullShift(self))) & 1) != 0))) {
							markAndTrace(field, self);
						}
					}
				}
				numToEnumerate -= numToEnumerateOnThisPage;
				/* begin fetchPointer:ofObject: */
				objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
			}
			numTracedWeaklings = size;
		} while((sizeOfObjStack(GIV(weaklingStack), self)) > numTracedWeaklings);
		if (((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start))) {
			markAndTraceUntracedReachableStackPages(self);
			freeUntracedStackPages(self);
			return;
		}
		if (!(markInactiveEphemerons(self))) {
			/* begin fireAllUnscannedEphemerons */
			assert(!(noUnscannedEphemerons(self)));
			assert(allUnscannedEphemeronsAreActive(self));
			for (p = ((GIV(unscannedEphemerons).start)); p <= (((GIV(unscannedEphemerons).top)) - BytesPerOop); p += BytesPerOop) {
				/* begin fireEphemeron: */
				queueMourner(longAt(p), self);
				/* begin setFormatOf:to: */
				assert(((1 /* nonIndexablePointerFormat */ >= 0) && (1 /* nonIndexablePointerFormat */ <= (formatMask(self)))));
				longAtput(longAt(p), ((longAt(longAt(p))) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))))) + (1U << (formatShift(self))));
				/* begin signalFinalization: */
				forceInterruptCheck(self);
				GIV(pendingFinalizationSignals) += 1;
			}
		}
		/* begin markAllUnscannedEphemerons */
		assert(!(noUnscannedEphemerons(self)));
		assert(allUnscannedEphemeronsAreActive(self));
		while (((GIV(unscannedEphemerons).top)) > ((GIV(unscannedEphemerons).start))) {
			ephemeron = longAt((GIV(unscannedEphemerons).start));
			lastptr = ((GIV(unscannedEphemerons).top)) - BytesPerOop;
			if (lastptr > ((GIV(unscannedEphemerons).start))) {
				longAtput((GIV(unscannedEphemerons).start), longAt(lastptr));
			}
			(GIV(unscannedEphemerons).top = lastptr);
			assert((isNonImmediate(ephemeron, self))
			 && (isMaybeFiredEphemeron(ephemeron, self)));
			/* begin followOopField:ofObject: */
			oop1 = longAt((ephemeron + BaseHeaderSize) + (0U << (shiftForWord(self))));
			if (((oop1 & (tagMask(self))) == 0)
			 && (((longAt(oop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				oop1 = fixFollowedFieldofObjectwithInitialValue(0, ephemeron, oop1, self);
			}
			key = oop1;
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(ephemeron, self)));
			longAtput(ephemeron, (longAt(ephemeron)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			markAndTrace(key, self);
			markAndTrace(ephemeron, self);
		}
	}
}


/*	Answers if the code is installed in a class instantiating objects with the
	format. Used in primitive 
	generation to make a quick path based on where the method is installed.
	This method cannot
	be used as a guarantee as there can be false positive, it's just a
	heuristic. Tries to interpret the last literal of the method as a behavior
	(more than 3 fields, 3rd field a Smi).
	If it can be interpreted as a behavior, answers if instSpec matches the
	format, else answers false. */

	/* SpurMemoryManager>>#maybeMethodClassOf:seemsToBeInstantiating: */
sqInt
maybeMethodClassOfseemsToBeInstantiating(sqInt methodObj, sqInt format, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instSpec;
    sqInt literal;
    sqInt maybeClassObj;
    sqInt maybeFormat;
    sqInt objOop;
    sqInt objOop1;
    sqInt offset;

	/* begin methodClassOf: */
	offset = ((assert((((((assert(isCompiledMethod(methodObj, self)),
/* begin fetchPointer:ofObject: */
longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(methodObj, self)),
/* begin fetchPointer:ofObject: */
longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
	/* begin followField:ofObject: */
	objOop1 = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
	if (((objOop1 & (tagMask(self))) == 0)
	 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, methodObj, objOop1, self);
	}
	literal = objOop1;
	if ((literal != GIV(nilObj))
	 && (((literal & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(literal))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))) {
		assert((numSlotsOf(literal, self)) > ValueIndex);
		/* begin followField:ofObject: */
		objOop = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
		if (((objOop & (tagMask(self))) == 0)
		 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop, self);
		}
		maybeClassObj = objOop;
	}
	else {
		/* begin nilObject */
		maybeClassObj = GIV(nilObj);
	}
	if (!(((((usqInt) (longAt(maybeClassObj))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)) {
		return 0;
	}
	if (!((numSlotsOfAny(maybeClassObj, self)) > InstanceSpecificationIndex)) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	maybeFormat = longAt((maybeClassObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))));
	if (!((((maybeFormat) & 7) == 1))) {
		return 0;
	}
	/* begin instSpecOfClassFormat: */
	instSpec = (((usqInt) ((maybeFormat >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	return instSpec == format;
}


/*	Answer one of the objects in the SpecialObjectsArray, if in range,
	otherwise answer nil.
 */

	/* SpurMemoryManager>>#maybeSplObj: */
sqInt
maybeSplObj(sqInt index, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (index < (numSlotsOf(GIV(specialObjectsOop), self))
		? (/* begin fetchPointer:ofObject: */
			longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self)))))))
		: 0);
}

	/* SpurMemoryManager>>#memoryActiveProcess */
static sqInt
memoryActiveProcess(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt objOop1;

	/* begin fetchPointer:ofObject: */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
}


/*	Answer the method header of a CompiledMethod object. */

	/* SpurMemoryManager>>#methodHeaderOf: */
static sqInt NoDbgRegParms
methodHeaderOf(sqInt methodObj, struct foo * self)
{
	assert(isCompiledMethod(methodObj, self));
	/* begin fetchPointer:ofObject: */
	return longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
}


/*	Answer the minimum number of additional slots to allocate in an object to
	always be able to shorten it.
	This is enough slots to allocate a minimum-sized object. */

	/* SpurMemoryManager>>#minSlotsForShortening */
sqInt
minSlotsForShortening(struct foo * self)
{
	return (8 /* allocationUnit */ * 2) / BytesPerOop;
}


/*	Use a slight variation on D.H. Lehmer's linear congruential generator from
	1951. See e.g. http://en.wikipedia.org/wiki/Linear_congruential_generator. */

	/* SpurMemoryManager>>#newObjectHash */
static sqInt
newObjectHash(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;

	do {
		GIV(lastHash) = GIV(lastHash) * 16807;

		/* adding the top bits gives much better spread.  See below: */
		hash = GIV(lastHash) + (((usqInt) GIV(lastHash)) >> 4);
	} while((hash & (identityHashHalfWordMask(self))) == 0);
	return hash;
}

	/* SpurMemoryManager>>#newSpaceIsEmpty */
static sqInt
newSpaceIsEmpty(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(freeStart) == (((eden(self)).start)))
	 && (GIV(pastSpaceStart) == (((pastSpace(self)).start)));
}

	/* SpurMemoryManager>>#nilObject */
sqInt
nilObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	Nil the unmarked slots in the weaklings on the
	weakling stack, finalizing those that lost references.
	Finally, empty the weaklingStack. */
/*	for profiling */

	/* SpurMemoryManager>>#nilUnmarkedWeaklingSlots */
static void NeverInline
nilUnmarkedWeaklingSlots(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anyUnmarked;
    sqInt anyUnmarked1;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt numOnThisPage;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt objStackPage;
    sqInt referent;
    sqInt size;
    sqInt topIndex;
    sqInt weakling;

	eassert(allOldMarkedWeakObjectsOnWeaklingStack(self));
	if (GIV(weaklingStack) == GIV(nilObj)) {
		return;
	}
	/* begin objStack:from:do: */
	eassert(isValidObjStack(GIV(weaklingStack), self));
	/* begin fetchPointer:ofObject: */
	size = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	objStackPage = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	while (objStackPage != 0) {
		size += ObjStackLimit;
		assert((fetchPointerofObject(ObjStackTopx, objStackPage, self)) == ObjStackLimit);
		/* begin fetchPointer:ofObject: */
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	}
	numToEnumerate = size;
	objStackPage = GIV(weaklingStack);
	while (numToEnumerate > 0) {
		/* begin fetchPointer:ofObject: */
		numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
		numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
		topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
		for (i = topIndex; i >= ((topIndex - numToEnumerateOnThisPage) + 1); i += -1) {
			assert(isWeak(fetchPointerofObject(i, objStackPage, self), self));
			weakling = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			/* begin nilUnmarkedWeaklingSlotsIn: */
			anyUnmarked1 = 0;
			assert(allStrongSlotsOfWeaklingAreMarked(weakling, self));
			for (i1 = ((assert((formatOf(weakling, self)) == (weakArrayFormat(self))),
fixedFieldsOfClass(fetchClassOfNonImm(weakling, self), self))), iLimiT = ((numSlotsOf(weakling, self)) - 1); i1 <= iLimiT; i1 += 1) {
				/* begin fetchPointer:ofObject: */
				referent = longAt((weakling + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
				if ((referent & (tagMask(self))) == 0) {
					if (((longAt(referent)) & (classIndexMask(self))) == (isForwardedObjectClassIndexPun(self))) {
						referent = fixFollowedFieldofObjectwithInitialValue(i1, weakling, referent, self);
					}
					if (!((referent & (tagMask(self)))
						 || (((((usqInt) (longAt(referent))) >> (markedBitFullShift(self))) & 1) != 0))) {
						assert(!(isOopForwarded(weakling, self)));
						longAtput((weakling + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), GIV(nilObj));
						anyUnmarked1 = 1;
					}
				}
			}
			anyUnmarked = anyUnmarked1;
			if (anyUnmarked) {

				/* fireFinalization: could grow the mournQueue and if so,
				   additional pages must be marked to avoid being GC'ed. */
				assert(GIV(marking));
				/* begin fireFinalization: */
				if (GIV(newFinalization)) {
					queueMourner(weakling, self);
				}
				/* begin signalFinalization: */
				forceInterruptCheck(self);
				GIV(pendingFinalizationSignals) += 1;
			}
		}
		numToEnumerate -= numToEnumerateOnThisPage;
		/* begin fetchPointer:ofObject: */
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	}
	emptyObjStack(GIV(weaklingStack), self);
}

	/* SpurMemoryManager>>#noCheckClassAtIndex: */
static sqInt NoDbgRegParms
noCheckClassAtIndex(sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift(self));
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift(self))) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
}


/*	Push an element on an objStack. Split from push:onObjStack: for testing. */

	/* SpurMemoryManager>>#noCheckPush:onObjStack: */
static sqInt NoDbgRegParms
noCheckPushonObjStack(sqInt objOop, sqInt objStack, struct foo * self)
{
    sqInt topx;

	eassert(isValidObjStack(objStack, self));
	/* begin fetchPointer:ofObject: */
	topx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
	if (topx >= ObjStackLimit) {
		noCheckPushonObjStack(objOop, ensureRoomOnObjStackAt(longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord(self)))))), self), self);
	}
	else {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack, self)) == (wordIndexableFormat(self)));
		longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)((ObjStackFixedSlots + topx)) << (shiftForWord(self))))), objOop);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack, self)) == (wordIndexableFormat(self)));
		longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))), topx + 1);
	}
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#noFixupFollowField:ofObject: */
static sqInt NoDbgRegParms
noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject, struct foo * self)
{
    sqInt objOop;
    sqInt referent;

	/* begin fetchPointer:ofObject: */
	objOop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(objOop, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		objOop = referent;
	}
	return objOop;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated numSlots. If the word
	following an object doesn't have a saturated numSlots field it must be a
	single-header object.
	If the word following does have a saturated numSlots it must be the
	overflow size word. */

	/* SpurMemoryManager>>#noInlineObjectAfter:limit: */
static sqInt NoDbgRegParms
noInlineObjectAfterlimit(sqInt objOop, sqInt limit, struct foo * self)
{
    sqInt followingWord;
    usqInt followingWordAddress;

	/* begin objectAfter:limit: */
	followingWordAddress = addressAfter(objOop, self);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
		return limit;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
		? followingWordAddress + BaseHeaderSize
		: followingWordAddress);
}

	/* SpurMemoryManager>>#nonIndexablePointerFormat */
sqInt
nonIndexablePointerFormat(struct foo * self)
{
	return 1;
}

	/* SpurMemoryManager>>#noUnscannedEphemerons */
static sqInt
noUnscannedEphemerons(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start));
}


/*	Answer the number of indexable bytes in the given non-immediate
	byte-indexable object.
 */

	/* SpurMemoryManager>>#numBytesOfBytes: */
static sqInt NoDbgRegParms
numBytesOfBytes(sqInt objOop, struct foo * self)
{
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	return ((numSlotsOf(objOop, self)) << (shiftForWord(self))) - (fmt & 7);
}


/*	Answer the number of indexable bytes in the given non-immediate object.
	Does not adjust the size of contexts by stackPointer. */

	/* SpurMemoryManager>>#numBytesOf: */
sqInt
numBytesOf(sqInt objOop, struct foo * self)
{
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOf: */
	assert((classIndexOf(objOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(objOop + 7);
	numBytes = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord(self));
	if (fmt >= (firstByteFormat(self))) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat(self))) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat(self))) {
		return numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
	}
	return numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
}


/*	Answer the number of pointer fields in the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numPointerSlotsOf: */
usqInt
numPointerSlotsOf(sqInt objOop, struct foo * self)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    usqInt numSlots;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	if (fmt <= 5 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat(self)))
		 && (((longAt(objOop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l3;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop, self)));
			contextSize = (sp >> 3);
	l3:	/* end fetchStackPointerOf: */;
			return CtxtTempFrameStart + contextSize;
		}
		/* begin numSlotsOf: */
		assert((classIndexOf(objOop, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(objOop + 7);
		return (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
	}
	if (fmt == 7 /* forwardedFormat */) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat(self))) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}


/*	A private internal version of numSlotsOf: that is happy to be applied to
	free or forwarded objects.
 */

	/* SpurMemoryManager>>#numSlotsOfAny: */
static usqInt NoDbgRegParms
numSlotsOfAny(sqInt objOop, struct foo * self)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
}

	/* SpurMemoryManager>>#numSlotsOf: */
usqInt
numSlotsOf(sqInt objOop, struct foo * self)
{
    usqInt numSlots;

	flag("endianness");
	assert((classIndexOf(objOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
}


/*	Answer the number of strong pointer fields in the given object,
	which is .expected not to be an active ephemeron.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numStrongSlotsOfInephemeral: */
static sqInt NoDbgRegParms
numStrongSlotsOfInephemeral(sqInt objOop, struct foo * self)
{
    sqInt classFormat;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	assert((fmt != (ephemeronFormat(self)))
	 || (isMarked(keyOfEphemeron(objOop, self), self)));
	if (fmt <= 5 /* lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(objOop, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(objOop + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 2 /* arrayFormat */) {
			return numSlots;
		}
		if (fmt == (indexablePointersFormat(self))) {
			if (((longAt(objOop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(objOop, self);
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l4;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop, self)));
				contextSize = (sp >> 3);
	l4:	/* end fetchStackPointerOf: */;
				return CtxtTempFrameStart + contextSize;
			}
			return numSlots;
		}
		if (fmt == (weakArrayFormat(self))) {
			/* begin fixedFieldsOfClass: */
			objOop1 = fetchClassOfNonImm(objOop, self);
			/* begin fixedFieldsOfClassFormat: */
			classFormat = ((longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
			return classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
		}
	}
	if (fmt == 7 /* forwardedFormat */) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat(self))) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}


/*	Answer the number of strong pointer fields in the given weakling. */

	/* SpurMemoryManager>>#numStrongSlotsOfWeakling: */
sqInt
numStrongSlotsOfWeakling(sqInt objOop, struct foo * self)
{
    sqInt classFormat;
    sqInt objOop1;

	assert((formatOf(objOop, self)) == (weakArrayFormat(self)));
	/* begin fixedFieldsOfClass: */
	objOop1 = fetchClassOfNonImm(objOop, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	return classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#objectAfter: */
sqInt
objectAfter(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt followingWordAddress3;
    sqInt limit;

	if (oopisLessThan(objOop, GIV(newSpaceLimit), self)) {
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((eden(self)).start), GIV(freeStart), self)) {
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart), self)) {
				return GIV(freeStart);
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			return ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
		}
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((pastSpace(self)).start), GIV(pastSpaceStart), self)) {
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart), self)) {
				return GIV(pastSpaceStart);
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			return ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		}
		/* begin objectAfter:limit: */
		limit = futureSurvivorStart(self);
		followingWordAddress2 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit, self)) {
			return limit;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		return ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	}
	/* begin objectAfter:limit: */
	followingWordAddress3 = addressAfter(objOop, self);
	if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory), self)) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord3 = longAt(followingWordAddress3);
	return ((((usqInt) followingWord3) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
		? followingWordAddress3 + BaseHeaderSize
		: followingWordAddress3);
}

	/* SpurMemoryManager>>#objectBefore: */
sqInt
objectBefore(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prev;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	prev = null;
	if (oopisLessThan(objOop, GIV(newSpaceLimit), self)) {
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((pastSpace(self)).start)) < (((eden(self)).start)));
		/* begin objectStartingAt: */
		address = ((pastSpace(self)).start);
		numSlots = byteAt(address + 7);
		objOop1 = (numSlots == (numSlotsMask(self))
			? address + BaseHeaderSize
			: address);
		limit = GIV(pastSpaceStart);
		while (oopisLessThan(objOop1, limit, self)) {
			if (oopisGreaterThanOrEqualTo(objOop1, objOop, self)) {
				return prev;
			}
			prev = objOop1;
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
				objOop1 = limit;
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address1 = ((eden(self)).start);
		numSlots1 = byteAt(address1 + 7);
		objOop1 = (numSlots1 == (numSlotsMask(self))
			? address1 + BaseHeaderSize
			: address1);
		while (oopisLessThan(objOop1, GIV(freeStart), self)) {
			if (oopisGreaterThanOrEqualTo(objOop1, objOop, self)) {
				return prev;
			}
			prev = objOop1;
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
				objOop1 = GIV(freeStart);
				goto l2;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
		}
		return prev;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop2 = GIV(nilObj);
	while (1) {
		assert((objOop2 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop2, GIV(endOfMemory), self))) break;
		assert((long64At(objOop2)) != 0);
		if (oopisGreaterThanOrEqualTo(objOop2, objOop, self)) {
			return prev;
		}
		prev = objOop2;
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop2;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop2, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop2 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop2 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For enumerating objects find the header of the first object in a space.
	If the object starts with an overflow size field it will start at the next
	allocationUnit. c.f. numSlotsOf: */

	/* SpurMemoryManager>>#objectStartingAt: */
static sqInt NoDbgRegParms
objectStartingAt(sqInt address, struct foo * self)
{
    usqInt numSlots;

	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Answer an Array of all the objects only reachable from the argument, an
	Array of root objects,
	starting with arrayOfRoots. If there is no space, answer a SmallInteger
	whose value is the
	number of slots required. This is used to collect the objects to include
	in an image segment
	on Spur, separate from creating the segment, hence simplifying the
	implementation. Thanks to Igor Stasenko for this idea. */

	/* SpurMemoryManager>>#objectsReachableFromRoots: */
static sqInt NoDbgRegParms NeverInline
objectsReachableFromRoots(sqInt arrayOfRoots, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt count;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt iLimiT2;
    usqInt limit;
    usqInt limit1;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt ptr;
    sqInt referent;
    usqInt start;

	assert(isArray(arrayOfRoots, self));
	assert(allObjectsUnmarked(self));
	/* begin markObjectsIn: */
	assert(!(isFreeObject(arrayOfRoots, self)));
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | (1ULL << (markedBitFullShift(self))));
	for (i1 = 0, iLimiT1 = ((numSlotsOf(arrayOfRoots, self)) - 1); i1 <= iLimiT1; i1 += 1) {
		/* begin followField:ofObject: */
		objOop1 = longAt((arrayOfRoots + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
		if (((objOop1 & (tagMask(self))) == 0)
		 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(i1, arrayOfRoots, objOop1, self);
		}
		oop1 = objOop1;
		if ((oop1 & (tagMask(self))) == 0) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop1, self)));
			longAtput(oop1, (longAt(oop1)) | (1ULL << (markedBitFullShift(self))));
		}
	}
	markObjects(0, self);
	assert(isEmptyObjStack(GIV(markStack), self));
	assert(isEmptyObjStack(GIV(weaklingStack), self));
	assert(noUnscannedEphemerons(self));
	/* begin unmarkObjectsIn: */
	for (i2 = 0, iLimiT2 = ((numSlotsOf(arrayOfRoots, self)) - 1); i2 <= iLimiT2; i2 += 1) {
		/* begin followField:ofObject: */
		objOop2 = longAt((arrayOfRoots + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord(self))))));
		if (((objOop2 & (tagMask(self))) == 0)
		 && (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop2 = fixFollowedFieldofObjectwithInitialValue(i2, arrayOfRoots, objOop2, self);
		}
		oop2 = objOop2;
		if ((oop2 & (tagMask(self))) == 0) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop2, self)));
			longAtput(oop2, (longAt(oop2)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
		}
	}

	/* N.B. Does /not/ update totalFreeOldSpace */
	freeChunk = allocateLargestFreeChunk(self);

	/* but must update so that growth in the markStack does not cause assert fails. */
	GIV(totalFreeOldSpace) -= bytesInObject(freeChunk, self);
	ptr = (start = freeChunk + BaseHeaderSize);
	limit = addressAfter(freeChunk, self);

	/* First put the arrayOfRoots; order is important. */
	count = 0;
	noCheckPushonObjStack(arrayOfRoots, GIV(markStack), self);
	while (!(isEmptyObjStack(GIV(markStack), self))) {
		objOop = popObjStack(GIV(markStack), self);
		assert(isMarked(objOop, self));
		count += 1;
		if (ptr < limit) {
			longAtput(ptr, objOop);
			ptr += BytesPerOop;
		}
		oop = fetchClassOfNonImm(objOop, self);
		if (!(((((usqInt) (longAt(oop))) >> (markedBitFullShift(self))) & 1) != 0)) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop, self)));
			longAtput(oop, (longAt(oop)) | (1ULL << (markedBitFullShift(self))));
			noCheckPushonObjStack(oop, GIV(markStack), self);
		}
		if ((((longAt(objOop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
		 && ((((((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(objOop, self))))) {
			for (i = 0, iLimiT = ((numSlotsOfMarriedContext(objOop, self)) - 1); i <= iLimiT; i += 1) {
				oop = fetchPointerofMarriedContext(i, objOop, self);
				if (!((oop & (tagMask(self)))
					 || (((((usqInt) (longAt(oop))) >> (markedBitFullShift(self))) & 1) != 0))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(oop, self)));
					longAtput(oop, (longAt(oop)) | (1ULL << (markedBitFullShift(self))));
					noCheckPushonObjStack(oop, GIV(markStack), self);
				}
			}
		}
		else {
			for (i = 0, iLimiT = ((numPointerSlotsOf(objOop, self)) - 1); i <= iLimiT; i += 1) {
				/* begin fetchPointer:ofObject: */
				oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
				if (!((oop & (tagMask(self)))
					 || (((((usqInt) (longAt(oop))) >> (markedBitFullShift(self))) & 1) != 0))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(oop, self)));
					longAtput(oop, (longAt(oop)) | (1ULL << (markedBitFullShift(self))));
					noCheckPushonObjStack(oop, GIV(markStack), self);
				}
			}
		}
	}
	/* begin unmarkAllObjects */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (((((usqInt) (longAt(objOop11))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((longAt(objOop11)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop11, self)));
				longAtput(objOop11, (longAt(objOop11)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			else {
				if (!(((longAt(objOop11)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop11, self)));
					longAtput(objOop11, (longAt(objOop11)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l11;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l11:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop3 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit1 = GIV(pastSpaceStart);
	while (oopisLessThan(objOop3, limit1, self)) {
		if (((((usqInt) (longAt(objOop3))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((longAt(objOop3)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop3, self)));
				longAtput(objOop3, (longAt(objOop3)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			else {
				if (!(((longAt(objOop3)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop3, self)));
					longAtput(objOop3, (longAt(objOop3)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop3;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop3, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit1, self)) {
			objOop3 = limit1;
			goto l13;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop3 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l13:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop3 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop3, GIV(freeStart), self)) {
		if (((((usqInt) (longAt(objOop3))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((longAt(objOop3)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop3, self)));
				longAtput(objOop3, (longAt(objOop3)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			else {
				if (!(((longAt(objOop3)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop3, self)));
					longAtput(objOop3, (longAt(objOop3)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop3;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop3, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop3 = GIV(freeStart);
			goto l10;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop3 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l10:	/* end objectAfter:limit: */;
	}
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8 /* allocationUnit */))) {

		/* can't split a single word */
		freeObject(freeChunk, self);
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeImageSegment)) == (GCModeFreeSpace | GCModeImageSegment))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
		}
		return (((usqInt)count << 3) | 1);
	}
	/* begin setFormatOf:to: */
	assert(((2 /* arrayFormat */ >= 0) && (2 /* arrayFormat */ <= (formatMask(self)))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))))) + (2U << (formatShift(self))));
	/* begin setClassIndexOf:to: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask(self)))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(classIndexMask(self)))) + ClassArrayCompactIndex);
	shortentoIndexableSize(freeChunk, count, self);
	if (((longAt(freeChunk)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(freeChunk, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		freeChunk = referent;
	}
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt) (longAt(freeChunk))) >> (rememberedBitShift(self))) & 1) != 0)) {
		remember(freeChunk, self);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeImageSegment)) == (GCModeFreeSpace | GCModeImageSegment))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	runLeakCheckerFor(GCModeImageSegment, self);
	return freeChunk;
}


/*	This message is deprecated but supported for a while via a tweak to
	sqVirtualMachine.[ch] Use fetchLong32, fetchLong64 or fetchPointer instead
	for new code
 */

	/* SpurMemoryManager>>#obsoleteDontUseThisFetchWord:ofObject: */
sqInt
obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop, struct foo * self)
{
	/* begin fetchLong32:ofObject: */
	return long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

	/* SpurMemoryManager>>#okayOop: */
static sqInt NoDbgRegParms
okayOop(sqInt signedOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqInt oop;
    usqLong unusedBits;
    int unusedBitsInYoungObjects;


	/* address and size checks */
	oop = ((usqInt) signedOop);
	if (oop & (tagMask(self))) {
		return 1;
	}
	if (!(addressCouldBeObj(oop, self))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop, self), GIV(endOfMemory), self))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & (classIndexMask(self)))) >= (firstClassIndexPun(self)))) {
		error("oop is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask(self)))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask(self)))) {
		error("oop header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	if ((fmt == 6) || (fmt == 8)) {
		error("oop has an unknown format type");
		return 0;
	}
	if ((fmt == 7 /* forwardedFormat */) != (classIndex == (isForwardedObjectClassIndexPun(self)))) {
		error("oop has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1U << 22 /* classIndexFieldWidth */) | (1ULL << (22 /* identityHashFieldWidth */ + 32));
	if (((long64At(oop)) & unusedBits) != 0) {
		error("some unused header bits are set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = ((1U << (greyBitShift(self))) | (1U << (pinnedBitShift(self)))) | (1U << (rememberedBitShift(self)));
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		error("some header bits unused in young objects are set; should be zero");
		return 0;
	}
	return 1;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#oldSpaceObjectAfter: */
sqInt
oldSpaceObjectAfter(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;

	/* begin objectAfter:limit: */
	followingWordAddress = addressAfter(objOop, self);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
		? followingWordAddress + BaseHeaderSize
		: followingWordAddress);
}


/*	in an effort to fix a compiler bug with two-way become post r3427 */
/*	Allocate two new objects, n1 & n2. Copy the contents appropriately.
	Convert obj1 and obj2 into forwarding objects pointing to n2 and n1
	respectively  */

	/* SpurMemoryManager>>#outOfPlaceBecome:and:copyHashFlag: */
static void NoDbgRegParms NeverInline
outOfPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt clone1;
    sqInt clone2;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt hash3;

	clone1 = (((longAt(obj1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex
		? cloneContext(obj1, self)
		: clone(obj1, self));
	clone2 = (((longAt(obj2)) & (classIndexMask(self))) == ClassMethodContextCompactIndex
		? cloneContext(obj2, self)
		: clone(obj2, self));
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(obj1))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin setIsImmutableOf:to: */
		longAtput(clone1, (longAt(clone1)) | (1U << (immutableBitShift(self))));
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(obj2))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin setIsImmutableOf:to: */
		longAtput(clone2, (longAt(clone2)) | (1U << (immutableBitShift(self))));
	}
	if (copyHashFlag) {
		/* begin setHashBitsOf:to: */
		hash = (long32At(obj1 + 4)) & (identityHashHalfWordMask(self));
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask(self)))));
		long32Atput(clone1 + 4, ((((long32At(clone1 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash);
		/* begin setHashBitsOf:to: */
		hash1 = (long32At(obj2 + 4)) & (identityHashHalfWordMask(self));
		assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask(self)))));
		long32Atput(clone2 + 4, ((((long32At(clone2 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash1);
	}
	else {
		/* begin setHashBitsOf:to: */
		hash2 = (long32At(obj2 + 4)) & (identityHashHalfWordMask(self));
		assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask(self)))));
		long32Atput(clone1 + 4, ((((long32At(clone1 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash2);
		/* begin setHashBitsOf:to: */
		hash3 = (long32At(obj1 + 4)) & (identityHashHalfWordMask(self));
		assert(((hash3 >= 0) && (hash3 <= (identityHashHalfWordMask(self)))));
		long32Atput(clone2 + 4, ((((long32At(clone2 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash3);
	}
	/* begin forward:to: */
	classIndex = isForwardedObjectClassIndexPun(self);
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
	assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
	longAtput(obj1, ((longAt(obj1)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex + (7U << (formatShift(self)))));
	
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(obj1, (longAt(obj1)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#  endif /* IMMUTABILITY */
	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(obj1, self));
	assert(!(isOopForwarded(clone2, self)));
	if ((assert(isNonImmediate(obj1, self)),
	oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((clone2 & (tagMask(self))) == 0)
		 && (oopisLessThan(clone2, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj1))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(obj1, self);
			}
		}
	}
	longAtput((obj1 + BaseHeaderSize) + (0U << (shiftForWord(self))), clone2);
	if ((byteAt(obj1 + 7)) == 0) {
		byteAtput(obj1 + 7, 1);
	}
	/* begin forward:to: */
	classIndex1 = isForwardedObjectClassIndexPun(self);
	assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask(self)))));
	assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
	longAtput(obj2, ((longAt(obj2)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex1 + (7U << (formatShift(self)))));
	
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(obj2, (longAt(obj2)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#  endif /* IMMUTABILITY */
	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(obj2, self));
	assert(!(isOopForwarded(clone1, self)));
	if ((assert(isNonImmediate(obj2, self)),
	oopisGreaterThanOrEqualTo(obj2, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((clone1 & (tagMask(self))) == 0)
		 && (oopisLessThan(clone1, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj2))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(obj2, self);
			}
		}
	}
	longAtput((obj2 + BaseHeaderSize) + (0U << (shiftForWord(self))), clone1);
	if ((byteAt(obj2 + 7)) == 0) {
		byteAtput(obj2 + 7, 1);
	}
	if ((((assert(isNonImmediate(obj1, self)),
	oopisLessThan(obj1, GIV(newSpaceLimit), self))) != ((assert(isNonImmediate(clone2, self)),
	oopisLessThan(clone2, GIV(newSpaceLimit), self))))
	 || (((assert(isNonImmediate(obj2, self)),
	oopisLessThan(obj2, GIV(newSpaceLimit), self))) != ((assert(isNonImmediate(clone1, self)),
	oopisLessThan(clone1, GIV(newSpaceLimit), self))))) {
		GIV(becomeEffectsFlags) = GIV(becomeEffectsFlags) | OldBecameNewFlag;
	}
}


/*	Attempt to pin objOop, which must not be immediate.
	If the attempt succeeds answer objOop's (possibly moved) oop.
	If the attempt fails, which can only occur if there is no memory, answer
	0.  */

	/* SpurMemoryManager>>#pinObject: */
sqInt
pinObject(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt i;
    sqInt oldClone;
    sqInt referent;
    SpurSegmentInfo *seg;

	assert(isNonImmediate(objOop, self));
	flag("policy decision here. if already old, do we clone in a segment containing pinned objects or merely pin?");
	if ((assert(isNonImmediate(objOop, self)),
	oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self))) {
		if ((numBytesOf(objOop, self)) > (1024 * 1024)) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1U << (pinnedBitShift(self))));
			return objOop;
		}
		/* begin segmentContainingObj: */
		for (i = (GIV(numSegments) - 1); i >= 0; i += -1) {
			if (objOop >= (((GIV(segments)[i]).segStart))) {
				seg = (&(GIV(segments)[i]));
				goto l1;
			}
		}
		seg = null;
	l1:	/* end segmentContainingObj: */;
		if ((seg->containsPinned)) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1U << (pinnedBitShift(self))));
			return objOop;
		}
		if (!(someSegmentContainsPinned(self))) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1U << (pinnedBitShift(self))));
			(seg->containsPinned = 1);
			return objOop;
		}
	}
	oldClone = cloneInOldSpaceforPinning(objOop, 1, self);
	if (oldClone != 0) {
		GIV(becomeEffectsFlags) = becomeEffectFlagsFor(objOop, self);
		/* begin setIsPinnedOf:to: */
		longAtput(oldClone, (longAt(oldClone)) | (1U << (pinnedBitShift(self))));
		/* begin forward:to: */
		classIndex = isForwardedObjectClassIndexPun(self);
		assert(((classIndex >= 0) && (classIndex <= (classIndexMask(self)))));
		assert(((7 /* forwardedFormat */ >= 0) && (7 /* forwardedFormat */ <= (formatMask(self)))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask(self))) << (formatShift(self))))) + (classIndexMask(self))))) + (classIndex + (7U << (formatShift(self)))));
		
#    if IMMUTABILITY
		/* begin setIsImmutableOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (immutableBitShift(self)))));
#    endif /* IMMUTABILITY */
		/* begin storePointer:ofForwarder:withValue: */
		assert(isForwarded(objOop, self));
		assert(!(isOopForwarded(oldClone, self)));
		if ((assert(isNonImmediate(objOop, self)),
		oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((oldClone & (tagMask(self))) == 0)
			 && (oopisLessThan(oldClone, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(objOop, self);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))), oldClone);
		if ((byteAt(objOop + 7)) == 0) {
			byteAtput(objOop + 7, 1);
		}
		/* begin followSpecialObjectsOop */
		if (((longAt(GIV(specialObjectsOop))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(specialObjectsOop), self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent & (tagMask(self))) == 0)
			 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			GIV(specialObjectsOop) = referent;
		}
		followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0, self);
		/* begin postBecomeAction: */
		spurPostBecomeAction(GIV(becomeEffectsFlags), self);
		postBecomeScanClassTable(GIV(becomeEffectsFlags), self);
		GIV(becomeEffectsFlags) = 0;
	}
	return oldClone;
}

	/* SpurMemoryManager>>#popObjStack: */
static sqInt NoDbgRegParms
popObjStack(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt myx;
    sqInt nextPage;
    sqInt top;
    sqInt topx;

	eassert(isValidObjStack(objStack, self));
	/* begin fetchPointer:ofObject: */
	topx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack, self)) == 0);
		return null;
	}
	topx -= 1;
	/* begin fetchPointer:ofObject: */
	top = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)((topx + ObjStackFixedSlots)) << (shiftForWord(self))))));
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack, self)) == (wordIndexableFormat(self)));
	longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))), topx);
	if ((topx == 0)
	 && (((nextPage = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self)))))))) != 0)) {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage, self)) == (wordIndexableFormat(self)));
		longAtput((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))), objStack);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack, self)) == (wordIndexableFormat(self)));
		longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))), 0);
		/* begin fetchPointer:ofObject: */
		myx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord(self))))));
		/* begin updateRootOfObjStackAt:with: */
		assert(!(isForwarded(GIV(hiddenRootsObj), self)));
		if ((assert(isNonImmediate(GIV(hiddenRootsObj), self)),
		oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((nextPage & (tagMask(self))) == 0)
			 && (oopisLessThan(nextPage, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(GIV(hiddenRootsObj), self);
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(myx) << (shiftForWord(self))))), nextPage);
		
		switch (myx) {
		case MarkStackRootIndex:
			GIV(markStack) = nextPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = nextPage;
			break;
		case MournQueueRootIndex:
			GIV(mournQueue) = nextPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		eassert(isValidObjStack(nextPage, self));
	}
	else {
		eassert(isValidObjStack(objStack, self));
	}
	return top;
}


/*	Pop and return the possibly remapped object from the remap buffer.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#popRemappableOop */
sqInt
popRemappableOop(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	Scan the class table post-become (iff an active class object was becommed)
	to ensure no
	forwarding pointers, and no unhashed classes exist in the class table.
	
	Note that one-way become can cause duplications in the class table.
	When can these be eliminated? We use the classTableBitmap to mark
	classTable entries
	(not the classes themselves, since marking a class doesn't help in knowing
	if its index is used).
	On image load, and during incrememtal scan-mark and full GC, classIndices
	are marked.
	We can somehow avoid following classes from the classTable until after
	this mark phase. */

	/* SpurMemoryManager>>#postBecomeScanClassTable: */
static void NoDbgRegParms
postBecomeScanClassTable(sqInt effectsFlags, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt i;
    sqInt iLimiT;
    sqInt j;
    sqInt page;
    sqInt referent;

	assert(validClassTableRootPages(self));
	if (!(effectsFlags & BecamePointerObjectFlag)) {
		return;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		/* begin fetchPointer:ofObject: */
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		assert(!(isForwarded(page, self)));
		for (j = 0, iLimiT = ((numSlotsOf(page, self)) - 1); j <= iLimiT; j += 1) {
			/* begin fetchPointer:ofObject: */
			classOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))));
			if (classOrNil != GIV(nilObj)) {
				if (((longAt(classOrNil)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(classOrNil, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((classOrNil + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					classOrNil = referent;
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(page, self)));
					if ((assert(isNonImmediate(page, self)),
					oopisGreaterThanOrEqualTo(page, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((classOrNil & (tagMask(self))) == 0)
						 && (oopisLessThan(classOrNil, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(page))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(page, self);
							}
						}
					}
					longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))), classOrNil);
				}
				if (((long32At(classOrNil + 4)) & (identityHashHalfWordMask(self))) == 0) {
					assert(!(isOopForwarded(page, self)));
					longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))), GIV(nilObj));
					if (((((sqInt)((usqInt)(i) << (classTableMajorIndexShift(self))))) + j) < GIV(classTableIndex)) {
						GIV(classTableIndex) = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift(self))))) + j;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift(self))));
}

	/* SpurMemoryManager>>#primitiveErrorTable */
sqInt
primitiveErrorTable(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(PrimErrTableIndex) << (shiftForWord(self))))));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */

	/* SpurMemoryManager>>#printActivationsOf: */
void
printActivationsOf(sqInt aMethodObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
		 && (aMethodObj == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))))))) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			print(" pc ", self);
			printHex(longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))), self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
		 && (aMethodObj == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))))))) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			print(" pc ", self);
			printHex(longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))), self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if ((((longAt(objOop11)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
			 && (aMethodObj == (longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))))))) {
				printHex(objOop11, self);
				/* begin space */
				putchar(' ');
				printOopShort(objOop11, self);
				print(" pc ", self);
				printHex(longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))), self);
				/* begin cr */
				printf("\n");
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printBogons */
void
printBogons(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printTheBogons: */
	print("bogon ", self);
	printf("0x%" PRIxSQINT "", GIV(bogon));
	/* begin cr */
	printf("\n");
	print("anomaly ", self);
	printf("0x%" PRIxSQINT "", GIV(anomaly));
	/* begin cr */
	printf("\n");
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */

	/* SpurMemoryManager>>#printContextReferencesTo: */
void
printContextReferencesTo(sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
			i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1, self));
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					printHex(objOop1, self);
					print(" @ ", self);
					printNum(i, self);
					/* begin space */
					putchar(' ');
					printOopShort(objOop1, self);
					print(" pc ", self);
					printHex(longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))), self);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
			i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1, self));
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					printHex(objOop1, self);
					print(" @ ", self);
					printNum(i, self);
					/* begin space */
					putchar(' ');
					printOopShort(objOop1, self);
					print(" pc ", self);
					printHex(longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))), self);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if (((longAt(objOop11)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
				i = CtxtTempFrameStart + (fetchStackPointerOf(objOop11, self));
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
						printHex(objOop11, self);
						print(" @ ", self);
						printNum(i, self);
						/* begin space */
						putchar(' ');
						printOopShort(objOop11, self);
						print(" pc ", self);
						printHex(longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))), self);
						/* begin cr */
						printf("\n");
						i = 0;
					}
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printEntity: */
void
printEntity(sqInt oop, struct foo * self)
{
    usqInt n;
    usqInt n1;
    usqInt n2;
    sqInt printFlags;

	printFlags = 0;
	printHex(oop, self);
	/* begin space */
	putchar(' ');
	if (!(addressCouldBeObj(oop, self))) {
		print((oop & (tagMask(self))
			? "immediate"
			: "unknown"), self);
		return;
	}
	print((((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))
		? "free"
		: (((longAt(oop)) & (classIndexMask(self))) == (segmentBridgePun(self))
				? "bridge"
				: (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0
						? "forwarder"
						: (((longAt(oop)) & (classIndexMask(self))) <= (lastClassIndexPun(self))
								? ((printFlags = 1),
									"pun/obj stack")
								: ((printFlags = 1),
									"object"))))), self);
	/* begin space */
	putchar(' ');
	/* begin printHexnpnp: */
	n1 = byteAt(oop + 7);
	printf("%" PRIxSQINT "", n1);
	print("/", self);
	/* begin printHexnpnp: */
	n2 = bytesInObject(oop, self);
	printf("%" PRIxSQINT "", n2);
	print("/", self);
	printNum(bytesInObject(oop, self), self);
	if (printFlags) {
		/* begin space */
		putchar(' ');
		print((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 15
			? "f:0"
			: "f:"), self);
		/* begin printHexnpnp: */
		n = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
		printf("%" PRIxSQINT "", n);
		print((((((usqInt) (longAt(oop))) >> (greyBitShift(self))) & 1) != 0
			? " g"
			: " ."), self);
		print((((((usqInt) (longAt(oop))) >> (immutableBitShift(self))) & 1) != 0
			? "i"
			: "."), self);
		print((((((usqInt) (longAt(oop))) >> (markedBitFullShift(self))) & 1) != 0
			? "m"
			: "."), self);
		print((((((usqInt) (longAt(oop))) >> (pinnedBitShift(self))) & 1) != 0
			? "p"
			: "."), self);
		print((((((usqInt) (longAt(oop))) >> (rememberedBitShift(self))) & 1) != 0
			? "r"
			: "."), self);
	}
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printForwarders */
void
printForwarders(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask(self))) == (isForwardedObjectClassIndexPun(self))) {
			printHex(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop2 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop2, limit, self)) {
		if (((longAt(objOop2)) & (classIndexMask(self))) == (isForwardedObjectClassIndexPun(self))) {
			printHex(objOop2, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop2;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop2, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop2 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop2 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop2 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop2, GIV(freeStart), self)) {
		if (((longAt(objOop2)) & (classIndexMask(self))) == (isForwardedObjectClassIndexPun(self))) {
			printHex(objOop2, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop2;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop2, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop2 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop2 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}


/*	This version goes through memory, printing all free chunks.
	Other versions go through the free lists. This one will show
	all free chunks even if the free lists are corrupt. */

	/* SpurMemoryManager>>#printFreeChunks */
void
printFreeChunks(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt seenNewFreeChunk;

	seenNewFreeChunk = 0;
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			if (!seenNewFreeChunk) {
				print("NewSpace CONTAINS FREE OBJECT(S)!!", self);
				/* begin cr */
				printf("\n");
				seenNewFreeChunk = 1;
			}
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop, 1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			if (!seenNewFreeChunk) {
				print("NewSpace CONTAINS FREE OBJECT(S)!!", self);
				/* begin cr */
				printf("\n");
				seenNewFreeChunk = 1;
			}
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop, 1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop1, 1, self);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printFreeChunk: */
void
printFreeChunk(sqInt freeChunk, struct foo * self)
{
	printFreeChunkprintAsTreeNode(freeChunk, 1, self);
}

	/* SpurMemoryManager>>#printFreeChunk:printAsTreeNode: */
static void NoDbgRegParms
printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt n;
    usqInt n1;
    usqInt n2;
    usqInt n3;
    usqInt n4;
    usqInt n5;
    usqInt n6;
    usqInt numBytes;
    void *p;
    void *p1;
    void *p2;
    void *p3;
    void *p4;
    void *p5;

	numBytes = bytesInObject(freeChunk, self);
	print("freeChunk ", self);
	/* begin printHexPtrnp: */
	n5 = oopForPointer(((void *) freeChunk));
	printf("0x%" PRIxSQINT "", n5);
	if (printAsTreeNode) {
		print((freeChunk == (GIV(freeLists)[0])
			? " + "
			: " - "), self);
		/* begin printHexPtrnp: */
		p = ((void *) (addressAfter(freeChunk, self)));
		/* begin printHexnp: */
		n = oopForPointer(p);
		printf("0x%" PRIxSQINT "", n);
	}
	print(" bytes ", self);
	printNum(numBytes, self);
	print(" next ", self);
	/* begin printHexPtrnp: */
	p5 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))))));
	/* begin printHexnp: */
	n6 = oopForPointer(p5);
	printf("0x%" PRIxSQINT "", n6);
	if (!((assert(numBytes >= (BaseHeaderSize + (allocationUnit(self)))),
		numBytes == (BaseHeaderSize + 8 /* allocationUnit */)))) {
		print(" prev ", self);
		/* begin printHexPtrnp: */
		p1 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))))));
		/* begin printHexnp: */
		n1 = oopForPointer(p1);
		printf("0x%" PRIxSQINT "", n1);
	}
	if ((numBytes >= (64 /* numFreeLists */ * 8 /* allocationUnit */))
	 && (printAsTreeNode)) {
		print(" ^ ", self);
		/* begin printHexPtrnp: */
		p2 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (2U << (shiftForWord(self))))));
		/* begin printHexnp: */
		n2 = oopForPointer(p2);
		printf("0x%" PRIxSQINT "", n2);
		print(" < ", self);
		/* begin printHexPtrnp: */
		p3 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (3U << (shiftForWord(self))))));
		/* begin printHexnp: */
		n3 = oopForPointer(p3);
		printf("0x%" PRIxSQINT "", n3);
		print(" > ", self);
		/* begin printHexPtrnp: */
		p4 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (4U << (shiftForWord(self))))));
		/* begin printHexnp: */
		n4 = oopForPointer(p4);
		printf("0x%" PRIxSQINT "", n4);
	}
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printFreeListHeads */
void
printFreeListHeads(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt expectedMask;
    sqInt i;
    sqInt iLimiT;

	expectedMask = 0;
	for (i = 0, iLimiT = (64 /* numFreeLists */ - 1); i <= iLimiT; i += 1) {
		printHex(GIV(freeLists)[i], self);
		if ((GIV(freeLists)[i]) != 0) {
			expectedMask += 1ULL << i;
		}
		if (((i + 1) % (((usqInt) 32) >> 3 /* logBytesPerOop */)) == 0) {
			/* begin cr */
			printf("\n");
		}
		else {
			print("  ", self);
		}
	}
	/* begin cr */
	printf("\n");
	print("mask: ", self);
	printf("0x%" PRIxSQINT "", GIV(freeListsMask));
	print(" expected: ", self);
	printf("0x%" PRIxSQINT "", expectedMask);
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printFreeList: */
sqInt
printFreeList(sqInt chunkOrIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt freeChunk;

	if ((chunkOrIndex >= 0)
	 && (chunkOrIndex < 64 /* numFreeLists */)) {
		return printFreeList(GIV(freeLists)[chunkOrIndex], self);
	}
	freeChunk = chunkOrIndex;
	while (freeChunk != 0) {
		/* begin printFreeChunk: */
		printFreeChunkprintAsTreeNode(freeChunk, 1, self);
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex = 0 /* freeChunkNextIndex */;
		freeChunk = longAt((freeChunk + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	}
	return 0;
}

	/* SpurMemoryManager>>#printFreeTree */
void
printFreeTree(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFreeTreeChunk(GIV(freeLists)[0], self);
}


/*	Slang is blind-sided by the inlining of printFreeTreeChunk: into
	printFreeTree. 
 */

	/* SpurMemoryManager>>#printFreeTreeChunk: */
static void NoDbgRegParms
printFreeTreeChunk(sqInt chunkOrZero, struct foo * self)
{
	if (chunkOrZero > 0) {
		printFreeTreeChunk(longAt((chunkOrZero + BaseHeaderSize) + (3U << (shiftForWord(self)))), self);
		/* begin printFreeChunk: */
		printFreeChunkprintAsTreeNode(chunkOrZero, 1, self);
		printFreeTreeChunk(longAt((chunkOrZero + BaseHeaderSize) + (4U << (shiftForWord(self)))), self);
	}
}


/*	N.B. No safety bounds checks!! We need to look e.g. at corpses. */

	/* SpurMemoryManager>>#printHeaderOf: */
void
printHeaderOf(sqInt objOop, struct foo * self)
{
    sqInt aByte;
    sqInt aByte1;
    sqInt aByte2;
    sqInt aByte3;
    sqInt aByte4;
    usqInt n;
    usqInt n1;
    usqInt n2;
    usqInt n3;
    usqInt n4;
    usqInt numSlots;
    usqInt numSlots1;

	printf("0x%" PRIxSQINT "", objOop);
	if ((numSlotsOfAny(objOop, self)) >= (numSlotsMask(self))) {
		print(" hdr16 slotf ", self);
		/* begin printHexnp: */
		numSlots = byteAt((objOop - 8 /* allocationUnit */) + 7);
		n = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt((objOop - 8 /* allocationUnit */) - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		printf("0x%" PRIxSQINT "", n);
		print(" slotc ", self);
		/* begin printHexnp: */
		printf("0x%" PRIxSQINT "", ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8);
		/* begin space */
		putchar(' ');
	}
	else {
		print(" hdr8 slots ", self);
		/* begin printHexnp: */
		numSlots1 = byteAt(objOop + 7);
		n1 = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		printf("0x%" PRIxSQINT "", n1);
	}
	/* begin space */
	putchar(' ');
	/* begin printChar: */
	aByte = (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0
		? 'M'
		: 'm');
	putchar(aByte);
	/* begin printChar: */
	aByte1 = (((((usqInt) (longAt(objOop))) >> (greyBitShift(self))) & 1) != 0
		? 'G'
		: 'g');
	putchar(aByte1);
	/* begin printChar: */
	aByte2 = (((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0
		? 'P'
		: 'p');
	putchar(aByte2);
	/* begin printChar: */
	aByte3 = (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0
		? 'R'
		: 'r');
	putchar(aByte3);
	/* begin printChar: */
	aByte4 = (((((usqInt) (longAt(objOop))) >> (immutableBitShift(self))) & 1) != 0
		? 'I'
		: 'i');
	putchar(aByte4);
	print(" hash ", self);
	/* begin printHexnp: */
	n2 = (long32At(objOop + 4)) & (identityHashHalfWordMask(self));
	printf("0x%" PRIxSQINT "", n2);
	print(" fmt ", self);
	/* begin printHexnp: */
	n3 = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	printf("0x%" PRIxSQINT "", n3);
	print(" cidx ", self);
	/* begin printHexnp: */
	n4 = (longAt(objOop)) & (classIndexMask(self));
	printf("0x%" PRIxSQINT "", n4);
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printHeaderTypeOf: */
static void NoDbgRegParms
printHeaderTypeOf(sqInt objOop, struct foo * self)
{
    sqInt aByte;
    sqInt aByte1;
    sqInt aByte2;
    sqInt aByte3;
    sqInt aByte4;

	print(((numSlotsOfAny(objOop, self)) >= (numSlotsMask(self))
		? " hdr16 "
		: " hdr8 "), self);
	/* begin printChar: */
	aByte = (((((usqInt) (longAt(objOop))) >> (immutableBitShift(self))) & 1) != 0
		? 'i'
		: '.');
	putchar(aByte);
	/* begin printChar: */
	aByte1 = (((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0
		? 'r'
		: '.');
	putchar(aByte1);
	/* begin printChar: */
	aByte2 = (((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0
		? 'p'
		: '.');
	putchar(aByte2);
	/* begin printChar: */
	aByte3 = (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0
		? 'm'
		: '.');
	putchar(aByte3);
	/* begin printChar: */
	aByte4 = (((((usqInt) (longAt(objOop))) >> (greyBitShift(self))) & 1) != 0
		? 'g'
		: '.');
	putchar(aByte4);
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

	/* SpurMemoryManager>>#printInstancesOf: */
void
printInstancesOf(sqInt aClassOop, struct foo * self)
{
    sqInt classIndex;

	classIndex = (long32At(aClassOop + 4)) & (identityHashHalfWordMask(self));
	if (classIndex != (isFreeObjectClassIndexPun(self))) {
		printInstancesWithClassIndex(classIndex, self);
	}
}


/*	Scan the heap printing the oops of any and all objects whose classIndex
	equals the argument.
 */

	/* SpurMemoryManager>>#printInstancesWithClassIndex: */
void
printInstancesWithClassIndex(sqInt classIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask(self))) == classIndex) {
			printHex(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == classIndex) {
			printHex(objOop, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (((longAt(objOop)) & (classIndexMask(self))) == classIndex) {
			printHex(objOop, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}


/*	Print the objects in the classTable that have bad hashes. */

	/* SpurMemoryManager>>#printInvalidClassTableEntries */
void
printInvalidClassTableEntries(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil1;
    sqInt hash;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt j;
    sqInt page;

	if (!(validClassTableRootPages(self))) {
		print("class table invalid; cannot print", self);
		/* begin cr */
		printf("\n");
		return;
	}
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		for (j = 0, iLimiT = ((1U << (classTableMajorIndexShift(self))) - 1); j <= iLimiT; j += 1) {
			classOrNil1 = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))));
			if (classOrNil1 != GIV(nilObj)) {
				index = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift(self))))) + j;
				if ((((longAt(classOrNil1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)
				 || ((((hash = (long32At(classOrNil1 + 4)) & (identityHashHalfWordMask(self)))) == 0)
				 || ((noCheckClassAtIndex(hash, self)) != classOrNil1))) {
					print("entry ", self);
					printHex(index, self);
					print(" oop ", self);
					printHex(classOrNil1, self);
					print(" hash ", self);
					printHex(hash, self);
					print(" => ", self);
					printHex(classAtIndex(hash, self), self);
					/* begin cr */
					printf("\n");
				}
			}
		}
	}
}

	/* SpurMemoryManager>>#printMarkedOops */
#if LLDB
void
printMarkedOops(struct foo * self)
{
	printOopsSuchThat(isMarked, self);
}
#endif /* LLDB */


/*	Scan the heap printing the oops of any and all methods that implement
	anOop 
 */

	/* SpurMemoryManager>>#printMethodImplementorsOf: */
void
printMethodImplementorsOf(sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))
		 && ((maybeSelectorOfMethod(objOop1, self)) == anOop)) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))
		 && ((maybeSelectorOfMethod(objOop1, self)) == anOop)) {
			printHex(objOop1, self);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))
			 && ((maybeSelectorOfMethod(objOop11, self)) == anOop)) {
				printHex(objOop11, self);
				/* begin space */
				putchar(' ');
				printOopShort(objOop11, self);
				/* begin cr */
				printf("\n");
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}


/*	Scan the heap printing the oops of any and all methods that refer to anOop */

	/* SpurMemoryManager>>#printMethodReferencesTo: */
void
printMethodReferencesTo(sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
			i = (((assert((((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					printHex(objOop1, self);
					print(" @ ", self);
					printNum(i, self);
					/* begin space */
					putchar(' ');
					printOopShort(objOop1, self);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
			i = (((assert((((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop1, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					printHex(objOop1, self);
					print(" @ ", self);
					printNum(i, self);
					/* begin space */
					putchar(' ');
					printOopShort(objOop1, self);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if (((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
				i = (((assert((((((assert(isCompiledMethod(objOop11, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop11, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1;
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
						printHex(objOop11, self);
						print(" @ ", self);
						printNum(i, self);
						/* begin space */
						putchar(' ');
						printOopShort(objOop11, self);
						/* begin cr */
						printf("\n");
						i = 0;
					}
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printObjectsFrom:to: */
void
printObjectsFromto(sqInt startAddress, sqInt endAddress, struct foo * self)
{
    sqInt oop;

	oop = objectBefore(startAddress, self);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop, self)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress, self)) {
		if (!((((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)))
			 || (((longAt(oop)) & (classIndexMask(self))) == (segmentBridgePun(self))))) {
			printOop(oop, self);
		}
		oop = objectAfter(oop, self);
	}
}


/*	Scan the heap printing the oops of any and all objects whose hash equals
	the argument.
 */

	/* SpurMemoryManager>>#printObjectsWithHash: */
void
printObjectsWithHash(sqInt hash, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((long32At(objOop1 + 4)) & (identityHashHalfWordMask(self))) == hash) {
			shortPrintOop(objOop1, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (((long32At(objOop + 4)) & (identityHashHalfWordMask(self))) == hash) {
			shortPrintOop(objOop, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (((long32At(objOop + 4)) & (identityHashHalfWordMask(self))) == hash) {
			shortPrintOop(objOop, self);
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:pageType: */
static void NoDbgRegParms
printObjStackPagemyIndexpageType(sqInt objStackPage, sqInt myx, sqInt pageType, struct foo * self)
{
    sqInt freeOrNextPage;
    int isFirstPage;
    int isFreePage;
    int isNextPage;
    sqInt page;

	isFirstPage = pageType == ObjStackMyx;
	isNextPage = pageType == ObjStackNextx;
	isFreePage = pageType == ObjStackFreex;
	printObjStackPagemyIndextag(objStackPage, myx, (isFirstPage
		? "head"
		: (isFreePage
				? "free"
				: "next")), self);
	if (isFirstPage
	 || (isNextPage)) {
		/* begin tab */
		putchar('	');
		print("topx: ", self);
		printNum(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self)))))), self);
		print(" next: ", self);
		printHex(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self)))))), self);
		if (isFirstPage) {
			print(" free: ", self);
			printHex(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self)))))), self);
		}
		/* begin cr */
		printf("\n");
	}
	if (isFirstPage) {
		/* begin fetchPointer:ofObject: */
		freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
		while (freeOrNextPage != 0) {
			printObjStackPagemyIndexpageType(freeOrNextPage, myx, ObjStackFreex, self);
			/* begin fetchPointer:ofObject: */
			page = longAt((freeOrNextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
			if ((page == freeOrNextPage)
			 || (page == objStackPage)) {
				print("circularity in free page list!!", self);
				/* begin cr */
				printf("\n");
				page = 0;
			}
			freeOrNextPage = page;
		}
	}
	/* begin fetchPointer:ofObject: */
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
	if (freeOrNextPage != 0) {
		printObjStackPagemyIndexpageType(freeOrNextPage, myx, ObjStackNextx, self);
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:tag: */
static void NoDbgRegParms
printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType, struct foo * self)
{
	print(pageType, self);
	/* begin space */
	putchar(' ');
	printHex(objStackPage, self);
	/* begin space */
	putchar(' ');
	print("cx ", self);
	printNum((longAt(objStackPage)) & (classIndexMask(self)), self);
	print(" (", self);
	printNum(sixtyFourBitLongsClassIndexPun(self), self);
	print(") fmt ", self);
	printNum((((usqInt) (longAt(objStackPage))) >> (formatShift(self))) & (formatMask(self)), self);
	print(" (", self);
	printNum(sixtyFourBitIndexableFormat(self), self);
	print(") sz ", self);
	printNum(numSlotsOfAny(objStackPage, self), self);
	print(" (", self);
	printNum(ObjStackPageSlots, self);
	print(") myx: ", self);
	printNum(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord(self)))))), self);
	print(" (", self);
	printNum(myx, self);
	print((((((usqInt) (longAt(objStackPage))) >> (markedBitFullShift(self))) & 1) != 0
		? ") mkd"
		: ") unmkd"), self);
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printObjStack: */
void
printObjStack(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		print("nil", self);
		/* begin cr */
		printf("\n");
	}
	else {
		printObjStackPagemyIndexpageType(objStack, longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord(self)))))), ObjStackMyx, self);
	}
}

	/* SpurMemoryManager>>#printOopsExcept: */
void NeverInline
printOopsExcept(sqInt (*function)(sqInt), struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    sqInt n;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	n = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (!(function(objOop1))) {
			n += 1;
			printEntity(objOop1, self);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (!(function(objOop))) {
			n += 1;
			printEntity(objOop, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (!(function(objOop))) {
			n += 1;
			printEntity(objOop, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	if (n > 4) {

		/* rabbits */
		printNum(n, self);
		print(" objects", self);
		/* begin cr */
		printf("\n");
	}
}

	/* SpurMemoryManager>>#printOopsFrom:to: */
void
printOopsFromto(sqInt startAddress, sqInt endAddress, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstNonEntity;
    sqInt inEmptySpace;
    sqInt lastNonEntity;
    sqInt limit;
    usqInt n;
    usqInt n1;
    usqInt numSlots;
    sqInt oop;

	firstNonEntity = 0;
	oop = objectBefore(startAddress, self);
	limit = (((((usqIntptr_t)endAddress)) < GIV(endOfMemory)) ? (((usqIntptr_t)endAddress)) : GIV(endOfMemory));
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop, self)) == startAddress
				? startAddress
				: oop));
	inEmptySpace = 0;
	while (oopisLessThan(oop, limit, self)) {
		printEntity(oop, self);
		while (1) {
			oop = objectAfter(oop, self);
			if (!((long64At(oop)) == 0)) break;
			if (!inEmptySpace) {
				inEmptySpace = 1;
				firstNonEntity = oop;
			}
			lastNonEntity = oop;
		}
		if (inEmptySpace) {
			inEmptySpace = 0;
			print("skipped empty space from ", self);
			/* begin printHexPtrnp: */
			n = oopForPointer(((void *) firstNonEntity));
			printf("0x%" PRIxSQINT "", n);
			print(" to ", self);
			/* begin printHexPtrnp: */
			n1 = oopForPointer(((void *) lastNonEntity));
			printf("0x%" PRIxSQINT "", n1);
			/* begin cr */
			printf("\n");
			/* begin objectStartingAt: */
			numSlots = byteAt(oop + 7);
			oop = (numSlots == (numSlotsMask(self))
				? oop + BaseHeaderSize
				: oop);
		}
	}
}

	/* SpurMemoryManager>>#printOopsSuchThat: */
void NeverInline
printOopsSuchThat(sqInt (*function)(sqInt), struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    sqInt n;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	n = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (function(objOop1)) {
			n += 1;
			printEntity(objOop1, self);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (function(objOop)) {
			n += 1;
			printEntity(objOop, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (function(objOop)) {
			n += 1;
			printEntity(objOop, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	if (n > 4) {

		/* rabbits */
		printNum(n, self);
		print(" objects", self);
		/* begin cr */
		printf("\n");
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

	/* SpurMemoryManager>>#printReferencesTo: */
void
printReferencesTo(sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt contextSize;
    sqInt fmt;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt header;
    sqInt i;
    usqInt limit;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt sp;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots2 = byteAt(address + 7);
	objOop1 = (numSlots2 == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		/* begin numPointerSlotsOf: */
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self));
		if (fmt <= 5 /* lastPointerFormat */) {
			if ((fmt == (indexablePointersFormat(self)))
			 && (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l10;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop1, self)));
				contextSize = (sp >> 3);
	l10:	/* end fetchStackPointerOf: */;
				i = ((usqInt) (CtxtTempFrameStart + contextSize));
				goto l11;
			}
			/* begin numSlotsOf: */
			assert((classIndexOf(objOop1, self)) > (isForwardedObjectClassIndexPun(self)));
			numSlots = byteAt(objOop1 + 7);
			i = (numSlots == (numSlotsMask(self))
				? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop1 - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots);
			goto l11;
		}
		if (fmt == 7 /* forwardedFormat */) {
			i = 1;
			goto l11;
		}
		if (fmt < (firstCompiledMethodFormat(self))) {
			i = 0;
			goto l11;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(objOop1, self));
		/* begin fetchPointer:ofObject: */
		header = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		assert((((header) & 7) == 1));
		numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
		i = ((usqInt) (numLiterals + LiteralStart));
	l11:	/* end numPointerSlotsOf: */;
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
				printHex(objOop1, self);
				print(" @ ", self);
				printNum(i, self);
				/* begin space */
				putchar(' ');
				printOopShort(objOop1, self);
				/* begin cr */
				printf("\n");
				i = 0;
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l9;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l9:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		/* begin numPointerSlotsOf: */
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self));
		if (fmt <= 5 /* lastPointerFormat */) {
			if ((fmt == (indexablePointersFormat(self)))
			 && (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l12;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop1, self)));
				contextSize = (sp >> 3);
	l12:	/* end fetchStackPointerOf: */;
				i = ((usqInt) (CtxtTempFrameStart + contextSize));
				goto l13;
			}
			/* begin numSlotsOf: */
			assert((classIndexOf(objOop1, self)) > (isForwardedObjectClassIndexPun(self)));
			numSlots = byteAt(objOop1 + 7);
			i = (numSlots == (numSlotsMask(self))
				? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop1 - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots);
			goto l13;
		}
		if (fmt == 7 /* forwardedFormat */) {
			i = 1;
			goto l13;
		}
		if (fmt < (firstCompiledMethodFormat(self))) {
			i = 0;
			goto l13;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(objOop1, self));
		/* begin fetchPointer:ofObject: */
		header = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		assert((((header) & 7) == 1));
		numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
		i = ((usqInt) (numLiterals + LiteralStart));
	l13:	/* end numPointerSlotsOf: */;
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
				printHex(objOop1, self);
				print(" @ ", self);
				printNum(i, self);
				/* begin space */
				putchar(' ');
				printOopShort(objOop1, self);
				/* begin cr */
				printf("\n");
				i = 0;
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l7;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l7:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			/* begin numPointerSlotsOf: */
			fmt = (((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self));
			if (fmt <= 5 /* lastPointerFormat */) {
				if ((fmt == (indexablePointersFormat(self)))
				 && (((longAt(objOop11)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
					if (!((((sp) & 7) == 1))) {
						contextSize = 0;
						goto l14;
					}
					assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop11, self)));
					contextSize = (sp >> 3);
	l14:	/* end fetchStackPointerOf: */;
					i = ((usqInt) (CtxtTempFrameStart + contextSize));
					goto l15;
				}
				/* begin numSlotsOf: */
				assert((classIndexOf(objOop11, self)) > (isForwardedObjectClassIndexPun(self)));
				numSlots = byteAt(objOop11 + 7);
				i = (numSlots == (numSlotsMask(self))
					? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop11 - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots);
				goto l15;
			}
			if (fmt == 7 /* forwardedFormat */) {
				i = 1;
				goto l15;
			}
			if (fmt < (firstCompiledMethodFormat(self))) {
				i = 0;
				goto l15;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objOop11, self));
			/* begin fetchPointer:ofObject: */
			header = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			i = ((usqInt) (numLiterals + LiteralStart));
	l15:	/* end numPointerSlotsOf: */;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					printHex(objOop11, self);
					print(" @ ", self);
					printNum(i, self);
					/* begin space */
					putchar(' ');
					printOopShort(objOop11, self);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printUnmarkedOops */
#if LLDB
void
printUnmarkedOops(struct foo * self)
{
	printOopsExcept(isMarked, self);
}
#endif /* LLDB */


/*	Attempt to push anEphemeron on the unscanned ephemerons stack
	and answer if the attempt succeeded. Note that the ephemeron
	stack overflowing isn't a disaster; it simply means treating the
	ephemeron as strong in this GC cycle. */

	/* SpurMemoryManager>>#pushOnUnscannedEphemeronsStack: */
static sqInt NoDbgRegParms
pushOnUnscannedEphemeronsStack(sqInt anEphemeron, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isEphemeron(anEphemeron, self));
	if (((GIV(unscannedEphemerons).top)) >= ((GIV(unscannedEphemerons).limit))) {
		return 0;
	}
	longAtput((GIV(unscannedEphemerons).top), anEphemeron);
	(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) + BytesPerOop);
	return 1;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that
	objects in temporary variables are properly remapped.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#pushRemappableOop: */
void
pushRemappableOop(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop, self));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}


/*	Add the ephemeron to the queue and make it non-ephemeral, to avoid
	subsequent firing.
	Alas this means that other ephemerons on the same object not identified in
	this sccavenge
	or GC will not fire until later. But that's life. */

	/* SpurMemoryManager>>#queueMourner: */
static void NoDbgRegParms
queueMourner(sqInt anEphemeronOrWeakArray, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objStack;

	assert((isNonImmediate(anEphemeronOrWeakArray, self))
	 && (((formatOf(anEphemeronOrWeakArray, self)) == (ephemeronFormat(self)))
	 || ((formatOf(anEphemeronOrWeakArray, self)) == (weakArrayFormat(self)))));
	assert(!((((formatOf(anEphemeronOrWeakArray, self)) == (ephemeronFormat(self)))
 && (isonObjStack(anEphemeronOrWeakArray, GIV(mournQueue), self)))));
	ensureRoomOnObjStackAt(MournQueueRootIndex, self);
	/* begin push:onObjStack: */
	objStack = GIV(mournQueue);
	assert(addressCouldBeOop(anEphemeronOrWeakArray, self));
	if (anEphemeronOrWeakArray & (tagMask(self))) {
		assert(objStack == GIV(markStack));
		assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack, self))
			? fetchPointerofObject(ObjStackNextx, objStack, self)
			: objStack), self), self));
	}
	else {

		/* There should be no weaklings on the mark stack. */
		assert(!((objStack == GIV(markStack))
		 && (isWeakNonImm(anEphemeronOrWeakArray, self))));
		assert((objStack != GIV(weaklingStack))
		 || (isWeakNonImm(anEphemeronOrWeakArray, self)));
	}
	noCheckPushonObjStack(anEphemeronOrWeakArray, objStack, self);
}

	/* SpurMemoryManager>>#rawHashBitsOf: */
sqInt
rawHashBitsOf(sqInt objOop, struct foo * self)
{
	flag("endianness");
	return (long32At(objOop + 4)) & (identityHashHalfWordMask(self));
}


/*	Relocate all objStack pages that comprise objStack. */

	/* SpurMemoryManager>>#relocateObjStackForPlanningCompactor: */
static sqInt NoDbgRegParms
relocateObjStackForPlanningCompactor(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt finishIndex;
    sqInt freeList;
    sqInt fwd;
    sqInt fwd1;
    sqInt i;
    sqInt i1;
    sqInt next;
    sqInt oop;
    sqInt oop1;
    sqInt relocated;
    sqInt result;
    sqInt stackOrNil;

	if (objStack == GIV(nilObj)) {
		return objStack;
	}
	stackOrNil = objStack;
	/* begin fetchPointer:ofObject: */
	freeList = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
	while (1) {
		assert((numSlotsOfAny(stackOrNil, self)) == ObjStackPageSlots);
		/* begin fetchPointer:ofObject: */
		next = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
		/* begin relocateObjectsInHeapEntity:from:to: */
		finishIndex = ObjStackNextx + ((long32At(stackOrNil + 4)) & (identityHashHalfWordMask(self)));
		for (i = ObjStackFreex; i <= finishIndex; i += 1) {
			/* begin fetchPointer:ofObject: */
			oop = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			if (((oop & (tagMask(self))) == 0)
			 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject), self))
			 && (!(((((usqInt) (longAt(oop))) >> (pinnedBitShift(self))) & 1) != 0)))) {
				assert(isMarked(oop, self));
				/* begin fetchPointer:ofObject: */
				fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				assert(isPostMobile(fwd, self));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(stackOrNil, self)));
				longAtput((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), fwd);
			}
		}
		if ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(stackOrNil, GIV(mobileStart), GIV(lastMobileObject), self))
		 && (!(((((usqInt) (longAt(stackOrNil))) >> (pinnedBitShift(self))) & 1) != 0))) {
			/* begin fetchPointer:ofObject: */
			relocated = longAt((stackOrNil + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		else {
			relocated = stackOrNil;
		}
		if (stackOrNil == objStack) {
			result = relocated;
		}
		/* begin setHashBitsOf:to: */
		assert(((0 >= 0) && (0 <= (identityHashHalfWordMask(self)))));
		long32Atput(stackOrNil + 4, ((((long32At(stackOrNil + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))));
		if (!(next != 0)) break;
		stackOrNil = next;
	}
	while (freeList != 0) {
		assert((numSlotsOfAny(freeList, self)) == ObjStackPageSlots);
		/* begin fetchPointer:ofObject: */
		next = longAt((freeList + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))));
		/* begin relocateObjectsInHeapEntity:from:to: */
		for (i1 = ObjStackFreex; i1 <= ObjStackFreex; i1 += 1) {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((freeList + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
			if (((oop1 & (tagMask(self))) == 0)
			 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop1, GIV(mobileStart), GIV(lastMobileObject), self))
			 && (!(((((usqInt) (longAt(oop1))) >> (pinnedBitShift(self))) & 1) != 0)))) {
				assert(isMarked(oop1, self));
				/* begin fetchPointer:ofObject: */
				fwd1 = longAt((oop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				assert(isPostMobile(fwd1, self));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(freeList, self)));
				longAtput((freeList + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), fwd1);
			}
		}
		if ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(freeList, GIV(mobileStart), GIV(lastMobileObject), self))
		 && (!(((((usqInt) (longAt(freeList))) >> (pinnedBitShift(self))) & 1) != 0))) {
			/* begin fetchPointer:ofObject: */
			longAt((freeList + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		else {
		}
		freeList = next;
	}
	return relocated;
}


/*	Remove the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#removeGCRoot: */
sqInt
removeGCRoot(sqInt *varLoc, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		if (varLoc == (GIV(extraRoots)[i])) {

			/* swap varLoc with last entry */
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:. */

	/* SpurMemoryManager>>#return:restoringObjectsIn:savedFirstFields:and:savedHashes: */
static sqInt NoDbgRegParms
returnrestoringObjectsInsavedFirstFieldsandsavedHashes(sqInt errCode, sqInt firstArray, sqInt savedFirstFields, sqInt secondArray, sqInt savedHashes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt oop1;

	/* begin restoreObjectsIn:upTo:savedFirstFields: */
	/* begin numSlotsOf: */
	assert((classIndexOf(firstArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(firstArray + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(firstArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	for (i = 0; i < numSlots; i += 1) {
		/* begin fetchPointer:ofObject: */
		oop = longAt((firstArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(oop, self)));
		longAtput((oop + BaseHeaderSize) + (0U << (shiftForWord(self))), longAt((savedFirstFields + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(oop, self)));
		longAtput(oop, (longAt(oop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
	}
	if (oopisGreaterThanOrEqualToandLessThan(savedFirstFields, GIV(oldSpaceStart), GIV(endOfMemory), self)) {
		freeObject(savedFirstFields, self);
	}
	/* begin restoreObjectsIn:savedHashes: */
	for (i1 = 0, iLimiT = ((numSlotsOf(secondArray, self)) - 1); i1 <= iLimiT; i1 += 1) {
		if (((hash = long32At((savedHashes + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << 2)))))) > (identityHashHalfWordMask(self))) {
			if (oopisGreaterThanOrEqualToandLessThan(savedHashes, GIV(oldSpaceStart), GIV(endOfMemory), self)) {
				freeObject(savedHashes, self);
			}
			goto l5;
		}
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((secondArray + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
		/* begin setHashBitsOf:to: */
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask(self)))));
		long32Atput(oop1 + 4, ((((long32At(oop1 + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + hash);
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(oop1, self)));
		longAtput(oop1, (longAt(oop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
	}
	if (oopisGreaterThanOrEqualToandLessThan(savedHashes, GIV(oldSpaceStart), GIV(endOfMemory), self)) {
		freeObject(savedHashes, self);
	}
	l5:	/* end restoreObjectsIn:savedHashes: */;
	runLeakCheckerFor(GCModeImageSegment, self);
	assert(allObjectsUnmarked(self));
	return errCode;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:. */

	/* SpurMemoryManager>>#return:restoringObjectsIn:upTo:savedFirstFields: */
static sqInt NoDbgRegParms
returnrestoringObjectsInupTosavedFirstFields(sqInt errCode, sqInt firstArray, sqInt limitOrTag, sqInt savedFirstFields, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;

	/* begin restoreObjectsIn:upTo:savedFirstFields: */
	if (limitOrTag == -1) {
		/* begin numSlotsOf: */
		assert((classIndexOf(firstArray, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(firstArray + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(firstArray - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
	}
	else {
		numSlots = limitOrTag;
	}
	for (i = 0; i < numSlots; i += 1) {
		/* begin fetchPointer:ofObject: */
		oop = longAt((firstArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(oop, self)));
		longAtput((oop + BaseHeaderSize) + (0U << (shiftForWord(self))), longAt((savedFirstFields + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(oop, self)));
		longAtput(oop, (longAt(oop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
	}
	if (oopisGreaterThanOrEqualToandLessThan(savedFirstFields, GIV(oldSpaceStart), GIV(endOfMemory), self)) {
		freeObject(savedFirstFields, self);
	}
	runLeakCheckerFor(GCModeImageSegment, self);
	assert(allObjectsUnmarked(self));
	return errCode;
}


/*	This exists to get around a compiler bug in Apple LLVM version 7.0.0
	(clang-700.1.76) that was avoiding the second comparison of segVersion
	after the first byte swap. */

	/* SpurMemoryManager>>#reverseBytesIn32BitWordsIn: */
static void NoDbgRegParms NeverInline
reverseBytesIn32BitWordsIn(sqInt segmentWordArray, struct foo * self)
{
    sqInt addr;
    sqInt stopAddr;

	/* begin reverseBytesIn32BitWordsFrom:to: */
	stopAddr = addressAfter(segmentWordArray, self);
	addr = segmentWordArray + BaseHeaderSize;
	while (oopisLessThan(addr, stopAddr, self)) {
		long32Atput(addr, SQ_SWAP_4_BYTES((long32At(addr))));
		addr += 4;
	}
}

	/* SpurMemoryManager>>#runLeakCheckerForFreeSpace: */
static void NoDbgRegParms
runLeakCheckerForFreeSpace(sqInt gcModes, struct foo * self)
{
	if (gcModes & GCModeFreeSpace) {
		reverseDisplayFromto(16, 19, self);
		clearLeakMapAndMapAccessibleFreeSpace(self);
		asserta(checkHeapFreeSpaceIntegrity(self));
	}
}

	/* SpurMemoryManager>>#runLeakCheckerFor: */
static void NoDbgRegParms
runLeakCheckerFor(sqInt gcModes, struct foo * self)
{
	/* begin inLineRunLeakCheckerFor:excludeUnmarkedObjs:classIndicesShouldBeValid: */
	if (gcModes & checkForLeaks) {
		if (gcModes & GCModeFull) {
			reverseDisplayFromto(0, 7, self);
		}
		else {
			reverseDisplayFromto(8, 15, self);
		}
		clearLeakMapAndMapAccessibleObjects(self);
		asserta(checkHeapIntegrityclassIndicesShouldBeValid(0, 1, self));
		asserta((checkInterpreterIntegrity(self)) == 0);
		asserta(checkStackIntegrity(self));
		asserta(checkCodeIntegrity(gcModes, self));
	}
	return;
}

	/* SpurMemoryManager>>#runLeakCheckerFor:excludeUnmarkedObjs:classIndicesShouldBeValid: */
static void NoDbgRegParms
runLeakCheckerForexcludeUnmarkedObjsclassIndicesShouldBeValid(sqInt gcModes, sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid, struct foo * self)
{
	/* begin inLineRunLeakCheckerFor:excludeUnmarkedObjs:classIndicesShouldBeValid: */
	if (gcModes & checkForLeaks) {
		if (gcModes & GCModeFull) {
			reverseDisplayFromto(0, 7, self);
		}
		else {
			reverseDisplayFromto(8, 15, self);
		}
		clearLeakMapAndMapAccessibleObjects(self);
		asserta(checkHeapIntegrityclassIndicesShouldBeValid(excludeUnmarkedObjs, classIndicesShouldBeValid, self));
		asserta((checkInterpreterIntegrity(self)) == 0);
		asserta(checkStackIntegrity(self));
		asserta(checkCodeIntegrity(gcModes, self));
	}
}


/*	Run the scavenger. */

	/* SpurMemoryManager>>#scavengingGCTenuringIf: */
static void NoDbgRegParms
scavengingGCTenuringIf(sqInt tenuringCriterion, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i11;
    sqInt i2;
    sqInt probe;

	assert(GIV(remapBufferCount) == 0);
	if (!(asserta(((((eden(self)).limit)) - GIV(freeStart)) > (interpreterAllocationReserveBytes(self))))) {
		/* begin tab */
		putchar('	');
		printNum((((eden(self)).limit)) - GIV(freeStart), self);
		/* begin space */
		putchar(' ');
		printNum(interpreterAllocationReserveBytes(self), self);
		/* begin space */
		putchar(' ');
		printNum((interpreterAllocationReserveBytes(self)) - ((((eden(self)).limit)) - GIV(freeStart)), self);
		/* begin cr */
		printf("\n");
	}
	/* begin checkMemoryMap */
	assert(isYoungObject(GIV(newSpaceStart), self));
	assert(isYoungObject(GIV(newSpaceLimit) - BytesPerWord, self));
	assert(!(isOldObject(GIV(newSpaceStart), self)));
	assert(!(isOldObject(GIV(newSpaceLimit) - BytesPerWord, self)));
	assert(!(isYoungObject(GIV(newSpaceLimit), self)));
	assert(!(isYoungObject(GIV(oldSpaceStart), self)));
	assert(!(isYoungObject(GIV(endOfMemory), self)));
	assert(isOldObject(GIV(newSpaceLimit), self));
	assert(isOldObject(GIV(oldSpaceStart), self));
	assert(isOldObject(GIV(endOfMemory), self));
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	runLeakCheckerFor(GCModeNewSpace, self);
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
	}
	/* begin flushMethodCacheFrom:to: */
	probe = 0;
	for (i2 = 1; i2 <= MethodCacheEntries; i2 += 1) {
		if (!((GIV(methodCache)[probe + MethodCacheSelector]) == 0)) {
			if ((((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheSelector], GIV(newSpaceStart), self))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheSelector], GIV(newSpaceLimit), self)))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheClass], GIV(newSpaceStart), self))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheClass], GIV(newSpaceLimit), self))))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheMethod], GIV(newSpaceStart), self))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheMethod], GIV(newSpaceLimit), self)))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	/* begin flushAtCache */
	for (i11 = 1; i11 <= AtCacheTotalSize; i11 += 1) {
		GIV(atCache)[i11] = 0;
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow(self);
	doScavenge(tenuringCriterion, self);
	GIV(statScavenges) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow(self);
	GIV(statSGCDeltaUsecs) = GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statScavengeGCUsecs) += GIV(statSGCDeltaUsecs);
	GIV(statRootTableCount) = rememberedSetSize(self);
	/* begin logScavenge */
	if (GIV(scavengeLog)) {
		writeScavengeLog(self);
	}
	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	postGCUpdateDisplayBits(self);
	runLeakCheckerFor(GCModeNewSpace, self);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
}


/*	Set the dimensions of the heap, answering the start of oldSpace. edenBytes
	holds the desired ``size of eden''
	which is actually the total size of new space minus the reserve. edenBytes
	is then divided up between eden
	and the two survivor spaces, where each survivor space is a
	scavengerDenominator (one seventh) of the total. */
/*	Transcript
	cr; nextPutAll: 'heapBase: '; print: baseOfHeap; nextPut: $/; nextPutAll:
	baseOfHeap hex;
	nextPutAll: ' memLimit '; print: memLimit; nextPut: $/; nextPutAll:
	memLimit hex;
	nextPutAll: ' memEnd '; print: memEnd; nextPut: $/; nextPutAll: memEnd
	hex; cr; flush. */
/*	This is more than a little counter-intuitive. Eden must include
	interpreterAllocationReserveBytes. 
 */

	/* SpurMemoryManager>>#setHeapBase:memoryLimit:endOfMemory: */
static sqInt NoDbgRegParms NeverInline
setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualEdenBytes;
    SpurNewSpaceSpace *aNewSpace;
    usqInt limit;
    sqInt oldStart;
    sqInt p;
    sqInt reserve;
    sqInt survivorBytes;
    sqInt totalBytes;

	reserve = interpreterAllocationReserveBytes(self);
	GIV(newSpaceStart) = baseOfHeap;
	GIV(newSpaceLimit) = (baseOfHeap + GIV(edenBytes)) + reserve;
	/* begin newSpaceStart:newSpaceBytes:survivorBytes: */
	totalBytes = GIV(newSpaceLimit) - GIV(newSpaceStart);
	survivorBytes = ((((GIV(newSpaceLimit) - GIV(newSpaceStart)) - reserve) / 7 /* scavengerDenominator */) & ~7);
	actualEdenBytes = (((totalBytes - survivorBytes) - survivorBytes) & ~7);
	assert((((totalBytes - actualEdenBytes) - survivorBytes) - survivorBytes) < (allocationUnit(self)));
	(GIV(pastSpace).start = GIV(newSpaceStart));
	(GIV(pastSpace).limit = GIV(newSpaceStart) + survivorBytes);
	(GIV(futureSpace).start = (GIV(pastSpace).limit));
	(GIV(futureSpace).limit = ((GIV(pastSpace).limit)) + survivorBytes);
	(GIV(eden).start = (GIV(futureSpace).limit));
	(GIV(eden).limit = GIV(newSpaceStart) + totalBytes);
	assert((((futureSpace(self)).limit)) <= (GIV(newSpaceStart) + totalBytes));
	assert((((((eden(self)).start)) % (allocationUnit(self))) + ((((eden(self)).limit)) % (allocationUnit(self)))) == 0);
	assert((((((pastSpace(self)).start)) % (allocationUnit(self))) + ((((pastSpace(self)).limit)) % (allocationUnit(self)))) == 0);
	assert((((((futureSpace(self)).start)) % (allocationUnit(self))) + ((((futureSpace(self)).limit)) % (allocationUnit(self)))) == 0);
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	/* begin initSpaceForAllocationCheck:limit: */
	aNewSpace = ((SpurNewSpaceSpace *) ((&GIV(eden))));
	limit = (GIV(eden).limit);
	if (GIV(memory)) {
		if (checkAllocFiller(self)) {
			for (p = ((aNewSpace->start)); p < limit; p += BytesPerWord) {
				longAtput(p, p);
			}
		}
	}
	GIV(tenuringProportion) = 0.9;
	GIV(freeStart) = ((eden(self)).start);
	GIV(pastSpaceStart) = ((pastSpace(self)).start);
	GIV(oldSpaceStart) = GIV(newSpaceLimit);
	GIV(freeOldSpaceStart) = memEnd;
	GIV(endOfMemory) = memLimit;
	return baseOfHeap;
}

	/* SpurMemoryManager>>#shortPrintObjectsFrom:to: */
void
shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress, struct foo * self)
{
    sqInt oop;

	oop = objectBefore(startAddress, self);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop, self)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress, self)) {
		if (!(((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)))) {
			shortPrintOop(oop, self);
		}
		oop = objectAfter(oop, self);
	}
}


/*	Answer if the oop should be scavenged.. The method is called
	shouldRemapOop: for compatibility with ObjectMemory. */

	/* SpurMemoryManager>>#shouldRemapOop: */
sqInt
shouldRemapOop(sqInt oop, struct foo * self)
{
	return ((oop & (tagMask(self))) == 0)
	 && (shouldRemapObj(oop, self));
}

	/* SpurMemoryManager>>#sizeOfObjStack: */
static sqInt NoDbgRegParms
sizeOfObjStack(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objStackPage;
    sqInt total;

	if (objStack == GIV(nilObj)) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	total = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
	objStackPage = objStack;
	while (1) {
		/* begin fetchPointer:ofObject: */
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord(self))))));
		if (!(objStackPage != 0)) break;
		total += ObjStackLimit;
		assert((fetchPointerofObject(ObjStackTopx, objStackPage, self)) == ObjStackLimit);
	}
	return total;
}

	/* SpurMemoryManager>>#slidingCompactionInProgress */
static sqInt
slidingCompactionInProgress(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(gcPhaseInProgress) == SlidingCompactionInProgress;
}


/*	*DO NOT CONFUSE THIS WITH numSlotsOf:.
	This is an ObjectMemory compatibility method with questionable semantics.
	Answers the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

	/* SpurMemoryManager>>#slotSizeOf: */
sqInt
slotSizeOf(sqInt oop, struct foo * self)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	if (oop & (tagMask(self))) {
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord(self))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		return numSlots;
	}
	return 0;
}


/*	Return one of the objects in the specialObjectsArray */

	/* SpurMemoryManager>>#splObj: */
sqInt
splObj(sqInt index, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
}


/*	Answer the start of objOop, which is either the address of the overflow
	size word, or objOop itself, depending on the size of the object. This may
	be applied to any kind of object, normal, forwarders or free chunks. */

	/* SpurMemoryManager>>#startOfObject: */
static usqInt NoDbgRegParms
startOfObject(sqInt objOop, struct foo * self)
{
	return ((byteAt(objOop + 7)) == (numSlotsMask(self))
		? objOop - BaseHeaderSize
		: objOop);
}


/*	Part of InterpreterProxy's 1.14 API */

	/* SpurMemoryManager>>#statNumGCs */
EXPORT(sqInt)
statNumGCs(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statScavenges) + GIV(statIncrGCs)) + GIV(statFullGCs);
}


/*	A renaming for the Cogit, which couldn't make sense of GIV(newSpaceLimit) */

	/* SpurMemoryManager>>#storeCheckBoundary */
usqInt
storeCheckBoundary(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newSpaceLimit);
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
	This primitive will store a binary image segment (in the same format as
	objects in the heap) of the
	set of objects in arrayOfObjects. All pointers from within the set to
	objects outside the set will be
	copied into the array of outPointers. In their place in the image segment
	will be an oop equal to the
	offset in the outPointer array (the first would be 8), but with the high
	bit set.
	
	Since Spur has a class table the load primitive must insert classes that
	have instances into the
	class table. This primitive marks such classes using the isRemembered bit,
	which isn't meaningful
	as a remembered bit in the segment.
	
	The primitive expects the segmentWordArray and outPointerArray to be more
	than adequately long.
	In this case it returns normally, and truncates the two arrays to exactly
	the right size.
	
	The primitive can fail for the following reasons with the specified
	failure codes:
	PrimErrGenericError:		the segmentWordArray is too small for the version
	stamp PrimErrWritePastObject:	the segmentWordArray is too small to contain
	the reachable objects
	PrimErrBadIndex:			the outPointerArray is too small
	PrimErrNoMemory:			additional allocations failed
	PrimErrLimitExceeded:		there is no room in the hash field to store out
	pointer indices or class references. */

	/* SpurMemoryManager>>#storeImageSegmentInto:outPointers:roots: */
static sqInt NoDbgRegParms
storeImageSegmentIntooutPointersroots(sqInt segmentWordArrayArg, sqInt outPointerArrayArg, sqInt arrayOfRootsArg, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfObjects;
    sqInt arrayOfRoots;
    sqInt classIndex;
    sqInt classIndex1;
    usqInt endSeg;
    sqInt fillValue;
    sqInt formatField;
    sqInt formatField1;
    sqInt hash;
    sqInt here;
    sqInt i;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt nClasses;
    usqInt newObj;
    usqInt newObj1;
    sqInt newSegAddrOrError;
    usqInt numBytes;
    usqInt numBytes1;
    sqInt numBytes2;
    sqInt numClassesInSegment;
    sqInt numSlots;
    sqInt numSlots1;
    sqInt numSlots2;
    sqInt numSlots3;
    usqInt numSlots4;
    usqInt numSlots5;
    usqInt numSlots6;
    sqInt objOop;
    sqInt objOop1;
    sqInt outIndex;
    sqInt outPointerArray;
    usqInt p;
    usqInt p1;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt savedFirstFields;
    sqInt savedOutHashes;
    usqInt segAddr;
    sqInt segmentWordArray;
    usqInt segStart;
    sqInt tempObjOop;
    sqInt there;

	if ((
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(segmentWordArrayArg))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		)
	 || (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(outPointerArrayArg))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		)) {
		return PrimErrNoModification;
	}
	if ((((((usqInt) (longAt(segmentWordArrayArg))) >> (pinnedBitShift(self))) & 1) != 0)
	 || (((((usqInt) (longAt(outPointerArrayArg))) >> (pinnedBitShift(self))) & 1) != 0)) {
		return PrimErrObjectIsPinned;
	}
	if ((numSlotsOf(outPointerArrayArg, self)) > (identityHashHalfWordMask(self))) {
		return PrimErrLimitExceeded;
	}
	runLeakCheckerFor(GCModeImageSegment, self);
	/* begin scavengingGC */
	scavengingGCTenuringIf(TenureByAge, self);
	if (((longAt(segmentWordArrayArg)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(segmentWordArrayArg, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((segmentWordArrayArg + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		segmentWordArray = referent;
	}
	else {
		segmentWordArray = segmentWordArrayArg;
	}
	if (((longAt(outPointerArrayArg)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(outPointerArrayArg, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent1 = longAt((outPointerArrayArg + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent1 & (tagMask(self))) == 0)
		 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		outPointerArray = referent1;
	}
	else {
		outPointerArray = outPointerArrayArg;
	}
	if (((longAt(arrayOfRootsArg)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(arrayOfRootsArg, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent2 = longAt((arrayOfRootsArg + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent2 & (tagMask(self))) == 0)
		 && (((longAt(referent2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		arrayOfRoots = referent2;
	}
	else {
		arrayOfRoots = arrayOfRootsArg;
	}
	assert(!((forwardersIn(outPointerArray, self))));
	assert(!((forwardersIn(arrayOfRoots, self))));
	arrayOfObjects = objectsReachableFromRoots(arrayOfRoots, self);
	if (!(arrayOfObjects)) {
		return PrimErrNoMemory;
	}
	if ((((arrayOfObjects) & 7) == 1)) {
		if ((GIV(totalFreeOldSpace) - 8 /* allocationUnit */) >= ((arrayOfObjects >> 3))) {
			return PrimErrNeedCompaction;
		}
		return PrimErrNoMemory;
	}
	assert(allObjectsUnmarked(self));
	assert(!((forwardersIn(arrayOfObjects, self))));
	/* begin moveClassesForwardsIn: */

	/* if > 0, this is the index of the first non-class past the first element. */
	nClasses = (there = 0);
	for (here = 1, iLimiT1 = ((numSlotsOf(arrayOfObjects, self)) - 1); here <= iLimiT1; here += 1) {
		/* begin fetchPointer:ofObject: */
		objOop1 = longAt((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(here) << (shiftForWord(self))))));
		hash = (long32At(objOop1 + 4)) & (identityHashHalfWordMask(self));
		if ((hash > (lastClassIndexPun(self)))
		 && ((classOrNilAtIndex(hash, self)) == objOop1)) {
			nClasses += 1;
			if (there > 0) {

				/* if there is zero we're in a run of classes at the start so don't move */
				/* begin fetchPointer:ofObject: */
				tempObjOop = longAt((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(there) << (shiftForWord(self))))));
				assert(!(isOopForwarded(arrayOfObjects, self)));
				longAtput((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(there) << (shiftForWord(self))))), objOop1);
				assert(!(isOopForwarded(arrayOfObjects, self)));
				longAtput((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(here) << (shiftForWord(self))))), tempObjOop);
				there += 1;
			}
		}
		else {
			if (there == 0) {
				there = here;
			}
		}
	}
	numClassesInSegment = nClasses;
	/* begin allocateSlots:format:classIndex: */
	assert((classIndexOf(arrayOfObjects, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots6 = byteAt(arrayOfObjects + 7);
	numSlots2 = (numSlots6 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(arrayOfObjects - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots6);
	formatField = sixtyFourBitIndexableFormat(self);
	classIndex = sixtyFourBitLongsClassIndexPun(self);
	if (numSlots2 >= (numSlotsMask(self))) {
		if ((((usqInt) numSlots2) >> 56) > 0) {
			savedFirstFields = null;
			goto l17;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots2 * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots2 < 1
	? /* begin allocationUnit */ 8
	: numSlots2 * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		savedFirstFields = allocateSlotsInOldSpacebytesformatclassIndex(numSlots2, numBytes, formatField, classIndex, self);
		goto l17;
	}
	if (numSlots2 >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots2);
		longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(self), formatField, classIndex, self));
	}
	else {
		longAtput(newObj, (((((usqLong) numSlots2)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + classIndex);
	}
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	GIV(freeStart) += numBytes;
	savedFirstFields = newObj;
	l17:	/* end allocateSlots:format:classIndex: */;
	/* begin allocateSlots:format:classIndex: */
	numBytes2 = (numSlotsOf(outPointerArray, self)) * 4;
	numSlots3 = (numBytes2 + (BytesPerWord - 1)) / BytesPerWord;
	formatField1 = firstLongFormat(self);
	classIndex1 = thirtyTwoBitLongsClassIndexPun(self);
	if (numSlots3 >= (numSlotsMask(self))) {
		if ((((usqInt) numSlots3) >> 56) > 0) {
			savedOutHashes = null;
			goto l19;
		}
		newObj1 = GIV(freeStart) + BaseHeaderSize;
		numBytes1 = (BaseHeaderSize + BaseHeaderSize) + (numSlots3 * BytesPerOop);
	}
	else {
		newObj1 = GIV(freeStart);
		numBytes1 = BaseHeaderSize + ((numSlots3 < 1
	? /* begin allocationUnit */ 8
	: numSlots3 * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		savedOutHashes = allocateSlotsInOldSpacebytesformatclassIndex(numSlots3, numBytes1, formatField1, classIndex1, self);
		goto l19;
	}
	if (numSlots3 >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots3);
		longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(self), formatField1, classIndex1, self));
	}
	else {
		longAtput(newObj1, (((((usqLong) numSlots3)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField1) << (formatShift(self)))))) + classIndex1);
	}
	assert((numBytes1 % (allocationUnit(self))) == 0);
	assert((newObj1 % (allocationUnit(self))) == 0);
	GIV(freeStart) += numBytes1;
	savedOutHashes = newObj1;
	l19:	/* end allocateSlots:format:classIndex: */;
	if ((savedFirstFields == null)
	 || (savedOutHashes == null)) {
		freeObject(arrayOfObjects, self);
		if ((savedFirstFields != null)
		 && (oopisGreaterThanOrEqualToandLessThan(savedFirstFields, GIV(oldSpaceStart), GIV(endOfMemory), self))) {
			freeObject(savedFirstFields, self);
		}
		if ((savedOutHashes != null)
		 && (oopisGreaterThanOrEqualToandLessThan(savedOutHashes, GIV(oldSpaceStart), GIV(endOfMemory), self))) {
			freeObject(savedOutHashes, self);
		}
		return PrimErrNoMemory;
	}
	/* begin fillObj:numSlots:with: */
	assert((classIndexOf(savedFirstFields, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots4 = byteAt(savedFirstFields + 7);
	numSlots = (numSlots4 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(savedFirstFields - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots4);
	assert(oopisLessThan(((savedFirstFields + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(savedFirstFields, self), self));
	for (p = (((usqInt)(savedFirstFields + BaseHeaderSize))); p <= (((usqInt)(((savedFirstFields + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
		longAtput(p, 0);
	}
	/* begin fillObj:numSlots:with: */
	assert((classIndexOf(savedOutHashes, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots5 = byteAt(savedOutHashes + 7);
	numSlots1 = (numSlots5 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(savedOutHashes - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots5);
	fillValue = (((sqInt)((usqInt)(((identityHashHalfWordMask(self)) + 1)) << 32))) + ((identityHashHalfWordMask(self)) + 1);
	assert(oopisLessThan(((savedOutHashes + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1, addressAfter(savedOutHashes, self), self));
	for (p1 = (((usqInt)(savedOutHashes + BaseHeaderSize))); p1 <= (((usqInt)(((savedOutHashes + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1))); p1 += 8 /* allocationUnit */) {
		longAtput(p1, fillValue);
	}
	segAddr = segmentWordArray + BaseHeaderSize;

	/* Write a version number for byte order and version check. */
	endSeg = addressAfter(segmentWordArray, self);
	if (segAddr >= endSeg) {
		return PrimErrGenericFailure;
	}
	long32Atput(segAddr, imageSegmentVersion(self));
	long32Atput(segAddr + 4, imageSegmentVersion(self));
	segStart = (segAddr += 8 /* allocationUnit */);
	assert(arrayOfRoots == (fetchPointerofObject(0, arrayOfObjects, self)));
	for (i = 0, iLimiT = ((numSlotsOf(arrayOfObjects, self)) - 1); i <= iLimiT; i += 1) {
		if ((i == numClassesInSegment)
		 && ((((segAddr - segStart) / 8 /* allocationUnit */) + (lastClassIndexPun(self))) >= TopHashBit)) {
			return returnrestoringObjectsInupTosavedFirstFields(PrimErrLimitExceeded, arrayOfObjects, i, savedFirstFields, self);
		}
		/* begin fetchPointer:ofObject: */
		objOop = longAt((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		assert(!(((isImmediate(objOop, self))
 || (isForwarded(objOop, self)))));
		newSegAddrOrError = copyObjtoAddrstopAtsavedFirstFieldsindex(objOop, segAddr, endSeg, savedFirstFields, i, self);
		if (oopisLessThan(newSegAddrOrError, segStart, self)) {
			return returnrestoringObjectsInupTosavedFirstFields(newSegAddrOrError, arrayOfObjects, i, savedFirstFields, self);
		}
		segAddr = newSegAddrOrError;
	}
	if ((endSeg != segAddr)
	 && ((endSeg - segAddr) < (BaseHeaderSize + BytesPerOop))) {
		return returnrestoringObjectsInupTosavedFirstFields(PrimErrWritePastObject, arrayOfObjects, -1, savedFirstFields, self);
	}
	if (((outIndex = mapOopsFromtooutPointersoutHashes(segStart, segAddr, outPointerArray, savedOutHashes, self))) < 0) {

		/* no room in outPointers; fail */
		return returnrestoringObjectsInsavedFirstFieldsandsavedHashes(PrimErrBadIndex, arrayOfObjects, savedFirstFields, outPointerArray, savedOutHashes, self);
	}
	shortentoIndexableSize(segmentWordArray, (segAddr - (segmentWordArray + BaseHeaderSize)) / 4, self);
	shortentoIndexableSize(outPointerArray, outIndex, self);
	return returnrestoringObjectsInsavedFirstFieldsandsavedHashes(PrimNoErr, arrayOfObjects, savedFirstFields, outPointerArray, savedOutHashes, self);
}

	/* SpurMemoryManager>>#storePointerUnchecked:ofObject:withValue: */
sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer, struct foo * self)
{
	assert(!(isOopForwarded(objOop, self)));
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */

	/* SpurMemoryManager>>#storePointer:ofObject:withValue: */
sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isForwarded(objOop, self)));
	if ((assert(isNonImmediate(objOop, self)),
	oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((valuePointer & (tagMask(self))) == 0)
		 && (oopisLessThan(valuePointer, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(objOop, self);
			}
		}
	}
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), valuePointer);
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory. */

	/* SpurMemoryManager>>#stringForCString: */
sqInt
stringForCString(const char *aCString, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt formatField;
    sqInt len;
    usqInt newObj;
    sqInt newString;
    usqInt numBytes;
    sqInt numSlots;

	len = strlen(aCString);
	/* begin allocateSlots:format:classIndex: */
	numSlots = (len + (BytesPerWord - 1)) / BytesPerWord;
	formatField = (firstByteFormat(self)) + ((8 - len) & (BytesPerWord - 1));
	if (numSlots >= (numSlotsMask(self))) {
		if ((((usqInt) numSlots) >> 56) > 0) {
			newString = null;
			goto l2;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? /* begin allocationUnit */ 8
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		newString = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, ClassByteStringCompactIndex, self);
		goto l2;
	}
	if (numSlots >= (numSlotsMask(self))) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask(self))) << (numSlotsFullShift(self))))) + numSlots);
		longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(self), formatField, ClassByteStringCompactIndex, self));
	}
	else {
		longAtput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(formatField) << (formatShift(self)))))) + ClassByteStringCompactIndex);
	}
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	GIV(freeStart) += numBytes;
	newString = newObj;
	l2:	/* end allocateSlots:format:classIndex: */;
	if (newString) {
		strncpy(((char *) (newString + BaseHeaderSize)), aCString, len);
	}
	return newString;
}


/*	This is ObjectMemory's funky entry-point into its incremental GC,
	which is a stop-the-world a young generation reclaimer. In Spur
	we run the scavenger. Answer if space is not low. */

	/* SpurMemoryManager>>#sufficientSpaceAfterGC: */
static sqInt NoDbgRegParms
sufficientSpaceAfterGC(sqInt numBytes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt heapSizePostGC;

	assert(numBytes == 0);
	scavengingGCTenuringIf(TenureByAge, self);
	heapSizePostGC = (GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize))) - GIV(totalFreeOldSpace);
	if (((((double) (heapSizePostGC - GIV(heapSizeAtPreviousGC)) )) / GIV(heapSizeAtPreviousGC)) >= GIV(heapGrowthToSizeGCRatio)) {
		fullGC(self);
	}
	while ((GIV(totalFreeOldSpace) < GIV(growHeadroom))
	 && ((growOldSpaceByAtLeast(0, self)) != null)) {
		if (GIV(totalFreeOldSpace) >= GIV(growHeadroom)) {
			return 1;
		}
	}
	if (GIV(lowSpaceThreshold) > GIV(totalFreeOldSpace)) {

		/* space is low */

		/* avoid signalling low space twice */
		GIV(lowSpaceThreshold) = 0;
		return 0;
	}
	return 1;
}


/*	On load, swizzle the pointers in an obj stack. Answer the obj stack's oop. */

	/* SpurMemoryManager>>#swizzleObjStackAt: */
static sqInt NoDbgRegParms
swizzleObjStackAt(sqInt objStackRootIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt page;
    sqInt stackOrNil;

	firstPage = (stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord(self)))))));
	if (stackOrNil == GIV(nilObj)) {
		return stackOrNil;
	}
	do {
		assert((numSlotsOfAny(stackOrNil, self)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil, self)) == objStackRootIndex);

		/* swizzle fields including ObjStackNextx, excluding ObjStackFreex and leave field containing the next link. */
		index = (longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))))) + ObjStackNextx;
		do {
			/* begin fetchPointer:ofObject: */
			field = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
			if (!((field == 0)
				 || (field & (tagMask(self))))) {
				field = swizzleObj(field, self);
				/* begin storePointer:ofObjStack:withValue: */
				assert((formatOf(stackOrNil, self)) == (wordIndexableFormat(self)));
				longAtput((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))), field);
			}
		} while(((index -= 1)) >= ObjStackNextx);
	} while(((stackOrNil = field)) != 0);
	if (((stackOrNil = longAt((firstPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self)))))))) != 0) {
		page = firstPage;
		do {
			stackOrNil = swizzleObj(stackOrNil, self);
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(page, self)) == (wordIndexableFormat(self)));
			longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self))))), stackOrNil);
			page = stackOrNil;
		} while(((stackOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord(self)))))))) != 0);
	}
	assert(isValidObjStackAt(objStackRootIndex, self));
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord(self))))));
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. 
 */

	/* SpurMemoryManager>>#tenuringIncrementalGC */
void
tenuringIncrementalGC(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;

	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge, self);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize(self)) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace(self)).start)));
	assert(GIV(freeStart) == (((eden(self)).start)));
}


/*	This assert is tricky. push:onObjStack: may call topOfObjStack: just after
	pushing an
	empty page on the stack, and will ask if the second page is valid. */

	/* SpurMemoryManager>>#topOfObjStack: */
static sqInt NoDbgRegParms
topOfObjStack(sqInt objStack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt topx;


	/* This assert is tricky.  push:onObjStack: may call topOfObjStack: just after pushing an
	   empty page on the stack, and will ask if the second page is valid. */
	eassert(isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack, self), objStack == (fetchPointerofObject(fetchPointerofObject(ObjStackMyx, objStack, self), GIV(hiddenRootsObj), self)), self));
	/* begin fetchPointer:ofObject: */
	topx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord(self))))));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack, self)) == 0);
		return null;
	}
	/* begin fetchPointer:ofObject: */
	return longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(((topx + ObjStackFixedSlots) - 1)) << (shiftForWord(self))))));
}


/*	Answers the top of the remappable oop stack. Useful when writing loops.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#topRemappableOop */
sqInt
topRemappableOop(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}


/*	This method both computes the actual number of free bytes by traversing
	all free objects
	on the free lists/tree, and checks that the tree is valid. It is used
	mainly by checkFreeSpace. */

	/* SpurMemoryManager>>#totalFreeListBytes */
static sqInt
totalFreeListBytes(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesInChunk;
    sqInt cameFrom;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex11;
    sqInt fieldIndex2;
    sqInt fieldIndex3;
    sqInt i;
    sqInt iLimiT;
    sqInt largeChild;
    sqInt listNode;
    sqInt nextNode;
    sqInt smallChild;
    sqInt totalFreeBytes;
    sqInt treeNode1;

	totalFreeBytes = 0;
	for (i = 1, iLimiT = (64 /* numFreeLists */ - 1); i <= iLimiT; i += 1) {
		bytesInChunk = i * 8 /* allocationUnit */;
		listNode = GIV(freeLists)[i];
		while (listNode != 0) {
			totalFreeBytes += bytesInChunk;
			/* begin assertValidFreeObject: */
			assert(assertInnerValidFreeObject(listNode, self));
			assert(bytesInChunk == (bytesInObject(listNode, self)));
			/* begin fetchPointer:ofFreeChunk: */
			fieldIndex = 0 /* freeChunkNextIndex */;
			nextNode = longAt((listNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
			assert(nextNode != listNode);
			listNode = nextNode;
		}
	}
	/* begin freeTreeNodesDo: */
	treeNode1 = GIV(freeLists)[0];
	if (treeNode1 == 0) {
		goto l6;
	}
	cameFrom = -1;
	do {
		assert((bytesInObject(treeNode1, self)) >= ((numFreeLists(self)) * (allocationUnit(self))));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex11 = 3 /* freeChunkSmallerIndex */;
		smallChild = longAt((treeNode1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex11) << (shiftForWord(self))))));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex2 = 4 /* freeChunkLargerIndex */;
		largeChild = longAt((treeNode1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))));
		assert((smallChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(self), smallChild, self))));
		assert((largeChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(self), largeChild, self))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */
			bytesInChunk = bytesInObject(treeNode1, self);
			assert((bytesInChunk / (allocationUnit(self))) >= (numFreeLists(self)));
			listNode = treeNode1;
			while (listNode != 0) {

				/* self printFreeChunk: listNode */
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(listNode, self));
				assert((listNode == treeNode1)
				 || ((fetchPointerofFreeChunk(freeChunkParentIndex(self), listNode, self)) == 0));
				totalFreeBytes += bytesInChunk;
				assert(bytesInChunk == (bytesInObject(listNode, self)));
				/* begin fetchPointer:ofFreeChunk: */
				fieldIndex1 = 0 /* freeChunkNextIndex */;
				nextNode = longAt((listNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
				assert(nextNode != listNode);
				listNode = nextNode;
			}
			treeNode1 = treeNode1;
			cameFrom = treeNode1;
			/* begin fetchPointer:ofFreeChunk: */
			fieldIndex3 = 2 /* freeChunkParentIndex */;
			treeNode1 = longAt((treeNode1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex3) << (shiftForWord(self))))));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode1 = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode1 = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode1 != 0);
	l6:	/* end freeTreeNodesDo: */;
	return totalFreeBytes;
}

	/* SpurMemoryManager>>#trueObject */
sqInt
trueObject(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}


/*	Unlink a free object from the free lists. Do not alter totalFreeOldSpace.
	Used for coalescing.
 */

	/* SpurMemoryManager>>#unlinkFreeChunk:chunkBytes: */
static sqInt NoDbgRegParms
unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    sqInt index;
    sqInt next;
    sqInt next1;
    sqInt nextFreeChunk;
    sqInt prev;


	/* Pathological 64 bits case - size 1 - single linked list */
	index = chunkBytes / 8 /* allocationUnit */;
	if ((assert(chunkBytes >= (BaseHeaderSize + (allocationUnit(self)))),
	chunkBytes == (BaseHeaderSize + 8 /* allocationUnit */))) {
		return unlinkLilliputianChunkindex(freeChunk, index, self);
	}
	/* begin fetchPointer:ofFreeChunk: */
	fieldIndex = 1 /* freeChunkPrevIndex */;
	prev = longAt((freeChunk + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	if (prev != 0) {
		/* begin setNextFreeChunkOf:withValue:chunkBytes: */
		nextFreeChunk = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))));
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		assert(isFreeObject(prev, self));
		assert((nextFreeChunk == 0)
		 || (isFreeObject(nextFreeChunk, self)));
		longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord(self))), nextFreeChunk);
		if ((nextFreeChunk != 0)
		 && (!((assert(chunkBytes >= (BaseHeaderSize + (allocationUnit(self)))),
		chunkBytes == (BaseHeaderSize + 8 /* allocationUnit */))))) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk, self));
			assert((prev == 0)
			 || (isFreeObject(prev, self)));
			longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord(self))), prev);
		}
		return freeChunk;
	}
	if ((index < 64 /* numFreeLists */)
	 && ((1ULL << index) <= GIV(freeListsMask))) {
		/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
		assert(((bytesInObject(freeChunk, self)) == (index * (allocationUnit(self))))
		 && ((index > 1)
		 && ((startOfObject(freeChunk, self)) == freeChunk)));
		GIV(freeLists)[index] = ((next1 = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))))));
		if (next1 != 0) {
			/* begin storePointer:ofFreeChunk:withValue: */
			fieldIndex2 = 1 /* freeChunkPrevIndex */;
			assert(isFreeObject(next1, self));
			assert(1);
			longAtput((next1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))), 0);
		}
		return freeChunk;
	}
	/* begin fetchPointer:ofFreeChunk: */
	fieldIndex1 = 0 /* freeChunkNextIndex */;
	next = longAt((freeChunk + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
	if (next == 0) {

		/* no list; remove the interior node */
		unlinkSolitaryFreeTreeNode(freeChunk, self);
	}
	else {

		/* list; replace node with it */
		inFreeTreeReplacewith(freeChunk, next, self);
	}
	return freeChunk;
}

	/* SpurMemoryManager>>#unlinkLilliputianChunk:index: */
static sqInt NoDbgRegParms NeverInline
unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt next;
    sqInt next1;
    sqInt node;
    sqInt prev;

	node = GIV(freeLists)[index];
	prev = 0;
	while (node != 0) {
		assert(node == (startOfObject(node, self)));
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(node, self));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex = 0 /* freeChunkNextIndex */;
		next = longAt((node + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
		if (node == freeChunk) {
			if (prev == 0) {
				/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
				assert(((bytesInObject(freeChunk, self)) == (index * (allocationUnit(self))))
				 && ((index > 1)
				 && ((startOfObject(freeChunk, self)) == freeChunk)));
				GIV(freeLists)[index] = ((next1 = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord(self))))));
							}
			else {
				/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
				assert(isFreeObject(prev, self));
				assert((next == 0)
				 || (isFreeObject(next, self)));
				longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord(self))), next);
							}
			return freeChunk;
		}
		prev = node;
		node = next;
	}
	error("freeChunk not found in lilliputian chunk free list");
	return 0;
}


/*	Unlink a freeTreeNode. Assumes the node has no list (null next link). */

	/* SpurMemoryManager>>#unlinkSolitaryFreeTreeNode: */
static void NoDbgRegParms
unlinkSolitaryFreeTreeNode(sqInt freeTreeNode, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    sqInt fieldIndex3;
    sqInt fieldIndex4;
    sqInt fieldIndex5;
    sqInt fieldIndex6;
    sqInt fieldIndex7;
    sqInt fieldIndex8;
    sqInt larger;
    sqInt parent;
    sqInt smaller;

	assert((fetchPointerofFreeChunk(freeChunkNextIndex(self), freeTreeNode, self)) == 0);
	/* begin fetchPointer:ofFreeChunk: */
	fieldIndex6 = 3 /* freeChunkSmallerIndex */;
	smaller = longAt((freeTreeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex6) << (shiftForWord(self))))));
	/* begin fetchPointer:ofFreeChunk: */
	fieldIndex7 = 4 /* freeChunkLargerIndex */;
	larger = longAt((freeTreeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex7) << (shiftForWord(self))))));
	/* begin fetchPointer:ofFreeChunk: */
	fieldIndex8 = 2 /* freeChunkParentIndex */;
	parent = longAt((freeTreeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex8) << (shiftForWord(self))))));
	if (parent == 0) {

		/* no parent; stitch the subnodes back into the root */
		if (smaller == 0) {
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				fieldIndex = 2 /* freeChunkParentIndex */;
				assert(isFreeObject(larger, self));
				assert(1);
				longAtput((larger + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), 0);
			}
			GIV(freeLists)[0] = larger;
		}
		else {
			/* begin storePointer:ofFreeChunk:withValue: */
			fieldIndex1 = 2 /* freeChunkParentIndex */;
			assert(isFreeObject(smaller, self));
			assert(1);
			longAtput((smaller + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))), 0);
			GIV(freeLists)[0] = smaller;
			if (larger != 0) {
				addFreeSubTree(larger, self);
			}
		}
	}
	else {

		/* parent; stitch back into appropriate side of parent. */
		if (smaller == 0) {
			/* begin storePointer:ofFreeChunk:withValue: */
			if (freeTreeNode == (longAt((parent + BaseHeaderSize) + (3U << (shiftForWord(self)))))) {
				/* begin freeChunkSmallerIndex */
				fieldIndex3 = 3;
			}
			else {
				/* begin freeChunkLargerIndex */
				fieldIndex3 = 4;
			}
			assert(isFreeObject(parent, self));
			assert((larger == 0)
			 || (isFreeObject(larger, self)));
			longAtput((parent + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex3) << (shiftForWord(self))))), larger);
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				fieldIndex2 = 2 /* freeChunkParentIndex */;
				assert(isFreeObject(larger, self));
				assert((parent == 0)
				 || (isFreeObject(parent, self)));
				longAtput((larger + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))), parent);
			}
		}
		else {
			/* begin storePointer:ofFreeChunk:withValue: */
			if (freeTreeNode == (longAt((parent + BaseHeaderSize) + (3U << (shiftForWord(self)))))) {
				/* begin freeChunkSmallerIndex */
				fieldIndex4 = 3;
			}
			else {
				/* begin freeChunkLargerIndex */
				fieldIndex4 = 4;
			}
			assert(isFreeObject(parent, self));
			assert((smaller == 0)
			 || (isFreeObject(smaller, self)));
			longAtput((parent + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex4) << (shiftForWord(self))))), smaller);
			/* begin storePointer:ofFreeChunk:withValue: */
			fieldIndex5 = 2 /* freeChunkParentIndex */;
			assert(isFreeObject(smaller, self));
			assert((parent == 0)
			 || (isFreeObject(parent, self)));
			longAtput((smaller + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex5) << (shiftForWord(self))))), parent);
			if (larger != 0) {
				addFreeSubTree(larger, self);
			}
		}
	}
}

	/* SpurMemoryManager>>#unpinObject: */
sqInt
unpinObject(sqInt objOop, struct foo * self)
{
	assert(isNonImmediate(objOop, self));
	/* begin setIsPinnedOf:to: */
	longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (pinnedBitShift(self)))));
	return 0;
}

	/* SpurMemoryManager>>#updateListStartingAt: */
static void NoDbgRegParms
updateListStartingAt(sqInt freeNode, struct foo * self)
{
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    sqInt obj;
    sqInt prev;

	if (freeNode == 0) {
		return;
	}
	assert(!((isLilliputianSize(bytesInObject(freeNode, self), self))));
	prev = freeNode;
	/* begin storePointer:ofFreeChunk:withValue: */
	fieldIndex2 = 1 /* freeChunkPrevIndex */;
	assert(isFreeObject(prev, self));
	assert(1);
	longAtput((prev + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))), 0);
	while (1) {
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex = 0 /* freeChunkNextIndex */;
		obj = longAt((prev + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
		if (!(obj != 0)) break;
		/* begin storePointer:ofFreeChunk:withValue: */
		fieldIndex1 = 1 /* freeChunkPrevIndex */;
		assert(isFreeObject(obj, self));
		assert((prev == 0)
		 || (isFreeObject(prev, self)));
		longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))), prev);
		prev = obj;
	}
}


/*	Check the hashes of classes in the table. The tricky thing here is that
	classes may be duplicated
	in the table. So each entry must be in the table at its hash, even if it
	is elsewhere in the table. */

	/* SpurMemoryManager>>#validClassTableHashes */
static sqInt
validClassTableHashes(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil1;
    sqInt hash;
    sqInt i;
    sqInt ignored;
    sqInt iLimiT;
    sqInt j;
    sqInt page;

	if (!(validClassTableRootPages(self))) {
		return 0;
	}
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		for (j = 0, iLimiT = ((1U << (classTableMajorIndexShift(self))) - 1); j <= iLimiT; j += 1) {
			classOrNil1 = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord(self))))));
			if (classOrNil1 != GIV(nilObj)) {
				ignored = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift(self))))) + j;
				if (((longAt(classOrNil1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					return 0;
				}
				/* begin rawHashBitsOf: */
				hash = (long32At(classOrNil1 + 4)) & (identityHashHalfWordMask(self));
				if (hash == 0) {
					return 0;
				}
				if ((noCheckClassAtIndex(hash, self)) != classOrNil1) {
					return 0;
				}
			}
		}
	}
	return 1;
}


/*	Answer if hiddenRootsObj is of the right size with the
	expected contents, and if numClassTablePages is correct. */

	/* SpurMemoryManager>>#validClassTableRootPages */
static sqInt
validClassTableRootPages(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt obj;

	if (!((numSlotsOf(GIV(hiddenRootsObj), self)) == ((1U << (22 /* classIndexFieldWidth */ - (classTableMajorIndexShift(self)))) + 8 /* hiddenRootSlots */))) {
		return 0;
	}
	if (!((GIV(numClassTablePages) > 1)
		 && (GIV(numClassTablePages) <= (1U << (22 /* classIndexFieldWidth */ - (classTableMajorIndexShift(self))))))) {
		return 0;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		/* begin fetchPointer:ofObject: */
		obj = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if (!((addressCouldBeObj(obj, self))
			 && ((numSlotsOf(obj, self)) == (1U << (classTableMajorIndexShift(self)))))) {
			return 0;
		}
	}
	for (i = GIV(numClassTablePages), iLimiT = ((1U << (22 /* classIndexFieldWidth */ - (classTableMajorIndexShift(self)))) - 1); i <= iLimiT; i += 1) {
		if ((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))))) != GIV(nilObj)) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#validFreeTree */
sqInt
validFreeTree(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (validFreeTreeChunkparent(GIV(freeLists)[0], 0, self)) == null;
}

	/* SpurMemoryManager>>#validFreeTreeChunk: */
static sqInt NoDbgRegParms
validFreeTreeChunk(sqInt chunk, struct foo * self)
{
	if (!(segmentContainingObj(chunk, self))) {
		return 0;
	}
	return (validFreeTreeChunkparent(chunk, longAt((chunk + BaseHeaderSize) + (2U << (shiftForWord(self)))), self)) == null;
}

	/* SpurMemoryManager>>#validFreeTreeChunk:parent: */
static const char * NoDbgRegParms
validFreeTreeChunkparent(sqInt chunk, sqInt parent, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    const char *reason;

	if (chunk == 0) {
		return null;
	}
	if (!(((chunk & (BaseHeaderSize - 1)) == 0)
		 && (oopisGreaterThanOrEqualToandLessThan(chunk, GIV(oldSpaceStart), GIV(endOfMemory), self)))) {
		return "not in old space";
	}
	if (((bytesInObject(chunk, self)) / 8 /* allocationUnit */) < 64 /* numFreeLists */) {
		return "too small";
	}
	if (parent != (longAt((chunk + BaseHeaderSize) + (2U << (shiftForWord(self)))))) {
		return "bad parent";
	}
	if ((segmentContainingObj(chunk, self)) != (segmentContainingObj(addressAfter(chunk, self), self))) {
		return "not in one segment";
	}
	reason = validFreeTreeChunkparent(longAt((chunk + BaseHeaderSize) + (3U << (shiftForWord(self)))), chunk, self);
	if (!(reason == null)) {
		return reason;
	}
	reason = validFreeTreeChunkparent(longAt((chunk + BaseHeaderSize) + (4U << (shiftForWord(self)))), chunk, self);
	if (!(reason == null)) {
		return reason;
	}
	return null;
}

	/* SpurMemoryManager>>#validObjStacks */
static sqInt
validObjStacks(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(markStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(markStack), self)))
	 && (((GIV(weaklingStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(weaklingStack), self)))
	 && ((GIV(mournQueue) == GIV(nilObj))
	 || (isValidObjStack(GIV(mournQueue), self))));
}


/*	1 = big, 0 = little */

	/* SpurMemoryManager>>#vmEndianness */
sqInt
vmEndianness(struct foo * self)
{
	return VMBIGENDIAN;
}


/*	Sweep all of old space, sliding unpinned marked objects down over free and
	unmarked objects.
	Let the segmentManager mark which segments contain pinned objects via
	notePinned:. 
 */

	/* SpurPlanningCompactor>>#compact */
static void NeverInline
compact(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt finalPass;
    sqInt firstPass;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt highestSuitableFreeBlock;
    sqInt i;
    sqInt iLimiT;
    sqInt largestFreeChunk;
    sqInt largestFreeChunk1;
    sqInt largestFreeChunk2;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop111;
    sqInt objOop12;
    sqInt objOop13;
    sqInt objOop31;
    sqInt objOop4;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj2;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj2;
    sqInt sizeOfEden;
    sqInt spaceEstimate;
    sqInt spaceEstimate1;

	if (initializeScanCheckingForFullyCompactedHeap(self)) {
		/* begin unmarkObjectsInFullyCompactedHeap */
		assert(isOldObject(GIV(nilObj), self));
		prevPrevObj1 = (prevObj1 = null);
		objOop11 = GIV(nilObj);
		while (1) {
			assert((objOop11 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
			assert((long64At(objOop11)) != 0);
			if (isEnumerableObject(objOop11, self)) {
				if (oopisGreaterThanOrEqualTo(objOop11, GIV(firstMobileObject), self)) {
					goto l4;
				}
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop11, self)));
				longAtput(objOop11, (longAt(objOop11)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			prevPrevObj1 = prevObj1;
			prevObj1 = objOop11;
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop11, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory), self)) {
				objOop11 = GIV(endOfMemory);
				goto l3;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop11 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l3:	/* end objectAfter:limit: */;
		}
	l4:	/* end unmarkInitialImmobileObjects */;
		/* begin unmarkSurvivingObjectsForCompact */
		prevPrevObj = (prevObj = null);
		/* begin objectStartingAt: */
		address = ((pastSpace(self)).start);
		numSlots = byteAt(address + 7);
		objOop1 = (numSlots == (numSlotsMask(self))
			? address + BaseHeaderSize
			: address);
		while (oopisLessThan(objOop1, GIV(pastSpaceStart), self)) {
			assert(isEnumerableObjectNoAssert(objOop1, self));
			if (((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1, self)));
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart), self)) {
				objOop1 = GIV(pastSpaceStart);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
		}
		return;
	}
	/* begin initializeCompaction */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	/* begin selectSavedFirstFieldsSpace */
	spaceEstimate1 = ((endOfMemory(self)) - GIV(nilObj)) / 40;
	sizeOfEden = (((eden(self)).limit)) - (((eden(self)).start));
	if (spaceEstimate1 > sizeOfEden) {
		/* begin findHighestSuitableFreeBlock: */
		largestFreeChunk2 = findLargestFreeChunk(self);
		if (!(largestFreeChunk2 == null)) {
			if (((bytesInObject(largestFreeChunk2, self)) >= spaceEstimate1)
			 && ((((usqInt)largestFreeChunk2)) > (((usqInt)((endOfMemory(self)) - GIV(totalFreeOldSpace)))))) {
				highestSuitableFreeBlock = largestFreeChunk2;
				goto l6;
			}
		}
		highestSuitableFreeBlock = null;
	l6:	/* end findHighestSuitableFreeBlock: */;
		if (!(highestSuitableFreeBlock == null)) {
			if ((spaceEstimate1 > ((assert(isFreeObject(highestSuitableFreeBlock, self)),
			bytesInObject(highestSuitableFreeBlock, self))))
			 && (useSegmentForSavedFirstFieldsSpace(spaceEstimate1, self))) {
				goto l8;
			}
			if (((assert(isFreeObject(highestSuitableFreeBlock, self)),
			bytesInObject(highestSuitableFreeBlock, self))) > sizeOfEden) {
				/* begin useFreeChunkForSavedFirstFieldsSpace: */
				assert(validFreeTreeChunk(highestSuitableFreeBlock, self));
				(GIV(savedFirstFieldsSpace).start = highestSuitableFreeBlock + (4 /* freeChunkLargerIndex */ * BytesPerOop));
				(GIV(savedFirstFieldsSpace).limit = addressAfter(highestSuitableFreeBlock, self));
				GIV(savedFirstFieldsSpaceNotInOldSpace) = 0;
				assert(!((savedFirstFieldsSpaceWasAllocated(self))));
				goto l8;
			}
		}
		if (useSegmentForSavedFirstFieldsSpace(spaceEstimate1, self)) {
			goto l8;
		}
	}
	/* begin useEdenForSavedFirstFieldsSpace */
	(GIV(savedFirstFieldsSpace).start = ((eden(self)).start));
	(GIV(savedFirstFieldsSpace).limit = ((eden(self)).limit));
	GIV(savedFirstFieldsSpaceNotInOldSpace) = 1;
	assert(!((savedFirstFieldsSpaceWasAllocated(self))));
	l8:	/* end selectSavedFirstFieldsSpace */;
	/* begin unpinRememberedSet */
	objOop4 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
	GIV(firstFieldOfRememberedSet) = longAt((objOop4 + BaseHeaderSize) + (0U << (shiftForWord(self))));
	/* begin setIsPinnedOf:to: */
	objOop12 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
	longAtput(objOop12, (longAt(objOop12)) & (~(usqIntptr_t)(1U << (pinnedBitShift(self)))));
	/* begin resetFreeListHeads */
	GIV(freeListsMask) = 0;
	for (i = 0, iLimiT = (64 /* numFreeLists */ - 1); i <= iLimiT; i += 1) {
		GIV(freeLists)[i] = 0;
	}
	/* begin totalFreeOldSpace: */
	GIV(totalFreeOldSpace) = 0;
	/* begin beginSlidingCompaction */
	GIV(gcPhaseInProgress) = SlidingCompactionInProgress;
	(GIV(savedFirstFieldsSpace).top = ((GIV(savedFirstFieldsSpace).start)) - BytesPerOop);
	firstPass = 1;
	while (1) {
		finalPass = planCompactSavingForwarders(self);
		assert((validRelocationPlanInPass(finalPass, self)) == 0);
		updatePointers(self);
		copyAndUnmark(firstPass, self);
				if (finalPass
		 || (GIV(biasForGC))) break;
		firstPass = 0;
		reinitializeScanFrom(GIV(firstFreeObject), self);
		/* begin updateSavedFirstFieldsSpaceIfNecessary */
		if (((!GIV(savedFirstFieldsSpaceNotInOldSpace))
		 && (oopisGreaterThan((GIV(savedFirstFieldsSpace).start), GIV(nilObj), self)))
		 && (((GIV(savedFirstFieldsSpace).start)) < GIV(lastMobileObject))) {
			/* begin findHighestSuitableFreeBlock: */
			spaceEstimate = ((GIV(savedFirstFieldsSpace).limit)) - ((GIV(savedFirstFieldsSpace).start));
			largestFreeChunk1 = findLargestFreeChunk(self);
			if (!(largestFreeChunk1 == null)) {
				if (((bytesInObject(largestFreeChunk1, self)) >= spaceEstimate)
				 && ((((usqInt)largestFreeChunk1)) > (((usqInt)((endOfMemory(self)) - GIV(totalFreeOldSpace)))))) {
					largestFreeChunk = largestFreeChunk1;
					goto l5;
				}
			}
			largestFreeChunk = null;
	l5:	/* end findHighestSuitableFreeBlock: */;
			if (largestFreeChunk == null) {
				/* begin useEdenForSavedFirstFieldsSpace */
				(GIV(savedFirstFieldsSpace).start = ((eden(self)).start));
				(GIV(savedFirstFieldsSpace).limit = ((eden(self)).limit));
				GIV(savedFirstFieldsSpaceNotInOldSpace) = 1;
				assert(!((savedFirstFieldsSpaceWasAllocated(self))));
			}
			else {
				/* begin useFreeChunkForSavedFirstFieldsSpace: */
				assert(validFreeTreeChunk(largestFreeChunk, self));
				(GIV(savedFirstFieldsSpace).start = largestFreeChunk + (4 /* freeChunkLargerIndex */ * BytesPerOop));
				(GIV(savedFirstFieldsSpace).limit = addressAfter(largestFreeChunk, self));
				GIV(savedFirstFieldsSpaceNotInOldSpace) = 0;
				assert(!((savedFirstFieldsSpaceWasAllocated(self))));
			}
		}
		(GIV(savedFirstFieldsSpace).top = ((GIV(savedFirstFieldsSpace).start)) - BytesPerOop);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	/* begin endCompaction */
	prevPrevObj2 = (prevObj2 = null);
	/* begin objectStartingAt: */
	address1 = ((pastSpace(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop13 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop13, GIV(pastSpaceStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop13, self));
		if (((((usqInt) (longAt(objOop13))) >> (markedBitFullShift(self))) & 1) != 0) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(objOop13, self)));
			longAtput(objOop13, (longAt(objOop13)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
		}
		prevPrevObj2 = prevObj2;
		prevObj2 = objOop13;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop13, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(pastSpaceStart), self)) {
			objOop13 = GIV(pastSpaceStart);
			goto l15;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop13 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l15:	/* end objectAfter:limit: */;
	}
	/* begin endSlidingCompaction */
	GIV(gcPhaseInProgress) = 0;
	/* begin repinRememberedSet */
	if ((rememberedSetSize(self)) > 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		objOop31 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
		assert(!(isOopForwarded(objOop31, self)));
		longAtput((objOop31 + BaseHeaderSize) + (0U << (shiftForWord(self))), GIV(firstFieldOfRememberedSet));
	}
	/* begin setIsPinnedOf:to: */
	objOop111 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
	longAtput(objOop111, (longAt(objOop111)) | (1U << (pinnedBitShift(self))));
	/* begin relocateRememberedSet */
	GIV(rememberedSet) = firstIndexableField(longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self)))))), self);
	/* begin releaseSavedFirstFieldsSpace */
	if (GIV(savedFirstFieldsSpaceNotInOldSpace)
	 && (oopisGreaterThan((GIV(savedFirstFieldsSpace).start), GIV(nilObj), self))) {
		sqDeallocateMemorySegmentAtOfSize(((void *)((GIV(savedFirstFieldsSpace).start))), ((GIV(savedFirstFieldsSpace).limit)) - ((GIV(savedFirstFieldsSpace).start)));
	}
}


/*	Sweep the mobile portion of the heap, moving objects to their eventual
	locations, and clearing their marked bits.
	Remember to update the savedFirstFields of pointer objects, as these have
	been forwarded.
	Answer if the end of the heap was reached (savedFirstFieldsSpace has not
	overflowed). 
	The enumerations in planCompactSavingForwarders,
	updatePointersInMobileObjects and copyAndUnmarkMobileObjects
	match. We could implement them as a single enumeration method taking
	several block arguments, but arguably that
	would make understanding an already tricky algorithm more difficult.
	Instead we tolerate the duplication and encourage
	the reader to diff the three methods to see where they diverge (e.g. via
	Cmd-shift-C).  */

	/* SpurPlanningCompactor>>#copyAndUnmarkMobileObjects */
static sqInt NeverInline
copyAndUnmarkMobileObjects(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt availableSpace;
    usqInt bytes;
    sqInt destObj;
    sqInt finalObject;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt limit;
    usqInt next;
    usqInt nextBytes;
    sqInt nextObj;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt obj;
    usqInt objBytes;
    sqInt objOop;
    usqInt previousPin;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;
    usqInt startOfPreviousPin;
    usqInt toFinger;
    usqInt top;

	previousPin = 0;
	assert(!((isMarked(GIV(firstFreeObject), self))));
	/* begin startOfObject: */
	toFinger = ((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask(self))
		? GIV(firstFreeObject) - BaseHeaderSize
		: GIV(firstFreeObject));
	top = (GIV(savedFirstFieldsSpace).start);
	startOfPreviousPin = 0;
	/* begin allOldSpaceEntitiesForCompactingFrom:to:do: */
	finalObject = (!(GIV(lastMobileObject))
		? GIV(nilObj)
		: GIV(lastMobileObject));
	assert(isOldObject(GIV(firstFreeObject), self));
	assert(oopisLessThanOrEqualTo(finalObject, GIV(endOfMemory), self));
	prevPrevObj = (prevObj = null);
	objOop = GIV(firstFreeObject);
	limit = (oopisLessThan(finalObject, GIV(endOfMemory), self)
		? addressAfter(finalObject, self)
		: GIV(endOfMemory));
	while (1) {
		assert((objOop % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop, limit, self))) break;
		assert((long64At(objOop)) != 0);
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
			nextObj = GIV(endOfMemory);
			goto l7;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		nextObj = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l7:	/* end objectAfter:limit: */;
		assert((previousPin == null
			? toFinger <= (startOfObject(objOop, self))
			: (isMarked(previousPin, self))
				 && (toFinger <= startOfPreviousPin)));
		assert(GIV(savedFirstFieldsSpaceNotInOldSpace)
		 || (toFinger < top));
		if (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0) {
				if (!(previousPin)) {
					previousPin = objOop;
					/* begin startOfObject: */
					startOfPreviousPin = ((byteAt(objOop + 7)) == (numSlotsMask(self))
						? objOop - BaseHeaderSize
						: objOop);
				}
			}
			else {
				bytes = bytesInObject(objOop, self);
				while ((toFinger <= startOfPreviousPin)
				 && ((bytes != ((availableSpace = startOfPreviousPin - toFinger)))
				 && ((bytes + (2 * 8 /* allocationUnit */)) > availableSpace))) {

					/* The object does not fit in the space between toFinger and previousPin.
					   Move toFinger up to point at the first unmarked or mobile object after
					   previousPin, or, if previousPin is contiguous with o, to the start of this
					   object.  Update previousPin to be the next pinned object above toFInger
					   and below this object, or nil if no such pinned object exists.
					   Any unfillable gaps between adjacent pinned objects will be freed. */
					if (availableSpace > 0) {
						/* begin addFreeChunkWithBytes:at: */
						GIV(totalFreeOldSpace) += availableSpace;
						freeChunkWithBytesat(availableSpace, toFinger, self);
					}
					do {
						assert((isMarked(previousPin, self))
						 && (isPinned(previousPin, self)));
						/* begin unmarkPinned: */
						if (!(((longAt(previousPin)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(previousPin, self)));
							longAtput(previousPin, (longAt(previousPin)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
							/* begin notePinned: */
							assert(isPinned(previousPin, self));
							if (((longAt(previousPin)) & (classIndexMask(self))) == (segmentBridgePun(self))) {
								/* begin setIsMarkedOf:to: */
								assert(!(isFreeObject(previousPin, self)));
								longAtput(previousPin, (longAt(previousPin)) | (1ULL << (markedBitFullShift(self))));
							}
							else {
								while (oopisLessThan((((GIV(segments)[GIV(sweepIndex)]).segSize)) + (((GIV(segments)[GIV(sweepIndex)]).segStart)), previousPin, self)) {
									GIV(sweepIndex) += 1;
								}
								((GIV(segments)[GIV(sweepIndex)]).containsPinned = 1);
							}
						}
						toFinger = addressAfter(previousPin, self);
						/* begin objectStartingAt: */
						numSlots = byteAt(toFinger + 7);
						previousPin = (numSlots == (numSlotsMask(self))
							? toFinger + BaseHeaderSize
							: toFinger);
					} while((((((usqInt) (longAt(previousPin))) >> (markedBitFullShift(self))) & 1) != 0)
						 && ((((((usqInt) (longAt(previousPin))) >> (pinnedBitShift(self))) & 1) != 0)
						 && (previousPin < objOop)));
					while (!((previousPin >= objOop)
					 || ((((((usqInt) (longAt(previousPin))) >> (markedBitFullShift(self))) & 1) != 0)
					 && (((((usqInt) (longAt(previousPin))) >> (pinnedBitShift(self))) & 1) != 0)))) {
						previousPin = oldSpaceObjectAfter(previousPin, self);
					}
					if (previousPin >= objOop) {
						previousPin = null;
						startOfPreviousPin = 0;
					}
					else {
						/* begin startOfObject: */
						startOfPreviousPin = ((byteAt(previousPin + 7)) == (numSlotsMask(self))
							? previousPin - BaseHeaderSize
							: previousPin);
					}
				}
				/* begin copyAndUnmarkObject:to:bytes:firstField: */
				assert(!(isFreeObject(objOop, self)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				/* begin rawNumSlotsOf: */
				numSlots1 = byteAt(objOop + 7);
				destObj = (numSlots1 == (numSlotsMask(self))
					? toFinger + BaseHeaderSize
					: toFinger);
				/* begin startOfObject:given: */
				start = (numSlots1 == (numSlotsMask(self))
					? objOop - BaseHeaderSize
					: objOop);
				memmove(((void *)toFinger), ((void *)start), bytes);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(destObj, self)));
				longAtput((destObj + BaseHeaderSize) + (0U << (shiftForWord(self))), longAt(top));
				toFinger += bytes;
				if (((top += BytesPerOop)) >= ((GIV(savedFirstFieldsSpace).limit))) {
					assert(((GIV(savedFirstFieldsSpace).top)) == (top - BytesPerOop));
					assert(nextObj == GIV(objectAfterLastMobileObject));
					if (!(previousPin)) {
						previousPin = nextObj;
						/* begin startOfObject: */
						startOfPreviousPin = ((byteAt(nextObj + 7)) == (numSlotsMask(self))
							? nextObj - BaseHeaderSize
							: nextObj);
					}
					if (toFinger < startOfPreviousPin) {
						GIV(firstFreeObject) = initFreeChunkWithBytesat(startOfPreviousPin - toFinger, toFinger, self);
					}
					else {
						GIV(firstFreeObject) = previousPin;
					}
					return 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = nextObj;
	}
	freeFromupTonextObject(toFinger, endOfMemory(self), (!(previousPin)
		? (!(GIV(objectAfterLastMobileObject))
				? objectAfter(GIV(firstFreeObject), self)
				: GIV(objectAfterLastMobileObject))
		: previousPin), self);
	/* begin coalesceFrom: */
	if (toFinger >= (endOfMemory(self))) {
		goto l12;
	}
	/* begin objectStartingAt: */
	numSlots2 = byteAt(toFinger + 7);
	obj = (numSlots2 == (numSlotsMask(self))
		? toFinger + BaseHeaderSize
		: toFinger);
	while (1) {
		next = oldSpaceObjectAfter(obj, self);
		if (!(next < (endOfMemory(self)))) break;
		if ((((longAt(obj)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)))
		 && (((longAt(next)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)))) {
			objBytes = bytesInObject(obj, self);
			nextBytes = bytesInObject(next, self);
			unlinkFreeChunkchunkBytes(obj, objBytes, self);
			unlinkFreeChunkchunkBytes(next, nextBytes, self);
			obj = freeChunkWithBytesat(objBytes + nextBytes, ((byteAt(obj + 7)) == (numSlotsMask(self))
				? obj - BaseHeaderSize
				: obj), self);
		}
		else {
			obj = next;
		}
	}
	l12:	/* end coalesceFrom: */;
	return 1;
}


/*	Sweep the heap, unmarking all objects and moving mobile objects to their
	correct positions,
	restoring their savedFirstFields. */

	/* SpurPlanningCompactor>>#copyAndUnmark: */
static void NoDbgRegParms NeverInline
copyAndUnmark(sqInt firstPass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt finalPass;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt freeBytes;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt startOfFree;

	startOfFree = 0;
	/* begin logPhase: */
	if (firstPass) {
		/* begin unmarkInitialImmobileObjects */
		assert(isOldObject(GIV(nilObj), self));
		prevPrevObj = (prevObj = null);
		objOop1 = GIV(nilObj);
		while (1) {
			assert((objOop1 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
			assert((long64At(objOop1)) != 0);
			if (isEnumerableObject(objOop1, self)) {
				if (oopisGreaterThanOrEqualTo(objOop1, GIV(firstMobileObject), self)) {
					goto l2;
				}
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1, self)));
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
				objOop1 = GIV(endOfMemory);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
		}
	l2:	/* end unmarkInitialImmobileObjects */;
	}
	finalPass = copyAndUnmarkMobileObjects(self);
	if ((GIV(lastMobileObject) != null)
	 && ((!finalPass)
	 && (GIV(biasForGC)))) {

		/* only ever one pass if biasForGC is true. */
		/* begin unmarkObjectsFromFirstFreeObject */
		freeBytes = 0;
		/* begin allOldSpaceEntitiesFrom:do: */
		assert(isOldObject(GIV(firstFreeObject), self));
		prevPrevObj1 = (prevObj1 = null);
		objOop2 = GIV(firstFreeObject);
		while (1) {
			assert((objOop2 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop2, GIV(endOfMemory), self))) break;
			assert((long64At(objOop2)) != 0);
			if (((((usqInt) (longAt(objOop2))) >> (markedBitFullShift(self))) & 1) != 0) {
				if (startOfFree) {
					/* begin addFreeChunkWithBytes:at: */
					GIV(totalFreeOldSpace) += freeBytes;
					freeChunkWithBytesat(freeBytes, startOfFree, self);
					startOfFree = null;
					freeBytes = 0;
				}
				if (((((usqInt) (longAt(objOop2))) >> (pinnedBitShift(self))) & 1) != 0) {
					/* begin unmarkPinned: */
					if (!(((longAt(objOop2)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(objOop2, self)));
						longAtput(objOop2, (longAt(objOop2)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
						/* begin notePinned: */
						assert(isPinned(objOop2, self));
						if (((longAt(objOop2)) & (classIndexMask(self))) == (segmentBridgePun(self))) {
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(objOop2, self)));
							longAtput(objOop2, (longAt(objOop2)) | (1ULL << (markedBitFullShift(self))));
						}
						else {
							while (oopisLessThan((((GIV(segments)[GIV(sweepIndex)]).segSize)) + (((GIV(segments)[GIV(sweepIndex)]).segStart)), objOop2, self)) {
								GIV(sweepIndex) += 1;
							}
							((GIV(segments)[GIV(sweepIndex)]).containsPinned = 1);
						}
					}
				}
				else {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop2, self)));
					longAtput(objOop2, (longAt(objOop2)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				}
			}
			else {
				if (!(startOfFree)) {
					/* begin startOfObject: */
					startOfFree = ((byteAt(objOop2 + 7)) == (numSlotsMask(self))
						? objOop2 - BaseHeaderSize
						: objOop2);
				}
				freeBytes += bytesInObject(objOop2, self);
			}
			prevPrevObj1 = prevObj1;
			prevObj1 = objOop2;
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop2, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory), self)) {
				objOop2 = GIV(endOfMemory);
				goto l4;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop2 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
		}
		if (startOfFree) {
			/* begin addFreeChunkWithBytes:at: */
			GIV(totalFreeOldSpace) += freeBytes;
			freeChunkWithBytesat(freeBytes, startOfFree, self);
		}
	}
}


/*	Free from toFinger up to limit, dealing with possible intervening pinned
	objects. 
 */

	/* SpurPlanningCompactor>>#freeFrom:upTo:nextObject: */
static void NoDbgRegParms
freeFromupTonextObject(usqInt initialToFinger, usqInt limit, sqInt nextObject, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    sqInt obj;
    usqInt objStart;
    usqInt toFinger;

	toFinger = initialToFinger;
	/* begin startOfObject: */
	objStart = ((byteAt(nextObject + 7)) == (numSlotsMask(self))
		? nextObject - BaseHeaderSize
		: nextObject);
	if (toFinger < objStart) {
		/* begin addFreeChunkWithBytes:at: */
		GIV(totalFreeOldSpace) += objStart - toFinger;
		freeChunkWithBytesat(objStart - toFinger, toFinger, self);
	}
	toFinger = objStart;
	while (objStart < limit) {
		/* begin objectStartingAt: */
		numSlots = byteAt(objStart + 7);
		obj = (numSlots == (numSlotsMask(self))
			? objStart + BaseHeaderSize
			: objStart);
		if ((((((usqInt) (longAt(obj))) >> (markedBitFullShift(self))) & 1) != 0)
		 && (((((usqInt) (longAt(obj))) >> (pinnedBitShift(self))) & 1) != 0)) {
			/* begin unmarkPinned: */
			if (!(((longAt(obj)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(obj, self)));
				longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				/* begin notePinned: */
				assert(isPinned(obj, self));
				if (((longAt(obj)) & (classIndexMask(self))) == (segmentBridgePun(self))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(obj, self)));
					longAtput(obj, (longAt(obj)) | (1ULL << (markedBitFullShift(self))));
				}
				else {
					while (oopisLessThan((((GIV(segments)[GIV(sweepIndex)]).segSize)) + (((GIV(segments)[GIV(sweepIndex)]).segStart)), obj, self)) {
						GIV(sweepIndex) += 1;
					}
					((GIV(segments)[GIV(sweepIndex)]).containsPinned = 1);
				}
			}
			if (toFinger < objStart) {
				/* begin addFreeChunkWithBytes:at: */
				GIV(totalFreeOldSpace) += objStart - toFinger;
				freeChunkWithBytesat(objStart - toFinger, toFinger, self);
			}
			toFinger = (objStart = addressAfter(obj, self));
		}
		else {
			objStart = addressAfter(obj, self);
		}
	}
	if (limit > toFinger) {
		/* begin addFreeChunkWithBytes:at: */
		GIV(totalFreeOldSpace) += limit - toFinger;
		freeChunkWithBytesat(limit - toFinger, toFinger, self);
	}
}


/*	Scan for firstFreeObject and firstMobileObject from the start of memory.
	Answer if the heap is already fully compacted. */

	/* SpurPlanningCompactor>>#initializeScanCheckingForFullyCompactedHeap */
static sqInt
initializeScanCheckingForFullyCompactedHeap(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(firstMobileObject) = (GIV(lastMobileObject) = (GIV(objectAfterLastMobileObject) = null));
	reinitializeScanFrom(GIV(hiddenRootsObj), self);
	if (!(GIV(firstFreeObject))) {
		error("uncompactable heap; no unmarked objects found");
	}
	return GIV(firstMobileObject) >= (endOfMemory(self));
}

	/* SpurPlanningCompactor>>#isMobile: */
static sqInt NoDbgRegParms
isMobile(sqInt obj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThanOrEqualToandLessThanOrEqualTo(obj, GIV(mobileStart), GIV(lastMobileObject), self))
	 && (!(((((usqInt) (longAt(obj))) >> (pinnedBitShift(self))) & 1) != 0));
}


/*	For asserts */

	/* SpurPlanningCompactor>>#isPostMobile: */
static sqInt NoDbgRegParms
isPostMobile(sqInt obj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThanOrEqualTo(obj, GIV(mobileStart), GIV(lastMobileObject), self);
}


/*	Sweep the heap from firstFreeObject forwarding marked objects to where
	they can be moved to, saving their forwarding pointer in
	savedFirstFieldsSpace. Continue until either the end of the heap is
	reached or savedFirstFieldsSpace is full.
	Answer if the end of the heap was reached (savedFirstFieldsSpace has not
	overflowed). 
	The enumerations in planCompactSavingForwarders,
	updatePointersInMobileObjects and copyAndUnmarkMobileObjects
	match. We could implement them as a single enumeration method taking
	several block arguments, but arguably that
	would make understanding an already tricky algorithm more difficult.
	Instead we tolerate the duplication and encourage
	the reader to diff the three methods to see where they diverge (e.g. via
	Cmd-shift-C).  */

	/* SpurPlanningCompactor>>#planCompactSavingForwarders */
static sqInt NeverInline
planCompactSavingForwarders(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt availableSpace;
    usqInt bytes;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt objOop;
    usqInt previousPin;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt startOfPreviousPin;
    usqInt toFinger;
    usqInt top;
    sqInt valuePointer;

	previousPin = 0;
	if (((GIV(savedFirstFieldsSpace).top)) < ((GIV(savedFirstFieldsSpace).start))) {
		/* begin logPhase: */
	}
	assert(!((isMarked(GIV(firstFreeObject), self))));
	/* begin startOfObject: */
	toFinger = ((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask(self))
		? GIV(firstFreeObject) - BaseHeaderSize
		: GIV(firstFreeObject));
	top = (GIV(savedFirstFieldsSpace).start);
	startOfPreviousPin = 0;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(firstFreeObject), self));
	prevPrevObj = (prevObj = null);
	objOop = GIV(firstFreeObject);
	while (1) {
		assert((objOop % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory), self))) break;
		assert((long64At(objOop)) != 0);
		assert((previousPin == null
			? toFinger <= (startOfObject(objOop, self))
			: (isMarked(previousPin, self))
				 && (toFinger <= startOfPreviousPin)));
		assert(GIV(savedFirstFieldsSpaceNotInOldSpace)
		 || (toFinger < top));
		if (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0) {
				if (!(previousPin)) {
					previousPin = objOop;
					/* begin startOfObject: */
					startOfPreviousPin = ((byteAt(objOop + 7)) == (numSlotsMask(self))
						? objOop - BaseHeaderSize
						: objOop);
				}
			}
			else {
				bytes = bytesInObject(objOop, self);
				while ((toFinger <= startOfPreviousPin)
				 && ((bytes != ((availableSpace = startOfPreviousPin - toFinger)))
				 && ((bytes + (2 * 8 /* allocationUnit */)) > availableSpace))) {

					/* The object does not fit in the space between toFinger and previousPin.
					   Move toFinger up to point at the first unmarked or mobile object after
					   previousPin, or, if previousPin is contiguous with o, to the start of this
					   object.  Update previousPin to be the next pinned object above toFInger
					   and below this object, or nil if no such pinned object exists.
					   Any unfillable gaps between adjacent pinned objects will be freed. */
					do {
						toFinger = addressAfter(previousPin, self);
						/* begin objectStartingAt: */
						numSlots = byteAt(toFinger + 7);
						previousPin = (numSlots == (numSlotsMask(self))
							? toFinger + BaseHeaderSize
							: toFinger);
					} while((((((usqInt) (longAt(previousPin))) >> (markedBitFullShift(self))) & 1) != 0)
						 && ((((((usqInt) (longAt(previousPin))) >> (pinnedBitShift(self))) & 1) != 0)
						 && (previousPin < objOop)));
					while (!((previousPin >= objOop)
					 || ((((((usqInt) (longAt(previousPin))) >> (markedBitFullShift(self))) & 1) != 0)
					 && (((((usqInt) (longAt(previousPin))) >> (pinnedBitShift(self))) & 1) != 0)))) {
						previousPin = oldSpaceObjectAfter(previousPin, self);
					}
					if (previousPin >= objOop) {
						previousPin = null;
						startOfPreviousPin = 0;
					}
					else {
						/* begin startOfObject: */
						startOfPreviousPin = ((byteAt(previousPin + 7)) == (numSlotsMask(self))
							? previousPin - BaseHeaderSize
							: previousPin);
					}
				}
				/* begin forwardMobileObject:to:savedFirstFieldPtr: */
				GIV(lastMobileObject) = objOop;
				longAtput(top, longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self)))));
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer = ((byteAt(objOop + 7)) == (numSlotsMask(self))
					? toFinger + BaseHeaderSize
					: toFinger);
				assert(!(isOopForwarded(objOop, self)));
				longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))), valuePointer);
				toFinger += bytes;
				if (((top += BytesPerOop)) >= ((GIV(savedFirstFieldsSpace).limit))) {
					(GIV(savedFirstFieldsSpace).top = top - BytesPerOop);
					GIV(objectAfterLastMobileObject) = oldSpaceObjectAfter(GIV(lastMobileObject), self);
					return 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
			objOop = GIV(endOfMemory);
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	if (GIV(lastMobileObject)) {
		(GIV(savedFirstFieldsSpace).top = top - BytesPerOop);
		GIV(objectAfterLastMobileObject) = oldSpaceObjectAfter(GIV(lastMobileObject), self);
	}
	return 1;
}


/*	Search for firstFreeObject and firstMobileObject from initialObject, which
	is the
	hiddenRootsObject on the first pass, and the objectAfterLastMobileObject
	on subsequent passes). */

	/* SpurPlanningCompactor>>#reinitializeScanFrom: */
static void NoDbgRegParms
reinitializeScanFrom(sqInt initialObject, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	GIV(firstMobileObject) = endOfMemory(self);
	GIV(firstFreeObject) = scanForFirstFreeAndFirstMobileObjectFrom(initialObject, self);
	if (GIV(firstFreeObject)) {
		/* begin startOfObject: */
		GIV(mobileStart) = ((usqInt) (((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask(self))
	? GIV(firstFreeObject) - BaseHeaderSize
	: GIV(firstFreeObject))));
	}
	if (GIV(objectAfterLastMobileObject)) {
		/* begin allOldSpaceEntitiesFrom:to:do: */
		assert((isNonImmediate(GIV(firstFreeObject), self))
		 && (isInSegments(GIV(firstFreeObject), self)));
		assert((isNonImmediate(GIV(objectAfterLastMobileObject), self))
		 && (isInSegments(GIV(objectAfterLastMobileObject), self)));
		prevPrevObj = (prevObj = null);
		objOop = GIV(firstFreeObject);
		while (1) {
			assert((objOop % (allocationUnit(self))) == 0);
			if (!(oopisLessThanOrEqualTo(objOop, GIV(objectAfterLastMobileObject), self))) break;
			assert((long64At(objOop)) != 0);
			if (!((((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0)
				 || ((!(((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0))
				 || (GIV(objectAfterLastMobileObject) == objOop)))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop, self)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			prevPrevObj = prevObj;
			prevObj = objOop;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
				objOop = GIV(endOfMemory);
				goto l2;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
		}
		GIV(firstMobileObject) = GIV(objectAfterLastMobileObject);
	}
}


/*	Scavenge or simply follow objOop. Answer the new location of objOop.
	The send should have been guarded by a send of shouldRemapOop:.
	The method is called remapObj: for compatibility with ObjectMemory. */

	/* SpurPlanningCompactor>>#remapObj: */
sqInt
remapObj(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt resolvedObj;

	/* begin slidingCompactionRemapObj: */
	assert(shouldRemapOop(objOop, self));
	if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(objOop, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		resolvedObj = referent;
	}
	else {
		assert(!((isInFutureSpace(objOop, self))));
		resolvedObj = objOop;
	}
	if (GIV(gcPhaseInProgress) > 0) {
		if (GIV(gcPhaseInProgress) == ScavengeInProgress) {
			if ((((resolvedObj & (tagMask(self))) == 0)
			 && ((assert(isNonImmediate(resolvedObj, self)),
			oopisLessThan(resolvedObj, GIV(newSpaceLimit), self))))
			 && (!(oopisGreaterThanOrEqualToandLessThan(resolvedObj, ((futureSpace(self)).start), futureSurvivorStart(self), self)))) {
				return copyAndForward(resolvedObj, self);
			}
		}
		else {
			assert(slidingCompactionInProgress(self));
			if ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(objOop, GIV(mobileStart), GIV(lastMobileObject), self))
			 && (!(((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0))) {
				/* begin fetchPointer:ofObject: */
				return longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
		}
	}
	return resolvedObj;
}

	/* SpurPlanningCompactor>>#savedFirstFieldsSpaceWasAllocated */
static sqInt
savedFirstFieldsSpaceWasAllocated(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedFirstFieldsSpaceNotInOldSpace)
	 && (oopisGreaterThan((GIV(savedFirstFieldsSpace).start), GIV(nilObj), self));
}


/*	Scan from initialObject, setting firstMobileObject to the first marked
	object after
	the first free object found. Answer the first free object found, or nil if
	none. 
 */

	/* SpurPlanningCompactor>>#scanForFirstFreeAndFirstMobileObjectFrom: */
static sqInt NoDbgRegParms
scanForFirstFreeAndFirstMobileObjectFrom(sqInt initialObject, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstFree;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	firstFree = 0;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(initialObject, self));
	prevPrevObj = (prevObj = null);
	objOop = initialObject;
	while (1) {
		assert((objOop % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory), self))) break;
		assert((long64At(objOop)) != 0);
		if (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (firstFree) {
				GIV(firstMobileObject) = objOop;
				return firstFree;
			}
		}
		else {
			if (!(firstFree)) {
				firstFree = objOop;
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return firstFree;
}


/*	Answer if the obj should be scavenged, or simply followed. Sent via the
	compactor from shouldRemapObj:. We test for being already scavenged
	because mapStackPages
	via mapInterpreterOops may be applied twice in the context of a global GC
	where a
	scavenge, followed by a scan-mark-free, and final compaction passes may
	result in
	scavenged fields being visited twice. */

	/* SpurPlanningCompactor>>#shouldRemapObj: */
sqInt
shouldRemapObj(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)
	 || ((GIV(gcPhaseInProgress) > 0)
	 && ((GIV(gcPhaseInProgress) == ScavengeInProgress
		? ((assert(isNonImmediate(objOop, self)),
			oopisLessThan(objOop, GIV(newSpaceLimit), self)))
			 && (!(oopisGreaterThanOrEqualToandLessThan(objOop, ((futureSpace(self)).start), futureSurvivorStart(self), self)))
		: (oopisGreaterThanOrEqualToandLessThanOrEqualTo(objOop, GIV(mobileStart), GIV(lastMobileObject), self))
			 && (!(((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0)))));
}


/*	Sweep the heap, updating all objects to their eventual locations.
	Remember to update the savedFirstFields of pointer objects, as these have
	been forwarded. */

	/* SpurPlanningCompactor>>#updatePointers */
static void NeverInline
updatePointers(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt availableSpace;
    usqInt bytes;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt contextSize2;
    sqInt contextSize3;
    sqInt finishIndex;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt fmt3;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt followingWordAddress3;
    sqInt fwd;
    sqInt fwd1;
    sqInt fwd2;
    sqInt fwd3;
    sqInt fwd4;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt heapEntity;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt numLiterals;
    sqInt numLiterals1;
    sqInt numLiterals2;
    sqInt numLiterals3;
    usqInt numPointerSlots;
    usqInt numPointerSlots1;
    usqInt numPointerSlots2;
    usqInt numPointerSlots3;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop4;
    sqInt onePass;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt oop4;
    usqInt previousPin;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj2;
    sqInt prevObj3;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj2;
    sqInt prevPrevObj3;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    usqInt startOfPreviousPin;
    usqInt toFinger;
    usqInt top;

	previousPin = 0;
	/* begin logPhase: */
	if (!(GIV(lastMobileObject) != null)) {
		return;
	}
	assert((startOfObject(GIV(firstFreeObject), self)) == GIV(mobileStart));
	mapInterpreterOops(self);
	mapExtraRoots(self);
	/* begin updatePointersInManagerHeapEntities */
	GIV(markStack) = relocateObjStackForPlanningCompactor(GIV(markStack), self);
	GIV(weaklingStack) = relocateObjStackForPlanningCompactor(GIV(weaklingStack), self);
	GIV(mournQueue) = relocateObjStackForPlanningCompactor(GIV(mournQueue), self);
	if (((rememberedSetSize(self)) > 0)
	 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(GIV(firstFieldOfRememberedSet), GIV(mobileStart), GIV(lastMobileObject), self))
	 && (!(((((usqInt) (longAt(GIV(firstFieldOfRememberedSet)))) >> (pinnedBitShift(self))) & 1) != 0)))) {
		/* begin fetchPointer:ofObject: */
		GIV(firstFieldOfRememberedSet) = longAt((GIV(firstFieldOfRememberedSet) + BaseHeaderSize) + (0U << (shiftForWord(self))));
	}
	/* begin relocateObjectsInHeapEntity:from:to: */
	heapEntity = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord(self))))));
	finishIndex = (rememberedSetSize(self)) - 1;
	for (i = 1; i <= finishIndex; i += 1) {
		/* begin fetchPointer:ofObject: */
		oop = longAt((heapEntity + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if (((oop & (tagMask(self))) == 0)
		 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject), self))
		 && (!(((((usqInt) (longAt(oop))) >> (pinnedBitShift(self))) & 1) != 0)))) {
			assert(isMarked(oop, self));
			/* begin fetchPointer:ofObject: */
			fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
			assert(isPostMobile(fwd, self));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(heapEntity, self)));
			longAtput((heapEntity + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), fwd);
		}
	}
	if ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(heapEntity, GIV(mobileStart), GIV(lastMobileObject), self))
	 && (!(((((usqInt) (longAt(heapEntity))) >> (pinnedBitShift(self))) & 1) != 0))) {
		/* begin fetchPointer:ofObject: */
		longAt((heapEntity + BaseHeaderSize) + (0U << (shiftForWord(self))));
	}
	else {
	}
	/* begin updatePointersInSurvivingObjects */
	prevPrevObj1 = (prevObj1 = null);
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots2 = byteAt(address + 7);
	objOop11 = (numSlots2 == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	while (oopisLessThan(objOop11, GIV(pastSpaceStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop11, self));
		assert(isMarked(objOop11, self));
		/* begin updatePointersIn: */
		fmt1 = (((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self));
		if (fmt1 <= 5 /* lastPointerFormat */) {
			if ((fmt1 == (indexablePointersFormat(self)))
			 && (((longAt(objOop11)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp1 = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
				if (!((((sp1) & 7) == 1))) {
					contextSize1 = 0;
					goto l47;
				}
				assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(objOop11, self)));
				contextSize1 = (sp1 >> 3);
	l47:	/* end fetchStackPointerOf: */;
				numPointerSlots1 = CtxtTempFrameStart + contextSize1;
				goto l46;
			}
			/* begin numSlotsOf: */
			assert((classIndexOf(objOop11, self)) > (isForwardedObjectClassIndexPun(self)));
			numSlots1 = byteAt(objOop11 + 7);
			numPointerSlots1 = (numSlots1 == (numSlotsMask(self))
				? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop11 - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots1);
			goto l46;
		}
		if (fmt1 == 7 /* forwardedFormat */) {
			numPointerSlots1 = 1;
			goto l46;
		}
		if (fmt1 < (firstCompiledMethodFormat(self))) {
			numPointerSlots1 = 0;
			goto l46;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(objOop11, self));
		/* begin fetchPointer:ofObject: */
		header1 = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		assert((((header1) & 7) == 1));
		numLiterals1 = ((header1 >> 3)) & AlternateHeaderNumLiteralsMask;
		numPointerSlots1 = numLiterals1 + LiteralStart;
	l46:	/* end numPointerSlotsOf: */;
		for (i2 = 0; i2 < numPointerSlots1; i2 += 1) {
			/* begin fetchPointer:ofObject: */
			oop2 = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord(self))))));
			if (((oop2 & (tagMask(self))) == 0)
			 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop2, GIV(mobileStart), GIV(lastMobileObject), self))
			 && (!(((((usqInt) (longAt(oop2))) >> (pinnedBitShift(self))) & 1) != 0)))) {
				assert((isMarked(oop2, self))
				 || (objOop11 == (hiddenRootsObject(self))));
				/* begin fetchPointer:ofObject: */
				fwd2 = longAt((oop2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				assert(isPostMobile(fwd2, self));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(objOop11, self)));
				longAtput((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord(self))))), fwd2);
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart), self)) {
			objOop11 = GIV(pastSpaceStart);
			goto l21;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop11 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l21:	/* end objectAfter:limit: */;
	}
	/* begin updatePointersInInitialImmobileObjects */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj2 = (prevObj2 = null);
	objOop12 = GIV(nilObj);
	while (1) {
		assert((objOop12 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop12, GIV(endOfMemory), self))) break;
		assert((long64At(objOop12)) != 0);
		if (isEnumerableObject(objOop12, self)) {
			if (oopisGreaterThanOrEqualTo(objOop12, GIV(firstFreeObject), self)) {
				goto l32;
			}
			/* begin updatePointersIn: */
			fmt2 = (((usqInt) (longAt(objOop12))) >> (formatShift(self))) & (formatMask(self));
			if (fmt2 <= 5 /* lastPointerFormat */) {
				if ((fmt2 == (indexablePointersFormat(self)))
				 && (((longAt(objOop12)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp2 = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
					if (!((((sp2) & 7) == 1))) {
						contextSize2 = 0;
						goto l48;
					}
					assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(objOop12, self)));
					contextSize2 = (sp2 >> 3);
	l48:	/* end fetchStackPointerOf: */;
					numPointerSlots2 = CtxtTempFrameStart + contextSize2;
					goto l49;
				}
				/* begin numSlotsOf: */
				assert((classIndexOf(objOop12, self)) > (isForwardedObjectClassIndexPun(self)));
				numSlots3 = byteAt(objOop12 + 7);
				numPointerSlots2 = (numSlots3 == (numSlotsMask(self))
					? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop12 - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots3);
				goto l49;
			}
			if (fmt2 == 7 /* forwardedFormat */) {
				numPointerSlots2 = 1;
				goto l49;
			}
			if (fmt2 < (firstCompiledMethodFormat(self))) {
				numPointerSlots2 = 0;
				goto l49;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objOop12, self));
			/* begin fetchPointer:ofObject: */
			header2 = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
			assert((((header2) & 7) == 1));
			numLiterals2 = ((header2 >> 3)) & AlternateHeaderNumLiteralsMask;
			numPointerSlots2 = numLiterals2 + LiteralStart;
	l49:	/* end numPointerSlotsOf: */;
			for (i3 = 0; i3 < numPointerSlots2; i3 += 1) {
				/* begin fetchPointer:ofObject: */
				oop3 = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord(self))))));
				if (((oop3 & (tagMask(self))) == 0)
				 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop3, GIV(mobileStart), GIV(lastMobileObject), self))
				 && (!(((((usqInt) (longAt(oop3))) >> (pinnedBitShift(self))) & 1) != 0)))) {
					assert((isMarked(oop3, self))
					 || (objOop12 == (hiddenRootsObject(self))));
					/* begin fetchPointer:ofObject: */
					fwd3 = longAt((oop3 + BaseHeaderSize) + (0U << (shiftForWord(self))));
					assert(isPostMobile(fwd3, self));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(objOop12, self)));
					longAtput((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord(self))))), fwd3);
				}
			}
		}
		prevPrevObj2 = prevObj2;
		prevObj2 = objOop12;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop12, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop12 = GIV(endOfMemory);
			goto l29;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop12 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l29:	/* end objectAfter:limit: */;
	}
	l32:	/* end updatePointersInInitialImmobileObjects */;
	/* begin updatePointersInMobileObjects */
	assert(!((isMarked(GIV(firstFreeObject), self))));
	/* begin startOfObject: */
	toFinger = ((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask(self))
		? GIV(firstFreeObject) - BaseHeaderSize
		: GIV(firstFreeObject));
	top = (GIV(savedFirstFieldsSpace).start);
	startOfPreviousPin = 0;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(firstFreeObject), self));
	prevPrevObj3 = (prevObj3 = null);
	objOop4 = GIV(firstFreeObject);
	while (1) {
		assert((objOop4 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop4, GIV(endOfMemory), self))) break;
		assert((long64At(objOop4)) != 0);
		assert((previousPin == null
			? toFinger <= (startOfObject(objOop4, self))
			: (isMarked(previousPin, self))
				 && (toFinger <= startOfPreviousPin)));
		if (((((usqInt) (longAt(objOop4))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((((usqInt) (longAt(objOop4))) >> (pinnedBitShift(self))) & 1) != 0) {
				if (!(previousPin)) {
					previousPin = objOop4;
					/* begin startOfObject: */
					startOfPreviousPin = ((byteAt(objOop4 + 7)) == (numSlotsMask(self))
						? objOop4 - BaseHeaderSize
						: objOop4);
				}
				/* begin updatePointersIn: */
				fmt3 = (((usqInt) (longAt(objOop4))) >> (formatShift(self))) & (formatMask(self));
				if (fmt3 <= 5 /* lastPointerFormat */) {
					if ((fmt3 == (indexablePointersFormat(self)))
					 && (((longAt(objOop4)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

						/* contexts end at the stack pointer */
						/* begin fetchStackPointerOf: */
						sp3 = longAt((objOop4 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
						if (!((((sp3) & 7) == 1))) {
							contextSize3 = 0;
							goto l50;
						}
						assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(objOop4, self)));
						contextSize3 = (sp3 >> 3);
	l50:	/* end fetchStackPointerOf: */;
						numPointerSlots3 = CtxtTempFrameStart + contextSize3;
						goto l51;
					}
					/* begin numSlotsOf: */
					assert((classIndexOf(objOop4, self)) > (isForwardedObjectClassIndexPun(self)));
					numSlots11 = byteAt(objOop4 + 7);
					numPointerSlots3 = (numSlots11 == (numSlotsMask(self))
						? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop4 - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots11);
					goto l51;
				}
				if (fmt3 == 7 /* forwardedFormat */) {
					numPointerSlots3 = 1;
					goto l51;
				}
				if (fmt3 < (firstCompiledMethodFormat(self))) {
					numPointerSlots3 = 0;
					goto l51;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objOop4, self));
				/* begin fetchPointer:ofObject: */
				header3 = longAt((objOop4 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
				assert((((header3) & 7) == 1));
				numLiterals3 = ((header3 >> 3)) & AlternateHeaderNumLiteralsMask;
				numPointerSlots3 = numLiterals3 + LiteralStart;
	l51:	/* end numPointerSlotsOf: */;
				for (i4 = 0; i4 < numPointerSlots3; i4 += 1) {
					/* begin fetchPointer:ofObject: */
					oop4 = longAt((objOop4 + BaseHeaderSize) + (((sqInt)((usqInt)(i4) << (shiftForWord(self))))));
					if (((oop4 & (tagMask(self))) == 0)
					 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop4, GIV(mobileStart), GIV(lastMobileObject), self))
					 && (!(((((usqInt) (longAt(oop4))) >> (pinnedBitShift(self))) & 1) != 0)))) {
						assert((isMarked(oop4, self))
						 || (objOop4 == (hiddenRootsObject(self))));
						/* begin fetchPointer:ofObject: */
						fwd4 = longAt((oop4 + BaseHeaderSize) + (0U << (shiftForWord(self))));
						assert(isPostMobile(fwd4, self));
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(objOop4, self)));
						longAtput((objOop4 + BaseHeaderSize) + (((sqInt)((usqInt)(i4) << (shiftForWord(self))))), fwd4);
					}
				}
			}
			else {
				bytes = bytesInObject(objOop4, self);
				while ((toFinger <= startOfPreviousPin)
				 && ((bytes != ((availableSpace = startOfPreviousPin - toFinger)))
				 && ((bytes + (2 * 8 /* allocationUnit */)) > availableSpace))) {

					/* The object does not fit in the space between toFinger and previousPin.
					   Move toFinger up to point at the first unmarked or mobile object after
					   previousPin, or, if previousPin is contiguous with o, to the start of this
					   object.  Update previousPin to be the next pinned object above toFInger
					   and below this object, or nil if no such pinned object exists.
					   Any unfillable gaps between adjacent pinned objects will be freed. */
					do {
						toFinger = addressAfter(previousPin, self);
						/* begin objectStartingAt: */
						numSlots4 = byteAt(toFinger + 7);
						previousPin = (numSlots4 == (numSlotsMask(self))
							? toFinger + BaseHeaderSize
							: toFinger);
					} while((((((usqInt) (longAt(previousPin))) >> (markedBitFullShift(self))) & 1) != 0)
						 && ((((((usqInt) (longAt(previousPin))) >> (pinnedBitShift(self))) & 1) != 0)
						 && (previousPin < objOop4)));
					while (!((previousPin >= objOop4)
					 || ((((((usqInt) (longAt(previousPin))) >> (markedBitFullShift(self))) & 1) != 0)
					 && (((((usqInt) (longAt(previousPin))) >> (pinnedBitShift(self))) & 1) != 0)))) {
						previousPin = oldSpaceObjectAfter(previousPin, self);
					}
					if (previousPin >= objOop4) {
						previousPin = null;
						startOfPreviousPin = 0;
					}
					else {
						/* begin startOfObject: */
						startOfPreviousPin = ((byteAt(previousPin + 7)) == (numSlotsMask(self))
							? previousPin - BaseHeaderSize
							: previousPin);
					}
				}
				updatePointersInsavedFirstFieldPointer(objOop4, top, self);
				toFinger += bytes;
				if (((top += BytesPerOop)) >= ((GIV(savedFirstFieldsSpace).limit))) {
					assert(((GIV(savedFirstFieldsSpace).top)) == (top - BytesPerOop));
					onePass = 0;
					goto l45;
				}
			}
		}
		prevPrevObj3 = prevObj3;
		prevObj3 = objOop4;
		/* begin objectAfter:limit: */
		followingWordAddress3 = addressAfter(objOop4, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory), self)) {
			objOop4 = GIV(endOfMemory);
			goto l37;
		}
		flag("endianness");
		followingWord3 = longAt(followingWordAddress3);
		objOop4 = ((((usqInt) followingWord3) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress3 + BaseHeaderSize
			: followingWordAddress3);
	l37:	/* end objectAfter:limit: */;
	}
	assert(((GIV(savedFirstFieldsSpace).top)) == (top - BytesPerOop));
	onePass = 1;
	l45:	/* end updatePointersInMobileObjects */;
	if (!onePass) {
		/* begin updatePointersInObjectsOverflowingSavedFirstFieldsSpace */
		assert(isOldObject(GIV(objectAfterLastMobileObject), self));
		prevPrevObj = (prevObj = null);
		objOop1 = GIV(objectAfterLastMobileObject);
		while (1) {
			assert((objOop1 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
			assert((long64At(objOop1)) != 0);
			if (isEnumerableObject(objOop1, self)) {
				if (((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0) {
					/* begin updatePointersIn: */
					fmt = (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self));
					if (fmt <= 5 /* lastPointerFormat */) {
						if ((fmt == (indexablePointersFormat(self)))
						 && (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

							/* contexts end at the stack pointer */
							/* begin fetchStackPointerOf: */
							sp = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
							if (!((((sp) & 7) == 1))) {
								contextSize = 0;
								goto l52;
							}
							assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop1, self)));
							contextSize = (sp >> 3);
	l52:	/* end fetchStackPointerOf: */;
							numPointerSlots = CtxtTempFrameStart + contextSize;
							goto l53;
						}
						/* begin numSlotsOf: */
						assert((classIndexOf(objOop1, self)) > (isForwardedObjectClassIndexPun(self)));
						numSlots = byteAt(objOop1 + 7);
						numPointerSlots = (numSlots == (numSlotsMask(self))
							? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop1 - BaseHeaderSize))) << 8)))))) >> 8
							: numSlots);
						goto l53;
					}
					if (fmt == 7 /* forwardedFormat */) {
						numPointerSlots = 1;
						goto l53;
					}
					if (fmt < (firstCompiledMethodFormat(self))) {
						numPointerSlots = 0;
						goto l53;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objOop1, self));
					/* begin fetchPointer:ofObject: */
					header = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
					assert((((header) & 7) == 1));
					numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
					numPointerSlots = numLiterals + LiteralStart;
	l53:	/* end numPointerSlotsOf: */;
					for (i1 = 0; i1 < numPointerSlots; i1 += 1) {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))));
						if (((oop1 & (tagMask(self))) == 0)
						 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop1, GIV(mobileStart), GIV(lastMobileObject), self))
						 && (!(((((usqInt) (longAt(oop1))) >> (pinnedBitShift(self))) & 1) != 0)))) {
							assert((isMarked(oop1, self))
							 || (objOop1 == (hiddenRootsObject(self))));
							/* begin fetchPointer:ofObject: */
							fwd1 = longAt((oop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
							assert(isPostMobile(fwd1, self));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isOopForwarded(objOop1, self)));
							longAtput((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord(self))))), fwd1);
						}
					}
				}
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
				objOop1 = GIV(endOfMemory);
				goto l13;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l13:	/* end objectAfter:limit: */;
		}
			}
}


/*	Sweep the pointer fields in obj, updating all references to mobile objects
	to their eventual locations.
	firstFieldPtr is supplied for mobile objects so that the saved first field
	can be updated, and so that
	the first field of a compiled method (which is its header, or reference to
	a CogMethod holding its header)
	can be retrieved. */

	/* SpurPlanningCompactor>>#updatePointersIn:savedFirstFieldPointer: */
static void NoDbgRegParms
updatePointersInsavedFirstFieldPointer(sqInt obj, sqInt firstFieldPtr, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt fwd;
    sqInt header;
    sqInt i;
    sqInt numLiterals;
    sqInt numPointerSlots;
    usqInt numSlots;
    sqInt oop;
    sqInt oop1;
    sqInt sp;

	fmt = (((usqInt) (longAt(obj))) >> (formatShift(self))) & (formatMask(self));
	/* begin numPointerSlotsWhileCompactingOf:withFormat:savedFirstFieldPointer: */
	assert((firstFieldPtr != null)
	 && (isMobile(obj, self)));
	if (fmt <= 5 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat(self)))
		 && (((longAt(obj)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l6;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(obj, self)));
			contextSize = (sp >> 3);
	l6:	/* end fetchStackPointerOf: */;
			numPointerSlots = CtxtTempFrameStart + contextSize;
			goto l8;
		}
		/* begin numSlotsOf: */
		assert((classIndexOf(obj, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(obj + 7);
		numPointerSlots = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(obj - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		goto l8;
	}
	assert(!((fmt == (forwardedFormat(self)))));
	if (fmt < (firstCompiledMethodFormat(self))) {
		numPointerSlots = 0;
		goto l8;
	}
	/* begin methodHeaderFromSavedFirstField: */
	oop1 = longAt(firstFieldPtr);
	assert((((oop1) & 7) == 1));
	header = oop1;
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	numPointerSlots = numLiterals + LiteralStart;
	l8:	/* end numPointerSlotsWhileCompactingOf:withFormat:savedFirstFieldPointer: */;
	if ((fmt <= 5 /* lastPointerFormat */)
	 && (numPointerSlots > 0)) {

		/* Relocate the saved first field; Note that CompiledMethods can be excluded since their
		   first field is either a SmallInteger or a reference to a CogMethod outside of oldSpace. */
		oop = longAt(firstFieldPtr);
		if (((oop & (tagMask(self))) == 0)
		 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject), self))
		 && (!(((((usqInt) (longAt(oop))) >> (pinnedBitShift(self))) & 1) != 0)))) {
			assert(isMarked(oop, self));
			/* begin fetchPointer:ofObject: */
			fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
			assert(isPostMobile(fwd, self));
			longAtput(firstFieldPtr, fwd);
		}
	}
	for (i = 1; i < numPointerSlots; i += 1) {
		/* begin fetchPointer:ofObject: */
		oop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if (((oop & (tagMask(self))) == 0)
		 && ((oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject), self))
		 && (!(((((usqInt) (longAt(oop))) >> (pinnedBitShift(self))) & 1) != 0)))) {
			assert((isMarked(oop, self))
			 || (obj == (hiddenRootsObject(self))));
			/* begin fetchPointer:ofObject: */
			fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
			assert(isPostMobile(fwd, self));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(obj, self)));
			longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), fwd);
		}
	}
}


/*	Attempt to allocate a memory segment large enough to hold the
	savedFirstFieldsSpace. Invoked when neither eden nor a large free chunk
	are found to be big enough for the job. */

	/* SpurPlanningCompactor>>#useSegmentForSavedFirstFieldsSpace: */
static sqInt NoDbgRegParms
useSegmentForSavedFirstFieldsSpace(sqInt spaceEstimate, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt allocatedSize;
    sqInt roundedSize;
    void *segAddress;

	allocatedSize = 0;
	roundedSize = ((spaceEstimate + 0x3FF) / 1024) * 1024;
	segAddress = sqAllocateMemorySegmentOfSizeAboveAllocatedSizeInto(roundedSize, firstGapOfSizeAtLeast(roundedSize, self), (&allocatedSize));
	if (!(segAddress == null)) {
		(GIV(savedFirstFieldsSpace).start = ((usqIntptr_t)segAddress));
		(GIV(savedFirstFieldsSpace).limit = (((usqIntptr_t)segAddress)) + allocatedSize);
		GIV(savedFirstFieldsSpaceNotInOldSpace) = 1;
		assert(savedFirstFieldsSpaceWasAllocated(self));
		return 1;
	}
	return 0;
}


/*	Answer 0 if all the mobile objects from firstMobileObject to
	lastMobileObject have sane forwarding addresses, and that
	savedFirstFieldsSpace is of
	matching capacity. Otherwise answer an error code identifying the anomaly. */

	/* SpurPlanningCompactor>>#validRelocationPlanInPass: */
static sqInt NoDbgRegParms
validRelocationPlanInPass(sqInt onePass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt destination;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt nMobiles;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt toFinger;

	nMobiles = 0;
	toFinger = GIV(mobileStart);
	GIV(anomaly) = null;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(firstMobileObject), self));
	prevPrevObj = (prevObj = null);
	objOop = GIV(firstMobileObject);
	while (1) {
		assert((objOop % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory), self))) break;
		assert((long64At(objOop)) != 0);
		if (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (!(((((usqInt) (longAt(objOop))) >> (pinnedBitShift(self))) & 1) != 0)) {
				nMobiles += 1;
				/* begin fetchPointer:ofObject: */
				destination = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				if (!(destination >= toFinger)) {
					GIV(anomaly) = objOop;
					return 1;
				}
				toFinger += bytesInObject(objOop, self);
				if (oopisGreaterThan(objOop, GIV(lastMobileObject), self)) {
					GIV(anomaly) = objOop;
					return 2;
				}
				if (objOop == GIV(lastMobileObject)) {
					return ((((((GIV(savedFirstFieldsSpace).top)) + BytesPerOop) - ((GIV(savedFirstFieldsSpace).start))) / BytesPerOop) == nMobiles
						? 0
						: 3);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory), self)) {
			objOop = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
	}
	return ((((((GIV(savedFirstFieldsSpace).top)) + BytesPerOop) - ((GIV(savedFirstFieldsSpace).start))) / BytesPerOop) == nMobiles
		? 0
		: 4);
}

	/* SpurSegmentInfo>>#segLimit */
static usqInt NoDbgRegParms
segLimit(SpurSegmentInfo * self_in_segLimit, struct foo * self)
{
	return ((self_in_segLimit->segSize)) + ((self_in_segLimit->segStart));
}

	/* SpurSegmentManager>>#addSegmentOfSize: */
static SpurSegmentInfo * NoDbgRegParms
addSegmentOfSize(sqInt ammount, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocatedSize;
    sqInt i;
    sqInt idx;
    sqInt lastSegIndex;
    SpurSegmentInfo *newSeg;
    sqInt newSegIndex;
    void *segAddress;
    sqInt segAddress1;
    sqInt segIndex;

	allocatedSize = 0;
	newSegIndex = 0;
	segAddress = sqAllocateMemorySegmentOfSizeAboveAllocatedSizeInto(ammount, firstGapOfSizeAtLeast(ammount, self), (&allocatedSize));
	if (!(segAddress == null)) {
		/* begin insertSegmentFor: */
		segAddress1 = ((usqIntptr_t)segAddress);
		assert(segAddress1 >= (segLimit(&GIV(segments)[0]self)));
		if (GIV(numSegments) == GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos(self);
		}
		assert(GIV(numSegments) < GIV(numSegInfos));
		segIndex = (lastSegIndex = GIV(numSegments) - 1);
		GIV(numSegments) += 1;
		while(1) {
			if (segAddress1 >= ((((GIV(segments)[segIndex]).segSize)) + (((GIV(segments)[segIndex]).segStart)))) {
				segIndex += 1;
				for (idx = lastSegIndex; idx >= segIndex; idx += -1) {
					GIV(segments)[idx + 1] = (GIV(segments)[idx]);
				}
				newSegIndex = segIndex;
				goto l1;
			}
			segIndex -= 1;
		}
	l1:	/* end insertSegmentFor: */;
		newSeg = (&(GIV(segments)[newSegIndex]));
		(newSeg->segStart = ((usqIntptr_t)segAddress));
		(newSeg->segSize = allocatedSize);
		(newSeg->swizzle = 0);
		assert(!(segmentOverlap(self)));
		bridgeFromto((&(GIV(segments)[newSegIndex - 1])), newSeg, self);
		bridgeFromto(newSeg, (!(newSegIndex == (GIV(numSegments) - 1))
			? (&(GIV(segments)[newSegIndex + 1]))
			: 0), self);

		/* test isInMemory: */
		GIV(totalHeapSizeIncludingBridges) += allocatedSize;
		for (i = 0; i < GIV(numSegments); i += 1) {
			assert(isInSegments(((GIV(segments)[i]).segStart), self));
			assert(isInSegments((segLimit(&GIV(segments)[i]self)) - BytesPerWord, self));
			assert((!(isInSegments(segLimit(&GIV(segments)[i]self), self)))
			 || ((i < (GIV(numSegments) - 1))
			 && ((segLimit(&GIV(segments)[i]self)) == (((GIV(segments)[i + 1]).segStart)))));
			assert((!(isInSegments((((GIV(segments)[i]).segStart)) - BytesPerWord, self)))
			 || ((i > 0)
			 && ((segLimit(&GIV(segments)[i - 1]self)) == (((GIV(segments)[i]).segStart)))));
		}
		return newSeg;
	}
	return null;
}


/*	Adjust swizzles by firstSegmentShift. Also computes segStarts as
	they were in the image when it was written, so that oops' segments
	can be determined and hence oops correctly swizzled. */

	/* SpurSegmentManager>>#adjustSegmentSwizzlesBy: */
static void NoDbgRegParms
adjustSegmentSwizzlesBy(sqInt firstSegmentShift, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oldBaseAddr;
    SpurSegmentInfo *segInfo;

	oldBaseAddr = GIV(oldSpaceStart) - firstSegmentShift;
	for (i = 0; i < GIV(numSegments); i += 1) {
		segInfo = (&(GIV(segments)[i]));
		(segInfo->segStart = ((segInfo->segStart)) + oldBaseAddr);
		(segInfo->swizzle = ((segInfo->swizzle)) - oldBaseAddr);
	}
	GIV(canSwizzle) = 1;
}

	/* SpurSegmentManager>>#allBridgesMarked */
static sqInt
allBridgesMarked(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    SpurSegmentInfo *aSegment;
    sqInt bridgeObj;
    sqInt i;
    usqInt numSlots;

	for (i = 0; i < GIV(numSegments); i += 1) {
		/* begin bridgeFor: */
		aSegment = ((SpurSegmentInfo *) ((&(GIV(segments)[i]))));
		/* begin objectStartingAt: */
		address = (((aSegment->segSize)) + ((aSegment->segStart))) - (2 * BaseHeaderSize);
		numSlots = byteAt(address + 7);
		bridgeObj = (numSlots == (numSlotsMask(self))
			? address + BaseHeaderSize
			: address);
		assert(isValidSegmentBridge(bridgeObj, self));
		if (!(((((usqInt) (longAt(bridgeObj))) >> (markedBitFullShift(self))) & 1) != 0)) {
			return 0;
		}
	}
	return 1;
}


/*	Increase the number of allocated segInfos by 16. */

	/* SpurSegmentManager>>#allocateOrExtendSegmentInfos */
static void
allocateOrExtendSegmentInfos(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newNumSegs;

	if (GIV(numSegInfos) == 0) {
		GIV(numSegInfos) = 16;
		GIV(segments) = calloc(GIV(numSegInfos), sizeof(SpurSegmentInfo));
		return;
	}
	newNumSegs = GIV(numSegInfos) + 16;
	GIV(segments) = realloc(GIV(segments), newNumSegs * (sizeof(SpurSegmentInfo)));
	if (GIV(segments) == 0) {
		error("out of memory; cannot allocate more segments");
	}
	memset(GIV(segments) + GIV(numSegInfos), 0, (newNumSegs - GIV(numSegInfos)) * (sizeof(SpurSegmentInfo)));
	GIV(numSegInfos) = newNumSegs;
}

	/* SpurSegmentManager>>#bridgeAt: */
static sqInt NoDbgRegParms
bridgeAt(sqInt segIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (((((&(GIV(segments)[segIndex])))->segSize)) + ((((&(GIV(segments)[segIndex])))->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
}

	/* SpurSegmentManager>>#bridgeFor: */
static sqInt NoDbgRegParms
bridgeFor(SpurSegmentInfo *aSegment, struct foo * self)
{
    sqInt address;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (((aSegment->segSize)) + ((aSegment->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
}


/*	Create a bridge from aSegment to the next segment,
	or create a terminating bridge if there is no next segment. */

	/* SpurSegmentManager>>#bridgeFrom:to: */
static void NoDbgRegParms
bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil, struct foo * self)
{
    sqInt bridgeSpan;
    sqInt clifton;
    usqInt segEnd;

	segEnd = ((aSegment->segSize)) + ((aSegment->segStart));

	/* clifton is where the Avon bridge begins... */
	clifton = segEnd - (2 * BaseHeaderSize);
	if (nextSegmentOrNil == null) {
		/* begin bridgeSize */
		bridgeSpan = 2 * BaseHeaderSize;
	}
	else {
		bridgeSpan = (((nextSegmentOrNil->segStart)) - segEnd) + (2 * BaseHeaderSize);
	}
	assert(bridgeSpan >= 0);
	initSegmentBridgeWithBytesat(bridgeSpan, clifton, self);
	assert((addressAfter(objectStartingAt(clifton, self), self)) == ((nextSegmentOrNil == null
		? segLimit(aSegmentself)
		: (nextSegmentOrNil->segStart))));
}

	/* SpurSegmentManager>>#checkSegments */
static void
checkSegments(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(numSegments) >= 1);
	for (i = 0; i < GIV(numSegments); i += 1) {
		assert(addressCouldBeObj(((GIV(segments)[i]).segStart), self));
		assert(isValidSegmentBridge(bridgeAt(i, self), self));
	}
	assert(((segLimit(&GIV(segments)[GIV(numSegments) - 1]self)) - (bridgeSize(self))) == (endOfMemory(self)));
}


/*	The image has been loaded, old segments reconstructed, and the heap
	swizzled into a single contiguous segment. Collapse the segments into one. */

	/* SpurSegmentManager>>#collapseSegmentsPostSwizzle */
static void
collapseSegmentsPostSwizzle(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurSegmentInfo * cascade0;

	GIV(canSwizzle) = 0;
	GIV(numSegments) = 1;
	cascade0 = (&(GIV(segments)[0]));
	(cascade0->segStart = oldSpaceStart(self));
	(cascade0->segSize = (GIV(totalHeapSizeIncludingBridges) = (endOfMemory(self)) - (oldSpaceStart(self))));
	assert(isSegmentBridge(bridgeAt(0, self), self));
	assert((numSlotsOfAny(bridgeAt(0, self), self)) == 0);
}


/*	Answer the segment limit of the first segment followed by a gap of at
	least size bytes.
 */

	/* SpurSegmentManager>>#firstGapOfSizeAtLeast: */
static void * NoDbgRegParms
firstGapOfSizeAtLeast(sqInt size, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bridge;
    sqInt i;
    usqInt numSlots;

	for (i = 0; i <= (GIV(numSegments) - 2); i += 1) {
		/* begin objectStartingAt: */
		address = (((((&(GIV(segments)[i])))->segSize)) + ((((&(GIV(segments)[i])))->segStart))) - (2 * BaseHeaderSize);
		numSlots = byteAt(address + 7);
		bridge = (numSlots == (numSlotsMask(self))
			? address + BaseHeaderSize
			: address);
		if (((bytesInObject(bridge, self)) - (2 * BaseHeaderSize)) >= size) {
			return ((void *)((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart))));
		}
	}
	return ((void *)((((GIV(segments)[GIV(numSegments) - 1]).segSize)) + (((GIV(segments)[GIV(numSegments) - 1]).segStart))));
}

	/* SpurSegmentManager>>#isEmptySegment: */
static sqInt NoDbgRegParms
isEmptySegment(SpurSegmentInfo *seg, struct foo * self)
{
    sqInt address;
    sqInt firstObj;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (seg->segStart);
	numSlots = byteAt(address + 7);
	firstObj = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	return (((longAt(firstObj)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)))
	 && ((addressAfter(firstObj, self)) == ((((seg->segSize)) + ((seg->segStart))) - (2 * BaseHeaderSize)));
}

	/* SpurSegmentManager>>#isInSegments: */
static sqInt NoDbgRegParms
isInSegments(usqInt address, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < ((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart)))) {
			return 1;
		}
	}
	return 0;
}


/*	bridges bridge the gaps between segments. They are the last object in each
	segment. 
 */

	/* SpurSegmentManager>>#isValidSegmentBridge: */
static sqInt NoDbgRegParms
isValidSegmentBridge(sqInt objOop, struct foo * self)
{
	return ((addressCouldBeObj(objOop, self))
	 || (objOop == (endOfMemory(self))))
	 && ((((longAt(objOop)) & (classIndexMask(self))) == (segmentBridgePun(self)))
	 && (((byteAt(objOop + 7)) == (numSlotsMask(self)))
	 || ((numSlotsOfAny(objOop, self)) == 0)));
}


/*	Answer the the next non-empty segment or nil. The size of a segment
	includes that of its bridge. A segment containing just a free object and a
	bridge will still
	have a size of manager bridgeSize after shortening it in
	prepareForSnapshot. 
 */

	/* SpurSegmentManager>>#nextNonEmptySegmentAfter: */
static SpurSegmentInfo * NoDbgRegParms
nextNonEmptySegmentAfter(sqInt i, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nextx;

	nextx = i;
	while(1) {
		if (((nextx += 1)) >= GIV(numSegments)) {
			return null;
		}
		if ((((GIV(segments)[nextx]).segSize)) > (2 * BaseHeaderSize)) {
			return (&(GIV(segments)[nextx]));
		}
	}
	return 0;
}


/*	Restore all shortened segments to their proper size, re-freeing the
	trailing space.
 */

	/* SpurSegmentManager>>#postSnapshot */
static void
postSnapshot(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bytes;
    usqInt freeChunk;
    sqInt i;
    sqInt newEndOfMemory;
    SpurSegmentInfo *seg;

	seg = (&(GIV(segments)[GIV(numSegments) - 1]));
	if (((seg->lastFreeObject)) == null) {
		assert((endOfMemory(self)) == ((segLimit(segself)) - (bridgeSize(self))));
	}
	else {
		/* begin setEndOfMemory: */
		newEndOfMemory = (((seg->savedSegSize)) + ((seg->segStart))) - (2 * BaseHeaderSize);
		GIV(endOfMemory) = newEndOfMemory;
		if (GIV(freeOldSpaceStart) > newEndOfMemory) {
			GIV(freeOldSpaceStart) = newEndOfMemory;
		}
	}
	for (i = (GIV(numSegments) - 1); i >= 0; i += -1) {
		seg = (&(GIV(segments)[i]));
		freeChunk = (seg->lastFreeObject);
		if (!(freeChunk == null)) {
			address = (((seg->segSize)) + ((seg->segStart))) - (2 * BaseHeaderSize);
			(seg->segSize = (seg->savedSegSize));
			bridgeFromto(seg, (i < (GIV(numSegments) - 1)
				? (&(GIV(segments)[i + 1]))
				: 0), self);
			/* begin addFreeChunkWithBytes:at: */
			bytes = ((((seg->segSize)) + ((seg->segStart))) - address) - (2 * BaseHeaderSize);
			GIV(totalFreeOldSpace) += bytes;
			freeChunkWithBytesat(bytes, address, self);
		}
	}
	checkSegments(self);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
}


/*	shorten all segments by any trailing free space. */

	/* SpurSegmentManager>>#prepareForSnapshot */
static void NeverInline
prepareForSnapshot(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    SpurSegmentInfo * cascade0;
    usqInt chunkBytes;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    sqInt fieldIndex3;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt largeChild;
    sqInt limit;
    sqInt newEndOfMemory;
    sqInt next;
    usqInt node;
    SpurSegmentInfo *seg;
    sqInt smallChild;
    sqInt treeNode;

	checkSegments(self);
	for (i = 0; i < GIV(numSegments); i += 1) {
		cascade0 = (&(GIV(segments)[i]));
		(cascade0->savedSegSize = ((GIV(segments)[i]).segSize));
		(cascade0->lastFreeObject = null);
	}
	/* begin freeTreeNodesDo: */
	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		goto l5;
	}
	cameFrom = -1;
	do {
		assert((bytesInObject(treeNode, self)) >= ((numFreeLists(self)) * (allocationUnit(self))));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex1 = 3 /* freeChunkSmallerIndex */;
		smallChild = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex2 = 4 /* freeChunkLargerIndex */;
		largeChild = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord(self))))));
		assert((smallChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(self), smallChild, self))));
		assert((largeChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(self), largeChild, self))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */
			node = treeNode;
			while (node != 0) {
				/* begin objectAfter:limit: */
				limit = endOfMemory(self);
				followingWordAddress = addressAfter(node, self);
				if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
					next = limit;
					goto l8;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				next = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
	l8:	/* end objectAfter:limit: */;
				if (((longAt(next)) & (classIndexMask(self))) == (segmentBridgePun(self))) {
					/* begin segmentContainingObj: */
					for (i1 = (GIV(numSegments) - 1); i1 >= 0; i1 += -1) {
						if (node >= (((GIV(segments)[i1]).segStart))) {
							seg = (&(GIV(segments)[i1]));
							goto l9;
						}
					}
					seg = null;
	l9:	/* end segmentContainingObj: */;
					(seg->lastFreeObject = node);
					node = 0;
				}
				else {
					/* begin fetchPointer:ofFreeChunk: */
					fieldIndex = 0 /* freeChunkNextIndex */;
					node = longAt((node + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
				}
			}
			treeNode = treeNode;
			cameFrom = treeNode;
			/* begin fetchPointer:ofFreeChunk: */
			fieldIndex3 = 2 /* freeChunkParentIndex */;
			treeNode = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex3) << (shiftForWord(self))))));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode != 0);
	l5:	/* end freeTreeNodesDo: */;
	for (i = 0; i < GIV(numSegments); i += 1) {
		freeChunk = ((GIV(segments)[i]).lastFreeObject);
		if (!(freeChunk == null)) {
			/* begin detachFreeObject: */
			chunkBytes = bytesInObject(freeChunk, self);
			GIV(totalFreeOldSpace) -= chunkBytes;
			unlinkFreeChunkchunkBytes(freeChunk, chunkBytes, self);
			((GIV(segments)[i]).segSize = ((((byteAt(freeChunk + 7)) == (numSlotsMask(self))
	? freeChunk - BaseHeaderSize
	: freeChunk)) + (2 * BaseHeaderSize)) - (((GIV(segments)[i]).segStart)));
			bridgeFromto((&(GIV(segments)[i])), (i < (GIV(numSegments) - 1)
				? (&(GIV(segments)[i + 1]))
				: 0), self);
		}
	}
	/* begin setEndOfMemory: */
	newEndOfMemory = ((((GIV(segments)[GIV(numSegments) - 1]).segSize)) + (((GIV(segments)[GIV(numSegments) - 1]).segStart))) - (2 * BaseHeaderSize);
	GIV(endOfMemory) = newEndOfMemory;
	if (GIV(freeOldSpaceStart) > newEndOfMemory) {
		GIV(freeOldSpaceStart) = newEndOfMemory;
	}
}


/*	Read numBytes of image data from f into memory at memoryBaseForImageRead.
	Answer the number of bytes written. In addition, read each segment, build
	up the
	segment info for swizzling, while eliminating the bridge objects at the
	end of each
	segment that specify the distance to and the size of the subsequent
	segment.  */

	/* SpurSegmentManager>>#readHeapFromImageFile:dataBytes: */
static sqInt NoDbgRegParms
readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bridge;
    sqInt bridgehead;
    usqLong bridgeSpan;
    sqInt bytesRead;
    usqInt newBase;
    sqInt nextSegmentSize;
    sqInt oldBase;
    SpurSegmentInfo *segInfo;
    sqInt totalBytesRead;

	allocateOrExtendSegmentInfos(self);
	GIV(numSegments) = (totalBytesRead = 0);

	/* N.B. still must be adjusted by oldBaseAddr. */
	oldBase = 0;
	newBase = oldSpaceStart(self);
	nextSegmentSize = GIV(firstSegmentSize);
	bridgehead = (GIV(firstSegmentSize) + (oldSpaceStart(self))) - (2 * BaseHeaderSize);
	while (1) {
		segInfo = (&(GIV(segments)[GIV(numSegments)]));
		(segInfo->segStart = oldBase);
		(segInfo->segSize = nextSegmentSize);
		(segInfo->swizzle = newBase - oldBase);
		bytesRead = sqImageFileRead(pointerForOop(newBase), sizeof(char), nextSegmentSize, f, self);
		if (bytesRead > 0) {
			totalBytesRead += bytesRead;
		}
		if (bytesRead != nextSegmentSize) {
			return totalBytesRead;
		}
		if (((GIV(numSegments) += 1)) >= GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos(self);
		}
		bridge = bridgehead + BaseHeaderSize;
		bridgeSpan = ((byteAt(bridgehead + 7)) == 0
			? 0
			: BytesPerOop * (((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(bridge - BaseHeaderSize))) << 8)))))) >> 8));
		oldBase = (oldBase + nextSegmentSize) + bridgeSpan;
		newBase = (newBase + nextSegmentSize) - (2 * BaseHeaderSize);
		nextSegmentSize = ((usqInt)(long64At(bridge)));
		if (!(nextSegmentSize != 0)) break;
		bridgehead = (bridgehead - (2 * BaseHeaderSize)) + nextSegmentSize;
	}
	assert((newBase - (oldSpaceStart(self))) == (totalBytesRead - (GIV(numSegments) * (bridgeSize(self)))));
	/* begin setFreeOldSpaceStart: */
	GIV(freeOldSpaceStart) = newBase;
	GIV(firstSegmentSize) = null;
	return totalBytesRead;
}

	/* SpurSegmentManager>>#segmentContainingObj: */
EXPORT(SpurSegmentInfo *)
segmentContainingObj(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = (GIV(numSegments) - 1); i >= 0; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return (&(GIV(segments)[i]));
		}
	}
	return null;
}


/*	Answers true if a segment overlaps with another one. */

	/* SpurSegmentManager>>#segmentOverlap */
static sqInt
segmentOverlap(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt endi;
    usqInt endj;
    sqInt i;
    sqInt j;
    usqInt starti;
    usqInt startj;

	for (i = 0; i < GIV(numSegments); i += 1) {
		starti = ((GIV(segments)[i]).segStart);
		endi = (((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart));
		for (j = 0; j < GIV(numSegments); j += 1) {
			startj = ((GIV(segments)[j]).segStart);
			endj = (((GIV(segments)[j]).segSize)) + (((GIV(segments)[j]).segStart));
			if (!(i == j)) {
				if (!((starti < startj)
					 || (starti >= endj))) {
					return 1;
				}
				if (!((endi <= startj)
					 || (endi >= endj))) {
					return 1;
				}
			}
		}
	}
	return 0;
}


/*	Answer if any shrinkage was achieved. */

	/* SpurSegmentManager>>#shrinkObjectMemory: */
static sqInt NoDbgRegParms
shrinkObjectMemory(usqInt delta, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    SpurSegmentInfo *best;
    usqInt chunkBytes;
    usqInt currentEnd;
    sqInt delta1;
    SpurSegmentInfo *emptySeg;
    sqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt j;
    usqInt numSlots;
    SpurSegmentInfo *seg;
    SpurSegmentInfo *segInfo;
    usqInt shrinkage;

	i = 0;
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFreeSpace)) == (GCModeFreeSpace | GCModeFreeSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	shrinkage = delta;
	while(1) {
		/* begin findEmptySegNearestInSizeTo: */
		best = null;
		delta1 = shrinkage;
		for (i2 = 0; i2 < GIV(numSegments); i2 += 1) {
			seg = (&(GIV(segments)[i2]));
			if (isEmptySegment(seg, self)) {
				if (best == null) {
					best = seg;
				}
				else {
					if ((shrinkage >= (((seg->segSize)) * 0.75))
					 && ((SQABS((((sqInt) (((seg->segSize)) - shrinkage))))) < delta1)) {
						best = seg;
						delta1 = SQABS((((sqInt) (((seg->segSize)) - shrinkage))));
					}
				}
			}
		}
		emptySeg = best;
		if ((emptySeg == null)
		 || (((emptySeg->segSize)) > shrinkage)) {
			/* begin checkFreeSpace: */
			assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
			assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
			if (((checkForLeaks & (GCModeFreeSpace | GCModeFreeSpace)) == (GCModeFreeSpace | GCModeFreeSpace))) {
				runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
			}
			return shrinkage < delta;
		}
		shrinkage -= (emptySeg->segSize);
		/* begin detachFreeObject: */
		address = (emptySeg->segStart);
		numSlots = byteAt(address + 7);
		freeChunk = (numSlots == (numSlotsMask(self))
			? address + BaseHeaderSize
			: address);
		chunkBytes = bytesInObject(freeChunk, self);
		GIV(totalFreeOldSpace) -= chunkBytes;
		unlinkFreeChunkchunkBytes(freeChunk, chunkBytes, self);
		/* begin removeSegment: */
		for (i1 = 0; i1 < GIV(numSegments); i1 += 1) {
			if (((emptySeg->segStart)) == (((GIV(segments)[i1]).segStart))) {
				i = i1;
				goto l1;
			}
		}
		error("segment not found");
	l1:	/* end indexOfSegment: */;
		assert(i > 0);
		GIV(totalHeapSizeIncludingBridges) -= (emptySeg->segSize);
		sqDeallocateMemorySegmentAtOfSize(((void *)((emptySeg->segStart))), (emptySeg->segSize));
		for (j = i; j <= (GIV(numSegments) - 2); j += 1) {
			GIV(segments)[j] = (GIV(segments)[j + 1]);
		}
		GIV(numSegments) -= 1;
		bridgeFromto((&(GIV(segments)[i - 1])), (i <= (GIV(numSegments) - 1)
			? (&(GIV(segments)[i]))
			: 0), self);
		/* begin setLastSegment: */
		segInfo = ((SpurSegmentInfo *) ((&(GIV(segments)[GIV(numSegments) - 1]))));
		currentEnd = (((segInfo->segSize)) + ((segInfo->segStart))) - (2 * BaseHeaderSize);
		if (currentEnd <= GIV(endOfMemory)) {
			GIV(endOfMemory) = currentEnd;
			if (GIV(freeOldSpaceStart) > currentEnd) {
				GIV(freeOldSpaceStart) = currentEnd;
			}
		}
	}
	return 0;
}

	/* SpurSegmentManager>>#someSegmentContainsPinned */
static sqInt
someSegmentContainsPinned(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (((GIV(segments)[i]).containsPinned)) {
			return 1;
		}
	}
	return 0;
}

	/* SpurSegmentManager>>#swizzleObj: */
static sqInt NoDbgRegParms
swizzleObj(sqInt objOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(canSwizzle));
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}

	/* SpurSegmentManager>>#totalBytesInSegments */
static usqInt
totalBytesInSegments(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt total;

	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		total += ((GIV(segments)[i]).segSize);
	}
	assert(GIV(totalHeapSizeIncludingBridges) == total);
	return total;
}

	/* SpurSegmentManager>>#writeImageSegmentsToFile: */
static sqInt NoDbgRegParms
writeImageSegmentsToFile(sqImageFile aBinaryStream, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt total;

	assert(((endOfMemory(self)) == (segLimit(&GIV(segments)[GIV(numSegments) - 1]self)))
	 || (((endOfMemory(self)) + (bridgeSize(self))) == (segLimit(&GIV(segments)[GIV(numSegments) - 1]self))));
	if (GIV(firstSegmentSize)) {
		assert(GIV(firstSegmentSize) == (((GIV(segments)[0]).segSize)));
	}
	assert((((GIV(segments)[0]).segSize)) > 0);
	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		if ((((GIV(segments)[i]).segSize)) > (2 * BaseHeaderSize)) {
			total += writeSegmentnextSegmenttoFile((&(GIV(segments)[i])), nextNonEmptySegmentAfter(i, self), aBinaryStream, self);
		}
	}
	return total;
}


/*	Write the segment contents, the size of and the distance to the next
	segment to aBinaryStream.
 */

	/* SpurSegmentManager>>#writeSegment:nextSegment:toFile: */
static sqInt NoDbgRegParms
writeSegmentnextSegmenttoFile(SpurSegmentInfo *segment, SpurSegmentInfo *nextSegment, sqImageFile aBinaryStream, struct foo * self)
{
    usqLong firstSavedBridgeWord;
    sqInt nWritten;
    sqInt pier1;
    sqInt pier2;
    usqLong secondSavedBridgeWord;

	pier1 = (((segment->segSize)) + ((segment->segStart))) - (2 * BaseHeaderSize);
	pier2 = pier1 + BaseHeaderSize;
	assert(isValidSegmentBridge(bridgeFor(segment, self), self));
	assert((startOfObject(bridgeFor(segment, self), self)) == pier1);
	firstSavedBridgeWord = long64At(pier1);
	secondSavedBridgeWord = long64At(pier2);
	bridgeFromto(segment, nextSegment, self);
	long64Atput(pier2, (nextSegment == null
		? 0
		: (nextSegment->segSize)));
	nWritten = sqImageFileWrite(((void *)((segment->segStart))), 1, (segment->segSize), aBinaryStream, self);
	long64Atput(pier1, firstSavedBridgeWord);
	long64Atput(pier2, secondSavedBridgeWord);
	return nWritten;
}


/*	Answer the current activeProcess. */
/*	useful for VM debugging */

	/* StackInterpreter>>#activeProcess */
sqInt
activeProcess(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt objOop1;

	/* begin memoryActiveProcess */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
}


/*	The various poll/select calls in the VM should attempt to tally the
	ammount of time spent at idle here, so as to render the uptime value
	meaningful. 
 */

	/* StackInterpreter>>#addIdleUsecs: */
void
addIdleUsecs(sqInt idleUsecs, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(statIdleUsecs) += idleUsecs;
}


/*	Add the given process to the end of the given linked list
	and set the backpointer of process to its new list. */

	/* StackInterpreter>>#addLastLink:toList: */
static void NoDbgRegParms
addLastLinktoList(sqInt proc, sqInt aList, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLink;

	assert(!((isForwarded(proc, self))));
	assert(!((isForwarded(aList, self))));
	assert((fetchPointerofObject(NextLinkIndex, proc, self)) == (nilObject(self)));
	if ((assert(!(isForwarded(aList, self))),
	(longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))))) == GIV(nilObj))) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList, self)));
		if ((assert(isNonImmediate(aList, self)),
		oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((proc & (tagMask(self))) == 0)
			 && (oopisLessThan(proc, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(aList, self);
				}
			}
		}
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))), proc);
	}
	else {
		/* begin fetchPointer:ofObject: */
		lastLink = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))));
		assert(lastLink != proc);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(lastLink, self)));
		if ((assert(isNonImmediate(lastLink, self)),
		oopisGreaterThanOrEqualTo(lastLink, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((proc & (tagMask(self))) == 0)
			 && (oopisLessThan(proc, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(lastLink))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(lastLink, self);
				}
			}
		}
		longAtput((lastLink + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))), proc);
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(aList, self)));
	if ((assert(isNonImmediate(aList, self)),
	oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((proc & (tagMask(self))) == 0)
		 && (oopisLessThan(proc, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(aList))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(aList, self);
			}
		}
	}
	longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))), proc);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(proc, self)));
	if ((assert(isNonImmediate(proc, self)),
	oopisGreaterThanOrEqualTo(proc, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((aList & (tagMask(self))) == 0)
		 && (oopisLessThan(aList, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(proc))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(proc, self);
			}
		}
	}
	longAtput((proc + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord(self))))), aList);
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */

	/* StackInterpreter>>#addNewMethodToCache: */
static void NoDbgRegParms
addNewMethodToCache(sqInt classObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt err;
    sqInt err1;
    sqInt err2;
    sqInt firstBytecode;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt hash3;
    sqInt methodHeader;
    sqInt p;
    sqInt primitiveIndex;
    sqInt probe;

	/* begin methodCacheHashOf:with: */
	assert(addressCouldBeClassObj(classObj, self));
	classTag = (((hash1 = (long32At(classObj + 4)) & (identityHashHalfWordMask(self)))) != 0
		? hash1
		: (objCouldBeClassObj(classObj, self)
				? (((err = enterIntoClassTable(classObj, self))) != 0
						? -err
						: (/* begin rawHashBitsOf: */
							(long32At(classObj + 4)) & (identityHashHalfWordMask(self))))
				: -PrimErrBadReceiver));
	hash = GIV(messageSelector) ^ (((sqInt)((usqInt)(classTag) << 2)));
	if (((GIV(newMethod) & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))) {
		/* begin primitiveIndexOfMethod:header: */
		assert(isCompiledMethod(GIV(newMethod), self));
		/* begin fetchPointer:ofObject: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		if (methodHeader & AlternateHeaderHasPrimFlag) {
			firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
			primitiveIndex = (byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8)));
		}
		else {
			primitiveIndex = 0;
		}
		/* begin functionPointerFor:inClass: */
		GIV(primitiveFunctionPointer) = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		assert(!((isNonImmediate(GIV(newMethod), self))
		 && (isForwarded(GIV(newMethod), self))));
		GIV(primitiveFunctionPointer) = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {

			/* Found an empty entry -- use it */
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = ((assert(addressCouldBeClassObj(classObj, self)),
(((hash2 = (long32At(classObj + 4)) & (identityHashHalfWordMask(self)))) != 0
		? hash2
		: (objCouldBeClassObj(classObj, self)
				? (((err1 = enterIntoClassTable(classObj, self))) != 0
						? -err1
						: (/* begin rawHashBitsOf: */
							(long32At(classObj + 4)) & (identityHashHalfWordMask(self))))
				: -PrimErrBadReceiver))));
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) GIV(primitiveFunctionPointer)));

			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}

	/* first probe */
	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = ((assert(addressCouldBeClassObj(classObj, self)),
(((hash3 = (long32At(classObj + 4)) & (identityHashHalfWordMask(self)))) != 0
		? hash3
		: (objCouldBeClassObj(classObj, self)
				? (((err2 = enterIntoClassTable(classObj, self))) != 0
						? -err2
						: (/* begin rawHashBitsOf: */
							(long32At(classObj + 4)) & (identityHashHalfWordMask(self))))
				: -PrimErrBadReceiver))));
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) GIV(primitiveFunctionPointer)));

	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */
	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}


/*	Answer if maybeClassObj looks like a class object */

	/* StackInterpreter>>#addressCouldBeClassObj: */
static sqInt NoDbgRegParms
addressCouldBeClassObj(sqInt maybeClassObj, struct foo * self)
{
	return (addressCouldBeObj(maybeClassObj, self))
	 && (objCouldBeClassObj(maybeClassObj, self));
}

	/* StackInterpreter>>#addressOf:inGIV: */
static sqInt NoDbgRegParms
addressOfinGIV(char *GIVElement, struct foo *interpreterState, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt externalAddress;
    sqInt *ptr;

	externalAddress = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord(self)))))), BytesPerWord, self);

	/* It could be a caseOf but at the time i was even worst than a caseOf */
	ptr = firstIndexableField(externalAddress, self);
	if ((strcmp(GIVElement, "method")) == 0) {
		ptr[0] = (interpreterState->method);
		return externalAddress;
	}
	if ((strcmp(GIVElement, "nilObj")) == 0) {
		ptr[0] = (interpreterState->nilObj);
		return externalAddress;
	}
	if ((strcmp(GIVElement, "instructionPointer")) == 0) {
		ptr[0] = (interpreterState->instructionPointer);
		return externalAddress;
	}
	if ((strcmp(GIVElement, "specialObjectsOop")) == 0) {
		ptr[0] = (interpreterState->specialObjectsOop);
		return externalAddress;
	}
	if ((strcmp(GIVElement, "oldSpaceStart")) == 0) {
		ptr[0] = (interpreterState->oldSpaceStart);
		return externalAddress;
	}
	return null;
}

	/* StackInterpreter>>#allOnesAsCharStar */
static char *
allOnesAsCharStar(struct foo * self)
{
	return ((char *) (((usqInt) -1)));
}


/*	for Cogit */

	/* StackInterpreter>>#argumentCountOfClosure: */
sqInt
argumentCountOfClosure(sqInt closurePointer, struct foo * self)
{
    sqInt oop;

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((closurePointer + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	return (oop >> 3);
}

	/* StackInterpreter>>#argumentCountOfMethodHeader: */
sqInt
argumentCountOfMethodHeader(sqInt header, struct foo * self)
{
	return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
}

	/* StackInterpreter>>#argumentCountOf: */
sqInt
argumentCountOf(sqInt methodPointer, struct foo * self)
{
    sqInt header;

	/* begin argumentCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if
	the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#arrayValueOf: */
void *
arrayValueOf(sqInt arrayOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (((arrayOop & (tagMask(self))) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(arrayOop))) >> (formatShift(self))) & (formatMask(self)), self))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Returns an integer object */

	/* StackInterpreter>>#asciiOfCharacter: */
static sqInt NoDbgRegParms
asciiOfCharacter(sqInt characterObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (characterObj & (characterTag(self))) {
		return characterObj - ((characterTag(self)) - (smallIntegerTag(self)));
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	return ConstZero;
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s: */
void
assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp, struct foo * self)
{
	assertValidExecutionPointersimbarline(lip, lifp, lisp, !0, __LINE__, self);
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s:imbar:line: */
static void NoDbgRegParms
assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertl(inInterpreter, ln);
	assertl(GIV(stackPage) == (mostRecentlyUsedPage(self)), ln);
	/* begin assertValidStackLimits: */
	assertl((GIV(stackLimit) == ((GIV(stackPage)->realStackLimit)))
	 || (GIV(stackLimit) == (allOnesAsCharStar(self))), ln);
	assertl((((GIV(stackPage)->stackLimit)) == ((GIV(stackPage)->realStackLimit)))
	 || (((GIV(stackPage)->stackLimit)) == (allOnesAsCharStar(self))), ln);
	assertl(addressIsInPage(GIV(stackPage), lfp, self), ln);
	assertl(lsp < lfp, ln);
	assertl(lfp > lsp, ln);
	assertl(lsp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset(self))), ln);
	assertl(((lfp - lsp) / BytesPerOop) < LargeContextSlots, ln);
	assertl(validInstructionPointerinFrame(lip, lfp, self), ln);
	assertl((frameIsBlockActivation(lfp, self))
	 || ((pushedReceiverOrClosureOfFrame(lfp, self)) == (frameReceiver(lfp, self))), ln);
	assertl(GIV(method) == (frameMethod(lfp, self)), ln);
	
#  if MULTIPLEBYTECODESETS
	assertl((methodUsesAlternateBytecodeSet(GIV(method), self)) == (GIV(bytecodeSetSelector) == 256), ln);
#  endif /* MULTIPLEBYTECODESETS */
}


/*	convert true and false (Smalltalk) to true or false(C) */

	/* StackInterpreter>>#booleanValueOf: */
sqInt
booleanValueOf(sqInt obj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}


/*	Re-enter the interpreter to execute a (non-ALien,non-FFI) callback (as
	used by the Python bridge).
 */

	/* StackInterpreter>>#callbackEnter: */
EXPORT(sqInt)
callbackEnter(sqInt *callbackID, struct foo * self)
{   DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT
    volatile sqInt header;
    volatile jmp_buf savedReenterInterpreter;
    volatile sqInt xArray;

	if (!(asserta(GIV(primitiveFunctionPointer) != 0))) {
		return 0;
	}
	assert(GIV(primFailCode) == 0);
	if (!(asserta(GIV(jmpDepth) < MaxJumpBuf))) {
		return 0;
	}

	/* Suspend the currently active process */
	GIV(jmpDepth) += 1;
	GIV(suspendedCallbacks)[GIV(jmpDepth)] = (memoryActiveProcess(self));
	GIV(suspendedMethods)[GIV(jmpDepth)] = GIV(newMethod);
	/* begin signalExternalSemaphores */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord(self))))));
	doSignalExternalSemaphores(numSlotsOf(xArray, self));
	if ((GIV(suspendedCallbacks)[GIV(jmpDepth)]) == (memoryActiveProcess(self))) {
		transferTo(wakeHighestPriority(self), self);
	}
	forceInterruptCheck(self);
	memcpy(((void *)savedReenterInterpreter), reenterInterpreter, sizeof(jmp_buf));
	if ((setjmp(GIV(jmpBuf)[GIV(jmpDepth)])) == 0) {

		/* Fill in callbackID */
		callbackID[0] = GIV(jmpDepth);
		enterSmalltalkExecutive(self);
		assert(0);
	}
	memcpy(reenterInterpreter, ((void *) savedReenterInterpreter), sizeof(jmp_buf));
	putToSleepyieldingIf(memoryActiveProcess(self), GIV(preemptionYields), self);
	transferTo(GIV(suspendedCallbacks)[GIV(jmpDepth)], self);

	/* see comment above */
	GIV(newMethod) = GIV(suspendedMethods)[GIV(jmpDepth)];
	/* begin argumentCountOf: */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	GIV(argumentCount) = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
	assert(GIV(primFailCode) == 0);
	GIV(jmpDepth) -= 1;
	return 1;
}


/*	Leave from a previous callback */
/*	For now, do not allow a callback return unless we're in a
	primitiveResponse 
 */

	/* StackInterpreter>>#callbackLeave: */
EXPORT(sqInt)
callbackLeave(sqInt cbID, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(asserta(GIV(primitiveFunctionPointer) != 0))) {
		return 0;
	}
	if (!(cbID == GIV(jmpDepth))) {
		return 0;
	}
	if (cbID < 1) {
		return 0;
	}
	longjmp(GIV(jmpBuf)[GIV(jmpDepth)], 1);
	return null;
}


/*	Context switch should not be allowed on every method activation. In
	particular the implementation of ensure: and ifCurtailed: depends on there
	being no
	suspension point on failing primitive 198 (primitiveMarkUnwindMethod).
	slowPrimitiveResponse states
	``N.B. This means there is no suspension point on primitive failure
	which methods such as ensure: and ifCurtailed: rely on.''
	Rather than prevent context switch on all primitives but the ones we
	really need
	to be suspension points (primitiveSignal et al) we choose to allow context
	switch for all but primitiveMarkUnwindMethod. */

	/* StackInterpreter>>#canContextSwitchIfActivating:header: */
sqInt
canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader, struct foo * self)
{
    sqInt firstBytecode;
    sqInt primitiveIndex;

	if (methodHeader & AlternateHeaderHasPrimFlag) {
		firstBytecode = (theMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primitiveIndex = (byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8)));
	}
	else {
		primitiveIndex = 0;
	}
	return 
#  if 1
		primitiveIndex != 198
#  else /* 1 */
		(primitiveIndex == 0)
			 || ((((primitiveIndex >= 85) && (primitiveIndex <= 88)))
			 || (primitiveIndex == 167))
#  endif /* 1 */
		;
}

	/* StackInterpreter>>#channelIn: */
static sqInt NoDbgRegParms
channelIn(struct foo *anInterpreterState, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return anInterpreterState->channel;
	return 0;
}


/*	Above ObjectMemory, arg must lie in range 0-255! */

	/* StackInterpreter>>#characterForAscii: */
sqInt
characterForAscii(sqInt ascii, struct foo * self)
{
	return (((sqInt)((usqInt)(ascii) << (numTagBits(self))))) + (characterTag(self));
}


/*	Ensure that all accessible objects in the heap are okay. */

	/* StackInterpreter>>#checkAllAccessibleObjectsOkay */
sqInt
checkAllAccessibleObjectsOkay(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	ok = 1;
	/* begin allObjectsDoSafely: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		ok = ok && (checkOkayFields(objOop1, self));
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		ok = ok && (checkOkayFields(objOop1, self));
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			ok = ok && (checkOkayFields(objOop11, self));
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	return ok;
}


/*	This is a no-op in the StackVM */

	/* StackInterpreter>>#checkCodeIntegrity: */
static sqInt NoDbgRegParms
checkCodeIntegrity(sqInt fullGCFlag, struct foo * self)
{
	return 1;
}


/*	Check for a hit of the longRunningPrimitive probe and if so attempt to
	signal the
	longRunningPrimitiveCheckSemaphore. Answer if a process switch occurred as
	a result. */

	/* StackInterpreter>>#checkDeliveryOfLongRunningPrimitiveSignal */
static sqInt
checkDeliveryOfLongRunningPrimitiveSignal(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((GIV(longRunningPrimitiveCheckSemaphore) != null)
	 && (GIV(longRunningPrimitiveSignalUndelivered)))) {

		/* but not yet delivered */
		GIV(longRunningPrimitiveSignalUndelivered) = 0;

		/* Signal the LRP check semaphore if it is present */
		GIV(longRunningPrimitiveGCUsecs) = ((GIV(gcStartUsecs) < GIV(longRunningPrimitiveStopUsecs))
		 && (GIV(statGCEndUsecs) > GIV(longRunningPrimitiveStartUsecs))
			? GIV(statGCEndUsecs) - GIV(gcStartUsecs)
			: 0);
		return synchronousSignal(GIV(longRunningPrimitiveCheckSemaphore), self);
	}
	return 0;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#checkedIntegerValueOf: */
sqInt
checkedIntegerValueOf(sqInt intOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((intOop) & 7) == 1)) {
		return (intOop >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Check for possible interrupts and handle one if necessary.
	Answer if a context switch has occurred. */

	/* StackInterpreter>>#checkForEventsMayContextSwitch: */
static sqInt NoDbgRegParms
checkForEventsMayContextSwitch(sqInt mayContextSwitch, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong now;
    sqInt objOop;
    sqInt objOop1;
    sqInt sema;
    sqInt switched;


	/* restore the stackLimit if it has been smashed. */
	GIV(statCheckForEvents) += 1;
	/* begin restoreStackLimit */
	(GIV(stackPage)->stackLimit = (GIV(stackPage)->realStackLimit));
	GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	ioSynchronousCheckForEvents(self);
	if (GIV(needGCFlag)) {

		/* sufficientSpaceAfterGC: runs the incremental GC and
		   then, if not enough space is available, the fullGC. */
		if (!(sufficientSpaceAfterGC(0, self))) {
			setSignalLowSpaceFlagAndSaveProcess(self);
		}
	}
	if (!mayContextSwitch) {
		return 0;
	}
	switched = 0;
	if ((GIV(profileProcess) != GIV(nilObj))
	 || ((GIV(nextProfileTick) > 0)
	 && ((ioHighResClock(self)) >= GIV(nextProfileTick)))) {

		/* Take a sample (if not already done so) for the profiler if it is active.  This
		   must be done before any of the synchronousSignals below or else we will
		   attribute a pause in ioRelinquishProcessor to the newly activated process. */
		GIV(nextProfileTick) = 0;
		if (GIV(profileProcess) == GIV(nilObj)) {
			/* begin memoryActiveProcess */
			objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
			objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
			GIV(profileProcess) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
			/* begin nilObject */
			GIV(profileMethod) = GIV(nilObj);
		}
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && (synchronousSignal(GIV(profileSemaphore), self))) {
			switched = 1;
		}
	}
	if (checkDeliveryOfLongRunningPrimitiveSignal(self)) {
		switched = 1;
	}
	if (GIV(signalLowSpace)) {
		/* begin signalLowSpace: */
		GIV(signalLowSpace) = 0;
		/* begin splObj: */
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord(self))))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema, self))) {
			switched = 1;
		}
	}
	if (((now = ioUTCMicroseconds(self))) >= GIV(nextPollUsecs)) {
		GIV(statIOProcessEvents) += 1;
		ioProcessEvents(self);
		GIV(nextPollUsecs) = now + 20000;
	}
	if (GIV(interruptPending)) {

		/* reset interrupt flag */
		GIV(interruptPending) = 0;
		/* begin splObj: */
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord(self))))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema, self))) {
			switched = 1;
		}
	}
	if (GIV(nextWakeupUsecs) != 0) {
		if (now >= GIV(nextWakeupUsecs)) {

			/* set timer interrupt to 0 for 'no timer' */
			GIV(nextWakeupUsecs) = 0;
			/* begin splObj: */
			sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord(self))))));
			if ((sema != GIV(nilObj))
			 && (synchronousSignal(sema, self))) {
				switched = 1;
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		GIV(pendingFinalizationSignals) = 0;
		/* begin splObj: */
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheFinalizationSemaphore) << (shiftForWord(self))))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema, self))) {
			switched = 1;
		}
	}
	if (signalExternalSemaphores(self)) {
		switched = 1;
	}
	return switched;
}


/*	Read and verify the image file version number and return true if the the
	given image file needs to be byte-swapped. As a side effect, position the
	file stream just after the version number of the image header. This code
	prints a warning and does a hard-exit if it cannot find a valid version
	number. 
 */
/*	This code is based on C code by Ian Piumarta. */

	/* StackInterpreter>>#checkImageVersionFrom:startingAt: */
static sqInt NoDbgRegParms
checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset, struct foo * self)
{
    sqInt firstVersion;
    sqInt version;
    int w;
    int w1;
    int w2;

	sqImageFileSeek(f, imageOffset, self);
	version = (firstVersion = getWord32FromFileswap(f, 0, self));
	if ((version == 68021 /* imageFormatVersion */)
	 || (0)) {
		return 0;
	}
	sqImageFileSeek(f, imageOffset, self);
	/* begin getWord32FromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(int), 1, f, self);
	version = SQ_SWAP_4_BYTES(w2);
	if ((version == 68021 /* imageFormatVersion */)
	 || (0)) {
		return 1;
	}
	if (imageOffset == 0) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */
		sqImageFileSeek(f, 512, self);
		/* begin getWord32FromFile:swap: */
		w = 0;
		sqImageFileRead((&w), sizeof(int), 1, f, self);
		version = w;
		if ((version == 68021 /* imageFormatVersion */)
		 || (0)) {
			return 0;
		}
		sqImageFileSeek(f, 512, self);
		/* begin getWord32FromFile:swap: */
		w1 = 0;
		sqImageFileRead((&w1), sizeof(int), 1, f, self);
		version = SQ_SWAP_4_BYTES(w1);
		if ((version == 68021 /* imageFormatVersion */)
		 || (0)) {
			return 1;
		}
	}
	print("This interpreter (vers. ", self);
	printNum(68021 /* imageFormatVersion */, self);
	print(") cannot read image file (vers. ", self);
	printNum(firstVersion, self);
	print(").", self);
	/* begin cr */
	printf("\n");
	print("Press CR to quit...", self);
	getchar();
	ioExitWithErrorCode(1);
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all oops in the interpreter's state
	points to a header. Answer 0 if all checks pass. */

	/* StackInterpreter>>#checkInterpreterIntegrity */
static sqInt
checkInterpreterIntegrity(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    sqInt i;

	flags = 0;
	if (!(checkOopIntegritynamed(GIV(specialObjectsOop), "specialObjectsOop", self))) {
		flags = 1;
	}
	if (!(checkOopIntegritynamed(GIV(newMethod), "newMethod", self))) {
		flags += 2;
	}
	if (!(checkOopIntegritynamed(GIV(profileProcess), "profileProcess", self))) {
		flags += 4;
	}
	if (!(checkOopIntegritynamed(GIV(profileMethod), "profileMethod", self))) {
		flags += 8;
	}
	if (!(checkOopIntegritynamed(GIV(profileSemaphore), "profileSemaphore", self))) {
		flags += 16;
	}
	if (!(GIV(tempOop) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop), "tempOop", self))) {
			flags += 32;
		}
	}
	if (!(GIV(tempOop2) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop2), "tempOop2", self))) {
			flags += 64;
		}
	}
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		if (!(checkOopIntegritynamedindex(GIV(suspendedCallbacks)[i], "suspendedCallbacks", i, self))) {
			flags += 128;
		}
		if (!(checkOopIntegritynamedindex(GIV(suspendedMethods)[i], "suspendedMethods", i, self))) {
			flags += 256;
		}
	}
	return flags;
}


/*	Another version of isWidowedContext: for debugging.
	This will not bereave a widowed context. */

	/* StackInterpreter>>#checkIsStillMarriedContext:currentFP: */
static sqInt NoDbgRegParms
checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *limitFP;
    char *maybeFP;
    sqInt maybeFrameCtxt;
    sqInt referent;
    sqInt senderOop;
    StackPage *thePage;

	if (!((((aContext & (tagMask(self))) == 0)
		 && (((longAt(aContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))
		 && (((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)))) {
		return 0;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	maybeFP = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(maybeFP, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);
	limitFP = ((thePage == GIV(stackPage))
	 && (currentFP != null)
		? currentFP
		: (thePage->headFP));
	if (!((maybeFP >= limitFP)
		 && ((((((sqInt)(pointerForOop(longAt(maybeFP + FoxSavedFP))))) & (tagMask(self))) == 0)
		 && ((((assert(((oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) & (BytesPerWord - 1)) == 0),
		(oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) + (smallIntegerTag(self)))) == (longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))))))
		 && ((byteAt((maybeFP + FoxFrameFlags) + 2)) != 0))))) {
		return 0;
	}

	/* On Spur we need to follow the context to check for a match, but since the VM is
	   only speculating about maybeFrame being a frame, and only speculating about
	   maybeContext being a context, we need to be sure before we can safely follow. */
	maybeFrameCtxt = longAt(maybeFP + FoxThisContext);
	if ((!(isFree(thePage, self)))
	 && ((isFrameonPage(maybeFP, thePage, self))
	 && (((longAt(maybeFrameCtxt)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(maybeFrameCtxt, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((maybeFrameCtxt + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		maybeFrameCtxt = referent;
	}
	return maybeFrameCtxt == aContext;
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

	/* StackInterpreter>>#checkOkayFields: */
static sqInt NoDbgRegParms
checkOkayFields(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldOop;
    sqInt hasYoung;
    sqInt i;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((((oop) & 7) == 1)) {
		return 1;
	}
	if (!(checkOkayOop(oop, self))) {
		return 0;
	}
	if (!(checkOopHasOkayClass(oop, self))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
		 || (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		return 1;
	}
	hasYoung = 0;
	if (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
		i = (((assert((((((assert(isCompiledMethod(oop, self)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(oop, self)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1;
	}
	else {
		if (((oop & (tagMask(self))) == 0)
		 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop, self))) - 1;
		}
		else {
			i = (lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)) - 1;
		}
	}
	while (i >= 0) {
		/* begin fetchPointer:ofObject: */
		fieldOop = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if (!((((fieldOop) & 7) == 1))) {
			hasYoung = hasYoung
			 || (((fieldOop & (tagMask(self))) == 0)
			 && (oopisLessThan(fieldOop, GIV(newSpaceLimit), self)));
			if (!(checkOkayOop(fieldOop, self))) {
				return 0;
			}
			if (!(checkOopHasOkayClass(fieldOop, self))) {
				return 0;
			}
		}
		i -= 1;
	}
	if (hasYoung) {
		/* begin checkOkayYoungReferrer: */
		if (oopisLessThan(oop, GIV(newSpaceLimit), self)) {
			return 1;
		}
		if (!(((((usqInt) (longAt(oop))) >> (rememberedBitShift(self))) & 1) != 0)) {
			print("remembered bit is not set in ", self);
			printHex(oop, self);
			/* begin cr */
			printf("\n");
			return 0;
		}
		if (isInRememberedSet(oop, self)) {
			return 1;
		}
		printHex(oop, self);
		print(" has remembered bit set but is not in remembered set", self);
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

	/* StackInterpreter>>#checkOkayInterpreterObjects: */
sqInt
checkOkayInterpreterObjects(sqInt writeBack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt ok;
    sqInt oop;
    sqIntptr_t oopOrZero;

	ok = 1;
	ok = ok && (checkOkayFields(GIV(nilObj), self));
	ok = ok && (checkOkayFields(GIV(falseObj), self));
	ok = ok && (checkOkayFields(GIV(trueObj), self));
	ok = ok && (checkOkayFields(GIV(specialObjectsOop), self));
	ok = ok && (checkOkayFields(GIV(messageSelector), self));
	ok = ok && (checkOkayFields(GIV(newMethod), self));
	ok = ok && (checkOkayFields(GIV(lkupClass), self));
	for (i = 0; i < MethodCacheEntries; i += MethodCacheEntrySize) {
		oopOrZero = GIV(methodCache)[i + MethodCacheSelector];
		if (!(oopOrZero == 0)) {
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheSelector], self));
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheMethod], self));
		}
	}
	for (i = 1, iLimiT = (remapBufferCount(self)); i <= iLimiT; i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!(oop & (tagMask(self)))) {
			ok = ok && (checkOkayFields(oop, self));
		}
	}
	ok = ok && (checkOkayStackZone(writeBack, self));
	return ok;
}

	/* StackInterpreter>>#checkOkayStackPage: */
static sqInt NoDbgRegParms
checkOkayStackPage(StackPage *thePage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt ok;
    sqInt oop;
    char *theFP;
    char *theSP;

	theSP = (thePage->headSP);
	theFP = (thePage->headFP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	ok = 1;
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((((oop) & 7) == 1))) {
				ok = ok && (checkOkayFields(oop, self));
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP, self), self));
			ok = ok && (checkOkayFields(longAt(theFP + FoxThisContext), self));
		}
		ok = ok && (checkOkayFields(longAt(theFP + FoxMethod), self));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((((oop) & 7) == 1))) {
			ok = ok && (checkOkayFields(oop, self));
		}
		theSP += BytesPerWord;
	}
	return ok;
}


/*	Check that all objects in the stack zone are okay */

	/* StackInterpreter>>#checkOkayStackZone: */
static sqInt NoDbgRegParms
checkOkayStackZone(sqInt writeBack, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;
    StackPage *thePage;

	if (writeBack) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
	}
	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		if (!(isFree(thePage, self))) {
			ok = ok && (checkOkayStackPage(thePage, self));
		}
	}
	return ok;
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil. */

	/* StackInterpreter>>#checkProfileTick: */
static void NoDbgRegParms
checkProfileTick(sqInt aPrimitiveMethod, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt objOop1;

	assert(GIV(nextProfileTick) != 0);
	if ((ioHighResClock(self)) >= GIV(nextProfileTick)) {
		/* begin memoryActiveProcess */
		objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
		objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
		GIV(profileProcess) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
		if (!GIV(primFailCode)) {
			GIV(profileMethod) = aPrimitiveMethod;
		}
		else {
			/* begin nilObject */
			GIV(profileMethod) = GIV(nilObj);
		}
		forceInterruptCheck(self);
		GIV(nextProfileTick) = 0;
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

	/* StackInterpreter>>#checkStackIntegrity */
static sqInt
checkStackIntegrity(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt ok;
    sqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		if (!(isFree(thePage, self))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & (tagMask(self))) == 0)
					 && ((heapMapAtWord(pointerForOop(oop), self)) == 0)) {
						printFrameThingandFrameat("object leak in frame temp", theFP, theSP, self);
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					oop = longAt(theFP + FoxThisContext);
					if ((oop & (tagMask(self)))
					 || ((heapMapAtWord(pointerForOop(oop), self)) == 0)) {
						printFrameThingandFrameat("object leak in frame ctxt", theFP, theFP + FoxThisContext, self);
						ok = 0;
					}
					if (!(((oop & (tagMask(self))) == 0)
						 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
						printFrameThingandFrameat("frame ctxt should be context", theFP, theFP + FoxThisContext, self);
						ok = 0;
					}
					if (!((((oop & (tagMask(self))) == 0)
						 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))
						 && (((((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)))) {
						printFrameThingandFrameat("frame ctxt should be married", theFP, theFP + FoxThisContext, self);
						ok = 0;
					}
					if (!((((oop & (tagMask(self))) == 0)
						 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))
						 && ((((((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
						 && ((frameOfMarriedContext(oop, self)) == theFP)))) {
						printFrameThingandFrameat("frame ctxt should be married to this frame ", theFP, theFP + FoxThisContext, self);
						ok = 0;
					}
				}
				oop = longAt(theFP + FoxMethod);
				if ((oop & (tagMask(self)))
				 || ((heapMapAtWord(pointerForOop(oop), self)) == 0)) {
					printFrameThingandFrameat("object leak in frame mthd", theFP, theFP + FoxMethod, self);
					ok = 0;
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & (tagMask(self))) == 0)
				 && ((heapMapAtWord(pointerForOop(oop), self)) == 0)) {
					printFrameThingandFrameat("object leak in frame arg", theFP, theSP, self);
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}


/*	Version of stackPointerForMaybeMarriedContext: with no side-effects (does
	not widow).
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the stackPointer of a Context. */

	/* StackInterpreter>>#checkStackPointerForMaybeMarriedContext: */
static sqInt NoDbgRegParms
checkStackPointerForMaybeMarriedContext(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt methodPointer;
    sqInt sp;
    sqInt sp1;

	if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer), self)) {
		sp = checkStackPointerIndexForFrame(frameOfMarriedContext(aContext, self), self);
		assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext, self)));
		return sp;
	}
	if (((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
		/* begin argumentCountOf: */
		methodPointer = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
		/* begin argumentCountOfMethodHeader: */
		assert(isCompiledMethod(methodPointer, self));
		/* begin fetchPointer:ofObject: */
		header = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
	}
	/* begin fetchStackPointerOf: */
	sp1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
	if (!((((sp1) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext, self)));
	return (sp1 >> 3);
}


/*	Version of stackPointerIndexForFrame: that does not depend on writing back
	head frame pointers.
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#checkStackPointerIndexForFrame: */
static sqInt NoDbgRegParms
checkStackPointerIndexForFrame(char *theFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    sqInt index;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (theFP == GIV(framePointer)) {
		return (((usqInt) ((theFP + FoxReceiver) - GIV(stackPointer))) >> (shiftForWord(self))) + (byteAt((theFP + FoxFrameFlags) + 1));
	}
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);
	/* begin findSPOrNilOf:on:startingFrom: */
	startFrame = (thePage == GIV(stackPage)
		? GIV(framePointer)
		: (thePage->headFP));
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = theFP + FoxReceiver;
			goto l2;
		}
		theSP = (thePage == GIV(stackPage)
			? (thePage->headSP)
			: ((thePage->headSP)) + BytesPerWord);
		goto l2;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			assert(!(isBaseFrame(prevFrame, self)));
			theSP = (prevFrame + (frameStackedReceiverOffset(prevFrame, self))) + BytesPerWord;
			goto l2;
		}
	}
	theSP = null;
	l2:	/* end findSPOrNilOf:on:startingFrom: */;
	if (!(theSP)) {
		return -1;
	}
	return (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord(self))) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	Check if aClass's name is className */

	/* StackInterpreter>>#classNameOf:Is: */
static sqInt NoDbgRegParms
classNameOfIs(sqInt aClass, char *className, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((lengthOfformat(aClass, (((usqInt) (longAt(aClass))) >> (formatShift(self))) & (formatMask(self)), self)) <= GIV(classNameIndex)) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	name = longAt((aClass + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord(self))))));
	if (!(((name & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(name))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))) {
		return 0;
	}
	length = stSizeOf(name, self);
	srcName = ((char *) (arrayValueOf(name, self)));
	for (i = 0; i < length; i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}


/*	Does thisCntx have aContext in its sender chain?
	Cheapo implementation above extant machinery. */

	/* StackInterpreter>>#context:hasSender: */
static sqInt NoDbgRegParms
contexthasSender(sqInt thisCntx, sqInt aContext, struct foo * self)
{
    sqInt handlerOrNilOrZero;

	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(-1, thisCntx, aContext, self);
	return handlerOrNilOrZero == 0;
}


/*	For asserts. Check that theIP maps back correctly to the context's pc.
	The CallPrimitive bytecode presents a complication. */

	/* StackInterpreter>>#context:hasValidInversePCMappingOf:in: */
static sqInt NoDbgRegParms
contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP, struct foo * self)
{
    sqInt encodedip;
    sqInt methodHeader;
    sqInt pc;

	/* begin fetchPointer:ofObject: */
	pc = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))));
	assert(validInstructionPointerinFrame(theIP + 1, theFP, self));
	encodedip = (((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
	return (pc == encodedip)
	 || (((methodHeader = methodHeaderOf(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self)))))), self)),
	((/* begin alternateHeaderHasPrimitiveFlag: */
		methodHeader & AlternateHeaderHasPrimFlag))
		 && ((((encodedip >> 3)) - ((pc >> 3))) == (3))));
}


/*	for Cogit */

	/* StackInterpreter>>#copiedValueCountOfClosure: */
sqInt
copiedValueCountOfClosure(sqInt closurePointer, struct foo * self)
{
	return (numSlotsOf(closurePointer, self)) - ClosureFirstCopiedValueIndex;
}


/*	for Cogit */

	/* StackInterpreter>>#copiedValueCountOfFullClosure: */
sqInt
copiedValueCountOfFullClosure(sqInt closurePointer, struct foo * self)
{
	return (numSlotsOf(closurePointer, self)) - FullClosureFirstCopiedValueIndex;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

	/* StackInterpreter>>#copyBits */
sqInt
copyBits(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin", self);
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#copyBitsFrom:to:at: */
sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin", self);
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}

	/* StackInterpreter>>#couldBeProcess: */
static sqInt NoDbgRegParms NeverInline
couldBeProcess(sqInt oop, struct foo * self)
{
	return (addressCouldBeObj(oop, self))
	 && ((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
	 && ((!(((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)))
	 && (((lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)) > MyListIndex)
	 && (isContext(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self)))))), self)))));
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#cr */
static void
cr(struct foo * self)
{
	printf("\n");
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand: */

	/* StackInterpreter>>#createActualMessageTo: */
static void NoDbgRegParms
createActualMessageTo(sqInt lookupClass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt argumentArray;
    sqInt i;
    usqInt message;
    usqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numBytes1;
    sqInt numSlots;
    char *sp;

	assert((isImmediate(GIV(messageSelector), self))
	 || (addressCouldBeObj(GIV(messageSelector), self)));
	/* begin mnuBreakpoint:receiver: */
	mnuBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector), self), lengthOfMaybeImmediate(GIV(messageSelector), self), null, self);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && ((knownClassAtIndex(ClassArrayCompactIndex, self)) != GIV(nilObj)));
	assert((2 /* arrayFormat */) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(GIV(argumentCount) < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((GIV(argumentCount) < 1
	? 8 /* allocationUnit */
	: GIV(argumentCount) * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			argumentArray = 0;
			goto l4;
		}
	}
	long64Atput(newObj, (((((usqLong) GIV(argumentCount))) << (numSlotsFullShift(self))) + (2U << (formatShift(self)))) + ClassArrayCompactIndex);
	GIV(freeStart) += numBytes;
	argumentArray = newObj;
	l4:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	numSlots = MessageLookupClassIndex + 1;
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassMessageCompactIndex, self)) != GIV(nilObj)));
	assert((1 /* nonIndexablePointerFormat */) == (instSpecOfClass(knownClassAtIndex(ClassMessageCompactIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj1 = GIV(freeStart);
	numBytes1 = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes1 % (allocationUnit(self))) == 0);
	assert((newObj1 % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes1) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			message = 0;
			goto l5;
		}
	}
	long64Atput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (1U << (formatShift(self)))) + ClassMessageCompactIndex);
	GIV(freeStart) += numBytes1;
	message = newObj1;
	l5:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	for (i = ((GIV(argumentCount) - 1) * BytesPerOop); i >= 0; i += (-BytesPerOop)) {
		longAtput((argumentArray + BaseHeaderSize) + i, popStack(self));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(message, self)));
	longAtput((message + BaseHeaderSize) + (((sqInt)((usqInt)(MessageSelectorIndex) << (shiftForWord(self))))), GIV(messageSelector));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(message, self)));
	longAtput((message + BaseHeaderSize) + (((sqInt)((usqInt)(MessageArgumentsIndex) << (shiftForWord(self))))), argumentArray);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(message, self)));
	longAtput((message + BaseHeaderSize) + (((sqInt)((usqInt)(MessageLookupClassIndex) << (shiftForWord(self))))), lookupClass);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
}


/*	Return the default number of stack pages allocate at startup.
	This V3 default suits Qwaq Forums (specifically general rendering).
	The Spur default reflects tuning for GC performance ast Cadence.
	It is probably a bit high for normal use but QF is profligate with
	processes. The actual value can be set via vmParameterAt: and/or a
	preference in the ini file. */

	/* StackInterpreter>>#defaultNumStackPages */
static sqInt
defaultNumStackPages(struct foo * self)
{
	return 50;
}


/*	Release the VM to other threads and answer the current thread's index.
	Currently valid flags for the non-threaded VM are:
	DisownVMLockOutFullGC	- prevent fullGCs while this thread disowns the VM
	DisownVMForFFICall			- informs the VM that it is entering an FFI call
	
	This is the entry-point for plugins and primitives that wish to release
	the VM while
	performing some operation that may potentially block, and for callbacks
	returning back to some blocking operation. While this exists for the
	threaded FFI VM we use
	it to reset newMethod and the argumentCount after a callback. */

	/* StackInterpreter>>#disownVM: */
sqInt
disownVM(sqInt flags, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	assert(GIV(primFailCode) == 0);
	assert((isImmediate(flags, self)
		? ((((flags) & 7) == 1))
			 && (((((flags >> 3)) >= 0) && (((flags >> 3)) <= (argumentCountOfMethodHeader(-1, self)))))
		: (flags == (flags & ((DisownVMLockOutFullGC + DisownVMForFFICall) + DisownVMForThreading)))
			 && (flags & DisownVMForFFICall)));
	if ((!(flags & (tagMask(self))))
	 && (flags & DisownVMForFFICall)) {
		assert((isOopCompiledMethod(GIV(newMethod), self))
		 && ((argumentCountOf(GIV(newMethod), self)) == GIV(argumentCount)));
		GIV(inFFIFlags) = DisownVMForFFICall;
		return flags;
	}
	assert(((((flags) & 7) == 1))
	 && (((((flags >> 3)) >= 0) && (((flags >> 3)) <= (argumentCountOfMethodHeader(-1, self))))));
	GIV(argumentCount) = (flags >> 3);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = top;
	assert((isOopCompiledMethod(GIV(newMethod), self))
	 && ((argumentCountOf(GIV(newMethod), self)) == GIV(argumentCount)));
	return 0;
}

	/* StackInterpreter>>#divorceAllFrames */
static sqInt
divorceAllFrames(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt i;

	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer), self), self));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l2;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord, self);
	l2:	/* end ensureFrameIsMarried:SP: */;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages), self);
		if (!(isFree(aPage, self))) {
			divorceFramesIn(aPage, self);
		}
	}
	/* begin zeroStackPage */
	assert((GIV(stackPage) == 0)
	 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
	GIV(stackPage) = 0;
	return activeContext;
}

	/* StackInterpreter>>#divorceFramesIn: */
static void NoDbgRegParms
divorceFramesIn(StackPage *aStackPage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    sqInt theIP;
    char *theSP;
    sqInt valuePointer;

	GIV(statStackPageDivorce) += 1;
	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	theIP = longAt(theSP);

	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	calleeContext = null;
	while (1) {
		/* begin ensureFrameIsMarried:SP: */
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP, self), self));
			theContext = longAt(theFP + FoxThisContext);
			goto l3;
		}
		theContext = marryFrameSP(theFP, theSP, self);
	l3:	/* end ensureFrameIsMarried:SP: */;
		updateStateOfSpouseContextForFrameWithSP(theFP, theSP, self);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(validInstructionPointerinFrame(theIP + 1, theFP, self));
		valuePointer = (((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
		assert(!(isOopForwarded(theContext, self)));
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer);
		assert((frameReceiver(theFP, self)) == (fetchPointerofObject(ReceiverIndex, theContext, self)));
		if (calleeContext != null) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(calleeContext, self)));
			if ((assert(isNonImmediate(calleeContext, self)),
			oopisGreaterThanOrEqualTo(calleeContext, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((theContext & (tagMask(self))) == 0)
				 && (oopisLessThan(theContext, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(calleeContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(calleeContext, self);
					}
				}
			}
			longAtput((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), theContext);
		}
		calleeContext = theContext;
		calleeFP = theFP;
		theIP = ((sqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;

		/* theSP points at stacked hottest item on frame's stack */
		assert(!(isBaseFrame(calleeFP, self)));
		theSP = (calleeFP + (frameStackedReceiverOffset(calleeFP, self))) + BytesPerWord;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(theContext, self)));
	if ((assert(isNonImmediate(theContext, self)),
	oopisGreaterThanOrEqualTo(theContext, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if ((((longAt(calleeFP + FoxCallerContext)) & (tagMask(self))) == 0)
		 && (oopisLessThan(longAt(calleeFP + FoxCallerContext), GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(theContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(theContext, self);
			}
		}
	}
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), longAt(calleeFP + FoxCallerContext));
	(aStackPage->baseFP = 0);
}


/*	Rounds negative results towards negative infinity, rather than zero. */

	/* StackInterpreter>>#doPrimitiveDiv:by: */
static sqInt NoDbgRegParms
doPrimitiveDivby(sqInt rcvr, sqInt arg, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt posArg;
    sqInt posRcvr;
    sqInt result;
    sqInt successBoolean;

	integerArg = 0;
	integerRcvr = 0;
	if ((rcvr & arg) & (smallIntegerTag(self))) {
		integerRcvr = (rcvr >> 3);
		integerArg = (arg >> 3);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */
			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */
			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	successBoolean = (((((usqInt) result) >> 60) + 1) & 15) <= 1;
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return result;
}

	/* StackInterpreter>>#doPrimitiveMod:by: */
static sqInt NoDbgRegParms
doPrimitiveModby(sqInt rcvr, sqInt arg, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt successBoolean;

	integerArg = 0;
	integerRcvr = 0;
	if ((rcvr & arg) & (smallIntegerTag(self))) {
		integerRcvr = (rcvr >> 3);
		integerArg = (arg >> 3);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */
	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	successBoolean = (((((usqInt) integerResult) >> 60) + 1) & 15) <= 1;
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

	/* StackInterpreter>>#doSignalSemaphoreWithIndex: */
sqInt
doSignalSemaphoreWithIndex(sqInt index, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    sqInt xArray;

	/* begin splObj: */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord(self))))));
	assert(isArray(xArray, self));
	/* begin fetchPointer:ofObject: */
	sema = longAt((xArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self))))));
	assert(!(isOopForwarded(sema, self)));
	return (((sema & (tagMask(self))) == 0)
	 && (((longAt(sema)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self))))
	 && (synchronousSignal(sema, self));
}

	/* StackInterpreter>>#dummyReferToProxy */
static void
dummyReferToProxy(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interpreterProxy) = GIV(interpreterProxy);
}


/*	Dummy definition to allow the StackInterpreter to link against the Cog
	run-time. 
 */

	/* StackInterpreter>>#dumpPrimTraceLog */
void
dumpPrimTraceLog(struct foo * self)
{
}


/*	Answerr the caller context for a frame. If the frame has a caller
	frame that doesn't have a context, then marry the caller frame. */

	/* StackInterpreter>>#ensureCallerContext: */
static sqInt NoDbgRegParms
ensureCallerContext(char *theFP, struct foo * self)
{
    char *callerFP;

	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		return longAt(theFP + FoxCallerContext);
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP, self), self));
		return longAt(callerFP + FoxThisContext);
	}
	return marryFrameSP(callerFP, (assert(!(isBaseFrame(theFP, self))),
	(theFP + (frameStackedReceiverOffset(theFP, self))) + BytesPerWord), self);
}


/*	Ensure the image data has been updated to suit the current VM. */

	/* StackInterpreter>>#ensureImageFormatIsUpToDate: */
static void NoDbgRegParms
ensureImageFormatIsUpToDate(sqInt swapBytes, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt fmt;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord11;
    sqInt followingWord2;
    sqInt followingWord21;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress11;
    usqInt followingWordAddress2;
    usqInt followingWordAddress21;
    usqInt followingWordAddress3;
    usqInt limit;
    usqInt limit1;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop111;
    sqInt objOop12;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj11;
    sqInt prevObj2;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj11;
    sqInt prevPrevObj2;
    sqInt stopAddr;
    int swapFloatWords;
    int temp;
    sqInt temp1;
    sqInt wordAddr;

	if (swapBytes) {
		/* begin reverseBytesInImage */
		addr = GIV(oldSpaceStart);
		while (oopisLessThan(addr, GIV(endOfMemory), self)) {
			longAtput(addr, SQ_SWAP_8_BYTES((longAt(addr))));
			addr += BytesPerWord;
		}
		/* begin updateObjectsPostByteSwap */
		swapFloatWords = VMBIGENDIAN != GIV(imageFloatsBigEndian);
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj2 = (prevObj2 = null);
		assert((((pastSpace(self)).start)) < (((eden(self)).start)));
		/* begin objectStartingAt: */
		address2 = ((pastSpace(self)).start);
		numSlots2 = byteAt(address2 + 7);
		objOop12 = (numSlots2 == (numSlotsMask(self))
			? address2 + BaseHeaderSize
			: address2);
		limit1 = GIV(pastSpaceStart);
		while (oopisLessThan(objOop12, limit1, self)) {
			assert(isEnumerableObjectNoAssert(objOop12, self));
			fmt = (((usqInt) (longAt(objOop12))) >> (formatShift(self))) & (formatMask(self));
			if (fmt >= (firstByteFormat(self))) {

				/* oop contains bytes */
				wordAddr = objOop12 + BaseHeaderSize;
				if (fmt >= (firstCompiledMethodFormat(self))) {

					/* compiled method; start after methodHeader and literals */
					methodHeader = longAt(objOop12 + BaseHeaderSize);
					wordAddr += (((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
				}
				/* begin reverseBytesFrom:to: */
				stopAddr = objOop12 + (((numSlotsOf(objOop12, self)) << (shiftForWord(self))) + BaseHeaderSize);
				addr1 = wordAddr;
				while (oopisLessThan(addr1, stopAddr, self)) {
					longAtput(addr1, SQ_SWAP_8_BYTES((longAt(addr1))));
					addr1 += BytesPerWord;
				}
			}
			if (fmt == (firstLongFormat(self))) {

				/* Bitmap, Float etc */
				if (swapFloatWords
				 && ((compactClassIndexOf(objOop12, self)) == ClassFloatCompactIndex)) {
					temp1 = longAt(objOop12 + BaseHeaderSize);
					longAtput(objOop12 + BaseHeaderSize, longAt((objOop12 + BaseHeaderSize) + 4));
					longAtput((objOop12 + BaseHeaderSize) + 4, temp1);
				}
				else {
									}
			}
			prevPrevObj2 = prevObj2;
			prevObj2 = objOop12;
			/* begin objectAfter:limit: */
			followingWordAddress3 = addressAfter(objOop12, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress3, limit1, self)) {
				objOop12 = limit1;
				goto l11;
			}
			flag("endianness");
			followingWord3 = longAt(followingWordAddress3);
			objOop12 = ((((usqInt) followingWord3) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress3 + BaseHeaderSize
				: followingWordAddress3);
	l11:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address11 = ((eden(self)).start);
		numSlots11 = byteAt(address11 + 7);
		objOop12 = (numSlots11 == (numSlotsMask(self))
			? address11 + BaseHeaderSize
			: address11);
		while (oopisLessThan(objOop12, GIV(freeStart), self)) {
			assert(isEnumerableObjectNoAssert(objOop12, self));
			fmt = (((usqInt) (longAt(objOop12))) >> (formatShift(self))) & (formatMask(self));
			if (fmt >= (firstByteFormat(self))) {

				/* oop contains bytes */
				wordAddr = objOop12 + BaseHeaderSize;
				if (fmt >= (firstCompiledMethodFormat(self))) {

					/* compiled method; start after methodHeader and literals */
					methodHeader = longAt(objOop12 + BaseHeaderSize);
					wordAddr += (((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
				}
				/* begin reverseBytesFrom:to: */
				stopAddr = objOop12 + (((numSlotsOf(objOop12, self)) << (shiftForWord(self))) + BaseHeaderSize);
				addr1 = wordAddr;
				while (oopisLessThan(addr1, stopAddr, self)) {
					longAtput(addr1, SQ_SWAP_8_BYTES((longAt(addr1))));
					addr1 += BytesPerWord;
				}
			}
			if (fmt == (firstLongFormat(self))) {

				/* Bitmap, Float etc */
				if (swapFloatWords
				 && ((compactClassIndexOf(objOop12, self)) == ClassFloatCompactIndex)) {
					temp1 = longAt(objOop12 + BaseHeaderSize);
					longAtput(objOop12 + BaseHeaderSize, longAt((objOop12 + BaseHeaderSize) + 4));
					longAtput((objOop12 + BaseHeaderSize) + 4, temp1);
				}
				else {
									}
			}
			prevPrevObj2 = prevObj2;
			prevObj2 = objOop12;
			/* begin objectAfter:limit: */
			followingWordAddress11 = addressAfter(objOop12, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress11, GIV(freeStart), self)) {
				objOop12 = GIV(freeStart);
				goto l8;
			}
			flag("endianness");
			followingWord11 = longAt(followingWordAddress11);
			objOop12 = ((((usqInt) followingWord11) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress11 + BaseHeaderSize
				: followingWordAddress11);
	l8:	/* end objectAfter:limit: */;
		}
		/* begin allOldSpaceObjectsDo: */
		assert(isOldObject(GIV(nilObj), self));
		prevPrevObj11 = (prevObj11 = null);
		objOop111 = GIV(nilObj);
		while (1) {
			assert((objOop111 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop111, GIV(endOfMemory), self))) break;
			assert((long64At(objOop111)) != 0);
			if (isEnumerableObject(objOop111, self)) {
				fmt = (((usqInt) (longAt(objOop111))) >> (formatShift(self))) & (formatMask(self));
				if (fmt >= (firstByteFormat(self))) {

					/* oop contains bytes */
					wordAddr = objOop111 + BaseHeaderSize;
					if (fmt >= (firstCompiledMethodFormat(self))) {

						/* compiled method; start after methodHeader and literals */
						methodHeader = longAt(objOop111 + BaseHeaderSize);
						wordAddr += (((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
					}
					/* begin reverseBytesFrom:to: */
					stopAddr = objOop111 + (((numSlotsOf(objOop111, self)) << (shiftForWord(self))) + BaseHeaderSize);
					addr1 = wordAddr;
					while (oopisLessThan(addr1, stopAddr, self)) {
						longAtput(addr1, SQ_SWAP_8_BYTES((longAt(addr1))));
						addr1 += BytesPerWord;
					}
				}
				if (fmt == (firstLongFormat(self))) {

					/* Bitmap, Float etc */
					if (swapFloatWords
					 && ((compactClassIndexOf(objOop111, self)) == ClassFloatCompactIndex)) {
						temp1 = longAt(objOop111 + BaseHeaderSize);
						longAtput(objOop111 + BaseHeaderSize, longAt((objOop111 + BaseHeaderSize) + 4));
						longAtput((objOop111 + BaseHeaderSize) + 4, temp1);
					}
					else {
											}
				}
			}
			prevPrevObj11 = prevObj11;
			prevObj11 = objOop111;
			/* begin objectAfter:limit: */
			followingWordAddress21 = addressAfter(objOop111, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress21, GIV(endOfMemory), self)) {
				objOop111 = GIV(endOfMemory);
				goto l9;
			}
			flag("endianness");
			followingWord21 = longAt(followingWordAddress21);
			objOop111 = ((((usqInt) followingWord21) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress21 + BaseHeaderSize
				: followingWordAddress21);
	l9:	/* end objectAfter:limit: */;
		}
			}
	else {
		/* begin convertFloatsToPlatformOrder */
		if (VMBIGENDIAN == GIV(imageFloatsBigEndian)) {
			goto l6;
		}
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((pastSpace(self)).start)) < (((eden(self)).start)));
		/* begin objectStartingAt: */
		address = ((pastSpace(self)).start);
		numSlots = byteAt(address + 7);
		objOop1 = (numSlots == (numSlotsMask(self))
			? address + BaseHeaderSize
			: address);
		limit = GIV(pastSpaceStart);
		while (oopisLessThan(objOop1, limit, self)) {
			assert(isEnumerableObjectNoAssert(objOop1, self));
			if ((compactClassIndexOf(objOop1, self)) == ClassFloatCompactIndex) {
				temp = long32At(objOop1 + BaseHeaderSize);
				long32Atput(objOop1 + BaseHeaderSize, long32At((objOop1 + BaseHeaderSize) + 4));
				long32Atput((objOop1 + BaseHeaderSize) + 4, temp);
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
				objOop1 = limit;
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address1 = ((eden(self)).start);
		numSlots1 = byteAt(address1 + 7);
		objOop1 = (numSlots1 == (numSlotsMask(self))
			? address1 + BaseHeaderSize
			: address1);
		while (oopisLessThan(objOop1, GIV(freeStart), self)) {
			assert(isEnumerableObjectNoAssert(objOop1, self));
			if ((compactClassIndexOf(objOop1, self)) == ClassFloatCompactIndex) {
				temp = long32At(objOop1 + BaseHeaderSize);
				long32Atput(objOop1 + BaseHeaderSize, long32At((objOop1 + BaseHeaderSize) + 4));
				long32Atput((objOop1 + BaseHeaderSize) + 4, temp);
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop1, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
				objOop1 = GIV(freeStart);
				goto l2;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
		}
		/* begin allOldSpaceObjectsDo: */
		assert(isOldObject(GIV(nilObj), self));
		prevPrevObj1 = (prevObj1 = null);
		objOop11 = GIV(nilObj);
		while (1) {
			assert((objOop11 % (allocationUnit(self))) == 0);
			if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
			assert((long64At(objOop11)) != 0);
			if (isEnumerableObject(objOop11, self)) {
				if ((compactClassIndexOf(objOop11, self)) == ClassFloatCompactIndex) {
					temp = long32At(objOop11 + BaseHeaderSize);
					long32Atput(objOop11 + BaseHeaderSize, long32At((objOop11 + BaseHeaderSize) + 4));
					long32Atput((objOop11 + BaseHeaderSize) + 4, temp);
				}
			}
			prevPrevObj1 = prevObj1;
			prevObj1 = objOop11;
			/* begin objectAfter:limit: */
			followingWordAddress2 = addressAfter(objOop11, self);
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
				objOop11 = GIV(endOfMemory);
				goto l5;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
		}
	l6:	/* end convertFloatsToPlatformOrder */;
	}
}


/*	Main entry-point into the interpreter at each execution level, where an
	execution level is either the start of execution or reentry for a
	callback. This is the actual implementation, separated from
	enterSmalltalkExecutive so the
	simulator can wrap it in an exception handler and hence simulate the
	setjmp/longjmp.  */
/*	Setjmp for reentry into interpreter from elsewhere, e.g. FFI exception
	primitive failure.
 */

	/* StackInterpreter>>#enterSmalltalkExecutiveImplementation */
static sqInt
enterSmalltalkExecutiveImplementation(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	sigsetjmp(reenterInterpreter, 0);
	/* begin setMethod: */
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1, __LINE__, self);
	interpret(self);
	return 0;
}


/*	Divorce a single frame and its context. If it is not the top frame of a
	stack this means splitting its stack. */

	/* StackInterpreter>>#externalDivorceFrame:andContext: */
static void NoDbgRegParms
externalDivorceFrameandContext(char *theFP, sqInt ctxt, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerCtx;
    char *callerFP;
    char *callerFP1;
    sqInt callerIP;
    char *callerSP;
    char *frameAbove;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    int onCurrent;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;
    sqInt valuePointer;

	assert((GIV(stackPage) == 0)
	 || (GIV(stackPage) == (mostRecentlyUsedPage(self))));
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);
	if (!((onCurrent = thePage == GIV(stackPage)))) {
		markStackPageNextMostRecentlyUsed(thePage, self);
	}
	theSP = findSPOfon(theFP, thePage, self);
	updateStateOfSpouseContextForFrameWithSP(theFP, theSP, self);
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		callerCtx = longAt(theFP + FoxCallerContext);
		goto l4;
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1, self), self));
		callerCtx = longAt(callerFP1 + FoxThisContext);
		goto l4;
	}
	callerCtx = marryFrameSP(callerFP1, (assert(!(isBaseFrame(theFP, self))),
	(theFP + (frameStackedReceiverOffset(theFP, self))) + BytesPerWord), self);
	l4:	/* end ensureCallerContext: */;
	if (((frameAbove = findFrameAboveinPage(theFP, thePage, self))) == 0) {

		/* If we're divorcing the top frame we can simply peel it off. */
		theIP = longAt((thePage->headSP));
	}
	else {

		/* othewise move all frames above to a new stack and then peel the frame off. */
		/* begin newStackPage */
		lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
		if (((lruOrFree->baseFP)) == 0) {
			newPage = lruOrFree;
			goto l1;
		}
		divorceFramesIn(lruOrFree, self);
		newPage = lruOrFree;
	l1:	/* end newStackPage */;
		theIP = oopForPointer(pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
		frameAbove = moveFramesInthroughtoPage(thePage, frameAbove, newPage, self);
		if (onCurrent) {
			/* begin setStackPageAndLimit: */
			assert(newPage != 0);
			GIV(stackPage) = newPage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(newPage, self);
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (newPage->headSP);
			GIV(framePointer) = (newPage->headFP);
		}
		else {
			markStackPageMostRecentlyUsed(newPage, self);
		}
		assert((frameCallerContext(frameAbove, self)) == ctxt);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(validInstructionPointerinFrame(theIP + 1, theFP, self));
	valuePointer = (((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
	assert(!(isOopForwarded(ctxt, self)));
	longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(ctxt, self)));
	if ((assert(isNonImmediate(ctxt, self)),
	oopisGreaterThanOrEqualTo(ctxt, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((callerCtx & (tagMask(self))) == 0)
		 && (oopisLessThan(callerCtx, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(ctxt))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(ctxt, self);
			}
		}
	}
	longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), callerCtx);
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {
		freeStackPage(thePage, self);
	}
	else {
		callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
		callerSP = ((assert(!(isBaseFrame(theFP, self))),
(theFP + (frameStackedReceiverOffset(theFP, self))) + BytesPerWord)) - BytesPerWord;
		longAtput(callerSP, callerIP);
		/* begin setHeadFP:andSP:inPage: */
		assert(callerSP < callerFP);
		assert((callerSP < ((thePage->baseAddress)))
		 && (callerSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((callerFP < ((thePage->baseAddress)))
		 && (callerFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(thePage->headFP = callerFP);
		(thePage->headSP = callerSP);
	}
}


/*	Ensure aFramePtr is a base frame. Then we can assign its sender.
	Answer the possibly moved location of the frame. */

	/* StackInterpreter>>#externalEnsureIsBaseFrame: */
static char * NoDbgRegParms
externalEnsureIsBaseFrame(char *aFramePtr, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    int onCurrent;
    char *theFP;
    StackPage *thePage;

	if ((longAt(aFramePtr + FoxSavedFP)) == 0) {
		return aFramePtr;
	}
	theFP = aFramePtr;
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);

	/* Storing the frame's sender with its caller's context
	   has the side effect of making theFP a base frame. */
	onCurrent = thePage == GIV(stackPage);
	theFP = storeSenderOfFramewithValue(theFP, ensureCallerContext(theFP, self), self);
	if (onCurrent) {
		assert(GIV(stackPage) != thePage);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage), self);
	}
	assert(pageListIsWellFormed(self));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	return theFP;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state. */

	/* StackInterpreter>>#externalInstVar:ofContext: */
static sqInt NoDbgRegParms
externalInstVarofContext(sqInt offset, sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isContext(aContext, self));
	assert(offset <= (ReceiverIndex + (checkStackPointerForMaybeMarriedContext(aContext, self))));
	if (offset <= StackPointerIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
		if ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(aContext, self)))) {
			return fetchPointerofMarriedContext(offset, aContext, self);
		}
	}
	/* begin fetchPointer:ofObject: */
	return longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord(self))))));
}

	/* StackInterpreter>>#externalInstVar:ofContext:put: */
static sqInt NoDbgRegParms
externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index1;
    int onCurrentPage;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	assert(isContext(maybeMarriedContext, self));
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	assert(!((isObjImmutable(maybeMarriedContext, self))));
	if (!((((((longAt((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(maybeMarriedContext, self))))) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(maybeMarriedContext, self)));
		if ((assert(isNonImmediate(maybeMarriedContext, self)),
		oopisGreaterThanOrEqualTo(maybeMarriedContext, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((anOop & (tagMask(self))) == 0)
			 && (oopisLessThan(anOop, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(maybeMarriedContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(maybeMarriedContext, self);
				}
			}
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))), anOop);
		if (index == StackPointerIndex) {
		}
		return null;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	theFP = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index1, GIV(pages), self);
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	onCurrentPage = thePage == GIV(stackPage);
	if (index == SenderIndex) {
		storeSenderOfFramewithValue(theFP, anOop, self);
	}
	else {
		externalDivorceFrameandContext(theFP, maybeMarriedContext, self);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(maybeMarriedContext, self)));
		if ((assert(isNonImmediate(maybeMarriedContext, self)),
		oopisGreaterThanOrEqualTo(maybeMarriedContext, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((anOop & (tagMask(self))) == 0)
			 && (oopisLessThan(anOop, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(maybeMarriedContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(maybeMarriedContext, self);
				}
			}
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))), anOop);
		if (index == StackPointerIndex) {
		}
	}
	if (onCurrentPage) {
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage), self);
	}
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(pageListIsWellFormed(self));
	assert(validStackPageBaseFrames(self));
	return 0;
}


/*	Invoke a quick primitive.
	Called under the assumption that primFunctionPtr has been preloaded */

	/* StackInterpreter>>#externalQuickPrimitiveResponse */
static sqInt
externalQuickPrimitiveResponse(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	assert(isPrimitiveFunctionPointerAnIndex(self));
	localPrimIndex = ((sqInt) GIV(primitiveFunctionPointer));
	assert((localPrimIndex > 0xFF)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		/* begin pop:thenPush: */
		oop = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord(self))))));
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 256) {
		return 1;
	}
	if (localPrimIndex == 257) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp2;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput((sp3 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp3;
		return 1;
	}
	/* begin pop:thenPush: */
	longAtput((sp4 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)(localPrimIndex - 261) << 3) | 1));
	GIV(stackPointer) = sp4;
	return 1;
}


/*	not inlined for breakpoint value... */

	/* StackInterpreter>>#failUnbalancedPrimitive */
static void
failUnbalancedPrimitive(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchArray:ofObject: */
void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOop;

	/* begin fetchPointer:ofObject: */
	arrayOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	/* begin arrayValueOf: */
	if (((arrayOop & (tagMask(self))) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(arrayOop))) >> (formatShift(self))) & (formatMask(self)), self))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchFloat:ofObject: */
double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self)
{
    sqInt floatOop;

	/* begin fetchPointer:ofObject: */
	floatOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	return floatValueOf(floatOop, self);
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchInteger:ofObject: */
sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOop;

	/* begin fetchPointer:ofObject: */
	intOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	/* begin checkedIntegerValueOf: */
	if ((((intOop) & 7) == 1)) {
		return (intOop >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Fetch a slot from a married context. Compute the value
	of the relevant inst var from the spouse frame's state.
	
	This method assumes frame pointers have been written back. */

	/* StackInterpreter>>#fetchPointer:ofMarriedContext: */
static sqInt NoDbgRegParms
fetchPointerofMarriedContext(sqInt offset, sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt frameNumArgs;
    sqInt senderOop;
    sqInt senderOop1;
    char *spouseFP;

	assert(isContext(aContext, self));
	assert((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer)));
	assert(checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer), self));
	if (offset <= ReceiverIndex) {
		if (!(offset <= StackPointerIndex)) {
			/* begin fetchPointer:ofObject: */
			return longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord(self))))));
		}
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		spouseFP = pointerForOop(senderOop - 1);
		if (offset == SenderIndex) {
			/* begin ensureCallerContext: */
			callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
			if (callerFP == 0) {

				/* base frame, context in saved ip slot (or base of stack in Cog) */
				return longAt(spouseFP + FoxCallerContext);
			}
			/* begin ensureFrameIsMarried:SP: */
			if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
				assert(isContext(frameContext(callerFP, self), self));
				return longAt(callerFP + FoxThisContext);
			}
			return marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP, self))),
			(spouseFP + (frameStackedReceiverOffset(spouseFP, self))) + BytesPerWord), self);
		}
		if (offset == StackPointerIndex) {
			return (((usqInt)(stackPointerIndexForFrame(spouseFP, self)) << 3) | 1);
		}
		if (offset == InstructionPointerIndex) {
			return instructionPointerForFramecurrentFPcurrentIP(spouseFP, GIV(framePointer), GIV(instructionPointer), self);
		}
	}
	/* begin frameOfMarriedContext: */
	senderOop1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop1) & 7) == 1));
	spouseFP = pointerForOop(senderOop1 - 1);
	return ((((offset - ReceiverIndex) >= 1) && ((offset - ReceiverIndex) <= (stackPointerIndexForFrame(spouseFP, self))))
		? ((offset - (ReceiverIndex + 1)) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
				? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord))
				: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord)))
		: /* begin nilObject */ GIV(nilObj));
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

	/* StackInterpreter>>#fetchStackPointerOf: */
static sqInt NoDbgRegParms
fetchStackPointerOf(sqInt aContext, struct foo * self)
{
    sqInt sp;

	/* begin fetchPointer:ofObject: */
	sp = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
	if (!((((sp) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext, self)));
	return (sp >> 3);
}

	/* StackInterpreter>>#findClassContainingMethod:startingAt: */
static sqInt NoDbgRegParms
findClassContainingMethodstartingAt(sqInt meth, sqInt classObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methodArray;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;

	if (((classObj & (tagMask(self))) == 0)
	 && (((longAt(classObj)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(classObj, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((classObj + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		currClass = referent;
	}
	else {
		currClass = classObj;
	}
	do {
		assert(!(isForwarded(currClass, self)));
		if (!(addressCouldBeClassObj(currClass, self))) {
			/* begin nilObject */
			return GIV(nilObj);
		}
		/* begin noFixupFollowField:ofObject: */
		objOop1 = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))));
		if (((objOop1 & (tagMask(self))) == 0)
		 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(objOop1, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent2 = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent2 & (tagMask(self))) == 0)
			 && (((longAt(referent2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			objOop1 = referent2;
		}
		classDict = objOop1;
		assert(!(isForwarded(classDict, self)));
		/* begin numSlotsOf: */
		assert((classIndexOf(classDict, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(classDict + 7);
		classDictSize = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classDict - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		if (classDictSize > MethodArrayIndex) {
			/* begin noFixupFollowField:ofObject: */
			objOop = longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
			if (((objOop & (tagMask(self))) == 0)
			 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(objOop, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent1 = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent1 & (tagMask(self))) == 0)
				 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				objOop = referent1;
			}
			methodArray = objOop;
			assert(!(isForwarded(methodArray, self)));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (noFixupFollowFieldofObject(i, methodArray, self))) {
					return currClass;
				}
				i += 1;
			}
		}
		/* begin noFixupFollowField:ofObject: */
		objOop2 = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop2 & (tagMask(self))) == 0)
		 && (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(objOop2, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent3 = longAt((objOop2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent3 & (tagMask(self))) == 0)
			 && (((longAt(referent3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			objOop2 = referent3;
		}
		currClass = objOop2;
	} while(!(currClass == GIV(nilObj)));
	return currClass;
}

	/* StackInterpreter>>#findClassOfMethod:forReceiver: */
sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rclass;
    sqInt tagBits;

	if (((rcvr & (tagMask(self)))
	 || (addressCouldBeObj(rcvr, self)))
	 && (!(((rcvr & (tagMask(self))) == 0)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)))) {
		rclass = findClassContainingMethodstartingAt(meth, (((tagBits = rcvr & (tagMask(self)))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
			: fetchClassOfNonImm(rcvr, self)), self);
		if (rclass != GIV(nilObj)) {
			return rclass;
		}
	}
	if (!((addressCouldBeObj(meth, self))
		 && (((((usqInt) (longAt(meth))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	return findClassContainingMethodstartingAt(meth, safeMethodClassOf(meth, self), self);
}


/*	Answer the frame above theFP (adjacent frame nearest head end).
	If theFP is the head frame answer 0. */

	/* StackInterpreter>>#findFrameAbove:inPage: */
static char * NoDbgRegParms
findFrameAboveinPage(char *theFP, StackPage *thePage, struct foo * self)
{
    char *callerFP;
    char *fp;

	fp = (thePage->headFP);
	if (fp == theFP) {
		return 0;
	}
	while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
		if (callerFP == theFP) {
			return fp;
		}
		fp = callerFP;
	}
	error("did not find theFP in stack page");
	return 0;
}

	/* StackInterpreter>>#findHomeForContext: */
static sqInt NoDbgRegParms
findHomeForContext(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;

	if (!(((aContext & (tagMask(self))) == 0)
		 && (((longAt(aContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
		return null;
	}
	/* begin fetchPointer:ofObject: */
	closureOrNil = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord(self))))));
	if (closureOrNil == GIV(nilObj)) {
		return aContext;
	}
	if (((compactClassIndexOf(closureOrNil, self)) != ClassBlockClosureCompactIndex)
	 && ((compactClassIndexOf(closureOrNil, self)) != ClassFullBlockClosureCompactIndex)) {
		return null;
	}
	return findHomeForContext(longAt((closureOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self)))))), self);
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromFP:SP:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */
/*	Being mutually-recursive with findMethodWithPrimitive:FromFP:UpToContext:
	gives the author's type inference algorithm headaches. Wimp out by
	declaring the return type.
 */

	/* StackInterpreter>>#findMethodWithPrimitive:FromContext:UpToContext: */
static sqInt NoDbgRegParms
findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderContext1;
    sqInt senderOop;
    char *startFP;
    sqInt theContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    sqInt theMethod1;
    char *theSP;

	assert((senderContext == (nilObject(self)))
	 || (isContext(senderContext, self)));
	assert((homeContext == (nilObject(self)))
	 || (isContext(homeContext, self)));
	theContext = senderContext;
	while (1) {
		if (theContext == GIV(nilObj)) {
			return theContext;
		}
		if (((((longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) break;
		if (theContext == homeContext) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord(self))))))) != GIV(nilObj)))) {
			/* begin fetchPointer:ofObject: */
			theMethod = longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
			if ((primitiveIndexOfMethodheader(theMethod, methodHeaderOf(theMethod, self), self)) == primitive) {
				return theContext;
			}
		}
		/* begin fetchPointer:ofObject: */
		theContext = longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	}
	if (isWidowedContext(theContext, self)) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	/* begin findMethodWithPrimitive:FromFP:UpToContext: */
	senderOop = longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	startFP = pointerForOop(senderOop - 1);
	theFP = startFP;
	theFPAbove = startFP;
	do {
		if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((byteAt((theFP + FoxFrameFlags) + 3)) != 0))) {
			theMethod1 = longAt(theFP + FoxMethod);
			if ((primitiveIndexOfMethodheader(theMethod1, methodHeaderOf(theMethod1, self), self)) == primitive) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP, self), self);
				}
				else {
					assert(!(isBaseFrame(theFPAbove, self)));
					theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove, self))) + BytesPerWord;
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(theFP, self), self));
					return longAt(theFP + FoxThisContext);
				}
				return marryFrameSP(theFP, theSP, self);
			}
		}
		theFPAbove = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	senderContext1 = longAt(theFPAbove + FoxCallerContext);
	if (!(((senderContext1 & (tagMask(self))) == 0)
		 && (((longAt(senderContext1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromContextUpToContext(primitive, senderContext1, homeContext, self);
}


/*	Find the compiled method to be run when the current 
	messageSelector is sent to the given class, setting the values 
	of 'newMethod' and 'primitiveIndex'. */

	/* StackInterpreter>>#findNewMethodInClassTag: */
static sqInt NoDbgRegParms
findNewMethodInClassTag(sqInt classTagArg, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt classTag;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt ok;

	ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTagArg, self);
	if (!ok) {

		/* entry was not found in the cache; look it up the hard way */
		classTag = classTagArg;
		if ((((GIV(messageSelector) & (tagMask(self))) == 0)
		 && (((longAt(GIV(messageSelector))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))
		 || (classTag == (isForwardedObjectClassIndexPun(self)))) {
			if (((GIV(messageSelector) & (tagMask(self))) == 0)
			 && (((longAt(GIV(messageSelector))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector), self);
			}
			if (classTag == (isForwardedObjectClassIndexPun(self))) {
				classTag = handleForwardedSendFaultForTag(classTag, self);
			}
			ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag, self);
			if (ok) {
				return null;
			}
		}
		/* begin classAtIndex: */
		assert((classTag >= 0)
		 && ((classTag <= (tagMask(self)))
		 || ((classTag >= (arrayClassIndexPun(self)))
		 && (classTag <= (classIndexMask(self))))));
		/* begin fetchPointer:ofObject: */
		fieldIndex = ((usqInt) classTag) >> (classTableMajorIndexShift(self));
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
		if (classTablePage == GIV(nilObj)) {
			GIV(lkupClass) = null;
			goto l2;
		}
		/* begin fetchPointer:ofObject: */
		fieldIndex1 = classTag & ((1U << (classTableMajorIndexShift(self))) - 1);
		GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord(self))))));
	l2:	/* end classAtIndex: */;
		lookupMethodInClass(GIV(lkupClass), self);
		addNewMethodToCache(GIV(lkupClass), self);
	}
	return 0;
}

	/* StackInterpreter>>#findSelectorOfMethod: */
sqInt
findSelectorOfMethod(sqInt meth, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt classObj;
    sqInt i;
    sqInt methodArray;
    usqInt numSlots;
    sqInt selector;

	if (!(addressCouldBeObj(meth, self))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	if (((longAt(meth)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		return findSelectorOfMethod(followForwarded(meth, self), self);
	}
	if (!(((meth & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(meth))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	selector = maybeSelectorOfMethod(meth, self);
	if (!(selector == null)) {
		return selector;
	}
	classObj = safeMethodClassOf(meth, self);
	if (addressCouldBeClassObj(classObj, self)) {
		/* begin fetchPointer:ofObject: */
		classDict = longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))));
		/* begin numSlotsOf: */
		assert((classIndexOf(classDict, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(classDict + 7);
		classDictSize = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classDict - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		if (classDictSize > MethodArrayIndex) {
			/* begin fetchPointer:ofObject: */
			methodArray = longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					/* begin fetchPointer:ofObject: */
					return longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)((i + SelectorStart)) << (shiftForWord(self))))));
				}
				i += 1;
			}
		}
	}
	/* begin nilObject */
	return GIV(nilObj);
}


/*	Search for the stack pointer for theFP. This points to the hottest item on
	the frame's stack.
	DO NOT CALL THIS WITH theFP == localFP OR theFP == framePointer! */

	/* StackInterpreter>>#findSPOf:on: */
static char * NoDbgRegParms
findSPOfon(char *theFP, StackPage *thePage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *prevFrame;
    char *startFrame;
    char *theSP;

	assert(!((isFree(thePage, self))));
	/* begin findSPOrNilOf:on:startingFrom: */
	startFrame = (thePage->headFP);
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = theFP + FoxReceiver;
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
			? (thePage->headSP)
			: ((thePage->headSP)) + BytesPerWord);
		goto l1;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			assert(!(isBaseFrame(prevFrame, self)));
			theSP = (prevFrame + (frameStackedReceiverOffset(prevFrame, self))) + BytesPerWord;
			goto l1;
		}
	}
	theSP = null;
	l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (theSP) {
		return theSP;
	}
	error("did not find theFP in stack page");
	return 0;
}


/*	methodObj is a CompiledMethod. If it contains an external primitive,
	flush the function address and session ID of the CM. Answer the prim
	index for the benefit of subclass overrides. */

	/* StackInterpreter>>#flushExternalPrimitiveOf: */
static sqInt NoDbgRegParms
flushExternalPrimitiveOf(sqInt methodObj, struct foo * self)
{
    sqInt firstBytecode;
    sqInt header;
    sqInt lit;
    sqInt primIdx;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodObj, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	if (header & AlternateHeaderHasPrimFlag) {
		/* begin firstBytecodeOfAlternateHeader:method: */
		firstBytecode = (methodObj + ((LiteralStart + (((header >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primIdx = (byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8)));
	}
	else {
		primIdx = 0;
	}
	if ((primIdx == PrimNumberExternalCall)
	 && (((assert((((header) & 7) == 1)),
	((header >> 3)) & AlternateHeaderNumLiteralsMask)) > 0)) {

		/* If not, something's broken */
		/* begin fetchPointer:ofObject: */
		lit = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord(self))))));
		if ((((lit & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(lit))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && ((numSlotsOf(lit, self)) == 4)) {

			/* If not, something's broken */
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(lit, self)));
			longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord(self))), ConstZero);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(lit, self)));
			longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord(self))), ConstZero);
		}
	}
	return primIdx;
}


/*	follow pointers in the current stack frame up to theSP. */

	/* StackInterpreter>>#followForwardedFrameContents:stackPointer: */
static void NoDbgRegParms
followForwardedFrameContentsstackPointer(char *theFP, char *theSP, struct foo * self)
{
    sqInt oop;
    char *ptr;
    sqInt referent;
    char * toDoLimit1;
    char * toDoLimit2;

	for (ptr = theSP, toDoLimit1 = (theFP + FoxReceiver); ptr <= toDoLimit1; ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((oop & (tagMask(self))) == 0)
		 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			longAtput(ptr, followForwarded(oop, self));
		}
	}
	for (ptr = ((theFP + FoxCallerSavedIP) + BytesPerWord), toDoLimit2 = (theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord(self))))))); ptr <= toDoLimit2; ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((oop & (tagMask(self))) == 0)
		 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent & (tagMask(self))) == 0)
			 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			oop = referent;
			longAtput(ptr, oop);
		}
	}
	if ((byteAt((theFP + FoxFrameFlags) + 3)) != 0) {
		assert(oop == (longAt(theFP + (frameStackedReceiverOffset(theFP, self)))));
		followForwardedObjectFieldstoDepth(oop, 0, self);
	}
	assert(!(isForwarded(frameMethodObject(theFP, self), self)));
	if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
		assert(!(isForwarded(frameContext(theFP, self), self)));
	}
}


/*	Spur's become: is lazy, turning the becommed object into a forwarding
	object to the other.
	The read-barrier is minimised by arranging that forwarding pointers will
	fail a method cache
	probe, since notionally objects' internals are accessed only via sending
	messages to them,
	the exception is primitives that access the internals of the non-receiver
	argument(s). 
	To avoid a read barrier on bytecode, literal and inst var fetch and
	non-local return, we scan
	the receivers (including the stacked receiver for non-local return) and
	method references
	in the stack zone and follow any forwarded ones. This is of course way
	cheaper than
	scanning all of memory as in the old become. */

	/* StackInterpreter>>#followForwardingPointersInStackZone: */
static void NoDbgRegParms
followForwardingPointersInStackZone(sqInt theBecomeEffectsFlags, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    char *callerFP;
    sqInt delta;
    sqInt i;
    sqInt newOop;
    sqInt numArgs;
    sqInt offset;
    sqInt oop;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;
    char *theFP;
    usqInt theIPPtr;
    StackPage *thePage;

	if (GIV(stackPage) == 0) {

		/* the system must be snapshotting; nothing to do... */
		assert(isFree(mostRecentlyUsedPage(self), self));
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (theBecomeEffectsFlags & BecameCompiledMethodFlag) {
		if (((longAt(GIV(method))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			theIPPtr = GIV(instructionPointer) - GIV(method);
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(method), self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((GIV(method) + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent & (tagMask(self))) == 0)
			 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			GIV(method) = referent;
			GIV(instructionPointer) = GIV(method) + theIPPtr;
		}
		if (((GIV(newMethod) & (tagMask(self))) == 0)
		 && (((longAt(GIV(newMethod))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(newMethod), self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent1 = longAt((GIV(newMethod) + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent1 & (tagMask(self))) == 0)
			 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			GIV(newMethod) = referent1;
		}
	}
	assert(GIV(stackPage) != 0);
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage, self));

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			theIPPtr = (thePage == GIV(stackPage)
				? 0
				: ((usqInt)((thePage->headSP))));
			while (1) {
				assert(addressIsInPage(thePage, theFP, self));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, ((void *)theIPPtr), self)));
				oop = longAt(theFP + FoxReceiver);
				if (((oop & (tagMask(self))) == 0)
				 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					longAtput(theFP + FoxReceiver, followForwarded(oop, self));
				}
				if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
				 && (((longAt(longAt(theFP + FoxThisContext))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					longAtput(theFP + FoxThisContext, followForwarded(longAt(theFP + FoxThisContext), self));
				}
				oop = longAt(theFP + FoxMethod);
				if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(oop, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent2 = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent2 & (tagMask(self))) == 0)
					 && (((longAt(referent2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					newOop = referent2;
					if (theIPPtr != 0) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP, self)));
						delta = newOop - oop;
						longAtput(theIPPtr, (longAt(theIPPtr)) + delta);
					}
					longAtput(theFP + FoxMethod, (oop = newOop));
				}
				/* begin frameStackedReceiverOffsetNumArgs: */
				numArgs = byteAt((theFP + FoxFrameFlags) + 1);
				offset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord(self)))));
				oop = longAt(theFP + offset);
				if (((oop & (tagMask(self))) == 0)
				 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					longAtput(theFP + offset, followForwarded(oop, self));
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theIPPtr = ((usqInt)(theFP + FoxCallerSavedIP));
				theFP = callerFP;
			}
			assert(theFP == ((thePage->baseFP)));
			oop = longAt(theFP + FoxCallerContext);
			if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin frameCallerContext:put: */
				assert(isUnambiguouslyForwarder(oop, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent3 = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent3 & (tagMask(self))) == 0)
				 && (((longAt(referent3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				aValue = referent3;
				assert((aValue == (nilObject(self)))
				 || (isContext(aValue, self)));
				longAtput(theFP + FoxCallerContext, aValue);
			}
		}
	}
}


/*	Force an interrupt check ASAP.
	Must set the stack page's limit before stackLimit to avoid
	a race condition if this is called from an interrupt handler. */

	/* StackInterpreter>>#forceInterruptCheck */
sqInt
forceInterruptCheck(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*iccFunc)();
    StackPage *thePage;

	if (GIV(stackLimit) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	if ((thePage != null)
	 && (thePage != 0)) {
		(thePage->stackLimit = ((char *) (((usqInt) -1))));
	}
	/* begin allOnesAsCharStar */
	GIV(stackLimit) = ((char *) (((usqInt) -1)));
	sqLowLevelMFence(self);
	if (((iccFunc = interruptCheckChain)) != null) {
		iccFunc();
	}
	GIV(statForceInterruptCheck) += 1;
	return 0;
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

	/* StackInterpreter>>#forceInterruptCheckFromHeartbeat */
void
forceInterruptCheckFromHeartbeat(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!suppressHeartbeatFlag) {
		/* begin checkForLongRunningPrimitive */
		if (GIV(longRunningPrimitiveCheckSemaphore) == null) {
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
		 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds(self);
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			goto l1;
		}
		if (GIV(longRunningPrimitiveStopUsecs) == 0) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds(self);
			sqLowLevelMFence(self);
		}
	l1:	/* end checkForLongRunningPrimitive */;
		forceInterruptCheck(self);
	}
}

	/* StackInterpreter>>#frameCallerContext: */
static sqInt NoDbgRegParms
frameCallerContext(char *theFP, struct foo * self)
{
	return longAt(theFP + FoxCallerContext);
}

	/* StackInterpreter>>#frameContext: */
static sqInt NoDbgRegParms
frameContext(char *theFP, struct foo * self)
{
	return longAt(theFP + FoxThisContext);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameHasContext: */
static sqInt NoDbgRegParms
frameHasContext(char *theFP, struct foo * self)
{
	return (byteAt((theFP + FoxFrameFlags) + 2)) != 0;
}


/*	<Integer> */

	/* StackInterpreter>>#frameIsBlockActivation: */
static sqInt NoDbgRegParms
frameIsBlockActivation(char *theFP, struct foo * self)
{
	return (byteAt((theFP + FoxFrameFlags) + 3)) != 0;
}


/*	Homonym of frameMethod: for compatibility with CoInterpreter */

	/* StackInterpreter>>#frameMethodObject: */
static sqInt NoDbgRegParms
frameMethodObject(char *theFP, struct foo * self)
{
	return longAt(theFP + FoxMethod);
}

	/* StackInterpreter>>#frameMethod: */
static sqInt NoDbgRegParms
frameMethod(char *theFP, struct foo * self)
{
	return longAt(theFP + FoxMethod);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameNumArgs: */
static sqInt NoDbgRegParms
frameNumArgs(char *theFP, struct foo * self)
{
	return byteAt((theFP + FoxFrameFlags) + 1);
}

	/* StackInterpreter>>#frameOfMarriedContext: */
static char * NoDbgRegParms
frameOfMarriedContext(sqInt aContext, struct foo * self)
{
    sqInt senderOop;

	/* begin fetchPointer:ofObject: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	return (assert((((senderOop) & 7) == 1)),
		pointerForOop(senderOop - 1));
}

	/* StackInterpreter>>#frameReceiver: */
static sqInt NoDbgRegParms
frameReceiver(char *theFP, struct foo * self)
{
	return longAt(theFP + FoxReceiver);
}


/*	Answer the offset in bytes from the the frame pointer to its stacked
	receiver. The receiver of a message send or the closure of a block
	activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#frameStackedReceiverOffset: */
static sqInt NoDbgRegParms
frameStackedReceiverOffset(char *theFP, struct foo * self)
{
    sqInt numArgs;

	/* begin frameStackedReceiverOffsetNumArgs: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	return (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord(self)))));
}


/*	Free any untraced stack pages. */

	/* StackInterpreter>>#freeUntracedStackPages */
static void
freeUntracedStackPages(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {

		/* Invalidate the trace state for assertion checks */
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		if ((!(isFree(thePage, self)))
		 && (((thePage->trace)) == StackPageUnreached)) {
			assert(noMarkedContextsOnPage(thePage, self));
			freeStackPage(thePage, self);
		}
		assert(((thePage->trace = StackPageTraceInvalid)) != 0);
	}
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

	/* StackInterpreter>>#fullDisplayUpdate */
sqInt
fullDisplayUpdate(struct foo * self)
{
	updateDisplayLeftTopRightBottom(0, 0, displayWidth, displayHeight, self);
	ioForceDisplayUpdate(self);
	return 0;
}


/*	Find an actual function pointer for this primitiveIndex. This is an
	opportunity to specialise the prim for the relevant class (format for
	example). Default for now is simply the entry in the base primitiveTable. */

	/* StackInterpreter>>#functionPointerFor:inClass: */
void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void)

{
	return (primIdx > MaxPrimitiveIndex
		? 0
		: primitiveTable[primIdx]);
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. 
 */

	/* StackInterpreter>>#getCurrentBytecode */
sqInt
getCurrentBytecode(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return byteAt(GIV(instructionPointer));
}


/*	This is nil in the StackVM */

	/* StackInterpreter>>#getDesiredCogCodeSize */
static sqInt
getDesiredCogCodeSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin nilObject */
	return GIV(nilObj);
}


/*	Answer the errorCode object to supply to a failing primitive method that
	accepts one.
	If there is a primitive error table and the primFailCode is a valid index
	there-in answer
	the corresponding entry in the table, otherwise simply answer the code as
	an integer.
 */

	/* StackInterpreter>>#getErrorObjectFromPrimFailCode */
static sqInt
getErrorObjectFromPrimFailCode(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt clone;
    sqInt errObj;
    sqInt fieldIndex;
    sqInt i;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    usqInt numSlots;
    sqInt objOop;
    sqInt table;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;

	if (GIV(primFailCode) > 0) {
		/* begin splObj: */
		table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(PrimErrTableIndex) << (shiftForWord(self))))));
		if (GIV(primFailCode) <= (numSlotsOf(table, self))) {
			/* begin followField:ofObject: */
			fieldIndex = GIV(primFailCode) - 1;
			/* begin fetchPointer:ofObject: */
			objOop = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
			if (((objOop & (tagMask(self))) == 0)
			 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, table, objOop, self);
			}
			errObj = objOop;
			if (((GIV(primFailCode) == PrimErrOSError)
			 || (GIV(primFailCode) == PrimErrFFIException))
			 && ((((((usqInt) (longAt(errObj))) >> (formatShift(self))) & (formatMask(self))) == 1 /* nonIndexablePointerFormat */)
			 && (((numSlots = numSlotsOf(errObj, self))) >= 2))) {
				/* begin cloneOSErrorObj:numSlots: */
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				knownClassIndex = (longAt(errObj)) & (classIndexMask(self));
				assert((numSlots >= 0)
				 && ((knownClassIndex != 0)
				 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
				assert((1 /* nonIndexablePointerFormat */) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask(self)));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit(self))) == 0);
				assert((newObj % (allocationUnit(self))) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck(self);
					}
					if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						clone = 0;
						goto l5;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (1U << (formatShift(self)))) + knownClassIndex);
				GIV(freeStart) += numBytes;
				clone = newObj;
	l5:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				for (i = 0; i < numSlots; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					valuePointer = longAt((errObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
					assert(!(isOopForwarded(clone, self)));
					longAtput((clone + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
				}
				if ((numSlots > 2)
				 && (GIV(primFailCode) == PrimErrFFIException)) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					valuePointer1 = positive64BitIntegerFor(((usqLong) GIV(osErrorCode)), self);
					assert(!(isOopForwarded(clone, self)));
					longAtput((clone + BaseHeaderSize) + (1U << (shiftForWord(self))), valuePointer1);
					/* begin storePointerUnchecked:ofObject:withValue: */
					valuePointer2 = positiveMachineIntegerFor(GIV(exceptionPC), self);
					assert(!(isOopForwarded(clone, self)));
					longAtput((clone + BaseHeaderSize) + (2U << (shiftForWord(self))), valuePointer2);
				}
				else {
					/* begin storePointerUnchecked:ofObject:withValue: */
					valuePointer3 = signed64BitIntegerFor(GIV(osErrorCode), self);
					assert(!(isOopForwarded(clone, self)));
					longAtput((clone + BaseHeaderSize) + (1U << (shiftForWord(self))), valuePointer3);
				}
				errObj = clone;
			}
			return errObj;
		}
	}
	return (((usqInt)GIV(primFailCode) << 3) | 1);
}

	/* StackInterpreter>>#getFullScreenFlag */
sqInt
getFullScreenFlag(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(fullScreenFlag);
}

	/* StackInterpreter>>#getInterruptKeycode */
sqInt
getInterruptKeycode(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptKeycode);
}

	/* StackInterpreter>>#getInterruptPending */
sqInt
getInterruptPending(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptPending);
}

	/* StackInterpreter>>#getNextWakeupUsecs */
usqLong
getNextWakeupUsecs(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nextWakeupUsecs);
}

	/* StackInterpreter>>#getNumberOfImage */
static int
getNumberOfImage()
{
	return numberOfImage;
	return 0;
}

	/* StackInterpreter>>#getSavedWindowSize */
sqInt
getSavedWindowSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedWindowSize);
}


/*	Answer the screen size to write to the snapshot.
	If the actual screen size is zero then write the savedWindowSize instead. */

	/* StackInterpreter>>#getSnapshotScreenSize */
static sqInt
getSnapshotScreenSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt screenSize;

	screenSize = ioScreenSize(self);
	if (((screenSize & 0xFFFF) == 0)
	 || ((((usqInt) screenSize) >> 16) == 0)) {
		screenSize = GIV(savedWindowSize);
	}
	return screenSize;
}


/*	For Alien FFI */

	/* StackInterpreter>>#getStackPointer */
sqInt *
getStackPointer(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((sqInt *) GIV(stackPointer));
}


/*	return the global session ID value */

	/* StackInterpreter>>#getThisSessionID */
sqInt
getThisSessionID(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(globalSessionID);
}


/*	Answer the next 32 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getWord32FromFile:swap: */
static sqInt NoDbgRegParms
getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag, struct foo * self)
{
    int w;

	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, aFile, self);
	return (swapFlag
		? SQ_SWAP_4_BYTES(w)
		: w);
}

	/* StackInterpreter>>#growAllGlobalsStruct: */
static void NoDbgRegParms
growAllGlobalsStruct(int numberImages)
{
	thread_id = realloc(thread_id, sizeof(pthread_t) * numberImages);
}

	/* StackInterpreter>>#haltIn: */
static sqInt NoDbgRegParms
haltIn(struct foo *interpreterState, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	interpreterState->isStepable = 1;
	return 0;
}


/*	Handle a send fault that is due to a send using a forwarded selector.
	Unforward the selector and follow the current method and special
	selectors array to unforward the source of the forwarded selector. */

	/* StackInterpreter>>#handleForwardedSelectorFaultFor: */
static sqInt NoDbgRegParms
handleForwardedSelectorFaultFor(sqInt selectorOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;

	assert(isOopForwarded(selectorOop, self));
	/* begin followForwardedFieldsInCurrentMethod */
	followForwardedObjectFieldstoDepth(GIV(method), 0, self);
	followForwardedObjectFieldstoDepth(splObj(SpecialSelectors, self), 0, self);
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(selectorOop, self));
	/* begin fetchPointer:ofMaybeForwardedObject: */
	referent = longAt((selectorOop + BaseHeaderSize) + (0U << (shiftForWord(self))));
	while (((referent & (tagMask(self))) == 0)
	 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
	}
	return referent;
}


/*	Handle a send fault that may be due to a send to a forwarded object.
	Unforward the receiver on the stack and answer its actual class. */

	/* StackInterpreter>>#handleForwardedSendFaultForTag: */
static sqInt NoDbgRegParms
handleForwardedSendFaultForTag(sqInt classTag, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt referent;
    sqInt tagBits;

	assert(isForwardedClassTag(classTag, self));

	/* should *not* be a super send, so the receiver should be forwarded. */
	rcvr = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	assert(isOopForwarded(rcvr, self));
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(rcvr, self));
	/* begin fetchPointer:ofMaybeForwardedObject: */
	referent = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord(self))));
	while (((referent & (tagMask(self))) == 0)
	 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
	}
	rcvr = referent;
	longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord), self);
	if ((((longAt(GIV(framePointer) + FoxReceiver)) & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(longAt(GIV(framePointer) + FoxReceiver)))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)) {
		followForwardedObjectFieldstoDepth(longAt(GIV(framePointer) + FoxReceiver), 0, self);
	}
	return (((tagBits = rcvr & (tagMask(self)))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask(self)));
}


/*	Handle a special send fault that may be due to a special selector
	send accessing a forwarded object. obj is forwarded.
	Unforward stack contents and and inst vars and answer obj's target. */

	/* StackInterpreter>>#handleSpecialSelectorSendFaultFor:fp:sp: */
static sqInt NoDbgRegParms
handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP, struct foo * self)
{
    sqInt rcvr;
    sqInt referent;

	assert(isOopForwarded(obj, self));
	followForwardedFrameContentsstackPointer(theFP, theSP, self);
	/* begin frameReceiver: */
	rcvr = longAt(theFP + FoxReceiver);
	if (((rcvr & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)) {
		followForwardedObjectFieldstoDepth(rcvr, 0, self);
	}
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(obj, self));
	/* begin fetchPointer:ofMaybeForwardedObject: */
	referent = longAt((obj + BaseHeaderSize) + (0U << (shiftForWord(self))));
	while (((referent & (tagMask(self))) == 0)
	 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
	}
	return referent;
}


/*	Check for stack overflow, moving frames to another stack if so.
	This should *only* be sent from checkForStackOverflow. */

	/* StackInterpreter>>#handleStackOverflow */
static void NeverInline
handleStackOverflow(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *callerFP1;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt overflowCount;
    char *overflowLimitAddress;
    char *theFP;

	assert(GIV(stackPointer) < ((GIV(stackPage)->realStackLimit)));

	/* The stack has overflowed this page.  If the system is executing some recursive algorithm,
	   e.g. fibonacci, then the system could thrash overflowing the stack if the call soon returns
	   back to the current page.  To avoid thrashing, since overflow is quite slow, we can move
	   more than one frame.  The idea is to record which page has overflowed, and the first
	   time it overflows move one frame, the second time two frames, and so on.  We move no
	   more frames than would leave the page half occupied. */
	GIV(statStackOverflow) += 1;
	theFP = GIV(framePointer);
	if (GIV(stackPage) == GIV(overflowedPage)) {
		overflowLimitAddress = ((GIV(stackPage)->baseAddress)) - GIV(overflowLimit);
		overflowCount = (GIV(extraFramesToMoveOnOverflow) += 1);
		while ((((overflowCount -= 1)) >= 0)
		 && ((((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) < overflowLimitAddress)
		 && (!((longAt(callerFP + FoxSavedFP)) == 0)))) {
			theFP = callerFP;
		}
	}
	else {
		GIV(overflowedPage) = GIV(stackPage);
		GIV(extraFramesToMoveOnOverflow) = 0;
	}
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		longAt(theFP + FoxCallerContext);
		goto l2;
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1, self), self));
		longAt(callerFP1 + FoxThisContext);
		goto l2;
	}
	marryFrameSP(callerFP1, (assert(!(isBaseFrame(theFP, self))),
	(theFP + (frameStackedReceiverOffset(theFP, self))) + BytesPerWord), self);
	l2:	/* end ensureCallerContext: */;
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree, self);
	newPage = lruOrFree;
	l1:	/* end newStackPage */;
	moveFramesInthroughtoPage(GIV(stackPage), theFP, newPage, self);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage, self);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	
	/* To overflow the stack this must be a new frame, but in Cog base frames are married. */
	assert(!(frameHasContext(GIV(framePointer), self)));
	assert(validInstructionPointerinMethodframePointer(GIV(instructionPointer) + 1, GIV(method), GIV(framePointer), self));
}


/*	The stackPointer is below the stackLimit. This is either because of a
	stack overflow or the setting of stackLimit to indicate a possible
	interrupt. Check for stackOverflow and interrupts anddeal with each
	appropriately. Answer if a context switch occurred. */

	/* StackInterpreter>>#handleStackOverflowOrEventAllowContextSwitch: */
static sqInt NoDbgRegParms
handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow(self);
	}
	if (GIV(stackLimit) == ((GIV(stackPage)->realStackLimit))) {
		return 0;
	}
	return checkForEventsMayContextSwitch(mayContextSwitch, self);
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

	/* StackInterpreter>>#highBit: */
sqInt
highBit(usqInt anUnsignedValue, struct foo * self)
{
    sqInt bitNo;
    usqInt shifted;

	shifted = anUnsignedValue;
	bitNo = 0;
	
#  if BytesPerWord > 4
	if (!(shifted < (1ULL << 32))) {
		shifted = ((usqInt) shifted) >> 32;
		bitNo += 32;
	}
#  endif /* BytesPerWord > 4 */
	if (!(shifted < (1U << 16))) {
		shifted = ((usqInt) shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (1U << 8))) {
		shifted = ((usqInt) shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (1U << 4))) {
		shifted = ((usqInt) shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (1U << 2))) {
		shifted = ((usqInt) shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (1U << 1))) {
		shifted = ((usqInt) shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	If thePage is the stackPage and the stackPointer and/or the framePointer
	are pointing within it,
	answer if thePage's heapSP and headFP are equal to the stackPointer and
	framePointer respectively.
 */

	/* StackInterpreter>>#ifCurrentStackPageHasValidHeadPointers: */
static sqInt NoDbgRegParms
ifCurrentStackPageHasValidHeadPointers(StackPage *thePage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (thePage == GIV(stackPage)) {
		if ((((thePage->lastAddress)) < GIV(framePointer))
		 && (GIV(framePointer) < ((thePage->baseAddress)))) {
			if (((thePage->headFP)) != GIV(framePointer)) {
				return 0;
			}
		}
		if ((((thePage->lastAddress)) < GIV(stackPointer))
		 && (GIV(stackPointer) < ((thePage->baseAddress)))) {
			if (((thePage->headSP)) != GIV(stackPointer)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* StackInterpreter>>#iframeMethod: */
static usqInt NoDbgRegParms
iframeMethod(char *theFP, struct foo * self)
{
	return longAt(theFP + FoxMethod);
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null.
	This is a noop in the stack VM since the C stack pointers are always
	elsewhere (e.g., in some C function running the interpreter). */

	/* StackInterpreter>>#ifValidWriteBackStack:Pointers:Save:To: */
void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP, struct foo * self)
{
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

	/* StackInterpreter>>#includesBehavior:ThatOf: */
sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		/* begin followField:ofObject: */
		objOop = longAt((theClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop & (tagMask(self))) == 0)
		 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass, objOop, self);
		}
		theClass = objOop;
	}
	return 0;
}

	/* StackInterpreter>>#initAllGlobalsStruct */
static void
initAllGlobalsStruct()
{
	
		thread_id = malloc(sizeof(pthread_t));
}


/*	Initialize metaclassNumSlots and thisClassIndex which are used in debug
	printing, and
	classNameIndex which is used not only for debug printing but for
	is:KindOf: & is:MemberOf:
	via classNameOf:is: (evil but a reality we have to accept). */

	/* StackInterpreter>>#initializeExtraClassInstVarIndices */
static void
initializeExtraClassInstVarIndices(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classArrayClass;
    sqInt classArrayObj;
    sqInt i;
    sqInt iLimiT;
    usqInt numSlots;
    sqInt oop;

	/* begin splObj: */
	classArrayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self))))));
	classArrayClass = fetchClassOfNonImm(classArrayObj, self);
	/* begin numSlotsOf: */
	assert((classIndexOf(classArrayClass, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(classArrayClass + 7);
	GIV(metaclassNumSlots) = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classArrayClass - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);

	/* default */
	GIV(thisClassIndex) = 5;
	for (i = (InstanceSpecificationIndex + 1), iLimiT = (lengthOfformat(classArrayClass, (((usqInt) (longAt(classArrayClass))) >> (formatShift(self))) & (formatMask(self)), self)); i <= iLimiT; i += 1) {
		if ((longAt((classArrayClass + BaseHeaderSize) + (((sqInt)((usqInt)((i - 1)) << (shiftForWord(self))))))) == classArrayObj) {
			GIV(thisClassIndex) = i - 1;
		}
	}

	/* default */
	GIV(classNameIndex) = 6;
	for (i = (InstanceSpecificationIndex + 1), iLimiT = (lengthOfformat(classArrayObj, (((usqInt) (longAt(classArrayObj))) >> (formatShift(self))) & (formatMask(self)), self)); i <= iLimiT; i += 1) {
		/* begin fetchPointer:ofObject: */
		oop = longAt((classArrayObj + BaseHeaderSize) + (((sqInt)((usqInt)((i - 1)) << (shiftForWord(self))))));
		if ((((oop & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))
		 && (((lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)) == 5)
		 && ((strncmp("Array", firstFixedField(oop, self), 5)) == 0))) {
			GIV(classNameIndex) = i - 1;
		}
	}
}


/*	Initialize the stack pages and enter interpret. Use alloca'ed memory so
	that when
	we have a JIT its stack pointer will be on the native stack since alloca
	allocates memory on the stack. Certain thread systems use the native stack
	pointer as the
	frame ID so putting the stack anywhere else can confuse the thread system. */
/*	This should be in its own initStackPages method but Slang can't inline
	C code strings. */

	/* StackInterpreter>>#initStackPagesAndInterpret */
static sqInt
initStackPagesAndInterpret(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anArray;
    sqInt channelClassOop;
    sqInt channelOop;
    sqInt classIndex;
    sqInt index1;
    sqInt index2;
    usqInt newObj;
    sqInt nilOop;
    usqInt numBytes;
    usqInt p;
    sqInt stackPageBytes;
    sqInt stackPagesBytes;
    void *theStackMemory;

	stackPageBytes = stackPageByteSize(self);
	/* begin computeStackZoneSize */
	stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize(self)))) + BytesPerWord;
	theStackMemory = alloca(stackPagesBytes);
	memset(theStackMemory, 0, stackPagesBytes);
	initializeStacknumSlotspageSize(theStackMemory, stackPagesBytes / BytesPerWord, stackPageBytes / BytesPerWord, self);
	loadInitialContext(self);
	initMutexForFetchNextBytecodeandCond(&GIV(mutexForFetchBytecode), &GIV(step), self);
	/* begin initializeBootstrapChannel */
	nilOop = GIV(nilObj);
	/* begin splObj: */
	channelOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialChannel) << (shiftForWord(self))))));
	if (nilOop == channelOop) {

		/* We don't have a channel */
		/* begin splObj: */
		channelClassOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassChannelQueue) << (shiftForWord(self))))));
		if (nilOop == channelClassOop) {

			/* We don't have the class neither there is nothing we can do */
			channelOop = nilOop;
		}
		else {

			/* We check that the class is at the fix index in order for other memory to look at this specific place */
			if (!((knownClassAtIndex(ClassChannelQueueCompactIndex, self)) == channelClassOop)) {

				/* our class exist but is not in the classTable at the expected index. We remove the entry and enter our class a the fix index. */
				expungeFromClassTable(channelClassOop, self);
				/* begin setHashBitsOf:to: */
				assert(((ClassChannelQueueCompactIndex >= 0) && (ClassChannelQueueCompactIndex <= (identityHashHalfWordMask(self)))));
				long32Atput(channelClassOop + 4, ((((long32At(channelClassOop + 4)) | (identityHashHalfWordMask(self))) - (identityHashHalfWordMask(self)))) + ClassChannelQueueCompactIndex);
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(classTableFirstPage), self)));
				if ((assert(isNonImmediate(GIV(classTableFirstPage), self)),
				oopisGreaterThanOrEqualTo(GIV(classTableFirstPage), GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((channelClassOop & (tagMask(self))) == 0)
					 && (oopisLessThan(channelClassOop, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(classTableFirstPage)))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(GIV(classTableFirstPage), self);
						}
					}
				}
				longAtput((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassChannelQueueCompactIndex) << (shiftForWord(self))))), channelClassOop);
			}

			/* for now it is a subclass of OrderedCollection, we need to initialize an array of size 10 and 2 index */
			channelOop = instantiateClassindexableSize(channelClassOop, 0, self);
			/* begin allocateSlots:format:classIndex: */
			classIndex = arrayClassIndexPun(self);
			newObj = GIV(freeStart);
			numBytes = BaseHeaderSize + (10 * BytesPerOop);
			if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
				if (!GIV(needGCFlag)) {
					/* begin scheduleScavenge */
					GIV(needGCFlag) = 1;
					forceInterruptCheck(self);
				}
				anArray = allocateSlotsInOldSpacebytesformatclassIndex(10, numBytes, 2, classIndex, self);
				goto l9;
			}
			longAtput(newObj, (((((usqLong) 10)) << (numSlotsFullShift(self))) + (2U << (formatShift(self)))) + classIndex);
			assert((numBytes % (allocationUnit(self))) == 0);
			assert((newObj % (allocationUnit(self))) == 0);
			GIV(freeStart) += numBytes;
			anArray = newObj;
	l9:	/* end allocateSlots:format:classIndex: */;
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((anArray + BaseHeaderSize) + (10 * BytesPerOop)) - 1, addressAfter(anArray, self), self));
			for (p = (((usqInt)(anArray + BaseHeaderSize))); p <= (((usqInt)(((anArray + BaseHeaderSize) + (10 * BytesPerOop)) - 1))); p += 8 /* allocationUnit */) {
				longAtput(p, nilOop);
			}
			index1 = (((usqInt)1 << 3) | 1);
			index2 = (((usqInt)0 << 3) | 1);
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(channelOop, self)));
			if ((assert(isNonImmediate(channelOop, self)),
			oopisGreaterThanOrEqualTo(channelOop, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((anArray & (tagMask(self))) == 0)
				 && (oopisLessThan(anArray, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(channelOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(channelOop, self);
					}
				}
			}
			longAtput((channelOop + BaseHeaderSize) + (0U << (shiftForWord(self))), anArray);
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(channelOop, self)));
			if ((assert(isNonImmediate(channelOop, self)),
			oopisGreaterThanOrEqualTo(channelOop, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((index1 & (tagMask(self))) == 0)
				 && (oopisLessThan(index1, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(channelOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(channelOop, self);
					}
				}
			}
			longAtput((channelOop + BaseHeaderSize) + (1U << (shiftForWord(self))), index1);
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(channelOop, self)));
			if ((assert(isNonImmediate(channelOop, self)),
			oopisGreaterThanOrEqualTo(channelOop, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((index2 & (tagMask(self))) == 0)
				 && (oopisLessThan(index2, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(channelOop))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(channelOop, self);
					}
				}
			}
			longAtput((channelOop + BaseHeaderSize) + (2U << (shiftForWord(self))), index2);
			/* begin splObj:put: */
			assert(!(isForwarded(GIV(specialObjectsOop), self)));
			if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
			oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((channelOop & (tagMask(self))) == 0)
				 && (oopisLessThan(channelOop, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(GIV(specialObjectsOop), self);
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialChannel) << (shiftForWord(self))))), channelOop);
		}
	}
	GIV(channel) = channelOop;
	ioInitHeartbeat(self);
	initialEnterSmalltalkExecutive(self);
	return null;
}


/*	Answer the bytecode pc object (i.e. SmallInteger) for an active frame. The
	bytecode pc is derived from the frame's pc. If the frame is the top frame
	on the current stack
	the frame pc is whatever the current instruction pointer is. If the frame
	is the top
	frame on some other stack the frame pc is the value on top of stack.
	Otherwise the
	frame pc is the saved pc of the frame above. Once the frame pc is found it
	must be
	mapped to a bytecode pc. */

	/* StackInterpreter>>#instructionPointerForFrame:currentFP:currentIP: */
static sqInt NoDbgRegParms
instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *fp;
    sqInt index;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;

	if (spouseFP == currentFP) {
		theIP = oopForPointer(instrPtr);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(spouseFP, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		/* begin findFrameAbove:inPage: */
		fp = (thePage->headFP);
		if (fp == spouseFP) {
			theFPAbove = 0;
			goto l1;
		}
		while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
			if (callerFP == spouseFP) {
				theFPAbove = fp;
				goto l1;
			}
			fp = callerFP;
		}
		error("did not find theFP in stack page");
		theFPAbove = 0;
	l1:	/* end findFrameAbove:inPage: */;
		theIP = (theFPAbove == 0
			? longAt((thePage->headSP))
			: oopForPointer(pointerForOop(longAt(theFPAbove + FoxCallerSavedIP))));
	}
	return (assert(validInstructionPointerinFrame(theIP + 1, spouseFP, self)),
		(((usqInt)(((theIP - (longAt(spouseFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1));
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

	/* StackInterpreter>>#interpreterAllocationReserveBytes */
static sqInt NeverInline
interpreterAllocationReserveBytes(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maxFramesPerPage;
    sqInt maxUsedBytesPerPage;

	maxUsedBytesPerPage = (stackPageFrameBytes(self)) + ((FrameSlots + 64) * BytesPerWord);
	maxFramesPerPage = (maxUsedBytesPerPage / BytesPerWord) / FrameSlots;
	return ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

	/* StackInterpreter>>#ioFilename:fromString:ofLength:resolveAliases: */
void
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean, struct foo * self)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	A base frame (first frame in a stack page) is so marked by having a null
	saved fp.
 */

	/* StackInterpreter>>#isBaseFrame: */
static sqInt NoDbgRegParms
isBaseFrame(char *theFP, struct foo * self)
{
	return (longAt(theFP + FoxSavedFP)) == 0;
}

	/* StackInterpreter>>#isBooleanObject: */
sqInt
isBooleanObject(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oop == GIV(trueObj))
	 || (oop == GIV(falseObj));
}

	/* StackInterpreter>>#isFloatObject: */
sqInt
isFloatObject(sqInt oop, struct foo * self)
{
    sqInt tagBits;

	return (((tagBits = oop & (tagMask(self)))) != 0
		? tagBits == (smallFloatTag(self))
		: ((longAt(oop)) & (classIndexMask(self))) == ClassFloatCompactIndex);
}

	/* StackInterpreter>>#isFrame:onPage: */
static sqInt NoDbgRegParms
isFrameonPage(char *aFrame, StackPage *aPage, struct foo * self)
{
    char *prevFP;
    char *theFP;

	assert(!((isFree(aPage, self))));
	theFP = (aPage->headFP);
	prevFP = theFP - BytesPerWord;
	while (1) {
		if (theFP == aFrame) {
			return 1;
		}
		if (!((theFP > prevFP)
		 && (theFP < ((aPage->baseFP))))) break;
		prevFP = theFP;
		/* begin frameCallerFP: */
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	}
	return 0;
}


/*	Answer true if the oop is kind of Integer (Small or Large). */

	/* StackInterpreter>>#isKindOfInteger: */
sqInt
isKindOfInteger(sqInt oop, struct foo * self)
{
	return ((((oop) & 7) == 1))
	 || (((oop & (tagMask(self))) == 0)
	 && ((((usqInt)(((longAt(oop)) & (classIndexMask(self))) - ClassLargeNegativeIntegerCompactIndex))) <= 1));
}

	/* StackInterpreter>>#isLargeIntegerObject: */
sqInt
isLargeIntegerObject(sqInt oop, struct foo * self)
{
	/* begin isLargeIntegerInstance: */
	return ((oop & (tagMask(self))) == 0)
	 && ((((usqInt)(((longAt(oop)) & (classIndexMask(self))) - ClassLargeNegativeIntegerCompactIndex))) <= 1);
}

	/* StackInterpreter>>#isLargeNegativeIntegerObject: */
sqInt
isLargeNegativeIntegerObject(sqInt oop, struct foo * self)
{
	/* begin isInstanceOfClassLargeNegativeInteger: */
	return ((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & (classIndexMask(self))) == ClassLargeNegativeIntegerCompactIndex);
}

	/* StackInterpreter>>#isLargePositiveIntegerObject: */
sqInt
isLargePositiveIntegerObject(sqInt oop, struct foo * self)
{
	/* begin isInstanceOfClassLargePositiveInteger: */
	return ((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & (classIndexMask(self))) == ClassLargePositiveIntegerCompactIndex);
}


/*	Answer if the argument, which can be any object, is a live context. */

	/* StackInterpreter>>#isLiveContext: */
static sqInt NoDbgRegParms
isLiveContext(sqInt oop, struct foo * self)
{
	assert(!((isOopForwarded(oop, self))));
	if (!(((oop & (tagMask(self))) == 0)
		 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (isNonImmediate(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))), self)) {
		return ((((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self)))))))) & 7) == 1);
	}
	return !(isWidowedContext(oop, self));
}

	/* StackInterpreter>>#isMarriedOrWidowedContext: */
static sqInt NoDbgRegParms
isMarriedOrWidowedContext(sqInt aContext, struct foo * self)
{
	return ((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1);
}


/*	This virtual machine provides two primitives that executes arbitrary
	primitives, one
	for indexed primitivces and one for named primitives. These meta
	primitives are used
	in the debugger to execute primitives while simulating execution. Spur
	needs to know
	the accessor depth for a primitive so that failures due to forwarders can
	be fixed up
	and retried. This method identifies such meta primitives so that
	metaAccessorDepth can be substituted when appropriate. */

	/* StackInterpreter>>#isMetaPrimitiveIndex: */
static sqInt NoDbgRegParms
isMetaPrimitiveIndex(sqInt primIndex, struct foo * self)
{
	return (primIndex == PrimNumberDoPrimitive)
	 || (primIndex == PrimNumberDoExternalCall);
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

	/* StackInterpreter>>#isPrimitiveFunctionPointerAnIndex */
static sqInt
isPrimitiveFunctionPointerAnIndex(struct foo * self)
{
	return (((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex;
}

	/* StackInterpreter>>#isQuickPrimitiveIndex: */
sqInt
isQuickPrimitiveIndex(sqInt anInteger, struct foo * self)
{
	return ((anInteger >= 256) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

	/* StackInterpreter>>#isReadMediatedContextInstVarIndex: */
sqInt
isReadMediatedContextInstVarIndex(sqInt index, struct foo * self)
{
	return index <= StackPointerIndex;
}

	/* StackInterpreter>>#isSingleContext: */
static sqInt NoDbgRegParms
isSingleContext(sqInt aContext, struct foo * self)
{
    sqInt oop;

	/* begin isNonImmediate: */
	oop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	return (oop & (tagMask(self))) == 0;
}


/*	See if the argument is married to a live frame or not. i.e. see if there
	is a matching
	frame whose frameContext field is aOnceMarriedContext, or a forwarder to
	it. If aOnceMarriedContext is not married to a live frame, turn it into a
	bereaved single context.
	This version is for use during scavenging when stack references may be
	forwarded. Following what appear to be references to forwarded objects on
	the stack is dangerous;
	an instruction ponter may be correctly aligned and may point to bytes that
	just happen
	to look like a forwarder. So it is only safe to follow fields that we know
	are frameContext
	fields; hence the stack page is walked to check that aOnceMarriedContext
	is pointing to
	a live frame. This only has to happen during scavenging because after a
	become: all
	frameContext fields have been followed and so there is no need to follow
	forwarders.  */

	/* StackInterpreter>>#isWidowedContextDuringGC: */
static sqInt NoDbgRegParms
isWidowedContextDuringGC(sqInt aOnceMarriedContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt index;
    char *maybeFrame;
    sqInt maybeFrameCtxt;
    sqInt referent;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    StackPage *thePage;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert((isContext(aOnceMarriedContext, self))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext, self)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	maybeFrame = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(maybeFrame, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);
	if (!((isFree(thePage, self))
		 || (maybeFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		/* begin withoutSmallIntegerTags: */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))));
		assert((((anInteger) & 7) == 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1);
		if (((pointerForOop(longAt(maybeFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((maybeFrame + FoxFrameFlags) + 2)) != 0)) {
			/* begin frameContext: */
			maybeFrameCtxt = longAt(maybeFrame + FoxThisContext);
			if ((isFrameonPage(maybeFrame, thePage, self))
			 && (((longAt(maybeFrameCtxt)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(maybeFrameCtxt, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((maybeFrameCtxt + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent & (tagMask(self))) == 0)
				 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				maybeFrameCtxt = referent;
				/* begin setFrameContext:to: */
				longAtput(maybeFrame + FoxThisContext, maybeFrameCtxt);
			}
			if (maybeFrameCtxt == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext, self));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = GIV(nilObj);
	assert(!(isOopForwarded(aOnceMarriedContext, self)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = GIV(nilObj);
	assert(!(isOopForwarded(aOnceMarriedContext, self)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
	return 1;
}


/*	See if the argument is married to a live frame or not.
	If it is not, turn it into a bereaved single context. This version is safe
	for use
	only when no frameContext fields may be forwarded (as maybe the case
	when scavenging). Post become: all frameContext fields are followed, and
	hence nrmally no following of frameCOtext fields is necessary. But during
	a scavenge one must use isWidowedContextDuringGC:. */

	/* StackInterpreter>>#isWidowedContext: */
static sqInt NoDbgRegParms
isWidowedContext(sqInt aOnceMarriedContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt index;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert((isContext(aOnceMarriedContext, self))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext, self)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	theFrame = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);
	if (!((isFree(thePage, self))
		 || (theFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		/* begin withoutSmallIntegerTags: */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))));
		assert((((anInteger) & 7) == 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1);
		if (((pointerForOop(longAt(theFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((theFrame + FoxFrameFlags) + 2)) != 0)) {
			assert(!(((isFrameonPage(theFrame, thePage, self))
 && (isForwarded(frameContext(theFrame, self), self)))));
			if ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext, self));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = GIV(nilObj);
	assert(!(isOopForwarded(aOnceMarriedContext, self)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = GIV(nilObj);
	assert(!(isOopForwarded(aOnceMarriedContext, self)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
	return 1;
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

	/* StackInterpreter>>#isWriteMediatedContextInstVarIndex: */
sqInt
isWriteMediatedContextInstVarIndex(sqInt index, struct foo * self)
{
	return index <= ReceiverIndex;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOfClass: */
sqInt
isKindOfClass(sqInt oop, sqInt aClass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt oopClass;
    sqInt tagBits;

	/* begin fetchClassOf: */
	oopClass = (((tagBits = oop & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(oop, self));
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		/* begin followField:ofObject: */
		objOop = longAt((oopClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop & (tagMask(self))) == 0)
		 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, oopClass, objOop, self);
		}
		oopClass = objOop;
	}
	return 0;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOf: */
sqInt
isKindOf(sqInt oop, char *className, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt oopClass;
    sqInt tagBits;

	/* begin fetchClassOf: */
	oopClass = (((tagBits = oop & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(oop, self));
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className, self)) {
			return 1;
		}
		/* begin followField:ofObject: */
		objOop = longAt((oopClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop & (tagMask(self))) == 0)
		 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, oopClass, objOop, self);
		}
		oopClass = objOop;
	}
	return 0;
}


/*	Support for external primitives */

	/* StackInterpreter>>#is:MemberOf: */
sqInt
isMemberOf(sqInt oop, char *className, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oopClass;
    sqInt tagBits;

	/* begin fetchClassOf: */
	oopClass = (((tagBits = oop & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(oop, self));
	return classNameOfIs(oopClass, className, self);
}

	/* StackInterpreter>>#lengthOfNameOfClass: */
static sqInt NoDbgRegParms
lengthOfNameOfClass(sqInt classOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt objOop;

	/* begin numSlotsOf: */
	assert((classIndexOf(classOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(classOop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord(self)))))), self);
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	/* begin lengthOf: */
	objOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord(self))))));
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(objOop + 7);
	numSlots2 = (numSlots11 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt <= 5 /* ephemeronFormat */) {
		return numSlots2;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		return (numSlots2 << (shiftForWord(self))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat(self))) {
		return (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat(self))) {
		return (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		return numSlots2;
	}
	return 0;
}

	/* StackInterpreter>>#literal:ofMethod: */
sqInt
literalofMethod(sqInt offset, sqInt methodPointer, struct foo * self)
{
	/* begin fetchPointer:ofObject: */
	return longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
}


/*	self cCode: [ 
	self preInitImage.
	self createMutexLock:[self openAndReadImage: aFileLocation].
	self interpret]. */

	/* StackInterpreter>>#loadAndExecute: */
void
loadAndExecute(ThreadInterpreterParameter *threadInterpreterParameters)
{
	
	
	//Preinit
	ioInitTime();
   ioVMThread = ioCurrentOSThread();
	ioInitExternalSemaphores();
	aioInit();
	
	/*Param init*/ 
	setImageParams(threadInterpreterParameters->imageArguments);
		
	/* Open image and create globals. */
	static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
	if(pthread_mutex_lock(&mutex) == 0){
		FILE* imageFile = NULL;

   		/*Open the image file. */
   		imageFile = fopen(threadInterpreterParameters->imagePath, "rb");
   		if(!imageFile){
    		perror("Opening Image");
       	return;
    	}

    	readImageFromFileHeapSizeStartingAt(imageFile, 0, 0, threadInterpreterParameters->interpreterState);
    	fclose(imageFile);
	   /*setImageName(imageParameters[0]); */
	}
		pthread_mutex_unlock(&mutex);
		interpret(threadInterpreterParameters->interpreterState);
	
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#loadBitBltFrom: */
sqInt
loadBitBltFrom(sqInt bb, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin", self);
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

	/* StackInterpreter>>#loadInitialContext */
void
loadInitialContext(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt objOop;
    sqInt objOop1;

	runLeakCheckerFor(GCModeFull, self);
	/* begin memoryActiveProcess */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	activeContext = longAt((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))));
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext, self);
}


/*	localSP and localFP are in the scope of interpret not in GIV */

	/* StackInterpreter>>#lockFetchNextBytecode */
static void
lockFetchNextBytecode(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	
	mutexLockandCond(&GIV(mutexForFetchBytecode), &GIV(step));
	
}

	/* StackInterpreter>>#longPrintOop: */
void
longPrintOop(sqInt oop, struct foo * self)
{
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt class;
    sqInt column;
    unsigned short field16;
    unsigned int field32;
    usqLong field64;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt lastIndex;
    sqInt len;
    usqInt n;
    usqInt n1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt startIP;

	if ((oop & (tagMask(self)))
	 || ((!(addressCouldBeObj(oop, self)))
	 || (((oop & (8 /* allocationUnit */ - 1)) != 0)
	 || ((((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)))
	 || (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))))) {
		printOop(oop, self);
		return;
	}
	printHex(oop, self);
	class = fetchClassOfNonImm(oop, self);
	if (class == null) {
		print(" has a nil class!!", self);
	}
	else {
		print(": a(n) ", self);
		printNameOfClasscount(class, 5, self);
		print(" (", self);
		/* begin printHexnp: */
		n = (longAt(oop)) & (classIndexMask(self));
		printf("0x%" PRIxSQINT "", n);
		print("=>", self);
		printf("0x%" PRIxSQINT "", class);
		print(")", self);
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	print(" format ", self);
	printf("0x%" PRIxSQINT "", fmt);
	if (fmt > 5 /* lastPointerFormat */) {
		print(" nbytes ", self);
		printNum(numBytesOf(oop, self), self);
	}
	else {
		if ((fmt >= 2 /* arrayFormat */)
		 && ((fmt <= (weakArrayFormat(self)))
		 || (fmt >= (sixtyFourBitIndexableFormat(self))))) {
			/* begin lengthOf:format: */
			fmt1 = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
			/* begin numSlotsOfAny: */
			numSlots1 = byteAt(oop + 7);
			numSlots = (numSlots1 == (numSlotsMask(self))
				? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots1);
			if (fmt1 <= 5 /* ephemeronFormat */) {
				len = numSlots;
				goto l8;
			}
			if (fmt1 >= (firstByteFormat(self))) {

				/* bytes, including CompiledMethod */
				len = (numSlots << (shiftForWord(self))) - (fmt1 & 7);
				goto l8;
			}
			if (fmt1 >= (firstShortFormat(self))) {
				len = (numSlots << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
				goto l8;
			}
			if (fmt1 >= (firstLongFormat(self))) {
				len = (numSlots << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
				goto l8;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
				len = numSlots;
				goto l8;
			}
			len = 0;
	l8:	/* end lengthOf:format: */;
			print(" size ", self);
			printNum(len - (fixedFieldsOfformatlength(oop, fmt, len, self)), self);
		}
	}
	printHeaderTypeOf(oop, self);
	print(" hash ", self);
	/* begin printHexnp: */
	n1 = (long32At(oop + 4)) & (identityHashHalfWordMask(self));
	printf("0x%" PRIxSQINT "", n1);
	/* begin cr */
	printf("\n");
	if (((fmt >= (firstByteFormat(self))) && (fmt <= ((firstCompiledMethodFormat(self)) - 1)))) {
		printStringOf(oop, self);
		/* begin cr */
		printf("\n");
		return;
	}
	if (((fmt >= (firstLongFormat(self))) && (fmt <= ((firstByteFormat(self)) - 1)))) {
		for (i = 0, iLimiT = (((((((usqInt) (numBytesOf(oop, self))) >> 2) < 256) ? (((usqInt) (numBytesOf(oop, self))) >> 2) : 256)) - 1); i <= iLimiT; i += 1) {
			/* begin fetchLong32:ofObject: */
			field32 = ((sqInt) (long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 2))))));
			/* begin space */
			putchar(' ');
			printNum(i, self);
			/* begin space */
			putchar(' ');
			printHex(field32, self);
			/* begin space */
			putchar(' ');
			/* begin cr */
			printf("\n");
		}
		return;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		for (i = 0, iLimiT = (((((((usqInt) (numBytesOf(oop, self))) >> 3) < 256) ? (((usqInt) (numBytesOf(oop, self))) >> 3) : 256)) - 1); i <= iLimiT; i += 1) {
			/* begin fetchLong64:ofObject: */
			field64 = long64At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 3))));
			/* begin space */
			putchar(' ');
			printNum(i, self);
			/* begin space */
			putchar(' ');
			printHex(field64, self);
			/* begin space */
			putchar(' ');
			/* begin cr */
			printf("\n");
		}
		return;
	}
	if (((fmt >= (firstShortFormat(self))) && (fmt <= ((firstShortFormat(self)) + 1)))) {
		for (i = 0, iLimiT = (((((((usqInt) (numBytesOf(oop, self))) >> 1) < 256) ? (((usqInt) (numBytesOf(oop, self))) >> 1) : 256)) - 1); i <= iLimiT; i += 1) {
			/* begin fetchShort16:ofObject: */
			field16 = shortAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 1))));
			/* begin space */
			putchar(' ');
			printNum(i, self);
			/* begin space */
			putchar(' ');
			printHex(field16, self);
			/* begin space */
			putchar(' ');
			/* begin cr */
			printf("\n");
		}
		return;
	}
	startIP = (((lastPointerOf(oop, self)) + BytesPerOop) - BaseHeaderSize) / BytesPerOop;
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			/* begin fetchPointer:ofObject: */
			fieldOop = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((i - 1)) << (shiftForWord(self))))));
			/* begin space */
			putchar(' ');
			printNum(i - 1, self);
			/* begin space */
			putchar(' ');
			printHex(fieldOop, self);
			/* begin space */
			putchar(' ');
			if ((i == 1)
			 && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))) {
				/* begin printMethodHeaderOop: */
				printOopShort(fieldOop, self);
				if ((/* begin alternateHeaderHasPrimitiveFlag: */
				fieldOop & AlternateHeaderHasPrimFlag)) {
					print(" hasPrim", self);
				}
				if ((fieldOop & LargeContextBit) != 0) {
					print(" largeFrame", self);
				}
				if (((fieldOop >> 3)) < 0) {
					print(" altSet", self);
				}
				print(" nLits ", self);
				printNum((assert((((fieldOop) & 7) == 1)),
				((fieldOop >> 3)) & AlternateHeaderNumLiteralsMask), self);
				print(" nArgs ", self);
				printNum((((usqInt) fieldOop) >> MethodHeaderArgCountShift) & 15, self);
				print(" nTemps ", self);
				printNum((((usqInt) fieldOop) >> MethodHeaderTempCountShift) & 0x3F, self);
				/* return self */
			}
			else {
				printOopShort(fieldOop, self);
			}
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf:format: */
		fmt2 = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
		/* begin numSlotsOfAny: */
		numSlots11 = byteAt(oop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots11);
		if (fmt2 <= 5 /* ephemeronFormat */) {
			lastIndex = numSlots2;
			goto l10;
		}
		if (fmt2 >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			lastIndex = (numSlots2 << (shiftForWord(self))) - (fmt2 & 7);
			goto l10;
		}
		if (fmt2 >= (firstShortFormat(self))) {
			lastIndex = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt2 & 3);
			goto l10;
		}
		if (fmt2 >= (firstLongFormat(self))) {
			lastIndex = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt2 & 1);
			goto l10;
		}
		if (fmt2 == (sixtyFourBitIndexableFormat(self))) {
			lastIndex = numSlots2;
			goto l10;
		}
		lastIndex = 0;
	l10:	/* end lengthOf:format: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08" PRIxSQPTR ": ", (usqIntptr_t)(oop+BaseHeaderSize+index-1));
			}
			/* begin fetchByte:ofObject: */
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", (int)byte,(int)byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > lastIndex) {
			print("...", self);
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#longStoreBytecodeForHeader: */
sqInt
longStoreBytecodeForHeader(sqInt methodHeader, struct foo * self)
{
	return 
#  if MULTIPLEBYTECODESETS
		((((sqLong) methodHeader)) < 0
				? AltLongStoreBytecode
				: LongStoreBytecode)
#  else /* MULTIPLEBYTECODESETS */
		LongStoreBytecode
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and classTag is found in the cache, set the values of
	'newMethod' and
	'primitiveFunctionPointer' and answer true. Otherwise, answer false. */

	/* StackInterpreter>>#lookupInMethodCacheSel:classTag: */
static sqInt NoDbgRegParms
lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;

	/* begin inlineLookupInMethodCacheSel:classTag: */
	hash = selector ^ (((sqInt)((usqInt)(classTag) << 2)));

	/* first probe */
	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		GIV(primitiveFunctionPointer) = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */
	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		GIV(primitiveFunctionPointer) = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		GIV(primitiveFunctionPointer) = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

	/* StackInterpreter>>#lookupMethodInClass: */
static sqInt NoDbgRegParms
lookupMethodInClass(sqInt class, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt index;
    usqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt selector;
    sqInt wrapAround;

	assert(addressCouldBeClassObj(class, self));
	/* begin lookupBreakFor: */
	if ((breakLookupClassTag != null)
	 && ((class == breakLookupClassTag)
	 || (((long32At(class + 4)) & (identityHashHalfWordMask(self))) == breakLookupClassTag))) {
		warning("lookup class send break (heartbeat suppressed)");
	}
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))));
		assert(isNonImmediate(objOop, self));
		if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop, self);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {

			/* MethodDict pointer is nil (hopefully due a swapped out stub)
			   -- raise exception #cannotInterpret:. */
			createActualMessageTo(class, self);
			/* begin splObj: */
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotInterpret) << (shiftForWord(self))))));
			/* begin sendBreakpoint:receiver: */
			selector = GIV(messageSelector);
			sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector, self), lengthOfMaybeImmediate(selector, self), null, self);
			return lookupMethodInClass(followFieldofObject(SuperclassIndex, currentClass, self), self);
		}
		/* begin lookupMethodInDictionary: */
		assert((classIndexOf(dictionary, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				/* begin fetchPointer:ofObject: */
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)((index + SelectorStart)) << (shiftForWord(self))))));
				if (((nextSelector & (tagMask(self))) == 0)
				 && (((longAt(nextSelector)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector, self);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop4 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
					assert(isNonImmediate(objOop4, self));
					if (((longAt(objOop4)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						objOop4 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop4, self);
					}
					methodArray = objOop4;
					/* begin followField:ofObject: */
					objOop11 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
					if (((objOop11 & (tagMask(self))) == 0)
					 && (((longAt(objOop11)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop11 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop11, self);
					}
					GIV(newMethod) = objOop11;
					found = 1;
					goto l18;
				}
				index += 1;
			}
			found = 0;
			goto l18;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((GIV(messageSelector) & (tagMask(self))
	? (GIV(messageSelector) >> 3)
	: (long32At(GIV(messageSelector) + 4)) & (identityHashHalfWordMask(self)))));
		wrapAround = 0;
		while (1) {
			/* begin fetchPointer:ofObject: */
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l18;
			}
			if (((nextSelector & (tagMask(self))) == 0)
			 && (((longAt(nextSelector)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector, self);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
				assert(isNonImmediate(objOop2, self));
				if (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2, self);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop3 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord(self))))));
				if (((objOop3 & (tagMask(self))) == 0)
				 && (((longAt(objOop3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop3, self);
				}
				GIV(newMethod) = objOop3;
				found = 1;
				goto l18;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l18;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l18:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		/* begin followField:ofObject: */
		objOop1 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop1 & (tagMask(self))) == 0)
		 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1, self);
		}
		currentClass = objOop1;
	}
	if (GIV(messageSelector) == (splObj(SelectorDoesNotUnderstand, self))) {
		error("Recursive not understood error encountered");
	}
	createActualMessageTo(class, self);
	/* begin splObj: */
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord(self))))));
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOfformat(GIV(messageSelector), (((usqInt) (longAt(GIV(messageSelector)))) >> (formatShift(self))) & (formatMask(self)), self), null, self);
	return lookupMethodInClass(class, self);
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

	/* StackInterpreter>>#lookupOrdinaryNoMNUEtcInClass: */
static sqInt NoDbgRegParms
lookupOrdinaryNoMNUEtcInClass(sqInt class, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt index;
    usqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;

	/* begin lookupBreakFor: */
	if ((breakLookupClassTag != null)
	 && ((class == breakLookupClassTag)
	 || (((long32At(class + 4)) & (identityHashHalfWordMask(self))) == breakLookupClassTag))) {
		warning("lookup class send break (heartbeat suppressed)");
	}
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop1 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))));
		assert(isNonImmediate(objOop1, self));
		if (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop1, self);
		}
		dictionary = objOop1;
		if (dictionary == GIV(nilObj)) {
			/* begin followField:ofObject: */
			objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
			if (((objOop & (tagMask(self))) == 0)
			 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop, self);
			}
			GIV(lkupClass) = objOop;
			return SelectorCannotInterpret;
		}
		/* begin lookupMethodInDictionary: */
		assert((classIndexOf(dictionary, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				/* begin fetchPointer:ofObject: */
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)((index + SelectorStart)) << (shiftForWord(self))))));
				if (((nextSelector & (tagMask(self))) == 0)
				 && (((longAt(nextSelector)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector, self);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop4 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
					assert(isNonImmediate(objOop4, self));
					if (((longAt(objOop4)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						objOop4 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop4, self);
					}
					methodArray = objOop4;
					/* begin followField:ofObject: */
					objOop11 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
					if (((objOop11 & (tagMask(self))) == 0)
					 && (((longAt(objOop11)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop11 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop11, self);
					}
					GIV(newMethod) = objOop11;
					found = 1;
					goto l16;
				}
				index += 1;
			}
			found = 0;
			goto l16;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((GIV(messageSelector) & (tagMask(self))
	? (GIV(messageSelector) >> 3)
	: (long32At(GIV(messageSelector) + 4)) & (identityHashHalfWordMask(self)))));
		wrapAround = 0;
		while (1) {
			/* begin fetchPointer:ofObject: */
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l16;
			}
			if (((nextSelector & (tagMask(self))) == 0)
			 && (((longAt(nextSelector)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector, self);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
				assert(isNonImmediate(objOop2, self));
				if (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2, self);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop3 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord(self))))));
				if (((objOop3 & (tagMask(self))) == 0)
				 && (((longAt(objOop3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop3, self);
				}
				GIV(newMethod) = objOop3;
				found = 1;
				goto l16;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l16;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l16:	/* end lookupMethodInDictionary: */;
		if (found) {
			addNewMethodToCache(class, self);
			return 0;
		}
		/* begin followField:ofObject: */
		objOop5 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop5 & (tagMask(self))) == 0)
		 && (((longAt(objOop5)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop5 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop5, self);
		}
		currentClass = objOop5;
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Lookup selector in class. Answer the method or nil. This is a debugging
	routine. It does /not/ side-effect lookupClass or newMethod. */

	/* StackInterpreter>>#lookupSelector:inClass: */
sqInt
lookupSelectorinClass(sqInt selector, sqInt class, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt index;
    usqInt length;
    sqInt mask;
    sqInt meth;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))));
		assert(isNonImmediate(objOop, self));
		if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop, self);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {
			return null;
		}
		/* begin lookupMethodFor:InDictionary: */
		assert((classIndexOf(dictionary, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		mask = (length - SelectorStart) - 1;

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((selector & (tagMask(self))
	? (selector >> 3)
	: (long32At(selector + 4)) & (identityHashHalfWordMask(self)))));
		wrapAround = 0;
		while (1) {
			/* begin fetchPointer:ofObject: */
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
			if (nextSelector == GIV(nilObj)) {
				meth = null;
				goto l8;
			}
			if (((nextSelector & (tagMask(self))) == 0)
			 && (((longAt(nextSelector)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector, self);
			}
			if (nextSelector == selector) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
				assert(isNonImmediate(objOop2, self));
				if (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2, self);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop1 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord(self))))));
				if (((objOop1 & (tagMask(self))) == 0)
				 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop1, self);
				}
				meth = objOop1;
				goto l8;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					meth = null;
					goto l8;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		meth = null;
	l8:	/* end lookupMethodFor:InDictionary: */;
		if (!(meth == null)) {
			return meth;
		}
		/* begin followField:ofObject: */
		objOop3 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
		if (((objOop3 & (tagMask(self))) == 0)
		 && (((longAt(objOop3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop3 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop3, self);
		}
		currentClass = objOop3;
	}
	return null;
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. */

	/* StackInterpreter>>#makeBaseFrameFor: */
static StackPage * NoDbgRegParms
makeBaseFrameFor(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    StackPage *lruOrFree;
    sqInt maybeClosure;
    sqInt numArgs;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt oop1;
    StackPage *page;
    char *pointer;
    sqInt rcvr;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	assert(isContext(aContext, self));
	assert(isSingleContext(aContext, self));
	assert(goodContextSize(aContext, self));
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		page = lruOrFree;
		goto l4;
	}
	divorceFramesIn(lruOrFree, self);
	page = lruOrFree;
	l4:	/* end newStackPage */;
	pointer = (page->baseAddress);
	/* begin fetchPointer:ofObject: */
	theIP = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))));
	/* begin followObjField:ofObject: */
	objOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
	assert(isNonImmediate(objOop, self));
	if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		objOop = fixFollowedFieldofObjectwithInitialValue(MethodIndex, aContext, objOop, self);
	}
	theMethod = objOop;
	if (!((((theIP) & 7) == 1))) {
		error("context is not resumable");
	}
	theIP = (theIP >> 3);
	/* begin followField:ofObject: */
	objOop1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord(self))))));
	if (((objOop1 & (tagMask(self))) == 0)
	 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, aContext, objOop1, self);
	}
	rcvr = objOop1;
	/* begin fetchPointer:ofObject: */
	maybeClosure = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord(self))))));
	if (maybeClosure != GIV(nilObj)) {
		if (((longAt(maybeClosure)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
			maybeClosure = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, aContext, maybeClosure, self);
		}
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))));
		assert((((oop) & 7) == 1));
		numArgs = (oop >> 3);
		longAtput(pointer, maybeClosure);
	}
	else {
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(theMethod, self));
		/* begin fetchPointer:ofObject: */
		header = longAt((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		/* begin argumentCountOfMethodHeader: */
		numArgs = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
		if (((/* begin alternateHeaderHasPrimitiveFlag: */
		header & AlternateHeaderHasPrimFlag))
		 && (theIP == (1 + ((((assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop)))) {
			theIP += 3;
		}
		longAtput(pointer, rcvr);
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord(self)))))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		assert(!(isOopForwarded(aContext, self)));
		longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord(self))))), valuePointer);
	}
	longAtput((pointer -= BytesPerWord), followObjFieldofObject(SenderIndex, aContext, self));
	longAtput((pointer -= BytesPerWord), 0);
	(page->baseFP = pointer);
	(page->headFP = pointer);
	longAtput((pointer -= BytesPerWord), theMethod);
	longAtput((pointer -= BytesPerWord), (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (1ULL << ((BytesPerWord * 8) - 16))) + ((maybeClosure != GIV(nilObj)
	? 1ULL << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (1U << 16)) + ((maybeClosure != GIV(nilObj)
	? 1U << 24
	: 0))));
	assert(frameHasContext((page->baseFP), self));
	assert((frameNumArgs((page->baseFP), self)) == numArgs);
	longAtput((pointer -= BytesPerWord), aContext);
	longAtput((pointer -= BytesPerWord), rcvr);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
	assert((((oop1) & 7) == 1));
	stackPtrIndex = (oop1 >> 3);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext, self)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord(self)))))));
	}
	/* begin iframeInstructionPointerForIndex:method: */
	assert(((theIP >= (((LiteralStart + (literalCountOf(theMethod, self))) * BytesPerOop) + 1)) && (theIP <= (lengthOf(theMethod, self)))));
	theIP = ((theMethod + theIP) + BaseHeaderSize) - 2;
	longAtput((pointer -= BytesPerWord), theIP);
	(page->headSP = pointer);
	assert(contexthasValidInversePCMappingOfin(aContext, theIP, (page->baseFP), self));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(((oopForPointer((page->baseFP))) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer((page->baseFP))) + (smallIntegerTag(self));
	assert(!(isOopForwarded(aContext, self)));
	longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0);
	valuePointer2 = (oopForPointer(0)) + (smallIntegerTag(self));
	assert(!(isOopForwarded(aContext, self)));
	longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer2);
	assert(((((fetchPointerofObject(SenderIndex, aContext, self))) & 7) == 1));
	assert((frameOfMarriedContext(aContext, self)) == ((page->baseFP)));
	assert(validStackPageBaseFrame(page, self));
	return page;
}


/*	Convert married contexts to widowed contexts, and in the CoInterpreter,
	map any machine code pcs to bytecode pcs, and then nil all slots beyond
	top of stack, so that the context can be resumed on any VM. */

	/* StackInterpreter>>#makeContextSnapshotSafe: */
static void NoDbgRegParms
makeContextSnapshotSafe(sqInt ctxt, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	assert(isContext(ctxt, self));
	if (((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
		/* begin markContextAsDead: */
		assert(isContext(ctxt, self));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer2 = GIV(nilObj);
		assert(!(isOopForwarded(ctxt, self)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer2);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		assert(!(isOopForwarded(ctxt, self)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
	}
	else {
	}
	for (i = ((fetchStackPointerOf(ctxt, self)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(ctxt, self)) - 1); i <= iLimiT; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		assert(!(isOopForwarded(ctxt, self)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
	}
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed */

	/* StackInterpreter>>#makePointwithxValue:yValue: */
usqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    usqInt pointResult;

	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord(self))))));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj, self)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask(self));
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3))) >> (fixedFieldsFieldWidth(self))) & (formatMask(self));
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex, self)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l3;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
	l3:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord(self))))), (((usqInt)xValue << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult, self)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord(self))))), (((usqInt)yValue << 3) | 1));
	return pointResult;
}


/*	Map all oops in the interpreter's state to their new values 
	during garbage collection or a become: operation. */
/*	Assume: All traced variables contain valid oops. */

	/* StackInterpreter>>#mapInterpreterOops */
static void
mapInterpreterOops(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt oop;

	mapStackPages(self);
	/* begin mapVMRegisters */
	if (shouldRemapObj(GIV(method), self)) {

		/* *rel to method */
		GIV(instructionPointer) -= GIV(method);
		GIV(method) = remapObj(GIV(method), self);
		GIV(instructionPointer) += GIV(method);
	}
	if (((GIV(newMethod) & (tagMask(self))) == 0)
	 && (shouldRemapObj(GIV(newMethod), self))) {

		/* maybe oop due to object-as-method */
		GIV(newMethod) = remapObj(GIV(newMethod), self);
	}
	/* begin mapProfileState */
	if (shouldRemapObj(GIV(profileProcess), self)) {
		GIV(profileProcess) = remapObj(GIV(profileProcess), self);
	}
	if (shouldRemapObj(GIV(profileMethod), self)) {
		GIV(profileMethod) = remapObj(GIV(profileMethod), self);
	}
	if (shouldRemapObj(GIV(profileSemaphore), self)) {
		GIV(profileSemaphore) = remapObj(GIV(profileSemaphore), self);
	}
	sqLowLevelMFence(self);
	if (GIV(longRunningPrimitiveCheckMethod)) {
		if (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)) {
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
		}
		else {
			if (shouldRemapObj(GIV(longRunningPrimitiveCheckMethod), self)) {
				GIV(longRunningPrimitiveCheckMethod) = remapObj(GIV(longRunningPrimitiveCheckMethod), self);
			}
		}
		sqLowLevelMFence(self);
	}
	if (GIV(longRunningPrimitiveCheckSemaphore)) {
		if (shouldRemapObj(GIV(longRunningPrimitiveCheckSemaphore), self)) {
			GIV(longRunningPrimitiveCheckSemaphore) = remapObj(GIV(longRunningPrimitiveCheckSemaphore), self);
		}
	}
	/* begin remapCallbackState */
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		oop = GIV(suspendedCallbacks)[i];
		if (((oop & (tagMask(self))) == 0)
		 && (shouldRemapObj(oop, self))) {
			GIV(suspendedCallbacks)[i] = (remapObj(oop, self));
		}
		oop = GIV(suspendedMethods)[i];
		if (shouldRemapObj(oop, self)) {
			GIV(suspendedMethods)[i] = (remapObj(oop, self));
		}
	}
	if ((GIV(tempOop) != 0)
	 && (((GIV(tempOop) & (tagMask(self))) == 0)
	 && (shouldRemapObj(GIV(tempOop), self)))) {
		GIV(tempOop) = remapObj(GIV(tempOop), self);
	}
	if ((GIV(tempOop2) != 0)
	 && (((GIV(tempOop2) & (tagMask(self))) == 0)
	 && (shouldRemapObj(GIV(tempOop2), self)))) {
		GIV(tempOop2) = remapObj(GIV(tempOop2), self);
	}
}

	/* StackInterpreter>>#mapStackPages */
static void NeverInline
mapStackPages(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt numLivePages;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	theIP = 0;
	numLivePages = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage, self));
			numLivePages += 1;
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = 0;
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP, self));
				assert(addressIsInPage(thePage, theSP, self));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr, self)));
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & (tagMask(self))) == 0)
					 && (shouldRemapObj(oop, self))) {
						longAtput(theSP, remapObj(oop, self));
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					if (shouldRemapObj(longAt(theFP + FoxThisContext), self)) {
						longAtput(theFP + FoxThisContext, remapObj(longAt(theFP + FoxThisContext), self));
					}
					if (!(GIV(gcPhaseInProgress) == SlidingCompactionInProgress)) {
						assert((isMarriedOrWidowedContext(frameContext(theFP, self), self))
						 && ((frameOfMarriedContext(frameContext(theFP, self), self)) == theFP));
					}
				}
				if (shouldRemapObj(longAt(theFP + FoxMethod), self)) {
					if (theIPPtr != 0) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP, self)));
						theIP = (longAt(theIPPtr)) - (longAt(theFP + FoxMethod));
					}
					longAtput(theFP + FoxMethod, remapObj(longAt(theFP + FoxMethod), self));
					if (theIPPtr != 0) {
						longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerSavedIP */
			theSP = theFP + FoxCallerContext;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & (tagMask(self))) == 0)
				 && (shouldRemapObj(oop, self))) {
					longAtput(theSP, remapObj(oop, self));
				}
				theSP += BytesPerWord;
			}
		}
	}
	/* begin recordLivePagesOnMapping: */
	GIV(statNumMaps) += 1;
	GIV(statPageCountWhenMappingSum) += numLivePages;
	GIV(statMaxPageCountWhenMapping) = ((GIV(statMaxPageCountWhenMapping) < numLivePages) ? numLivePages : GIV(statMaxPageCountWhenMapping));
}


/*	GC of pages. Throwing away all stack pages on full GC is simple but
	dangerous because it causes us to allocate lots of contexts immediately
	before a GC.
	Reclaiming pages whose top context is not referenced is poor because it
	would take N incrementalGCs to reclaim N unused pages. Only the page whose
	top context is not referred to by the bottom context of any other page
	would be
	reclaimed. Not until the next GC would the page whose top contect is the
	previously reclaimed page's base frame's bottom context be reclaimed.
	
	Better is to not mark stack pages until their contexts are encountered. We
	can eagerly trace the active page and the page reachable from its bottom
	context if any, and so on. Other pages can be marked when we encounter a
	married context. */

	/* StackInterpreter>>#markAndTraceStackPages: */
static sqInt NoDbgRegParms
markAndTraceStackPages(sqInt fullGCFlag, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt i;
    sqInt index;
    void *pointer;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages), self);
			if (!(isFree(thePage, self))) {
				markAndTraceStackPage(thePage, self);
			}
		}
		return null;
	}
	if (GIV(stackPage) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	do {
		markAndTraceStackPage(thePage, self);
		/* begin frameCallerContext: */
		theFP = (thePage->baseFP);
		context = longAt(theFP + FoxCallerContext);
		if ((((context & (tagMask(self))) == 0)
		 && (((longAt(context)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))
		 && ((((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && ((((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(context, self)))))) {
			/* begin stackPageFor: */
			senderOop = longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
			assert((((senderOop) & 7) == 1));
			pointer = pointerForOop(senderOop - 1);
			/* begin stackPageAt: */
			index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage), self);
			thePage = stackPageAtpages(index, GIV(pages), self);
			assert(!(isFree(thePage, self)));
		}
	} while(((thePage->trace)) < StackPageTraced);
	return 0;
}

	/* StackInterpreter>>#markAndTraceStackPage: */
static void NoDbgRegParms
markAndTraceStackPage(StackPage *thePage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt oop;
    sqInt referent;
    sqInt referent1;
    char *theFP;
    char *theSP;

	assert(!(isFree(thePage, self)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage, self));
	assert(((thePage->trace)) != StackPageTraced);
	(thePage->trace = StackPageTraced);
	theSP = (thePage->headSP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		/* begin frameReceiverLocation: */
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (((oop & (tagMask(self))) == 0)
			 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent & (tagMask(self))) == 0)
				 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				oop = referent;
				longAtput(theSP, oop);
			}
			if (!(oop & (tagMask(self)))) {
				markAndTrace(oop, self);
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP, self), self));
			markAndTrace(longAt(theFP + FoxThisContext), self);
		}
		markAndTrace(longAt(theFP + FoxMethod), self);
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (((oop & (tagMask(self))) == 0)
		 && (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent1 = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent1 & (tagMask(self))) == 0)
			 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			oop = referent1;
			longAtput(theSP, oop);
		}
		if (!(oop & (tagMask(self)))) {
			markAndTrace(oop, self);
		}
		theSP += BytesPerWord;
	}
}


/*	Trace any untraced pages */

	/* StackInterpreter>>#markAndTraceUntracedReachableStackPages */
static void
markAndTraceUntracedReachableStackPages(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundToBeTracedPage;
    sqInt i;
    StackPage *thePage;

	do {
		foundToBeTracedPage = 0;
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages), self);
			if ((!(isFree(thePage, self)))
			 && (((thePage->trace)) == StackPageReachedButUntraced)) {
				foundToBeTracedPage = 1;
				markAndTraceStackPage(thePage, self);
			}
		}
	} while(foundToBeTracedPage);
}


/*	This is a helper for primitiveObjectPointsTo so it *does not* check the
	frameContext field because that is an implicit self-reference not present
	in the state .
 */

	/* StackInterpreter>>#marriedContext:pointsTo:stackDeltaForCurrentFrame: */
static sqInt NoDbgRegParms
marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *rcvrOffset;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	/* begin frameOfMarriedContext: */
	senderOop = longAt((spouseContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	theFP = pointerForOop(senderOop - 1);
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer) + (stackDeltaForCurrentFrame * BytesPerWord);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		theSP = findSPOfon(theFP, thePage, self);
	}
	if ((((anOop) & 7) == 1)) {

		/* Check stack and instruction pointer fields. */
		if ((anOop == ((((usqInt)((((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord(self))) + (byteAt((theFP + FoxFrameFlags) + 1))) << 3) | 1)))
		 || (anOop == (externalInstVarofContext(InstructionPointerIndex, spouseContext, self)))) {
			return 1;
		}
	}
	else {

		/* Check method and sender fields, avoiding unnecessarily reifying sender context. */
		if (anOop == (longAt(theFP + FoxMethod))) {
			return 1;
		}
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			if (anOop == (longAt(theFP + FoxCallerContext))) {
				return 1;
			}
		}
		else {
			if (((byteAt(((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxFrameFlags) + 2)) != 0)
			 && (anOop == (longAt((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxThisContext)))) {
				return 1;
			}
		}
	}
	/* begin frameReceiverLocation: */
	rcvrOffset = theFP + FoxReceiver;
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	rcvrOffset = theFP + (frameStackedReceiverOffset(theFP, self));
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	return 0;
}


/*	Establish aContext at the base of a new stackPage, make the stackPage the
	active one and set-up the interreter registers. This is used to boot the
	system and bring it back after a snapshot. */

	/* StackInterpreter>>#marryContextInNewStackPageAndInitializeInterpreterRegisters: */
static void NoDbgRegParms
marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    StackPage *newPage;
    sqInt top;

	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(aContext, self);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage, self);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	/* begin setMethod: */
	aMethodObj = longAt(((GIV(stackPage)->headFP)) + FoxMethod);
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
}


/*	Marry an unmarried frame. This means creating a spouse context
	initialized with a subset of the frame's state (state through the last
	argument) that references the frame. */

	/* StackInterpreter>>#marryFrame:SP: */
static sqInt NoDbgRegParms
marryFrameSP(char *theFP, char *theSP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;
    sqInt i;
    sqInt methodHeader;
    sqInt methodObj;
    sqInt numArgs;
    sqInt numSlots;
    sqInt numStack;
    sqInt theContext;
    char *value;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;
    sqInt valuePointer4;
    sqInt valuePointer5;

	/* begin marryFrame:SP:copyTemps: */
	assert(!(frameHasContext(theFP, self)));
	assert(addressCouldBeOop(longAt(theSP), self));
	/* begin methodHeaderOf: */
	methodObj = longAt(theFP + FoxMethod);
	assert(isCompiledMethod(methodObj, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	/* begin frameNumArgs: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	numStack = (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord(self))) + (byteAt((theFP + FoxFrameFlags) + 1));
	if ((byteAt((theFP + FoxFrameFlags) + 3)) != 0) {
		closureOrNil = longAt(theFP + (frameStackedReceiverOffset(theFP, self)));
	}
	else {
		/* begin nilObject */
		closureOrNil = GIV(nilObj);
	}
	numSlots = ((methodHeader & LargeContextBit) != 0
		? LargeContextSlots
		: SmallContextSlots);
	theContext = allocateNewSpaceSlotsformatclassIndex(numSlots, indexablePointersFormat(self), ClassMethodContextCompactIndex, self);
	assert((numStack + ReceiverIndex) <= numSlots);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(((oopForPointer(theFP)) & (BytesPerWord - 1)) == 0);
	valuePointer2 = (oopForPointer(theFP)) + (smallIntegerTag(self));
	assert(!(isOopForwarded(theContext, self)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	value = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer3 = (oopForPointer(value)) + (smallIntegerTag(self));
	assert(!(isOopForwarded(theContext, self)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer3);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext, self)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))), (((usqInt)numStack << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer4 = longAt(theFP + FoxMethod);
	assert(!(isOopForwarded(theContext, self)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))), valuePointer4);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext, self)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord(self))))), closureOrNil);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer5 = longAt(theFP + FoxReceiver);
	assert(!(isOopForwarded(theContext, self)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord(self))))), valuePointer5);
	for (i = 1; i <= numArgs; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(theContext, self)));
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord(self))))), longAt((theFP + FoxCallerSavedIP) + (((numArgs - i) + 1) * BytesPerWord)));
	}
	for (i = (numArgs + 1); i <= numStack; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		assert(!(isOopForwarded(theContext, self)));
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord(self))))), valuePointer1);
	}
	/* begin setFrameContext:to: */
	longAtput(theFP + FoxThisContext, theContext);
	/* begin setFrameHasContext: */
	byteAtput((theFP + FoxFrameFlags) + 2, 1);
	assert(frameHasContext(theFP, self));
	assert((frameOfMarriedContext(theContext, self)) == theFP);
	assert((numStack + ReceiverIndex) < (lengthOf(theContext, self)));
	return theContext;
}


/*	Assert-only check for leaks after external prim calls if checkForLeaks
	includes the GCCheckPrimCall flag.
	This is ionly really useful from a low-level C debugger, hence no
	accessors for checkedPluginName.
 */

	/* StackInterpreter>>#maybeLeakCheckExternalPrimCall: */
static sqInt NoDbgRegParms
maybeLeakCheckExternalPrimCall(sqInt aMethodObj, struct foo * self)
{
	if ((checkForLeaks & GCCheckPrimCall)
	 && (((primitiveIndexOfMethodheader(aMethodObj, methodHeaderOf(aMethodObj, self), self)) == PrimNumberExternalCall)
	 && (checkedPluginName == (fetchPointerofObject(0, literalofMethod(0, aMethodObj, self), self))))) {
		runLeakCheckerFor(GCCheckPrimCall, self);
	}
	return 1;
}


/*	Answer the selector of a method, assuming its penultimate literal is
	either a symbol or a pointer object whose first slot references the method
	and whose second slot is a symbol (i.e. an AdditionalMethodState). If a
	Symbol can't be found answer nil. This isn't satisfactory, as it puts a
	lot of information
	into the VM, but it is needed for adequate crash debugging at Cadence.
	With full blocks as of 9/2016 the last literal of a CompiledBlock is a
	back pointer
	to the enclosing block or compiled method. */

	/* StackInterpreter>>#maybeSelectorOfMethod: */
sqInt
maybeSelectorOfMethod(sqInt methodObj, struct foo * self)
{
    sqInt maybeSelector;
    sqInt offset;
    sqInt offset1;
    sqInt penultimateLiteral;
    sqInt ultimateLiteral;

	assert(isOopCompiledMethod(methodObj, self));
	assert(isOopCompiledMethod(methodObj, self));
	/* begin literal:ofMethod: */
	offset = (literalCountOf(methodObj, self)) - 1;
	/* begin fetchPointer:ofObject: */
	ultimateLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
	if (((ultimateLiteral & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(ultimateLiteral))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))) {
		return maybeSelectorOfMethod(ultimateLiteral, self);
	}
	assert(isOopCompiledMethod(methodObj, self));
	/* begin literal:ofMethod: */
	offset1 = (literalCountOf(methodObj, self)) - 2;
	/* begin fetchPointer:ofObject: */
	penultimateLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset1 + LiteralStart)) << (shiftForWord(self))))));
	if (((penultimateLiteral & (tagMask(self))) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(penultimateLiteral))) >> (formatShift(self))) & (formatMask(self)), self))) {
		return ((fetchClassTagOfNonImm(penultimateLiteral, self)) == (fetchClassTagOfNonImm(splObj(SelectorDoesNotUnderstand, self), self))
			? penultimateLiteral
			: 0);
	}
	return ((((penultimateLiteral & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(penultimateLiteral))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
	 && (((numSlotsOf(penultimateLiteral, self)) >= 2)
	 && (((longAt((penultimateLiteral + BaseHeaderSize) + (0U << (shiftForWord(self))))) == methodObj)
	 && (((maybeSelector = longAt((penultimateLiteral + BaseHeaderSize) + (1U << (shiftForWord(self))))),
	(((maybeSelector & (tagMask(self))) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(maybeSelector))) >> (formatShift(self))) & (formatMask(self)), self)))
		 && ((fetchClassTagOfNonImm(maybeSelector, self)) == (fetchClassTagOfNonImm(splObj(SelectorDoesNotUnderstand, self), self)))))))
		? maybeSelector
		: 0);
}

	/* StackInterpreter>>#methodArgumentCount */
sqInt
methodArgumentCount(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(argumentCount);
}

	/* StackInterpreter>>#methodClassAssociationOf: */
sqInt
methodClassAssociationOf(sqInt methodPointer, struct foo * self)
{
    sqInt offset;

	/* begin literal:ofMethod: */
	offset = ((assert((((((assert(isCompiledMethod(methodPointer, self)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(methodPointer, self)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
	/* begin fetchPointer:ofObject: */
	return longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
}


/*	Answer the method class of a method which is the value of an Association
	in the last literal,
	or answer nil if there isn't one.
	Using a read barrier here simplifies the become implementation and costs
	very little
	because the class index and ValueIndex of the association almost certainly
	share a cache line. */

	/* StackInterpreter>>#methodClassOf: */
sqInt
methodClassOf(sqInt methodPointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt objOop;
    sqInt objOop1;
    sqInt offset;

	/* begin followLiteral:ofMethod: */
	offset = ((assert((((((assert(isCompiledMethod(methodPointer, self)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(methodPointer, self)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
	/* begin followField:ofObject: */
	objOop1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
	if (((objOop1 & (tagMask(self))) == 0)
	 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, methodPointer, objOop1, self);
	}
	literal = objOop1;
	return ((literal != GIV(nilObj))
	 && (((literal & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(literal))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		? (assert((numSlotsOf(literal, self)) > ValueIndex),
			/* begin followField:ofObject: */
			(objOop = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))))),
			(((objOop & (tagMask(self))) == 0)
				 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)
					? (objOop = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop, self))
					: 0),
			objOop)
		: /* begin nilObject */ GIV(nilObj));
}

	/* StackInterpreter>>#methodHeaderIndicatesLargeFrame: */
static sqInt NoDbgRegParms
methodHeaderIndicatesLargeFrame(sqInt methodHeader, struct foo * self)
{
	return (methodHeader & LargeContextBit) != 0;
}

	/* StackInterpreter>>#methodPrimitiveIndex */
sqInt
methodPrimitiveIndex(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt methodHeader;

	if (!((addressCouldBeObj(GIV(newMethod), self))
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		return -1;
	}
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (methodHeader & AlternateHeaderHasPrimFlag
		? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnBool: */
sqInt
methodReturnBool(sqInt boolean, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (boolean
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method. */

	/* StackInterpreter>>#methodReturnFloat: */
sqInt
methodReturnFloat(double aFloat, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nItems;
    char *sp;

	/* begin pop:thenPushFloat: */
	nItems = GIV(argumentCount) + 1;
	longAtput((sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord)), floatObjectOf(aFloat, self));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnInteger: */
sqInt
methodReturnInteger(sqInt integer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 3) | 1));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method */

	/* StackInterpreter>>#methodReturnReceiver */
sqInt
methodReturnReceiver(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	return 0;
}


/*	Sets the return value for a method. */

	/* StackInterpreter>>#methodReturnString: */
sqInt
methodReturnString(char *aCString, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = stringForCString(aCString, self);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnValue: */
sqInt
methodReturnValue(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

	/* StackInterpreter>>#methodUsesAlternateBytecodeSet: */
sqInt
methodUsesAlternateBytecodeSet(sqInt aMethodObj, struct foo * self)
{
    sqInt methodHeader;

	/* begin headerIndicatesAlternateBytecodeSet: */
	assert(isCompiledMethod(aMethodObj, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (((sqLong) methodHeader)) < 0;
}


/*	Answer if aMethodObj contains a primitive and uses the primitive error
	code. 
 */

	/* StackInterpreter>>#methodUsesPrimitiveErrorCode: */
static sqInt NoDbgRegParms
methodUsesPrimitiveErrorCode(sqInt aMethodObj, struct foo * self)
{
    sqInt firstBytecode;
    sqInt methodHeader;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(aMethodObj, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (((methodHeader & AlternateHeaderHasPrimFlag
		? (/* begin firstBytecodeOfAlternateHeader:method: */
			(firstBytecode = (aMethodObj + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0)) > 0)
	 && ((
#  if MULTIPLEBYTECODESETS
		((((sqLong) methodHeader)) < 0
				? AltLongStoreBytecode
				: LongStoreBytecode)
#  else /* MULTIPLEBYTECODESETS */
		LongStoreBytecode
#  endif /* MULTIPLEBYTECODESETS */
		) == (fetchByteofObject((((literalCountOf(aMethodObj, self)) + LiteralStart) * BytesPerOop) + (3), aMethodObj, self)));
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

	/* StackInterpreter>>#moduleUnloaded: */
EXPORT(void)
moduleUnloaded(char *aModuleName, struct foo * self)
{
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {

		/* Surface plugin went away. Should never happen. But  then, who knows */
		showSurfaceFn = 0;
	}
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

	/* StackInterpreter>>#moveFramesIn:through:toPage: */
static char * NoDbgRegParms
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage, struct foo * self)
{
    char *callerFP;
    sqInt callerIP;
    int delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    sqInt numArgs;
    char *offsetCallerFP;
    char *source;
    sqInt stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;
    sqInt valuePointer;
    sqInt valuePointer1;

	newSP = ((newPage->baseAddress)) + BytesPerWord;
	/* begin frameStackedReceiverOffset: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord(self)))));
	for (source = (theFP + stackedReceiverOffset); source >= ((oldPage->headSP)); source += (-BytesPerWord)) {
		newSP -= BytesPerWord;
		longAtput(newSP, longAt(source));
	}
	delta = newSP - ((oldPage->headSP));
	newFP = ((newPage->baseAddress)) - stackedReceiverOffset;
	/* begin setHeadFP:andSP:inPage: */
	theFP1 = ((oldPage->headFP)) + delta;
	assert(newSP < theFP1);
	assert((newSP < ((newPage->baseAddress)))
	 && (newSP > (((newPage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((theFP1 < ((newPage->baseAddress)))
	 && (theFP1 > (((newPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(newPage->headFP = theFP1);
	(newPage->headSP = newSP);
	(newPage->baseFP = newFP);
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(!(isBaseFrame(theFP, self)));
	assert(frameHasContext(callerFP, self));
	callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
	longAtput(theFP + stackedReceiverOffset, callerIP);
	assert((callerFP < ((oldPage->baseAddress)))
	 && (callerFP > (((oldPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(oldPage->headFP = callerFP);
	(oldPage->headSP = theFP + stackedReceiverOffset);
	longAtput(newFP + FoxCallerContext, longAt(callerFP + FoxThisContext));
	longAtput(newFP + FoxSavedFP, 0);
	fpInNewPage = (newPage->headFP);
	do {
		/* begin frameCallerFP: */
		offsetCallerFP = pointerForOop(longAt(fpInNewPage + FoxSavedFP));
		if (offsetCallerFP != 0) {
			offsetCallerFP += delta;
		}
		longAtput(fpInNewPage + FoxSavedFP, oopForPointer(offsetCallerFP));
		if ((byteAt((fpInNewPage + FoxFrameFlags) + 2)) != 0) {
			/* begin frameContext: */
			theContext = longAt(fpInNewPage + FoxThisContext);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(((oopForPointer(fpInNewPage)) & (BytesPerWord - 1)) == 0);
			valuePointer = (oopForPointer(fpInNewPage)) + (smallIntegerTag(self));
			assert(!(isOopForwarded(theContext, self)));
			longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(((oopForPointer(offsetCallerFP)) & (BytesPerWord - 1)) == 0);
			valuePointer1 = (oopForPointer(offsetCallerFP)) + (smallIntegerTag(self));
			assert(!(isOopForwarded(theContext, self)));
			longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
		}
		fpInNewPage = offsetCallerFP;
	} while(fpInNewPage != 0);
	return newFP;
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass: */
static char * NoDbgRegParms
nameOfClass(sqInt classOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOf: */
	assert((classIndexOf(classOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(classOop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		/* begin fetchPointer:ofObject: */
		maybeThisClassOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord(self))))));
		if (addressCouldBeClassObj(maybeThisClassOop, self)) {
			return nameOfClass(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord(self)))))), self);
		}
		return "bad class";
	}
	if (!((numSlots > GIV(classNameIndex))
		 && (((maybeNameOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord(self))))))),
		((maybeNameOop & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(maybeNameOop))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))))) {
		return "bad class";
	}
	return firstIndexableField(maybeNameOop, self);
}

	/* StackInterpreter>>#newGIV */
struct foo *
newGIV()
{
    int numberOfImage;

	numberOfImage = getNumberOfImage();
	if (numberOfImage == 0) {
		setNumberOfImage(1);
		initAllGlobalsStruct();
	}
	else {
		setNumberOfImage(numberOfImage + 1);
		growAllGlobalsStruct(numberOfImage + 1);
	}
	
		return calloc(sizeof(struct foo), 1);
	return 0;
}

	/* StackInterpreter>>#newImage:WithArguments: */
static struct foo * NoDbgRegParms
newImageWithArguments(char *imagePath, char *imageArgs, struct foo * self)
{
		
	ThreadInterpreterParameter* tip = malloc(sizeof(ThreadInterpreterParameter));
	tip->imagePath = imagePath;
	tip->imageArguments = imageArgs;
	tip->interpreterState = newGIV();
	
	printf ("Launching imageAt: %s which is gonna: %s\n", tip->imagePath, tip->imageArguments);	
	
	pthread_attr_t tattr;
	pthread_attr_init(&tattr);
	size_t size;
	pthread_attr_getstacksize(&tattr, &size);
   if(pthread_attr_setstacksize(&tattr, size*4)){
		perror("Thread attr");
   }
	
	if(pthread_create(&thread_id[numberOfImage], &tattr, loadAndExecute, tip)){
			perror("Thread creation");
		}
	return tip->interpreterState;
	
	return 0;
}

	/* StackInterpreter>>#nextInInterpreter: */
static int NoDbgRegParms
nextInInterpreter(struct foo *anInterpreterState, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	pthread_mutex_t * mut = &anInterpreterState->mutexForFetchBytecode;
	if(pthread_mutex_lock(mut) != 0){
		printf("Mutex lock error: %s\n", strerror(errno));
		abort();
	}
	pthread_cond_t * cond = anInterpreterState->step;
	if(pthread_cond_broadcast(cond) != 0){
		printf("Cond broadcast error: %s\n", strerror(errno));
		exit(1);
		}
	pthread_mutex_unlock(mut);
	
	return 0;
}

	/* StackInterpreter>>#noInlineTemporary:in: */
static sqInt NoDbgRegParms
noInlineTemporaryin(sqInt offset, char *theFP, struct foo * self)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord)));
}

	/* StackInterpreter>>#noInlineTemporary:in:put: */
static sqInt NoDbgRegParms
noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop, struct foo * self)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAtput((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord), valueOop)
		: longAtput(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord), valueOop));
}


/*	Answer true if there are no marked contexts on thePage. */

	/* StackInterpreter>>#noMarkedContextsOnPage: */
static sqInt NoDbgRegParms
noMarkedContextsOnPage(StackPage *thePage, struct foo * self)
{
    char *theFP;

	assert(!(isFree(thePage, self)));
	theFP = (thePage->headFP);
	do {
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP, self), self));
			if (((((usqInt) (longAt(longAt(theFP + FoxThisContext)))) >> (markedBitFullShift(self))) & 1) != 0) {
				return 0;
			}
		}
	} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
	return 1;
}


/*	Answer the number of effective pointer fields in the given context. */

	/* StackInterpreter>>#numSlotsOfMarriedContext: */
static sqInt NoDbgRegParms
numSlotsOfMarriedContext(sqInt aContext, struct foo * self)
{
    sqInt contextSize;

	contextSize = stackPointerIndexForFrame(frameOfMarriedContext(aContext, self), self);
	return CtxtTempFrameStart + contextSize;
}

	/* StackInterpreter>>#numStkPages */
static sqInt
numStkPages(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(numStackPages);
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

	/* StackInterpreter>>#objCouldBeClassObj: */
sqInt
objCouldBeClassObj(sqInt objOop, struct foo * self)
{
    sqInt fieldOop;

	return (((((usqInt) (longAt(objOop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
	 && (((numSlotsOfAny(objOop, self)) > InstanceSpecificationIndex)
	 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))))),
	((addressCouldBeObj(fieldOop, self))
		 && ((((((usqInt) (longAt(fieldOop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
		 || ((((fieldOop & (tagMask(self))) == 0)
		 && (((longAt(fieldOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))
		 && (isPointers(followForwarded(fieldOop, self), self)))))
		 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))))),
		((addressCouldBeObj(fieldOop, self))
			 && ((((((usqInt) (longAt(fieldOop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
			 || ((((fieldOop & (tagMask(self))) == 0)
			 && (((longAt(fieldOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))
			 && (isPointers(followForwarded(fieldOop, self), self)))))
			 && (((((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self)))))))) & 7) == 1)))))));
}


/*	This is the entry-point for plugins and primitives that wish to reacquire
	the VM after having
	released it via disownVM or callbacks that want to acquire it without
	knowing their ownership
	status. While this exists for the threaded FFI VM we use it to reset
	newMethod and the
	argumentCount after a callback.
	
	Answer -1 if the current thread is unknown to the VM and fails to take
	ownership. 
 */

	/* StackInterpreter>>#ownVM: */
sqInt
ownVM(sqInt threadIndexAndFlags, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    extern sqInt amInVMThread(void);
    char *sp;

	
#  if COGMTVM
	if (!(amInVMThread(self))) {
		return -1;
	}
#  endif /* COGMTVM */
	assert((isOopCompiledMethod(GIV(newMethod), self))
	 && ((argumentCountOf(GIV(newMethod), self)) == GIV(argumentCount)));
	if (threadIndexAndFlags & DisownVMForFFICall) {
		GIV(inFFIFlags) = 0;
		return threadIndexAndFlags;
	}
	assert(GIV(primFailCode) == 0);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	return (((usqInt)GIV(argumentCount) << 3) | 1);
}

	/* StackInterpreter>>#penultimateLiteralOf: */
sqInt
penultimateLiteralOf(sqInt aMethodOop, struct foo * self)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop, self));
	/* begin literal:ofMethod: */
	offset = ((assert((((((assert(isCompiledMethod(aMethodOop, self)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(aMethodOop, self)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 2;
	/* begin fetchPointer:ofObject: */
	return longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#popStack */
sqInt
popStack(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	return top;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop: */
sqInt
pop(sqInt nItems, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) += nItems * BytesPerWord;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop:thenPush: */
void
popthenPush(sqInt nItems, sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	integerValue is interpreted as POSITIVE, e.g. as the result of Bitmap>at:.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#positive32BitIntegerFor: */
sqInt
positive32BitIntegerFor(unsigned int integerValue, struct foo * self)
{
	return ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
}


/*	Answer a Large Positive Integer object for the given integer value. N.B.
	will *not* cause a GC. */

	/* StackInterpreter>>#positive64BitIntegerFor: */
sqInt
positive64BitIntegerFor(usqLong integerValue, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt sz;
    sqLong value;

	if (integerValue <= (MaxSmallInteger)) {
		return ((integerValue << 3) | 1);
	}
	sz = 8;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat(self)) + ((8 - sz) & (BytesPerWord - 1));
	numSlots = 8 / BytesPerOop;
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassLargePositiveIntegerCompactIndex, self)) != GIV(nilObj)));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l2;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
	l2:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	/* begin storeLong64:ofObject:withValue: */
	value = SQ_SWAP_8_BYTES_IF_BIGENDIAN(integerValue);
	long64Atput((newLargeInteger + BaseHeaderSize) + (0U << 3), value);
	return newLargeInteger;
}

	/* StackInterpreter>>#positiveMachineIntegerFor: */
static sqInt NoDbgRegParms
positiveMachineIntegerFor(usqIntptr_t value, struct foo * self)
{
    sqInt resultObj;

	resultObj = positive64BitIntegerFor(value, self);
	return resultObj;
}


/*	Update the displayBits after a GC may have moved it.
	Answer if the displayBits appear valid */

	/* StackInterpreter>>#postGCUpdateDisplayBits */
static sqInt
postGCUpdateDisplayBits(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void * bitsNow;
    sqInt bitsOop;
    sqInt displayObj;

	/* begin splObj: */
	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheDisplay) << (shiftForWord(self))))));
	if (!((((displayObj & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(displayObj))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && (((lengthOfformat(displayObj, (((usqInt) (longAt(displayObj))) >> (formatShift(self))) & (formatMask(self)), self)) >= 4)
		 && (isWordsOrBytes((bitsOop = longAt((displayObj + BaseHeaderSize) + (0U << (shiftForWord(self))))), self))))) {
		return 0;
	}
	if (!(((((usqInt) (longAt(bitsOop))) >> (pinnedBitShift(self))) & 1) != 0)) {
		bitsNow = firstIndexableField(bitsOop, self);
		if (displayBits != bitsNow) {
			displayBits = bitsNow;
			ioNoteDisplayChangedwidthheightdepth(displayBits, displayWidth, displayHeight, displayDepth);
		}
	}
	return 1;
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

	/* StackInterpreter>>#primitiveEventProcessingControl */
EXPORT(void)
primitiveEventProcessingControl(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int enabled;
    char *sp;
    char *sp1;

	enabled = inIOProcessEvents >= 0;
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				return;
			}
		}
		/* begin pop:thenPushBool: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	Note: With the Squeak V3 format we now have 10 bits of primitive index,
	but they are
	in two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the
	Spur format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

	/* StackInterpreter>>#primitiveIndexOfMethod:header: */
sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader, struct foo * self)
{
    sqInt firstBytecode;

	return (methodHeader & AlternateHeaderHasPrimFlag
		? ((firstBytecode = (theMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
}

	/* StackInterpreter>>#primitiveIndexOf: */
sqInt
primitiveIndexOf(sqInt methodPointer, struct foo * self)
{
    sqInt firstBytecode;
    sqInt methodHeader;

	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(methodPointer, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (methodHeader & AlternateHeaderHasPrimFlag
		? ((firstBytecode = (methodPointer + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
}

	/* StackInterpreter>>#printActivationNameForSelector:startClass: */
static void NoDbgRegParms
printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methClass;
    usqInt numSlots;
    sqInt objOop;

	if (addressCouldBeObj(startClass, self)) {
		/* begin findClassForSelector:lookupClass:do: */
		currClass = startClass;
		do {
			/* begin fetchPointer:ofObject: */
			classDict = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))));
			/* begin numSlotsOf: */
			assert((classIndexOf(classDict, self)) > (isForwardedObjectClassIndexPun(self)));
			numSlots = byteAt(classDict + 7);
			classDictSize = (numSlots == (numSlotsMask(self))
				? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classDict - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots);
			i = SelectorStart;
			while (i < classDictSize) {
				if (aSelector == (longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self)))))))) {
					methClass = currClass;
					goto l5;
				}
				i += 1;
			}
			/* begin followField:ofObject: */
			objOop = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
			if (((objOop & (tagMask(self))) == 0)
			 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currClass, objOop, self);
			}
			currClass = objOop;
		} while(!(currClass == GIV(nilObj)));
		methClass = null;
	l5:	/* end findClassForSelector:lookupClass:do: */;
		if ((methClass == null)
		 || (startClass == methClass)) {
			printNameOfClasscount(methClass, 5, self);
			/* begin printChar: */
			putchar('>');
			if (!(methClass)) {
				printStringOf(splObj(SelectorDoesNotUnderstand, self), self);
				print(" ", self);
			}
		}
		else {
			printNameOfClasscount(startClass, 5, self);
			/* begin printChar: */
			putchar('(');
			printNameOfClasscount(methClass, 5, self);
			/* begin printChar: */
			putchar(')');
			/* begin printChar: */
			putchar('>');
		}
	}
	else {
		print("INVALID CLASS", self);
	}
	if ((aSelector & (tagMask(self)))
	 || (addressCouldBeObj(aSelector, self))) {
		if (((aSelector & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(aSelector))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)))) {
			printStringOf(aSelector, self);
		}
		else {
			printOopShort(aSelector, self);
		}
	}
	else {
		print("INVALID SELECTOR", self);
	}
}

	/* StackInterpreter>>#printActivationNameFor:receiver:isBlock:firstTemporary: */
static void NoDbgRegParms
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt methClass;
    sqInt methodSel;
    sqInt rclass;
    sqInt tagBits;
    sqInt tagBits1;

	if (isBlock) {
		print("[] in ", self);
	}
	/* begin findClassOfMethod:forReceiver: */
	if (((anObject & (tagMask(self)))
	 || (addressCouldBeObj(anObject, self)))
	 && (!(((anObject & (tagMask(self))) == 0)
	 && (((longAt(anObject)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)))) {
		rclass = findClassContainingMethodstartingAt(aMethod, (((tagBits1 = anObject & (tagMask(self)))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits1) << (shiftForWord(self))))))
			: fetchClassOfNonImm(anObject, self)), self);
		if (rclass != GIV(nilObj)) {
			methClass = rclass;
			goto l2;
		}
	}
	if (!((addressCouldBeObj(aMethod, self))
		 && (((((usqInt) (longAt(aMethod))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin nilObject */
		methClass = GIV(nilObj);
		goto l2;
	}
	methClass = findClassContainingMethodstartingAt(aMethod, safeMethodClassOf(aMethod, self), self);
	l2:	/* end findClassOfMethod:forReceiver: */;
	methodSel = findSelectorOfMethod(aMethod, self);
	if (((anObject & (tagMask(self)))
	 || (addressCouldBeObj(anObject, self)))
	 && ((!(((anObject & (tagMask(self))) == 0)
	 && (((longAt(anObject)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)))
	 && (addressCouldBeClassObj((classObj = (((tagBits = anObject & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(anObject, self))), self)))) {
		if ((classObj == methClass)
		 || ((methClass == null)
		 || (methClass == GIV(nilObj)))) {
			printNameOfClasscount(classObj, 5, self);
		}
		else {
			printNameOfClasscount(classObj, 5, self);
			print("(", self);
			printNameOfClasscount(methClass, 5, self);
			print(")", self);
		}
	}
	else {
		print("INVALID RECEIVER", self);
	}
	print(">", self);
	if ((methodSel & (tagMask(self)))
	 || (addressCouldBeObj(methodSel, self))) {
		if (methodSel == GIV(nilObj)) {
			print("(nil)", self);
		}
		else {
			printStringOf(methodSel, self);
		}
	}
	else {
		print("INVALID SELECTOR", self);
	}
	if ((methodSel == (splObj(SelectorDoesNotUnderstand, self)))
	 && ((addressCouldBeObj(maybeMessage, self))
	 && ((fetchClassOfNonImm(maybeMessage, self)) == (splObj(ClassMessage, self))))) {

		/* print arg message selector */
		/* begin fetchPointer:ofObject: */
		methodSel = longAt((maybeMessage + BaseHeaderSize) + (((sqInt)((usqInt)(MessageSelectorIndex) << (shiftForWord(self))))));
		print(" ", self);
		printStringOf(methodSel, self);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */

	/* StackInterpreter>>#printAllStacks */
void
printAllStacks(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIdx;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    sqInt mutexClass;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    usqInt p;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt pri;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;
    sqInt semaphoreClass;
    sqInt tagBits;

	/* begin memoryActiveProcess */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop2 = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	proc = longAt((objOop2 + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	printNameOfClasscount((((tagBits = proc & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(proc, self)), 5, self);
	/* begin space */
	putchar(' ');
	printHex(proc, self);
	print(" priority ", self);
	printNum(quickFetchIntegerofObject(PriorityIndex, proc, self), self);
	/* begin cr */
	printf("\n");
	printCallStackFP(GIV(framePointer), self);
	/* begin fetchPointer:ofObject: */
	objOop3 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop3 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	schedLists = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord(self))))));
	if (GIV(highestRunnableProcessPriority) == 0) {
		/* begin numSlotsOf: */
		assert((classIndexOf(schedLists, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(schedLists + 7);
		p = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(schedLists - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
	}
	else {
		p = GIV(highestRunnableProcessPriority);
	}
	for (pri = (p - 1); pri >= 0; pri += -1) {
		/* begin fetchPointer:ofObject: */
		processList = longAt((schedLists + BaseHeaderSize) + (((sqInt)((usqInt)(pri) << (shiftForWord(self))))));
		if (!((assert(!(isForwarded(processList, self))),
			(longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))))) == GIV(nilObj)))) {
			/* begin cr */
			printf("\n");
			print("processes at priority ", self);
			printNum(pri + 1, self);
			printProcsOnList(processList, self);
		}
	}
	/* begin cr */
	printf("\n");
	print("suspended processes", self);
	/* begin fetchPointer:ofObject: */
	semaphoreClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	mutexClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMutex) << (shiftForWord(self))))));
	assert((rawHashBitsOf(semaphoreClass, self)) != 0);
	semaphoreClass = (long32At(semaphoreClass + 4)) & (identityHashHalfWordMask(self));
	assert((rawHashBitsOf(mutexClass, self)) != 0);
	mutexClass = (long32At(mutexClass + 4)) & (identityHashHalfWordMask(self));
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		/* begin classIndexOf: */
		classIdx = (longAt(objOop11)) & (classIndexMask(self));
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop11, self);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l14;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l14:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots2 = byteAt(address + 7);
	objOop4 = (numSlots2 == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop4, limit, self)) {
		/* begin classIndexOf: */
		classIdx = (longAt(objOop4)) & (classIndexMask(self));
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop4, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop4;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop4, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop4 = limit;
			goto l16;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop4 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l16:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop4 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop4, GIV(freeStart), self)) {
		/* begin classIndexOf: */
		classIdx = (longAt(objOop4)) & (classIndexMask(self));
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop4, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop4;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop4, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop4 = GIV(freeStart);
			goto l13;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop4 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l13:	/* end objectAfter:limit: */;
	}
	
}

	/* StackInterpreter>>#printCallStack */
void
printCallStack(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(framePointer) == null) {
		printCallStackOf(fetchPointerofObject(SuspendedContextIndex, memoryActiveProcess(self), self), self);
	}
	else {
		printCallStackFP(GIV(framePointer), self);
	}
}

	/* StackInterpreter>>#printCallStackFP: */
static sqInt NoDbgRegParms
printCallStackFP(char *theFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = shortReversePrintFrameAndCallers(theFP, self);
	while (!(context == GIV(nilObj))) {
		if (((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer), self))) {
				shortPrintContext(context, self);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context, self), self);
		}
		else {
			context = printContextCallStackOf(context, self);
		}
	}
	return 0;
}

	/* StackInterpreter>>#printCallStackOf: */
sqInt
printCallStackOf(sqInt aContextOrProcessOrFrame, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	if ((((((usqInt)aContextOrProcessOrFrame)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)aContextOrProcessOrFrame)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)aContextOrProcessOrFrame)) <= (((usqInt)GIV(pages))))))) {
		return printCallStackFP(((char *) aContextOrProcessOrFrame), self);
	}
	if (couldBeProcess(aContextOrProcessOrFrame, self)) {
		return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self)))))), self);
	}
	context = aContextOrProcessOrFrame;
	while (!(context == GIV(nilObj))) {
		if (((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer), self))) {
				shortPrintContext(context, self);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context, self), self);
		}
		else {
			context = printContextCallStackOf(context, self);
		}
	}
	return 0;
}

	/* StackInterpreter>>#printCallStackOf:currentFP: */
static sqInt NoDbgRegParms
printCallStackOfcurrentFP(sqInt aContext, char *currFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt index;
    sqInt referent;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		if (((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
			assert((((senderOop) & 7) == 1));
			theFP = pointerForOop(senderOop - 1);
			if (checkIsStillMarriedContextcurrentFP(ctxt, currFP, self)) {
				/* begin stackPageFor: */
				index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
				thePage = stackPageAtpages(index, GIV(pages), self);
				if (isFree(thePage, self)) {
					/* begin printHexPtr: */
					printHex(oopForPointer(theFP), self);
					print(" is on a free page?!", self);
					/* begin cr */
					printf("\n");
					return null;
				}
				shortPrintFrameAndCallers(theFP, self);
				theFP = (thePage->baseFP);
				/* begin frameCallerContext: */
				ctxt = longAt(theFP + FoxCallerContext);
				if (((longAt(ctxt)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(ctxt, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((ctxt + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					ctxt = referent;
				}
			}
			else {
				print("widowed caller frame ", self);
				/* begin printHexPtr: */
				printHex(oopForPointer(theFP), self);
				/* begin cr */
				printf("\n");
				return null;
			}
		}
		else {
			shortPrintContext(ctxt, self);
			/* begin fetchPointer:ofObject: */
			ctxt = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		}
	}
	return 0;
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#printChar: */
void
printChar(sqInt aByte, struct foo * self)
{
	putchar(aByte);
}


/*	Print the call stack of aContext until it links to a frame. */

	/* StackInterpreter>>#printContextCallStackOf: */
static sqInt NoDbgRegParms
printContextCallStackOf(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;

	ctxt = aContext;
	while (!((ctxt == GIV(nilObj))
	 || (((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)))) {
		shortPrintContext(ctxt, self);
		/* begin fetchPointer:ofObject: */
		ctxt = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	}
	return ctxt;
}

	/* StackInterpreter>>#printContext: */
void
printContext(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ip;
    sqInt sender;
    sqInt sp;

	shortPrintContext(aContext, self);
	/* begin fetchPointer:ofObject: */
	sender = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	ip = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))));
	if ((((sender) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer), self)) {
			print("married (assuming framePointer valid)", self);
			/* begin cr */
			printf("\n");
		}
		else {
			print("widowed (assuming framePointer valid)", self);
			/* begin cr */
			printf("\n");
		}
		print("sender   ", self);
		printNum(sender, self);
		print(" (", self);
		/* begin printHexPtr: */
		printHex(oopForPointer((assert((((sender) & 7) == 1)),
		pointerForOop(sender - 1))), self);
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		print("ip       ", self);
		printNum(ip, self);
		print(" (", self);
		/* begin printHexPtr: */
		printHex(oopForPointer((assert((((ip) & 7) == 1)),
		pointerForOop(ip - 1))), self);
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
	}
	else {
		print("sender   ", self);
		shortPrintOop(sender, self);
		print("ip       ", self);
		if (ip == GIV(nilObj)) {
			shortPrintOop(ip, self);
		}
		else {
			printNum(ip, self);
			print(" (", self);
			printNum((ip >> 3), self);
			/* begin space */
			putchar(' ');
			printHex((ip >> 3), self);
			/* begin printChar: */
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
	/* begin fetchPointer:ofObject: */
	sp = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
	sp = ((sp < ((lengthOfformat(aContext, (((usqInt) (longAt(aContext))) >> (formatShift(self))) & (formatMask(self)), self)) - ReceiverIndex)) ? sp : ((lengthOfformat(aContext, (((usqInt) (longAt(aContext))) >> (formatShift(self))) & (formatMask(self)), self)) - ReceiverIndex));
	print("sp       ", self);
	printNum(sp, self);
	print(" (", self);
	printNum((sp >> 3), self);
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	print("method   ", self);
	/* begin printMethodFieldForPrintContext: */
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self)))))), self);
	print("closure  ", self);
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord(self)))))), self);
	print("receiver ", self);
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord(self)))))), self);
	sp = (sp >> 3);
	for (i = 1; i <= sp; i += 1) {
		print("       ", self);
		printNum(i, self);
		/* begin space */
		putchar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord(self)))))), self);
	}
}

	/* StackInterpreter>>#printExternalHeadFrame */
void
printExternalHeadFrame(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFrameWithSP(GIV(framePointer), GIV(stackPointer), self);
}

	/* StackInterpreter>>#printFrameAndCallers:SP:short: */
static sqInt NoDbgRegParms
printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		printFrameAndCallersSPshort(pointerForOop(longAt(theFP + FoxSavedFP)), (assert(!(isBaseFrame(theFP, self))),
		(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord(self))))))) + BytesPerWord), printShort, self);
	}
	if (printShort) {
		shortPrintFrame(theFP, self);
		return null;
	}
	/* begin cr */
	printf("\n");
	printFrameWithSP(theFP, theSP, self);
	return 0;
}

	/* StackInterpreter>>#printFrameFlagsForFP: */
static void NoDbgRegParms
printFrameFlagsForFP(char *theFP, struct foo * self)
{
    char *address;
    sqInt it;

	address = theFP + FoxFrameFlags;
	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address), self);
	print(":       flags: ", self);
	printHex(it, self);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		printNum(it, self);
	}
	print("  numArgs: ", self);
	printNum(byteAt((theFP + FoxFrameFlags) + 1), self);
	print(((byteAt((theFP + FoxFrameFlags) + 2)) != 0
		? " hasContext"
		: " noContext"), self);
	print(((byteAt((theFP + FoxFrameFlags) + 3)) != 0
		? " isBlock"
		: " notBlock"), self);
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrameOop:at: */
static void NoDbgRegParms
printFrameOopat(char *name, char *address, struct foo * self)
{
    sqInt i;
    sqInt iLimiT;
    sqInt it;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address), self);
	/* begin printChar: */
	putchar(':');
	for (i = 1, iLimiT = (12 - (strlen(name))); i <= iLimiT; i += 1) {
		/* begin printChar: */
		putchar(' ');
	}
	print(name, self);
	print(": ", self);
	printHex(it, self);
	/* begin tab */
	putchar('	');
	/* begin printChar: */
	putchar('=');
	printOopShort(it, self);
	/* begin cr */
	printf("\n");
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

	/* StackInterpreter>>#printFramesInPage: */
EXPORT(void)
printFramesInPage(StackPage *thePage, struct foo * self)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 0, self);
}

	/* StackInterpreter>>#printFramesOnStackPageListInUse */
EXPORT(void)
printFramesOnStackPageListInUse(struct foo * self)
{
    usqInt n;
    StackPage *page;

	page = mostRecentlyUsedPage(self);
	do {
		if (!(isFree(page, self))) {
			print("page ", self);
			/* begin printHexPtrnp: */
			n = oopForPointer(page);
			printf("0x%" PRIxSQINT "", n);
			/* begin cr */
			printf("\n");
			printFramesInPage(page, self);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage(self)));
}

	/* StackInterpreter>>#printFrameThing:andFrame:at: */
static void NoDbgRegParms
printFrameThingandFrameat(char *name, char *theFP, char *address, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address), self);
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		putchar(' ');
	}
	print(name, self);
	print(": ", self);
	printHex(it, self);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil", self);
		}
		else {
			printNum(it, self);
		}
	}
	print(" frame: ", self);
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP), self);
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrameThing:at: */
static void NoDbgRegParms
printFrameThingat(char *name, char *address, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address), self);
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		putchar(' ');
	}
	print(name, self);
	print(": ", self);
	printHex(it, self);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil", self);
		}
		else {
			printNum(it, self);
		}
	}
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrame: */
sqInt
printFrame(char *theFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *frameAbove;
    sqInt index;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		if ((addressCouldBeObj(((sqInt)theFP), self))
		 && ((isInMemory(((sqInt)theFP), self))
		 && ((((longAt(((sqInt)theFP))) & (classIndexMask(self))) == ClassMethodContextCompactIndex)
		 && (checkIsStillMarriedContextcurrentFP(((sqInt)theFP), GIV(framePointer), self))))) {
			return printFrame(frameOfMarriedContext(((sqInt)theFP), self), self);
		}
		/* begin printHexPtr: */
		printHex(oopForPointer(theFP), self);
		print(" is not in the stack zone?!", self);
		/* begin cr */
		printf("\n");
		return null;
	}
	frameAbove = null;
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		if (isFree(thePage, self)) {
			/* begin printHexPtr: */
			printHex(oopForPointer(theFP), self);
			print(" is on a free page?!", self);
			/* begin cr */
			printf("\n");
			return null;
		}
		if ((thePage != GIV(stackPage))
		 && (theFP == ((thePage->headFP)))) {
			theSP = (thePage->headSP);
		}
		else {
			/* begin safeFindFrameAbove:on:startingFrom: */
			startFrame = ((thePage == GIV(stackPage))
			 && (((GIV(framePointer) >= ((thePage->realStackLimit))) && (GIV(framePointer) <= ((thePage->baseAddress)))))
				? GIV(framePointer)
				: (thePage->headFP));
			assert(!(isFree(thePage, self)));
			if (startFrame == theFP) {
				frameAbove = null;
				goto l3;
			}
			aFrame = startFrame;
			while (1) {
				prevFrame = aFrame;
				/* begin frameCallerFP: */
				aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
				if (!(aFrame != 0)) break;
				if (theFP == aFrame) {
					frameAbove = prevFrame;
					goto l3;
				}
			}
			frameAbove = null;
	l3:	/* end safeFindFrameAbove:on:startingFrom: */;
			theSP = (frameAbove
				? (assert(!(isBaseFrame(frameAbove, self))),
					(frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord(self))))))) + BytesPerWord)
				: 0);
		}
	}
	if (!(theSP)) {
		print("could not find sp; using bogus value", self);
		/* begin cr */
		printf("\n");
		/* begin frameReceiverLocation: */
		theSP = theFP + FoxReceiver;
	}
	printFrameWithSP(theFP, theSP, self);
	if (frameAbove) {
		printFrameThingat("frame pc", frameAbove + FoxCallerSavedIP, self);
	}
	return 0;
}

	/* StackInterpreter>>#printFrame:WithSP: */
sqInt
printFrameWithSP(char *theFP, char *theSP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *addr;
    sqInt i;
    sqInt numArgs;
    sqInt theMethod;
    sqInt topThing;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		/* begin printHexPtr: */
		printHex(oopForPointer(theFP), self);
		print(" is not in the stack zone?!", self);
		/* begin cr */
		printf("\n");
		return null;
	}
	/* begin frameMethod: */
	theMethod = longAt(theFP + FoxMethod);
	/* begin frameNumArgs: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	shortPrintFrame(theFP, self);
	printFrameOopat("rcvr/clsr", (theFP + FoxCallerSavedIP) + ((numArgs + 1) * BytesPerWord), self);
	for (i = numArgs; i >= 1; i += -1) {
		printFrameOopat("arg", (theFP + FoxCallerSavedIP) + (i * BytesPerWord), self);
	}
	printFrameThingat("cllr ip/ctxt", theFP + FoxCallerSavedIP, self);
	printFrameThingat("saved fp", theFP + FoxSavedFP, self);
	printFrameOopat("method", theFP + FoxMethod, self);
	printFrameFlagsForFP(theFP, self);
	printFrameThingat("context", theFP + FoxThisContext, self);
	printFrameOopat("receiver", theFP + FoxReceiver, self);
	topThing = longAt(theSP);
	if ((topThing >= theMethod)
	 && (topThing <= (theMethod + (((numSlotsOf(theMethod, self)) << (shiftForWord(self))) + BaseHeaderSize)))) {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= (theSP + BytesPerWord); addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr, self);
		}
		printFrameThingat("frame ip", theSP, self);
	}
	else {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= theSP; addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr, self);
		}
	}
	return 0;
}


/*	Print n in hex, in the form '0x1234', unpadded */

	/* StackInterpreter>>#printHexnp: */
sqInt
printHexnp(usqInt n, struct foo * self)
{
	return printf("0x%" PRIxSQINT "", n);
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles)  */

	/* StackInterpreter>>#printHex: */
void
printHex(usqInt n, struct foo * self)
{
    char buf[37];
    sqInt len;

	memset(buf,' ',36);
	len = sprintf(buf + 2 + 2 * BytesPerWord, "0x%" PRIxSQPTR, (usqIntptr_t)(n));
	printf("%s", buf + len);
	}


/*	Print all methods whose penultimate literal is either selector,
	or an object whose first inst var is the method and whose
	second is selector (e.g. an AdditionalMethodState). */

	/* StackInterpreter>>#printLikelyImplementorsOfSelector: */
void
printLikelyImplementorsOfSelector(sqInt selector, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt aByte1;
    sqInt address;
    sqInt address1;
    sqInt classLookupKey;
    sqInt classOop;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    sqInt methodClassAssociation;
    usqInt n;
    usqInt n1;
    usqInt n2;
    usqInt n3;
    char *name;
    sqInt nameLen;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt offset;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt referent;
    sqInt tagBits;
    sqInt theClass1;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop12 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop12, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop12, self));
		if ((((((usqInt) (longAt(objOop12))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))
		 && ((maybeSelectorOfMethod(objOop12, self)) == selector)) {

			/* try and print the key of the method class association (the name of the implementing class) */
			/* begin methodClassAssociationOf: */
			offset = ((assert((((((assert(isCompiledMethod(objOop12, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop12, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
			/* begin fetchPointer:ofObject: */
			methodClassAssociation = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
			/* begin printHexnp: */
			printf("0x%" PRIxSQINT "", objOop12);
			/* begin space */
			putchar(' ');
			/* begin printOopShortInner: */
			if ((((methodClassAssociation & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(methodClassAssociation))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
			 && ((numSlotsOf(methodClassAssociation, self)) >= 2)) {
				/* begin fetchPointer:ofObject: */
				oop = longAt((methodClassAssociation + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			else {
				oop = methodClassAssociation;
			}
			if (oop & (tagMask(self))) {
				if (oop & (characterTag(self))) {
					/* begin printChar: */
					putchar('$');
					/* begin printChar: */
					aByte = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
					putchar(aByte);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					n = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
					printf("0x%" PRIxSQINT "", n);
					/* begin printChar: */
					putchar(')');
					goto l29;
				}
				if ((((oop) & 7) == 1)) {
					printNum((oop >> 3), self);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					n1 = (oop >> 3);
					printf("0x%" PRIxSQINT "", n1);
					/* begin printChar: */
					putchar(')');
					goto l29;
				}
				if (oop & (smallFloatTag(self))) {
					printFloat(dbgFloatValueOf(oop, self), self);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					printf("0x%" PRIxSQINT "", oop);
					/* begin printChar: */
					putchar(')');
					goto l29;
				}
				print("unknown immediate ", self);
				/* begin printHexnp: */
				printf("0x%" PRIxSQINT "", oop);
				goto l29;
			}
			if (!(addressCouldBeObj(oop, self))) {
				print(((oop & (8 /* allocationUnit */ - 1)) != 0
					? " is misaligned"
					: whereIs(oop, self)), self);
				goto l29;
			}
			if (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
				print(" is a free chunk", self);
				goto l29;
			}
			if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				print(" is a forwarder to ", self);
				/* begin printHexnp: */
				assert(isUnambiguouslyForwarder(oop, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent & (tagMask(self))) == 0)
				 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				n2 = referent;
				printf("0x%" PRIxSQINT "", n2);
				goto l29;
			}
			if ((((tagBits = oop & (tagMask(self)))) != 0
				? tagBits == (smallFloatTag(self))
				: ((longAt(oop)) & (classIndexMask(self))) == ClassFloatCompactIndex)) {
				printFloat(dbgFloatValueOf(oop, self), self);
				goto l29;
			}
			classOop = fetchClassOfNonImm(oop, self);
			if (!(addressCouldBeObj(classOop, self))) {
				print("a ??", self);
				goto l29;
			}
			if ((numSlotsOf(classOop, self)) == GIV(metaclassNumSlots)) {
				printNameOfClasscount(oop, 5, self);
				goto l29;
			}
			if (oop == GIV(nilObj)) {
				print("nil", self);
				goto l29;
			}
			if (oop == GIV(trueObj)) {
				print("true", self);
				goto l29;
			}
			if (oop == GIV(falseObj)) {
				print("false", self);
				goto l29;
			}
			nameLen = lengthOfNameOfClass(classOop, self);
			if (nameLen == 0) {
				print("a ??", self);
				goto l29;
			}
			name = nameOfClass(classOop, self);
			if (nameLen == 10) {
				if ((strncmp(name, "ByteString", 10)) == 0) {
					/* begin printChar: */
					putchar('\'');
					printStringOf(oop, self);
					/* begin printChar: */
					putchar('\'');
					goto l29;
				}
				if ((strncmp(name, "ByteSymbol", 10)) == 0) {
					/* begin printChar: */
					putchar('#');
					printStringOf(oop, self);
					goto l29;
				}
			}
			if ((nameLen == 9)
			 && ((strncmp(name, "Character", 9)) == 0)) {
				/* begin printChar: */
				putchar('$');
				/* begin printChar: */
				aByte1 = ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))))) >> 3);
				putchar(aByte1);
				goto l29;
			}
			print("a(n) ", self);
			for (i = 0; i < nameLen; i += 1) {
				/* begin printChar: */
				putchar(name[i]);
			}
			if ((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
			 && ((((assert(addressCouldBeClassObj(classOop, self)),
			(((longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (ValueIndex + 1))
			 && (isBytes(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self)))) {
				classLookupKey = fetchClassOfNonImm(splObj(SchedulerAssociation, self), self);
				while (1) {
					if (classLookupKey == GIV(nilObj)) {
						goto l29;
					}
					if (((assert(addressCouldBeClassObj(classLookupKey, self)),
					(((longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (KeyIndex + 1)) break;
					/* begin followField:ofObject: */
					objOop = longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
					if (((objOop & (tagMask(self))) == 0)
					 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey, objOop, self);
					}
					classLookupKey = objOop;
				}
				if (classLookupKey == GIV(nilObj)) {
					goto l27;
				}
				theClass1 = classOop;
				while (1) {
					if (theClass1 == classLookupKey) {
						goto l28;
					}
					if (!(theClass1 != GIV(nilObj))) break;
					/* begin followField:ofObject: */
					objOop1 = longAt((theClass1 + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
					if (((objOop1 & (tagMask(self))) == 0)
					 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass1, objOop1, self);
					}
					theClass1 = objOop1;
				}
	l28:	;
				/* begin space */
				putchar(' ');
				printOopShort(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self);
				print(" -> ", self);
				/* begin printHexnp: */
				n3 = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
				printf("0x%" PRIxSQINT "", n3);
	l27:	;
			}
	l29:	/* end printOopShortInner: */;
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop12;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop12, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop12 = limit;
			goto l26;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop12 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l26:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop12 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop12, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop12, self));
		if ((((((usqInt) (longAt(objOop12))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))
		 && ((maybeSelectorOfMethod(objOop12, self)) == selector)) {

			/* try and print the key of the method class association (the name of the implementing class) */
			/* begin methodClassAssociationOf: */
			offset = ((assert((((((assert(isCompiledMethod(objOop12, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop12, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
			/* begin fetchPointer:ofObject: */
			methodClassAssociation = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
			/* begin printHexnp: */
			printf("0x%" PRIxSQINT "", objOop12);
			/* begin space */
			putchar(' ');
			/* begin printOopShortInner: */
			if ((((methodClassAssociation & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(methodClassAssociation))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
			 && ((numSlotsOf(methodClassAssociation, self)) >= 2)) {
				/* begin fetchPointer:ofObject: */
				oop = longAt((methodClassAssociation + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			else {
				oop = methodClassAssociation;
			}
			if (oop & (tagMask(self))) {
				if (oop & (characterTag(self))) {
					/* begin printChar: */
					putchar('$');
					/* begin printChar: */
					aByte = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
					putchar(aByte);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					n = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
					printf("0x%" PRIxSQINT "", n);
					/* begin printChar: */
					putchar(')');
					goto l32;
				}
				if ((((oop) & 7) == 1)) {
					printNum((oop >> 3), self);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					n1 = (oop >> 3);
					printf("0x%" PRIxSQINT "", n1);
					/* begin printChar: */
					putchar(')');
					goto l32;
				}
				if (oop & (smallFloatTag(self))) {
					printFloat(dbgFloatValueOf(oop, self), self);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					printf("0x%" PRIxSQINT "", oop);
					/* begin printChar: */
					putchar(')');
					goto l32;
				}
				print("unknown immediate ", self);
				/* begin printHexnp: */
				printf("0x%" PRIxSQINT "", oop);
				goto l32;
			}
			if (!(addressCouldBeObj(oop, self))) {
				print(((oop & (8 /* allocationUnit */ - 1)) != 0
					? " is misaligned"
					: whereIs(oop, self)), self);
				goto l32;
			}
			if (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
				print(" is a free chunk", self);
				goto l32;
			}
			if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				print(" is a forwarder to ", self);
				/* begin printHexnp: */
				assert(isUnambiguouslyForwarder(oop, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent & (tagMask(self))) == 0)
				 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				n2 = referent;
				printf("0x%" PRIxSQINT "", n2);
				goto l32;
			}
			if ((((tagBits = oop & (tagMask(self)))) != 0
				? tagBits == (smallFloatTag(self))
				: ((longAt(oop)) & (classIndexMask(self))) == ClassFloatCompactIndex)) {
				printFloat(dbgFloatValueOf(oop, self), self);
				goto l32;
			}
			classOop = fetchClassOfNonImm(oop, self);
			if (!(addressCouldBeObj(classOop, self))) {
				print("a ??", self);
				goto l32;
			}
			if ((numSlotsOf(classOop, self)) == GIV(metaclassNumSlots)) {
				printNameOfClasscount(oop, 5, self);
				goto l32;
			}
			if (oop == GIV(nilObj)) {
				print("nil", self);
				goto l32;
			}
			if (oop == GIV(trueObj)) {
				print("true", self);
				goto l32;
			}
			if (oop == GIV(falseObj)) {
				print("false", self);
				goto l32;
			}
			nameLen = lengthOfNameOfClass(classOop, self);
			if (nameLen == 0) {
				print("a ??", self);
				goto l32;
			}
			name = nameOfClass(classOop, self);
			if (nameLen == 10) {
				if ((strncmp(name, "ByteString", 10)) == 0) {
					/* begin printChar: */
					putchar('\'');
					printStringOf(oop, self);
					/* begin printChar: */
					putchar('\'');
					goto l32;
				}
				if ((strncmp(name, "ByteSymbol", 10)) == 0) {
					/* begin printChar: */
					putchar('#');
					printStringOf(oop, self);
					goto l32;
				}
			}
			if ((nameLen == 9)
			 && ((strncmp(name, "Character", 9)) == 0)) {
				/* begin printChar: */
				putchar('$');
				/* begin printChar: */
				aByte1 = ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))))) >> 3);
				putchar(aByte1);
				goto l32;
			}
			print("a(n) ", self);
			for (i = 0; i < nameLen; i += 1) {
				/* begin printChar: */
				putchar(name[i]);
			}
			if ((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
			 && ((((assert(addressCouldBeClassObj(classOop, self)),
			(((longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (ValueIndex + 1))
			 && (isBytes(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self)))) {
				classLookupKey = fetchClassOfNonImm(splObj(SchedulerAssociation, self), self);
				while (1) {
					if (classLookupKey == GIV(nilObj)) {
						goto l32;
					}
					if (((assert(addressCouldBeClassObj(classLookupKey, self)),
					(((longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (KeyIndex + 1)) break;
					/* begin followField:ofObject: */
					objOop = longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
					if (((objOop & (tagMask(self))) == 0)
					 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey, objOop, self);
					}
					classLookupKey = objOop;
				}
				if (classLookupKey == GIV(nilObj)) {
					goto l30;
				}
				theClass1 = classOop;
				while (1) {
					if (theClass1 == classLookupKey) {
						goto l31;
					}
					if (!(theClass1 != GIV(nilObj))) break;
					/* begin followField:ofObject: */
					objOop1 = longAt((theClass1 + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
					if (((objOop1 & (tagMask(self))) == 0)
					 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass1, objOop1, self);
					}
					theClass1 = objOop1;
				}
	l31:	;
				/* begin space */
				putchar(' ');
				printOopShort(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self);
				print(" -> ", self);
				/* begin printHexnp: */
				n3 = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
				printf("0x%" PRIxSQINT "", n3);
	l30:	;
			}
	l32:	/* end printOopShortInner: */;
			/* begin cr */
			printf("\n");
		}
		prevPrevObj = prevObj;
		prevObj = objOop12;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop12, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop12 = GIV(freeStart);
			goto l23;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop12 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l23:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))
			 && ((maybeSelectorOfMethod(objOop11, self)) == selector)) {

				/* try and print the key of the method class association (the name of the implementing class) */
				/* begin methodClassAssociationOf: */
				offset = ((assert((((((assert(isCompiledMethod(objOop11, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(objOop11, self)),
/* begin fetchPointer:ofObject: */
longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
				/* begin fetchPointer:ofObject: */
				methodClassAssociation = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
				/* begin printHexnp: */
				printf("0x%" PRIxSQINT "", objOop11);
				/* begin space */
				putchar(' ');
				/* begin printOopShortInner: */
				if ((((methodClassAssociation & (tagMask(self))) == 0)
				 && (((((usqInt) (longAt(methodClassAssociation))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
				 && ((numSlotsOf(methodClassAssociation, self)) >= 2)) {
					/* begin fetchPointer:ofObject: */
					oop = longAt((methodClassAssociation + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				else {
					oop = methodClassAssociation;
				}
				if (oop & (tagMask(self))) {
					if (oop & (characterTag(self))) {
						/* begin printChar: */
						putchar('$');
						/* begin printChar: */
						aByte = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
						putchar(aByte);
						/* begin printChar: */
						putchar('(');
						/* begin printHexnp: */
						n = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
						printf("0x%" PRIxSQINT "", n);
						/* begin printChar: */
						putchar(')');
						goto l35;
					}
					if ((((oop) & 7) == 1)) {
						printNum((oop >> 3), self);
						/* begin printChar: */
						putchar('(');
						/* begin printHexnp: */
						n1 = (oop >> 3);
						printf("0x%" PRIxSQINT "", n1);
						/* begin printChar: */
						putchar(')');
						goto l35;
					}
					if (oop & (smallFloatTag(self))) {
						printFloat(dbgFloatValueOf(oop, self), self);
						/* begin printChar: */
						putchar('(');
						/* begin printHexnp: */
						printf("0x%" PRIxSQINT "", oop);
						/* begin printChar: */
						putchar(')');
						goto l35;
					}
					print("unknown immediate ", self);
					/* begin printHexnp: */
					printf("0x%" PRIxSQINT "", oop);
					goto l35;
				}
				if (!(addressCouldBeObj(oop, self))) {
					print(((oop & (8 /* allocationUnit */ - 1)) != 0
						? " is misaligned"
						: whereIs(oop, self)), self);
					goto l35;
				}
				if (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
					print(" is a free chunk", self);
					goto l35;
				}
				if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					print(" is a forwarder to ", self);
					/* begin printHexnp: */
					assert(isUnambiguouslyForwarder(oop, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					n2 = referent;
					printf("0x%" PRIxSQINT "", n2);
					goto l35;
				}
				if ((((tagBits = oop & (tagMask(self)))) != 0
					? tagBits == (smallFloatTag(self))
					: ((longAt(oop)) & (classIndexMask(self))) == ClassFloatCompactIndex)) {
					printFloat(dbgFloatValueOf(oop, self), self);
					goto l35;
				}
				classOop = fetchClassOfNonImm(oop, self);
				if (!(addressCouldBeObj(classOop, self))) {
					print("a ??", self);
					goto l35;
				}
				if ((numSlotsOf(classOop, self)) == GIV(metaclassNumSlots)) {
					printNameOfClasscount(oop, 5, self);
					goto l35;
				}
				if (oop == GIV(nilObj)) {
					print("nil", self);
					goto l35;
				}
				if (oop == GIV(trueObj)) {
					print("true", self);
					goto l35;
				}
				if (oop == GIV(falseObj)) {
					print("false", self);
					goto l35;
				}
				nameLen = lengthOfNameOfClass(classOop, self);
				if (nameLen == 0) {
					print("a ??", self);
					goto l35;
				}
				name = nameOfClass(classOop, self);
				if (nameLen == 10) {
					if ((strncmp(name, "ByteString", 10)) == 0) {
						/* begin printChar: */
						putchar('\'');
						printStringOf(oop, self);
						/* begin printChar: */
						putchar('\'');
						goto l35;
					}
					if ((strncmp(name, "ByteSymbol", 10)) == 0) {
						/* begin printChar: */
						putchar('#');
						printStringOf(oop, self);
						goto l35;
					}
				}
				if ((nameLen == 9)
				 && ((strncmp(name, "Character", 9)) == 0)) {
					/* begin printChar: */
					putchar('$');
					/* begin printChar: */
					aByte1 = ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))))) >> 3);
					putchar(aByte1);
					goto l35;
				}
				print("a(n) ", self);
				for (i = 0; i < nameLen; i += 1) {
					/* begin printChar: */
					putchar(name[i]);
				}
				if ((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
				 && ((((assert(addressCouldBeClassObj(classOop, self)),
				(((longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (ValueIndex + 1))
				 && (isBytes(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self)))) {
					classLookupKey = fetchClassOfNonImm(splObj(SchedulerAssociation, self), self);
					while (1) {
						if (classLookupKey == GIV(nilObj)) {
							goto l35;
						}
						if (((assert(addressCouldBeClassObj(classLookupKey, self)),
						(((longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (KeyIndex + 1)) break;
						/* begin followField:ofObject: */
						objOop = longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
						if (((objOop & (tagMask(self))) == 0)
						 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
							objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey, objOop, self);
						}
						classLookupKey = objOop;
					}
					if (classLookupKey == GIV(nilObj)) {
						goto l33;
					}
					theClass1 = classOop;
					while (1) {
						if (theClass1 == classLookupKey) {
							goto l34;
						}
						if (!(theClass1 != GIV(nilObj))) break;
						/* begin followField:ofObject: */
						objOop1 = longAt((theClass1 + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
						if (((objOop1 & (tagMask(self))) == 0)
						 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
							objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass1, objOop1, self);
						}
						theClass1 = objOop1;
					}
	l34:	;
					/* begin space */
					putchar(' ');
					printOopShort(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self);
					print(" -> ", self);
					/* begin printHexnp: */
					n3 = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
					printf("0x%" PRIxSQINT "", n3);
	l33:	;
				}
	l35:	/* end printOopShortInner: */;
				/* begin cr */
				printf("\n");
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l24;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l24:	/* end objectAfter:limit: */;
	}
	}

	/* StackInterpreter>>#printLocalSP:LocalFP:LocalIP:CurrentBytecode: */
static void NoDbgRegParms
printLocalSPLocalFPLocalIPCurrentBytecode(char *anSP, char *anFP, char *anIP, sqInt byteCode, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printf("Step\n");
	printf("SP: %p\n",(void *) anSP);
	printf("FP: %p\n",(void *) anFP);
	printf("IP: %p\n",(void *) anIP);
	printf("Method: %d\n", GIV(method));
	/* -baseHeader (8) + 1 0base adresse (overall - 7)*/
	printf("IP-method: %p %d\n",(void *) GIV(instructionPointer) - GIV(method) - 7, (int) anIP - GIV(method) - 7);
	printf("Bytecode: %x\n",(char) byteCode);
	printf("PrimitiveFunctionPointer: %p\n",GIV(primitiveFunctionPointer));
	
}

	/* StackInterpreter>>#printMethodCache */
void
printMethodCache(struct foo * self)
{
	printMethodCacheFor(-1, self);
}

	/* StackInterpreter>>#printMethodDictionaryOf: */
void
printMethodDictionaryOf(sqInt behavior, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt dictionary;
    sqInt iLimiT;
    sqInt index;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	/* begin printMethodDictionary: */
	dictionary = longAt((behavior + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	methodArray = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
	for (index = SelectorStart, iLimiT = ((numSlotsOf(dictionary, self)) - 1); index <= iLimiT; index += 1) {
		/* begin fetchPointer:ofObject: */
		selector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
		if (selector != GIV(nilObj)) {
			/* begin fetchPointer:ofObject: */
			meth = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord(self))))));
			printOopShort(selector, self);
			print(" => ", self);
			printOopShort(meth, self);
			print(" (", self);
			printHex(selector, self);
			print(" => ", self);
			printHex(meth, self);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printMethodDictionary: */
void
printMethodDictionary(sqInt dictionary, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt iLimiT;
    sqInt index;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	/* begin fetchPointer:ofObject: */
	methodArray = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord(self))))));
	for (index = SelectorStart, iLimiT = ((numSlotsOf(dictionary, self)) - 1); index <= iLimiT; index += 1) {
		/* begin fetchPointer:ofObject: */
		selector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
		if (selector != GIV(nilObj)) {
			/* begin fetchPointer:ofObject: */
			meth = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord(self))))));
			printOopShort(selector, self);
			print(" => ", self);
			printOopShort(meth, self);
			print(" (", self);
			printHex(selector, self);
			print(" => ", self);
			printHex(meth, self);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

	/* StackInterpreter>>#printNameOfClass:count: */
static void NoDbgRegParms
printNameOfClasscount(sqInt classOop, sqInt cnt, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;

	if (!(GIV(classNameIndex))) {
		print("??nil cnidx??", self);
		return;
	}
	if ((classOop == null)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		print("bad class", self);
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(classOop, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots1 = byteAt(classOop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord(self)))))), cnt - 1, self);
		print(" class", self);
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			print("bad class", self);
		}
		else {
			printStringOf(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord(self)))))), self);
		}
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#printNum: */
static void NoDbgRegParms
printNum(sqInt n, struct foo * self)
{
	printf("%ld", (long) n);
}

	/* StackInterpreter>>#printOopShort: */
static void NoDbgRegParms
printOopShort(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt aByte1;
    sqInt classLookupKey;
    sqInt classOop;
    sqInt i;
    usqInt n;
    usqInt n1;
    usqInt n2;
    usqInt n3;
    char *name;
    sqInt nameLen;
    sqInt objOop;
    sqInt objOop1;
    sqInt referent;
    sqInt tagBits;
    sqInt theClass1;

	/* begin printOopShortInner: */
	if (oop & (tagMask(self))) {
		if (oop & (characterTag(self))) {
			/* begin printChar: */
			putchar('$');
			/* begin printChar: */
			aByte = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
			putchar(aByte);
			/* begin printChar: */
			putchar('(');
			/* begin printHexnp: */
			n = ((usqInt) (((usqInt)oop))) >> (numTagBits(self));
			printf("0x%" PRIxSQINT "", n);
			/* begin printChar: */
			putchar(')');
			goto l17;
		}
		if ((((oop) & 7) == 1)) {
			printNum((oop >> 3), self);
			/* begin printChar: */
			putchar('(');
			/* begin printHexnp: */
			n1 = (oop >> 3);
			printf("0x%" PRIxSQINT "", n1);
			/* begin printChar: */
			putchar(')');
			goto l17;
		}
		if (oop & (smallFloatTag(self))) {
			printFloat(dbgFloatValueOf(oop, self), self);
			/* begin printChar: */
			putchar('(');
			/* begin printHexnp: */
			printf("0x%" PRIxSQINT "", oop);
			/* begin printChar: */
			putchar(')');
			goto l17;
		}
		print("unknown immediate ", self);
		/* begin printHexnp: */
		printf("0x%" PRIxSQINT "", oop);
		goto l17;
	}
	if (!(addressCouldBeObj(oop, self))) {
		print(((oop & (8 /* allocationUnit */ - 1)) != 0
			? " is misaligned"
			: whereIs(oop, self)), self);
		goto l17;
	}
	if (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
		print(" is a free chunk", self);
		goto l17;
	}
	if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		print(" is a forwarder to ", self);
		/* begin printHexnp: */
		assert(isUnambiguouslyForwarder(oop, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		n2 = referent;
		printf("0x%" PRIxSQINT "", n2);
		goto l17;
	}
	if ((((tagBits = oop & (tagMask(self)))) != 0
		? tagBits == (smallFloatTag(self))
		: ((longAt(oop)) & (classIndexMask(self))) == ClassFloatCompactIndex)) {
		printFloat(dbgFloatValueOf(oop, self), self);
		goto l17;
	}
	classOop = fetchClassOfNonImm(oop, self);
	if (!(addressCouldBeObj(classOop, self))) {
		print("a ??", self);
		goto l17;
	}
	if ((numSlotsOf(classOop, self)) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5, self);
		goto l17;
	}
	if (oop == GIV(nilObj)) {
		print("nil", self);
		goto l17;
	}
	if (oop == GIV(trueObj)) {
		print("true", self);
		goto l17;
	}
	if (oop == GIV(falseObj)) {
		print("false", self);
		goto l17;
	}
	nameLen = lengthOfNameOfClass(classOop, self);
	if (nameLen == 0) {
		print("a ??", self);
		goto l17;
	}
	name = nameOfClass(classOop, self);
	if (nameLen == 10) {
		if ((strncmp(name, "ByteString", 10)) == 0) {
			/* begin printChar: */
			putchar('\'');
			printStringOf(oop, self);
			/* begin printChar: */
			putchar('\'');
			goto l17;
		}
		if ((strncmp(name, "ByteSymbol", 10)) == 0) {
			/* begin printChar: */
			putchar('#');
			printStringOf(oop, self);
			goto l17;
		}
	}
	if ((nameLen == 9)
	 && ((strncmp(name, "Character", 9)) == 0)) {
		/* begin printChar: */
		putchar('$');
		/* begin printChar: */
		aByte1 = ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))))) >> 3);
		putchar(aByte1);
		goto l17;
	}
	print("a(n) ", self);
	for (i = 0; i < nameLen; i += 1) {
		/* begin printChar: */
		putchar(name[i]);
	}
	if ((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)
	 && ((((assert(addressCouldBeClassObj(classOop, self)),
	(((longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (ValueIndex + 1))
	 && (isBytes(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self)))) {
		classLookupKey = fetchClassOfNonImm(splObj(SchedulerAssociation, self), self);
		while (1) {
			if (classLookupKey == GIV(nilObj)) {
				goto l17;
			}
			if (((assert(addressCouldBeClassObj(classLookupKey, self)),
			(((longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3)) & ((1U << (fixedFieldsFieldWidth(self))) - 1))) == (KeyIndex + 1)) break;
			/* begin followField:ofObject: */
			objOop = longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
			if (((objOop & (tagMask(self))) == 0)
			 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey, objOop, self);
			}
			classLookupKey = objOop;
		}
		if (classLookupKey == GIV(nilObj)) {
			goto l7;
		}
		theClass1 = classOop;
		while (1) {
			if (theClass1 == classLookupKey) {
				goto l8;
			}
			if (!(theClass1 != GIV(nilObj))) break;
			/* begin followField:ofObject: */
			objOop1 = longAt((theClass1 + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
			if (((objOop1 & (tagMask(self))) == 0)
			 && (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass1, objOop1, self);
			}
			theClass1 = objOop1;
		}
	l8:	;
		/* begin space */
		putchar(' ');
		printOopShort(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord(self)))))), self);
		print(" -> ", self);
		/* begin printHexnp: */
		n3 = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
		printf("0x%" PRIxSQINT "", n3);
	l7:	;
	}
	l17:	/* end printOopShortInner: */;
	flush(self);
}

	/* StackInterpreter>>#printOop: */
sqInt
printOop(sqInt oop, struct foo * self)
{
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt cls;
    sqInt column;
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt lastIndex;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt startIP;

	if (oop & (tagMask(self))) {
		return shortPrintOop(oop, self);
	}
	printHex(oop, self);
	if (!(addressCouldBeObj(oop, self))) {
		return (print(((oop & (8 /* allocationUnit */ - 1)) != 0
					? " is misaligned"
					: whereIs(oop, self)), self),
			/* begin cr */
			printf("\n"));
	}
	if (((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))) {
		print(" is a free chunk of size ", self);
		printNum((assert(isFreeObject(oop, self)),
		bytesInObject(oop, self)), self);
		print(" 0th: ", self);
		printHex(longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self)))), self);
		printHeaderTypeOf(oop, self);
		/* begin cr */
		printf("\n");
		return null;
	}
	if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		print(" is a forwarded object to ", self);
		printHex(followForwarded(oop, self), self);
		print(" of slot size ", self);
		printNum(numSlotsOfAny(oop, self), self);
		printHeaderTypeOf(oop, self);
		/* begin cr */
		printf("\n");
		return null;
	}
	print(": a(n) ", self);
	printNameOfClasscount((cls = fetchClassOfNonImm(oop, self)), 5, self);
	if (cls == (splObj(ClassFloat, self))) {
		return (/* begin cr */
			printf("\n"),
			printFloat(dbgFloatValueOf(oop, self), self),
			/* begin cr */
			printf("\n"));
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	if (fmt > 5 /* lastPointerFormat */) {
		print(" nbytes ", self);
		printNum(numBytesOf(oop, self), self);
	}
	/* begin cr */
	printf("\n");
	if (((fmt >= (firstLongFormat(self))) && (fmt <= ((firstCompiledMethodFormat(self)) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, splObj(ClassAlien, self), self)) {
			print(" datasize ", self);
			printNum(sizeOfAlienData(oop, self), self);
			print(((longAt(oop + BaseHeaderSize)) < 0
				? " indirect @ "
				: ((longAt(oop + BaseHeaderSize)) == 0
						? " pointer @ "
						: " direct @ ")), self);
			return (printHex(((usqInt)(startOfAlienData(oop, self))), self),
				/* begin cr */
				printf("\n"));
		}
		if (((((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstLongFormat(self))) && (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= ((firstShortFormat(self)) - 1)))) {
			lastIndex = ((64 < ((numBytesOf(oop, self)) / BytesPerWord)) ? 64 : ((numBytesOf(oop, self)) / BytesPerWord));
			if (lastIndex > 0) {
				for (index = 1; index <= lastIndex; index += 1) {
					/* begin space */
					putchar(' ');
					printHex(((unsigned int) (long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2)))))), self);
					if ((index % 5 /* elementsPerPrintOopLine */) == 0) {
						/* begin cr */
						printf("\n");
					}
				}
				if (!((lastIndex % 5 /* elementsPerPrintOopLine */) == 0)) {
					/* begin cr */
					printf("\n");
				}
			}
			return 0;
		}
		return (printStringOf(oop, self),
			/* begin cr */
			printf("\n"));
	}
	startIP = (((lastPointerOf(oop, self)) + BytesPerOop) - BaseHeaderSize) / BytesPerOop;
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self)))))), self);
			/* begin space */
			putchar(' ');
			if ((index % 5 /* elementsPerPrintOopLine */) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((lastIndex % 5 /* elementsPerPrintOopLine */) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf:format: */
		fmt1 = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
		/* begin numSlotsOfAny: */
		numSlots1 = byteAt(oop + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt1 <= 5 /* ephemeronFormat */) {
			lastIndex = numSlots;
			goto l3;
		}
		if (fmt1 >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			lastIndex = (numSlots << (shiftForWord(self))) - (fmt1 & 7);
			goto l3;
		}
		if (fmt1 >= (firstShortFormat(self))) {
			lastIndex = (numSlots << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
			goto l3;
		}
		if (fmt1 >= (firstLongFormat(self))) {
			lastIndex = (numSlots << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
			goto l3;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
			lastIndex = numSlots;
			goto l3;
		}
		lastIndex = 0;
	l3:	/* end lengthOf:format: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08" PRIxSQPTR ": ", (usqIntptr_t)(oop+BaseHeaderSize+index-1));
			}
			/* begin fetchByte:ofObject: */
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", (int)byte,(int)byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > 64) {
			print("...", self);
			/* begin cr */
			printf("\n");
		}
	}
	return 0;
}

	/* StackInterpreter>>#printProcessStack: */
void
printProcessStack(sqInt aProcess, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctx;
    sqInt objOop;
    sqInt tagBits;

	/* begin cr */
	printf("\n");
	printNameOfClasscount((((tagBits = aProcess & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(aProcess, self)), 5, self);
	/* begin space */
	putchar(' ');
	printHex(aProcess, self);
	print(" priority ", self);
	printNum(quickFetchIntegerofObject(PriorityIndex, aProcess, self), self);
	/* begin cr */
	printf("\n");
	/* begin followField:ofObject: */
	objOop = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuspendedContextIndex, aProcess, objOop, self);
	}
	ctx = objOop;
	if (!(ctx == GIV(nilObj))) {
		printCallStackOfcurrentFP(ctx, GIV(framePointer), self);
	}
}

	/* StackInterpreter>>#printProcsOnList: */
sqInt
printProcsOnList(sqInt procList, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstProc;
    sqInt objOop;
    sqInt proc;

	proc = (firstProc = followFieldofObject(FirstLinkIndex, procList, self));
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc, self);
		/* begin followField:ofObject: */
		objOop = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))));
		if (((objOop & (tagMask(self))) == 0)
		 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			objOop = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, proc, objOop, self);
		}
		proc = objOop;
		if (proc == firstProc) {
			warning("circular process list!!");
			return null;
		}
	}
	return 0;
}

	/* StackInterpreter>>#printStackCallStackOf: */
sqInt
printStackCallStackOf(sqInt aContextOrProcessOrFrame, struct foo * self)
{
    sqInt context;
    char *theFP;

	if (addressCouldBeObj(aContextOrProcessOrFrame, self)) {
		if ((((aContextOrProcessOrFrame & (tagMask(self))) == 0)
		 && (((longAt(aContextOrProcessOrFrame)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))
		 && (checkIsStillMarriedContextcurrentFP(aContextOrProcessOrFrame, null, self))) {
			return printStackCallStackOf(((sqInt)(frameOfMarriedContext(aContextOrProcessOrFrame, self))), self);
		}
		if (couldBeProcess(aContextOrProcessOrFrame, self)) {
			return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self)))))), self);
		}
		return null;
	}
	theFP = ((void *)aContextOrProcessOrFrame);
	while(1) {
		context = shortReversePrintFrameAndCallers(theFP, self);
		if (!((((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
			 && (((theFP = frameOfMarriedContext(context, self)),
			checkIsStillMarriedContextcurrentFP(context, theFP, self))))) {
			return null;
		}
	}
	return 0;
}

	/* StackInterpreter>>#printStackPageList */
void
printStackPageList(struct foo * self)
{
    StackPage *page;

	page = mostRecentlyUsedPage(self);
	do {
		/* begin printStackPage: */
		printStackPageuseCount(page, -1, self);
		/* begin cr */
		printf("\n");
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage(self)));
}

	/* StackInterpreter>>#printStackPageListInUse */
void
printStackPageListInUse(struct foo * self)
{
    sqInt n;
    StackPage *page;

	page = mostRecentlyUsedPage(self);
	n = 0;
	do {
		if (!(isFree(page, self))) {
			printStackPageuseCount(page, (n += 1), self);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage(self)));
}

	/* StackInterpreter>>#printStackPages */
void
printStackPages(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *page;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin printStackPage: */
		page = stackPageAtpages(i, GIV(pages), self);
		printStackPageuseCount(page, -1, self);
		/* begin cr */
		printf("\n");
	}
}

	/* StackInterpreter>>#printStackPagesInUse */
void
printStackPagesInUse(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt n;

	n = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		if (!(isFree(stackPageAt(i, self), self))) {
			printStackPageuseCount(stackPageAt(i, self), (n += 1), self);
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printStackPage:useCount: */
static void NoDbgRegParms
printStackPageuseCount(StackPage *page, sqInt n, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *p;
    void *p1;
    void *p2;
    void *p3;
    void *p4;
    void *p5;
    void *p6;
    void *p7;
    void *p8;

	print("page ", self);
	/* begin printHexPtr: */
	printHex(oopForPointer(page), self);
	print(" (", self);
	printNum(pageIndexForstackMemorybytesPerPage((page->realStackLimit), GIV(stackMemory), GIV(bytesPerPage), self), self);
	if (n >= 0) {
		print(",", self);
		printNum(n, self);
	}
	print(")  (trace: ", self);
	printNum((page->trace), self);
	/* begin printChar: */
	putchar(')');
	if (isFree(page, self)) {
		print(" (free)", self);
	}
	if (page == (mostRecentlyUsedPage(self))) {
		print(" (MRU)", self);
	}
	if (((page->prevPage)) == (mostRecentlyUsedPage(self))) {
		print(" (LRU)", self);
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	putchar('	');
	print("ba: ", self);
	/* begin printHexPtr: */
	p3 = (page->baseAddress);
	printHex(oopForPointer(p3), self);
	print(" - sl: ", self);
	/* begin printHexPtr: */
	p4 = (page->realStackLimit);
	printHex(oopForPointer(p4), self);
	print(" - sl-so: ", self);
	/* begin printHexPtr: */
	p5 = ((page->realStackLimit)) - ((FrameSlots + 64) * BytesPerWord);
	printHex(oopForPointer(p5), self);
	print(" - la:", self);
	/* begin printHexPtr: */
	p6 = (page->lastAddress);
	printHex(oopForPointer(p6), self);
	if (!(isFree(page, self))) {
		/* begin cr */
		printf("\n");
		/* begin tab */
		putchar('	');
		print("baseFP ", self);
		/* begin printHexPtr: */
		p = (page->baseFP);
		printHex(oopForPointer(p), self);
		/* begin tab */
		putchar('	');
		print("headFP ", self);
		/* begin printHexPtr: */
		p1 = (page->headFP);
		printHex(oopForPointer(p1), self);
		/* begin tab */
		putchar('	');
		print("headSP ", self);
		/* begin printHexPtr: */
		p2 = (page->headSP);
		printHex(oopForPointer(p2), self);
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	putchar('	');
	print("prev ", self);
	/* begin printHexPtr: */
	p7 = ((void *) (page->prevPage));
	printHex(oopForPointer(p7), self);
	print(" (", self);
	printNum(pageIndexForstackMemorybytesPerPage((((page->prevPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage), self), self);
	/* begin printChar: */
	putchar(')');
	/* begin tab */
	putchar('	');
	print("next ", self);
	/* begin printHexPtr: */
	p8 = ((void *) (page->nextPage));
	printHex(oopForPointer(p8), self);
	print(" (", self);
	printNum(pageIndexForstackMemorybytesPerPage((((page->nextPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage), self), self);
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printStackReferencesTo: */
void
printStackReferencesTo(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		if (!(((thePage->baseFP)) == 0)) {
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					if (oop == (longAt(theSP))) {
						print("FP: ", self);
						/* begin printHexnp: */
						printf("0x%" PRIxSQINT "", ((usqInt) theFP));
						print(" @ ", self);
						/* begin printHexnp: */
						printf("0x%" PRIxSQINT "", ((usqInt) theSP));
						/* begin cr */
						printf("\n");
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					if (oop == (longAt(theFP + FoxThisContext))) {
						print("FP: ", self);
						/* begin printHexnp: */
						printf("0x%" PRIxSQINT "", ((usqInt) theFP));
						print(" CTXT", self);
						/* begin cr */
						printf("\n");
					}
				}
				if (oop == (longAt(theFP + FoxMethod))) {
					print("FP: ", self);
					/* begin printHexnp: */
					printf("0x%" PRIxSQINT "", ((usqInt) theFP));
					print(" MTHD", self);
					/* begin cr */
					printf("\n");
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerContext */
			theSP = theFP + FoxCallerSavedIP;
			while (theSP <= ((thePage->baseAddress))) {
				if (oop == (longAt(theSP))) {
					print("FP: ", self);
					/* begin printHexnp: */
					printf("0x%" PRIxSQINT "", ((usqInt) theFP));
					print(" @ ", self);
					/* begin printHexnp: */
					printf("0x%" PRIxSQINT "", ((usqInt) theSP));
					/* begin cr */
					printf("\n");
				}
				theSP += BytesPerWord;
			}
		}
	}
}

	/* StackInterpreter>>#printStringOf: */
static void NoDbgRegParms
printStringOf(sqInt oop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt cnt;
    sqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if (oop & (tagMask(self))) {
		return;
	}
	if (!(addressCouldBeObj(oop, self))) {
		return;
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	if (fmt < (firstByteFormat(self))) {
		return;
	}
	cnt = ((((max = 128)) < ((len = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)))) ? ((max = 128)) : ((len = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, splObj(ClassByteArray, self), GIV(classByteArrayCompactIndex), self))
	 || (((oop & (tagMask(self))) == 0)
	 && ((((usqInt)(((longAt(oop)) & (classIndexMask(self))) - ClassLargeNegativeIntegerCompactIndex))) <= 1))) {
		while (i < cnt) {
			printHex(byteAt((oop + BaseHeaderSize) + i), self);
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			if ((byteAt((oop + BaseHeaderSize) + i)) == 13) {
				print("<CR>", self);
				if ((i + 1) < len) {
					print("...", self);
				}
				return;
			}
			/* begin printChar: */
			aByte = byteAt((oop + BaseHeaderSize) + i);
			putchar(aByte);
			i += 1;
		}
	}
	if (len > max) {
		print("...", self);
	}
	flush(self);
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#print: */
void
print(char *s, struct foo * self)
{
	fputs(s, stdout);
}

	/* StackInterpreter>>#pushBool: */
void
pushBool(sqInt trueOrFalse, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#pushedReceiverOrClosureOfFrame: */
static sqInt NoDbgRegParms
pushedReceiverOrClosureOfFrame(char *theFP, struct foo * self)
{
	return longAt(theFP + (frameStackedReceiverOffset(theFP, self)));
}

	/* StackInterpreter>>#pushFloat: */
void
pushFloat(double f, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = floatObjectOf(f, self);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

	/* StackInterpreter>>#pushInteger: */
sqInt
pushInteger(sqInt integerValue, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)integerValue << 3) | 1));
	GIV(stackPointer) = sp;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#push: */
void
push(sqInt object, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Append aLong to aFile in this platform's 'natural' byte order. aLong is
	either 32 or 64 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putLong:toFile: */
static void NoDbgRegParms
putLongtoFile(sqInt aLong, sqImageFile aFile, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aLong), sizeof(sqInt), 1, aFile, self);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Append the 16-bit aShort to aFile in this platform's 'natural' byte order.
	(Bytes will be swapped, if necessary, when the image is read on a
	different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putShort:toFile: */
static void NoDbgRegParms
putShorttoFile(short aShort, sqImageFile aFile, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aShort), sizeof(short), 1, aFile, self);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Save the given process on the scheduler process list for its priority,
	adding to the back if yieldImplicitly or to the front if not
	yieldImplicitly. 
 */

	/* StackInterpreter>>#putToSleep:yieldingIf: */
static void NoDbgRegParms
putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	priority = (oop >> 3);
	if ((GIV(highestRunnableProcessPriority) != 0)
	 && (priority > GIV(highestRunnableProcessPriority))) {
		GIV(highestRunnableProcessPriority) = priority;
	}
	/* begin fetchPointer:ofObject: */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	processLists = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	processList = longAt((processLists + BaseHeaderSize) + (((sqInt)((usqInt)((priority - 1)) << (shiftForWord(self))))));
	if (yieldImplicitly) {
		addLastLinktoList(aProcess, processList, self);
	}
	else {
		/* begin addFirstLink:toList: */
		assert(!(isForwarded(processList, self)));
		assert((fetchPointerofObject(NextLinkIndex, aProcess, self)) == (nilObject(self)));
		/* begin fetchPointer:ofObject: */
		firstLink = longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))));
		assert(firstLink != aProcess);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(processList, self)));
		if ((assert(isNonImmediate(processList, self)),
		oopisGreaterThanOrEqualTo(processList, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((aProcess & (tagMask(self))) == 0)
			 && (oopisLessThan(aProcess, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(processList))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(processList, self);
				}
			}
		}
		longAtput((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))), aProcess);
		if (firstLink == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(processList, self)));
			if ((assert(isNonImmediate(processList, self)),
			oopisGreaterThanOrEqualTo(processList, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((aProcess & (tagMask(self))) == 0)
				 && (oopisLessThan(aProcess, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(processList))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(processList, self);
					}
				}
			}
			longAtput((processList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))), aProcess);
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aProcess, self)));
			if ((assert(isNonImmediate(aProcess, self)),
			oopisGreaterThanOrEqualTo(aProcess, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((firstLink & (tagMask(self))) == 0)
				 && (oopisLessThan(firstLink, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(aProcess))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(aProcess, self);
					}
				}
			}
			longAtput((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))), firstLink);
		}
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aProcess, self)));
		if ((assert(isNonImmediate(aProcess, self)),
		oopisGreaterThanOrEqualTo(aProcess, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((processList & (tagMask(self))) == 0)
			 && (oopisLessThan(processList, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aProcess))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(aProcess, self);
				}
			}
		}
		longAtput((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord(self))))), processList);
	}
}


/*	Append aWord32 to aFile in this platform's 'natural' byte order. aWord32
	is 32 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putWord32:toFile: */
static void NoDbgRegParms
putWord32toFile(int aWord32, sqImageFile aFile, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aWord32), 4, 1, aFile, self);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Return the integer value of the field without verifying that it is an
	integer value! For use in time-critical places where the integer-ness of
	the field can be guaranteed.
 */

	/* StackInterpreter>>#quickFetchInteger:ofObject: */
static sqInt NoDbgRegParms
quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self)
{
    sqInt oop;

	/* begin fetchPointer:ofObject: */
	oop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	return (oop >> 3);
}


/*	Anwer true if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

	/* StackInterpreter>>#readableFormat: */
sqInt
readableFormat(sqInt imageVersion)
{
	return (imageVersion == 68021 /* imageFormatVersion */)
	 || (0);
}


/*	Read an image from the given file stream, allocating an amount of memory
	to its object heap.
	
	V3: desiredHeapSize is the total size of the heap. Fail if the image has
	an unknown format or
	requires more than the specified amount of memory.
	
	Spur: desiredHeapSize is ignored; this routine will attempt to provide at
	least extraVMMemory's
	ammount of free space after the image is loaded, taking any free space in
	teh image into account.
	extraVMMemory is stored in the image header and is accessible as
	vmParameterAt: 23. If
	extraVMMemory is 0, the value defaults to the default grow headroom. Fail
	if the image has an
	unknown format or if sufficient memory cannot be allocated.
	
	Details: This method detects when the image was stored on a machine with
	the opposite byte
	ordering from this machine and swaps the bytes automatically. Furthermore,
	it allows the header
	information to start 512 bytes into the file, since some file transfer
	programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix
	area could also be used to store an exec command on Unix systems, allowing
	one to launch
	Smalltalk by invoking the image name as a command. */

	/* StackInterpreter>>#readImageFromFile:HeapSize:StartingAtV2: */
size_t
readImageFromFileHeapSizeStartingAtV2(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocationReserve;
    sqInt anObject;
    sqInt aValue;
    sqInt bit;
    sqInt bytes;
    sqInt bytesRead;
    sqInt bytesToShift;
    size_t dataSize;
    sqInt firstSegSize;
    sqInt freeOldSpaceInImage;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt headroom;
    sqInt headroom1;
    usqInt heapSize;
    usqInt heapSize1;
    sqInt i;
    sqInt i1;
    usqInt minimumMemory;
    sqInt objOop;
    sqInt oldBaseAddr;
    sqInt seed;
    sqInt swapBytes;
    sqInt w;
    int w1;
    unsigned short w10;
    unsigned short w11;
    sqInt w12;
    sqInt w13;
    sqInt w14;
    sqInt w2;
    sqInt w3;
    sqInt w4;
    sqInt w5;
    int w6;
    unsigned short w7;
    unsigned short w8;
    int w9;


	/* guess Metaclass instSize */
	GIV(metaclassNumSlots) = 6;

	/* guess (Class instVarIndexFor: 'name' ifAbsent: []) - 1 */
	GIV(classNameIndex) = 6;
	swapBytes = checkImageVersionFromstartingAt(f, imageOffset, self);

	/* record header start position */
	headerStart = (sqImageFilePosition(f, self)) - 4;
	/* begin getWord32FromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(int), 1, f, self);
	headerSize = (swapBytes
		? SQ_SWAP_4_BYTES(w1)
		: w1);
	/* begin getLongFromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(w2), 1, f, self);
	dataSize = ((sqInt) ((swapBytes
	? (/* begin byteSwapped: */
		SQ_SWAP_8_BYTES(w2))
	: w2)));
	/* begin getLongFromFile:swap: */
	w3 = 0;
	sqImageFileRead((&w3), sizeof(w3), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		oldBaseAddr = SQ_SWAP_8_BYTES(w3);
	}
	else {
		oldBaseAddr = w3;
	}
	/* begin specialObjectsOop: */
	w13 = 0;
	sqImageFileRead((&w13), sizeof(w13), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		anObject = SQ_SWAP_8_BYTES(w13);
	}
	else {
		anObject = w13;
	}
	GIV(specialObjectsOop) = anObject;
	/* begin lastHash: */
	w14 = 0;
	sqImageFileRead((&w14), sizeof(w14), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		seed = SQ_SWAP_8_BYTES(w14);
	}
	else {
		seed = w14;
	}
	GIV(lastHash) = seed;
	/* begin getLongFromFile:swap: */
	w4 = 0;
	sqImageFileRead((&w4), sizeof(w4), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		GIV(savedWindowSize) = SQ_SWAP_8_BYTES(w4);
	}
	else {
		GIV(savedWindowSize) = w4;
	}
	/* begin getLongFromFile:swap: */
	w5 = 0;
	sqImageFileRead((&w5), sizeof(w5), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		headerFlags = SQ_SWAP_8_BYTES(w5);
	}
	else {
		headerFlags = w5;
	}
	/* begin setImageHeaderFlagsFrom: */

	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;

	/* processHasThreadId := headerFlags anyMask: 4. specific to CoInterpreterMT */
	/* flagInterpretedMethods := headerFlags anyMask: 8. specific to CoInterpreter */
	GIV(imageFloatsBigEndian) = ((headerFlags & 2) == 0
		? 1
		: 0);

	/* noThreadingOfGUIThread := headerFlags anyMask: 32. specific to CoInterpreterMT */
	GIV(preemptionYields) = (headerFlags & 16) == 0;
	GIV(newFinalization) = headerFlags & 64;
	sendWheelEvents = headerFlags & 128;
	/* begin getWord32FromFile:swap: */
	w6 = 0;
	sqImageFileRead((&w6), sizeof(int), 1, f, self);
	extraVMMemory = (swapBytes
		? SQ_SWAP_4_BYTES(w6)
		: w6);
	/* begin getShortFromFile:swap: */
	w7 = 0;
	sqImageFileRead((&w7), sizeof(unsigned short), 1, f, self);
	hdrNumStackPages = (swapBytes
		? ((((usqInt) w7) >> 8) & 0xFF) | (((sqInt)((usqInt)((w7 & 0xFF)) << 8)))
		: w7);
	GIV(numStackPages) = (desiredNumStackPages != 0
		? desiredNumStackPages
		: (hdrNumStackPages == 0
				? defaultNumStackPages(self)
				: hdrNumStackPages));

	/* pad to word boundary.  This slot can be used for anything else that will fit in 16 bits.
	   It is used for the cog code size in Cog.  Preserve it to be polite to other VMs. */
	desiredNumStackPages = hdrNumStackPages;
	/* begin getShortFromFile:swap: */
	w8 = 0;
	sqImageFileRead((&w8), sizeof(unsigned short), 1, f, self);
	GIV(theUnknownShort) = (swapBytes
		? ((((usqInt) w8) >> 8) & 0xFF) | (((sqInt)((usqInt)((w8 & 0xFF)) << 8)))
		: w8);
	/* begin getWord32FromFile:swap: */
	w9 = 0;
	sqImageFileRead((&w9), sizeof(int), 1, f, self);
	hdrEdenBytes = (swapBytes
		? SQ_SWAP_4_BYTES(w9)
		: w9);
	/* begin edenBytes: */
	bytes = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
				? defaultEdenBytes(self)
				: hdrEdenBytes));
	GIV(edenBytes) = bytes;
	desiredEdenBytes = hdrEdenBytes;
	/* begin getShortFromFile:swap: */
	w10 = 0;
	sqImageFileRead((&w10), sizeof(unsigned short), 1, f, self);
	hdrMaxExtSemTabSize = (swapBytes
		? ((((usqInt) w10) >> 8) & 0xFF) | (((sqInt)((usqInt)((w10 & 0xFF)) << 8)))
		: w10);
	if (hdrMaxExtSemTabSize != 0) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}
	/* begin getShortFromFile:swap: */
	w11 = 0;
	sqImageFileRead((&w11), sizeof(unsigned short), 1, f, self);
	GIV(the2ndUnknownShort) = (swapBytes
		? ((((usqInt) w11) >> 8) & 0xFF) | (((sqInt)((usqInt)((w11 & 0xFF)) << 8)))
		: w11);
	/* begin getLongFromFile:swap: */
	w12 = 0;
	sqImageFileRead((&w12), sizeof(w12), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		firstSegSize = SQ_SWAP_8_BYTES(w12);
	}
	else {
		firstSegSize = w12;
	}
	/* begin firstSegmentSize: */
	GIV(firstSegmentSize) = firstSegSize;
	allocationReserve = interpreterAllocationReserveBytes(self);
	minimumMemory = (dataSize + GIV(edenBytes)) + allocationReserve;
	/* begin getLongFromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(w), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		freeOldSpaceInImage = SQ_SWAP_8_BYTES(w);
	}
	else {
		freeOldSpaceInImage = w;
	}
	/* begin initialHeadroom:givenFreeOldSpaceInImage: */
	headroom1 = (extraVMMemory == 0
		? (!(GIV(growHeadroom))
				? (16 * 1024) * 1024
				: GIV(growHeadroom))
		: extraVMMemory);
	if (freeOldSpaceInImage >= headroom1) {
		headroom = 0;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 7) / 8)) {
		headroom = headroom1 / 8;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 3) / 4)) {
		headroom = headroom1 / 4;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 5) / 8)) {
		headroom = (headroom1 * 3) / 8;
		goto l2;
	}
	if (freeOldSpaceInImage >= (headroom1 / 2)) {
		headroom = headroom1 / 2;
		goto l2;
	}
	headroom = headroom1;
	l2:	/* end initialHeadroom:givenFreeOldSpaceInImage: */;
	/* begin roundUpHeapSize: */
	heapSize1 = ((dataSize + headroom) + GIV(edenBytes)) + ((headroom > allocationReserve
	? 0
	: allocationReserve));
	bit = (((highBit(heapSize1, self)) - 1) * 3) / 4;
	heapSize = (heapSize1 & ((1ULL << bit) - 1)
		? (((heapSize1 | ((1ULL << bit) - 1)) - ((1ULL << bit) - 1))) + (1ULL << bit)
		: heapSize1);
	/* begin memory: */
	aValue = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	GIV(memory) = aValue;
	if (!(memory(self))) {
		insufficientMemoryAvailableError();
	}
	setHeapBasememoryLimitendOfMemory(memory(self), (memory(self)) + heapSize, (memory(self)) + dataSize, self);
	sqImageFileSeek(f, headerStart + headerSize, self);
	bytesRead = readHeapFromImageFiledataBytes(f, dataSize, self);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes, self);
	bytesToShift = GIV(oldSpaceStart) - oldBaseAddr;
	/* begin initializeInterpreterV2: */
	GIV(interpreterProxy) = sqGetInterpreterProxy(self);
	dummyReferToProxy(self);
	initializeObjectMemory(bytesToShift, self);
	/* begin checkAssumedCompactClasses */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self))))))) != ((assert(((ClassArrayCompactIndex >= 1) && (ClassArrayCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArrayCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("Array", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord(self))))))) != ((assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeIntegerCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("LargeNegativeInteger", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveInteger) << (shiftForWord(self))))))) != ((assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveIntegerCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("LargePositiveInteger", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloat) << (shiftForWord(self))))))) != ((assert(((ClassFloatCompactIndex >= 1) && (ClassFloatCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloatCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("Float", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord(self))))))) != ((assert(((ClassBlockClosureCompactIndex >= 1) && (ClassBlockClosureCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosureCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("BlockClosure", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMethodContext) << (shiftForWord(self))))))) != ((assert(((ClassMethodContextCompactIndex >= 1) && (ClassMethodContextCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMethodContextCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("MethodContext", self);
	}
	/* begin compactIndexOfClass: */
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteArray) << (shiftForWord(self))))));
	assert((rawHashBitsOf(objOop, self)) != 0);
	GIV(classByteArrayCompactIndex) = (long32At(objOop + 4)) & (identityHashHalfWordMask(self));
	initializeExtraClassInstVarIndices(self);
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;
	/* begin initialCleanup2 */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = (time(NULL)) + (ioMSecs(self));
	}
	GIV(metaAccessorDepth) = -2;
	sHEAFn = ioLoadFunctionFrom("secHasEnvironmentAccess", "SecurityPlugin", self);
	return dataSize;
}


/*	Read an image from the given file stream, allocating an amount of memory
	to its object heap.
	
	V3: desiredHeapSize is the total size of the heap. Fail if the image has
	an unknown format or
	requires more than the specified amount of memory.
	
	Spur: desiredHeapSize is ignored; this routine will attempt to provide at
	least extraVMMemory's
	ammount of free space after the image is loaded, taking any free space in
	teh image into account.
	extraVMMemory is stored in the image header and is accessible as
	vmParameterAt: 23. If
	extraVMMemory is 0, the value defaults to the default grow headroom. Fail
	if the image has an
	unknown format or if sufficient memory cannot be allocated.
	
	Details: This method detects when the image was stored on a machine with
	the opposite byte
	ordering from this machine and swaps the bytes automatically. Furthermore,
	it allows the header
	information to start 512 bytes into the file, since some file transfer
	programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix
	area could also be used to store an exec command on Unix systems, allowing
	one to launch
	Smalltalk by invoking the image name as a command. */

	/* StackInterpreter>>#readImageFromFile:HeapSize:StartingAt: */
size_t
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocationReserve;
    sqInt anObject;
    sqInt aValue;
    sqInt bit;
    sqInt bytes;
    sqInt bytesRead;
    sqInt bytesToShift;
    size_t dataSize;
    sqInt firstSegSize;
    sqInt freeOldSpaceInImage;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt headroom;
    sqInt headroom1;
    usqInt heapSize;
    usqInt heapSize1;
    sqInt i;
    sqInt i1;
    sqInt i2;
    usqInt minimumMemory;
    sqInt objOop;
    sqInt oldBaseAddr;
    sqInt seed;
    sqInt swapBytes;
    sqInt w;
    int w1;
    unsigned short w10;
    unsigned short w11;
    sqInt w12;
    sqInt w13;
    sqInt w14;
    sqInt w2;
    sqInt w3;
    sqInt w4;
    sqInt w5;
    int w6;
    unsigned short w7;
    unsigned short w8;
    int w9;


	/* guess Metaclass instSize */
	GIV(metaclassNumSlots) = 6;

	/* guess (Class instVarIndexFor: 'name' ifAbsent: []) - 1 */
	GIV(classNameIndex) = 6;
	swapBytes = checkImageVersionFromstartingAt(f, imageOffset, self);

	/* record header start position */
	headerStart = (sqImageFilePosition(f, self)) - 4;
	/* begin getWord32FromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(int), 1, f, self);
	headerSize = (swapBytes
		? SQ_SWAP_4_BYTES(w1)
		: w1);
	/* begin getLongFromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(w2), 1, f, self);
	dataSize = ((sqInt) ((swapBytes
	? (/* begin byteSwapped: */
		SQ_SWAP_8_BYTES(w2))
	: w2)));
	/* begin getLongFromFile:swap: */
	w3 = 0;
	sqImageFileRead((&w3), sizeof(w3), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		oldBaseAddr = SQ_SWAP_8_BYTES(w3);
	}
	else {
		oldBaseAddr = w3;
	}
	/* begin specialObjectsOop: */
	w13 = 0;
	sqImageFileRead((&w13), sizeof(w13), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		anObject = SQ_SWAP_8_BYTES(w13);
	}
	else {
		anObject = w13;
	}
	GIV(specialObjectsOop) = anObject;
	/* begin lastHash: */
	w14 = 0;
	sqImageFileRead((&w14), sizeof(w14), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		seed = SQ_SWAP_8_BYTES(w14);
	}
	else {
		seed = w14;
	}
	GIV(lastHash) = seed;
	/* begin getLongFromFile:swap: */
	w4 = 0;
	sqImageFileRead((&w4), sizeof(w4), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		GIV(savedWindowSize) = SQ_SWAP_8_BYTES(w4);
	}
	else {
		GIV(savedWindowSize) = w4;
	}
	/* begin getLongFromFile:swap: */
	w5 = 0;
	sqImageFileRead((&w5), sizeof(w5), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		headerFlags = SQ_SWAP_8_BYTES(w5);
	}
	else {
		headerFlags = w5;
	}
	/* begin setImageHeaderFlagsFrom: */

	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;

	/* processHasThreadId := headerFlags anyMask: 4. specific to CoInterpreterMT */
	/* flagInterpretedMethods := headerFlags anyMask: 8. specific to CoInterpreter */
	GIV(imageFloatsBigEndian) = ((headerFlags & 2) == 0
		? 1
		: 0);

	/* noThreadingOfGUIThread := headerFlags anyMask: 32. specific to CoInterpreterMT */
	GIV(preemptionYields) = (headerFlags & 16) == 0;
	GIV(newFinalization) = headerFlags & 64;
	sendWheelEvents = headerFlags & 128;
	/* begin getWord32FromFile:swap: */
	w6 = 0;
	sqImageFileRead((&w6), sizeof(int), 1, f, self);
	extraVMMemory = (swapBytes
		? SQ_SWAP_4_BYTES(w6)
		: w6);
	/* begin getShortFromFile:swap: */
	w7 = 0;
	sqImageFileRead((&w7), sizeof(unsigned short), 1, f, self);
	hdrNumStackPages = (swapBytes
		? ((((usqInt) w7) >> 8) & 0xFF) | (((sqInt)((usqInt)((w7 & 0xFF)) << 8)))
		: w7);
	GIV(numStackPages) = (desiredNumStackPages != 0
		? desiredNumStackPages
		: (hdrNumStackPages == 0
				? defaultNumStackPages(self)
				: hdrNumStackPages));

	/* pad to word boundary.  This slot can be used for anything else that will fit in 16 bits.
	   It is used for the cog code size in Cog.  Preserve it to be polite to other VMs. */
	desiredNumStackPages = hdrNumStackPages;
	/* begin getShortFromFile:swap: */
	w8 = 0;
	sqImageFileRead((&w8), sizeof(unsigned short), 1, f, self);
	GIV(theUnknownShort) = (swapBytes
		? ((((usqInt) w8) >> 8) & 0xFF) | (((sqInt)((usqInt)((w8 & 0xFF)) << 8)))
		: w8);
	/* begin getWord32FromFile:swap: */
	w9 = 0;
	sqImageFileRead((&w9), sizeof(int), 1, f, self);
	hdrEdenBytes = (swapBytes
		? SQ_SWAP_4_BYTES(w9)
		: w9);
	/* begin edenBytes: */
	bytes = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
				? defaultEdenBytes(self)
				: hdrEdenBytes));
	GIV(edenBytes) = bytes;
	desiredEdenBytes = hdrEdenBytes;
	/* begin getShortFromFile:swap: */
	w10 = 0;
	sqImageFileRead((&w10), sizeof(unsigned short), 1, f, self);
	hdrMaxExtSemTabSize = (swapBytes
		? ((((usqInt) w10) >> 8) & 0xFF) | (((sqInt)((usqInt)((w10 & 0xFF)) << 8)))
		: w10);
	if (hdrMaxExtSemTabSize != 0) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}
	/* begin getShortFromFile:swap: */
	w11 = 0;
	sqImageFileRead((&w11), sizeof(unsigned short), 1, f, self);
	GIV(the2ndUnknownShort) = (swapBytes
		? ((((usqInt) w11) >> 8) & 0xFF) | (((sqInt)((usqInt)((w11 & 0xFF)) << 8)))
		: w11);
	/* begin getLongFromFile:swap: */
	w12 = 0;
	sqImageFileRead((&w12), sizeof(w12), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		firstSegSize = SQ_SWAP_8_BYTES(w12);
	}
	else {
		firstSegSize = w12;
	}
	/* begin firstSegmentSize: */
	GIV(firstSegmentSize) = firstSegSize;
	allocationReserve = interpreterAllocationReserveBytes(self);
	minimumMemory = (dataSize + GIV(edenBytes)) + allocationReserve;
	/* begin getLongFromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(w), 1, f, self);
	if (swapBytes) {
		/* begin byteSwapped: */
		freeOldSpaceInImage = SQ_SWAP_8_BYTES(w);
	}
	else {
		freeOldSpaceInImage = w;
	}
	/* begin initialHeadroom:givenFreeOldSpaceInImage: */
	headroom1 = (extraVMMemory == 0
		? (!(GIV(growHeadroom))
				? (16 * 1024) * 1024
				: GIV(growHeadroom))
		: extraVMMemory);
	if (freeOldSpaceInImage >= headroom1) {
		headroom = 0;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 7) / 8)) {
		headroom = headroom1 / 8;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 3) / 4)) {
		headroom = headroom1 / 4;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 5) / 8)) {
		headroom = (headroom1 * 3) / 8;
		goto l2;
	}
	if (freeOldSpaceInImage >= (headroom1 / 2)) {
		headroom = headroom1 / 2;
		goto l2;
	}
	headroom = headroom1;
	l2:	/* end initialHeadroom:givenFreeOldSpaceInImage: */;
	/* begin roundUpHeapSize: */
	heapSize1 = ((dataSize + headroom) + GIV(edenBytes)) + ((headroom > allocationReserve
	? 0
	: allocationReserve));
	bit = (((highBit(heapSize1, self)) - 1) * 3) / 4;
	heapSize = (heapSize1 & ((1ULL << bit) - 1)
		? (((heapSize1 | ((1ULL << bit) - 1)) - ((1ULL << bit) - 1))) + (1ULL << bit)
		: heapSize1);
	/* begin memory: */
	aValue = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	GIV(memory) = aValue;
	if (!(memory(self))) {
		insufficientMemoryAvailableError();
	}
	setHeapBasememoryLimitendOfMemory(memory(self), (memory(self)) + heapSize, (memory(self)) + dataSize, self);
	sqImageFileSeek(f, headerStart + headerSize, self);
	bytesRead = readHeapFromImageFiledataBytes(f, dataSize, self);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes, self);
	bytesToShift = GIV(oldSpaceStart) - oldBaseAddr;
	/* begin initializeInterpreter: */
	GIV(interpreterProxy) = sqGetInterpreterProxy(self);
	dummyReferToProxy(self);
	initializeObjectMemory(bytesToShift, self);
	/* begin checkAssumedCompactClasses */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self))))))) != ((assert(((ClassArrayCompactIndex >= 1) && (ClassArrayCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArrayCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("Array", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord(self))))))) != ((assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeIntegerCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("LargeNegativeInteger", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveInteger) << (shiftForWord(self))))))) != ((assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveIntegerCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("LargePositiveInteger", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloat) << (shiftForWord(self))))))) != ((assert(((ClassFloatCompactIndex >= 1) && (ClassFloatCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloatCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("Float", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord(self))))))) != ((assert(((ClassBlockClosureCompactIndex >= 1) && (ClassBlockClosureCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosureCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("BlockClosure", self);
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMethodContext) << (shiftForWord(self))))))) != ((assert(((ClassMethodContextCompactIndex >= 1) && (ClassMethodContextCompactIndex <= (classTablePageSize(self))))),
	/* begin fetchPointer:ofObject: */
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMethodContextCompactIndex) << (shiftForWord(self))))))))) {
		invalidCompactClassError("MethodContext", self);
	}
	/* begin compactIndexOfClass: */
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteArray) << (shiftForWord(self))))));
	assert((rawHashBitsOf(objOop, self)) != 0);
	GIV(classByteArrayCompactIndex) = (long32At(objOop + 4)) & (identityHashHalfWordMask(self));
	initializeExtraClassInstVarIndices(self);
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;
	/* begin initialCleanup */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i2 = 0; i2 < MaxExternalPrimitiveTableSize; i2 += 1) {
		GIV(externalPrimitiveTable)[i2] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));

	/* cmd-. as used for Mac but no other OS */
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = (time(NULL)) + (ioMSecs(self));
	}
	GIV(metaAccessorDepth) = -2;
	sHEAFn = ioLoadFunctionFrom("secHasEnvironmentAccess", "SecurityPlugin", self);
	return dataSize;
}


/*	Assuming the primFailCode is non-zero, check if the method consumes the
	error code
	and if so, assign it through theSP. Then zero the primFailCode. This is
	infrequent code,
	so keep it out of the common path. */

	/* StackInterpreter>>#reapAndResetErrorCodeTo:header: */
static void NoDbgRegParms NeverInline
reapAndResetErrorCodeToheader(char *theSP, sqInt methodHeader, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt initialPC;

	assert(GIV(primFailCode) != 0);
	initialPC = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) + (3);
	if ((byteAt(initialPC)) == (
#  if MULTIPLEBYTECODESETS
		((((sqLong) methodHeader)) < 0
				? AltLongStoreBytecode
				: LongStoreBytecode)
#  else /* MULTIPLEBYTECODESETS */
		LongStoreBytecode
#  endif /* MULTIPLEBYTECODESETS */
		)) {
		longAtPointerput(theSP, getErrorObjectFromPrimFailCode(self));
	}
	GIV(primFailCode) = 0;
}


/*	callbackContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state,
	and mark calloutContext as dead. */

	/* StackInterpreter>>#reestablishContextPriorToCallback: */
EXPORT(sqInt)
reestablishContextPriorToCallback(sqInt callbackContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutContext;
    sqInt index;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer11;
    sqInt valuePointer2;

	flag("obsolete");
	if (!(isLiveContext(callbackContext, self))) {
		return 0;
	}
	calloutContext = externalInstVarofContext(SenderIndex, callbackContext, self);
	if (!(isLiveContext(calloutContext, self))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (isSingleContext(callbackContext, self)) {
		/* begin markContextAsDead: */
		assert(isContext(callbackContext, self));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		assert(!(isOopForwarded(callbackContext, self)));
		longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		assert(!(isOopForwarded(callbackContext, self)));
		longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
	}
	else {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		if (GIV(framePointer) == theFP) {
			if ((longAt(theFP + FoxSavedFP)) == 0) {
				freeStackPage(GIV(stackPage), self);
			}
			else {

				/* calloutContext is immediately below on the same page.  Make it current. */
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP))));
				GIV(stackPointer) = (GIV(framePointer) + (frameStackedReceiverOffset(GIV(framePointer), self))) + BytesPerWord;
				/* begin frameCallerFP: */
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackContext, self);
			/* begin markContextAsDead: */
			assert(isContext(callbackContext, self));
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer2 = GIV(nilObj);
			assert(!(isOopForwarded(callbackContext, self)));
			longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer2);
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer11 = GIV(nilObj);
			assert(!(isOopForwarded(callbackContext, self)));
			longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer11);
		}
	}
	if ((((((longAt((calloutContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(calloutContext, self)))) {
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop1) & 7) == 1));
		theFP = pointerForOop(senderOop1 - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage, self)) - BytesPerWord;
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		thePage = makeBaseFrameFor(calloutContext, self);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage, self);
	return 1;
}


/*	Remove the first process from the given linked list. */

	/* StackInterpreter>>#removeFirstLinkOfList: */
static sqInt NoDbgRegParms
removeFirstLinkOfList(sqInt aList, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	assert(!((isForwarded(aList, self))));
	/* begin fetchPointer:ofObject: */
	first = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	last = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))));
	assert(!((isForwarded(first, self))));
	assert(!((isForwarded(last, self))));
	if (first == last) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		assert(!(isOopForwarded(aList, self)));
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		assert(!(isOopForwarded(aList, self)));
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))), valuePointer1);
	}
	else {
		/* begin fetchPointer:ofObject: */
		next = longAt((first + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList, self)));
		if ((assert(isNonImmediate(aList, self)),
		oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((next & (tagMask(self))) == 0)
			 && (oopisLessThan(next, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(aList, self);
				}
			}
		}
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))), next);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer2 = GIV(nilObj);
	assert(!(isOopForwarded(first, self)));
	longAtput((first + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))), valuePointer2);
	return first;
}


/*	Make aProcess runnable and if its priority is higher than that of the
	current process, preempt the current process. Answer if the current
	process was preempted. If the current process was preempted then if
	yieldImplicitly add the current process to the back of its run queue,
	causing an implicit yiled to other processes on the run queue, otherwise
	add the current process to the front of its run queue, hence not yielding.
	Blue book behaviour is to yield implicitly but is arguably incorrect. */

	/* StackInterpreter>>#resume:preemptedYieldingIf: */
static sqInt NoDbgRegParms
resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt oop1;

	/* begin memoryActiveProcess */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord(self))))));
	assert((((oop) & 7) == 1));
	activePriority = (oop >> 3);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord(self))))));
	assert((((oop1) & 7) == 1));
	newPriority = (oop1 >> 3);
	if (newPriority <= activePriority) {
		putToSleepyieldingIf(aProcess, 1, self);
		return 0;
	}
	putToSleepyieldingIf(activeProc, yieldImplicitly, self);
	transferTo(aProcess, self);
	return 1;
}


/*	In Spur two cases of primitive failure are handled specially. A primitive
	may fail due to validation
	encountering a forwarder. On failure, check the accessorDepth for the
	primitive and if non-negative
	scan the args to the depth, following any forwarders. Retry the primitive
	if any are found. Hence
	lazily and transparently following forwarders on primtiive failure.
	Additionally a prmitive might fail
	due to an allocation failing. Retry if external primitives have failed
	with PrimErrNoMemory after running
	first the scavenger and then on a subsequent failure, the global
	mark-sweep collector. Hence lazily
	and transparently GC on memory exhaustion. */

	/* StackInterpreter>>#retryPrimitiveOnFailure */
static sqInt
retryPrimitiveOnFailure(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt accessorDepth;
    sqInt canRetry;
    sqInt firstBytecode;
    sqInt followDone;
    sqInt found;
    sqInt gcDone;
    sqInt index;
    sqInt methodHeader;
    sqInt oop;
    sqInt primIndex;
    sqInt referent;
    sqInt retried;
    sqInt retry;
    sqInt scannedStackFrame;

	gcDone = 0;
	followDone = (canRetry = (retried = 0));
	while (1) {
		retry = 0;
		if (GIV(primFailCode) == PrimErrNoMemory) {
			if (((gcDone += 1)) == 1) {
				canRetry = (primitiveIndexOfMethodheader(GIV(newMethod), methodHeaderOf(GIV(newMethod), self), self)) == PrimNumberExternalCall;
			}
			if (canRetry) {
				if (gcDone == 1) {
					/* begin scavengingGC */
					scavengingGCTenuringIf(TenureByAge, self);
				}
				if (gcDone == 2) {
					fullGC(self);
				}
				retry = gcDone <= 2;
			}
		}
		else {
			if (!followDone) {
				followDone = 1;
				/* begin checkForAndFollowForwardedPrimitiveState */
				assert(failed(self));
				found = (scannedStackFrame = 0);
				/* begin primitiveIndexOfMethod:header: */
				assert(isCompiledMethod(GIV(newMethod), self));
				/* begin fetchPointer:ofObject: */
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
				if (methodHeader & AlternateHeaderHasPrimFlag) {
					firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
					primIndex = (byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8)));
				}
				else {
					primIndex = 0;
				}
				assert((GIV(argumentCount) == (argumentCountOf(GIV(newMethod), self)))
				 || (isMetaPrimitiveIndex(primIndex, self)));
				if (((primIndex == PrimNumberDoPrimitive)
				 || (primIndex == PrimNumberDoExternalCall))
				 && (GIV(metaAccessorDepth) > -2)) {
					accessorDepth = GIV(metaAccessorDepth);
				}
				else {
					if ((primIndex == PrimNumberExternalCall)
					 && (GIV(primitiveFunctionPointer) != primitiveExternalCall)) {
						accessorDepth = ((fetchPointerofObject(2, literalofMethod(0, GIV(newMethod), self), self)) >> 3);
					}
					else {
						accessorDepth = primitiveAccessorDepthTable[primIndex];
					}
				}
				assert(saneFunctionPointerForFailureOfPrimIndex(primIndex, self));
				assert(((accessorDepth >= -1) && (accessorDepth <= 5)));
				if (accessorDepth >= 0) {
					for (index = 0; index <= GIV(argumentCount); index += 1) {
						oop = longAt(GIV(stackPointer) + (index * BytesPerWord));
						if ((oop & (tagMask(self))) == 0) {
							if (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
								assert(index < GIV(argumentCount));
								found = 1;
								/* begin followForwarded: */
								assert(isUnambiguouslyForwarder(oop, self));
								/* begin fetchPointer:ofMaybeForwardedObject: */
								referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord(self))));
								while (((referent & (tagMask(self))) == 0)
								 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
									/* begin fetchPointer:ofMaybeForwardedObject: */
									referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
								}
								oop = referent;
								longAtput(GIV(stackPointer) + (index * BytesPerWord), oop);
								if (!scannedStackFrame) {
									scannedStackFrame = 1;
									followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord), self);
								}
							}
							if ((accessorDepth > 0)
							 && ((((oop & (tagMask(self))) == 0)
							 && (isAnyPointerFormat((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)))
							 && (followForwardedObjectFieldstoDepth(oop, accessorDepth, self)))) {
								found = 1;
							}
						}
					}
				}
				retry = found;
			}
		}
		if (!(retry)) break;
		assert(GIV(primFailCode) != 0);
		retried = 1;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
	}
	return retried;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

	/* StackInterpreter>>#returnAs:ThroughCallback:Context: */
EXPORT(sqInt)
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutMethodContext;
    sqInt index;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer11;
    sqInt valuePointer2;

	assert(GIV(primFailCode) == 0);
	assert((((returnTypeOop) & 7) == 1));
	assert(!(isImmediate(((sqInt)vmCallbackContext), self)));
	assert((addressCouldBeObj(callbackMethodContext, self))
	 && (isContext(callbackMethodContext, self)));
	assert(((debugCallbackPath = 0)) == 0);
	if (!(((((returnTypeOop) & 7) == 1))
		 && (isLiveContext(callbackMethodContext, self)))) {
		assert(((debugCallbackPath = 1)) == 1);
		return 0;
	}
	calloutMethodContext = externalInstVarofContext(SenderIndex, callbackMethodContext, self);
	if (!(isLiveContext(calloutMethodContext, self))) {
		assert(((debugCallbackPath = 2)) == 2);
		return 0;
	}
	assert(((debugCallbackReturns += 1)) > 0);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (isSingleContext(callbackMethodContext, self)) {
		assert(((debugCallbackPath = debugCallbackPath | 4)) > 0);
		/* begin markContextAsDead: */
		assert(isContext(callbackMethodContext, self));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		assert(!(isOopForwarded(callbackMethodContext, self)));
		longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		assert(!(isOopForwarded(callbackMethodContext, self)));
		longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 8)) > 0);
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		assert((frameReceiver(theFP, self)) == (splObj(ClassAlien, self)));
		if (GIV(framePointer) == theFP) {
			assert(((debugCallbackPath = debugCallbackPath | 16)) > 0);
			if (!((longAt(theFP + FoxSavedFP)) == 0)) {

				/* calloutMethodContext is immediately below on the same page.  Make it current. */
				assert(((debugCallbackPath = debugCallbackPath | 32)) > 0);
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
				GIV(stackPointer) = (theFP + (frameStackedReceiverOffset(theFP, self))) + BytesPerWord;
				/* begin frameCallerFP: */
				GIV(framePointer) = pointerForOop(longAt(theFP + FoxSavedFP));
				/* begin setMethod: */
				GIV(method) = longAt(GIV(framePointer) + FoxMethod);
				assert(isOopCompiledMethod(GIV(method), self));
				
#        if MULTIPLEBYTECODESETS
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
					? 256
					: 0);
#        endif /* MULTIPLEBYTECODESETS */
				/* begin restoreCStackStateForCallbackContext: */
				memcpy(reenterInterpreter, ((void *)((vmCallbackContext->savedReenterInterpreter))), sizeof(jmp_buf));
				/* begin assertValidExecutionPointe:r:s: */
				assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !0, __LINE__, self);
				longjmp((vmCallbackContext->trampoline), (returnTypeOop >> 3));
				return 1;
			}
			freeStackPage(GIV(stackPage), self);
		}
		else {
			assert(((debugCallbackPath = debugCallbackPath | 64)) > 0);
			externalDivorceFrameandContext(theFP, callbackMethodContext, self);
			/* begin markContextAsDead: */
			assert(isContext(callbackMethodContext, self));
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer2 = GIV(nilObj);
			assert(!(isOopForwarded(callbackMethodContext, self)));
			longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer2);
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer11 = GIV(nilObj);
			assert(!(isOopForwarded(callbackMethodContext, self)));
			longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer11);
		}
	}
	if ((((((longAt((calloutMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(calloutMethodContext, self)))) {
		assert(((debugCallbackPath = debugCallbackPath | 128)) > 0);
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop1) & 7) == 1));
		theFP = pointerForOop(senderOop1 - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (((thePage->headFP)) == theFP
			? (thePage->headSP)
			: (findSPOfon(theFP, thePage, self)) - BytesPerWord);
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 256)) > 0);
		thePage = makeBaseFrameFor(calloutMethodContext, self);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin setMethod: */
	GIV(method) = longAt((calloutMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord(self))))));
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage, self);
	/* begin restoreCStackStateForCallbackContext: */
	memcpy(reenterInterpreter, ((void *)((vmCallbackContext->savedReenterInterpreter))), sizeof(jmp_buf));

	/* N.B. siglongjmp is defined as _longjmp on non-win32 platforms.
	   This matches the use of _setjmp in ia32abicc.c. */
	GIV(primitiveFunctionPointer) = (vmCallbackContext->savedPrimFunctionPointer);
	longjmp((vmCallbackContext->trampoline), (returnTypeOop >> 3));
	return 1;
}


/*	Reverse the given range of Display pixels, rounded to whole word boundary.
	Used to give feedback during VM activities such as garbage collection when
	debugging. It is assumed that the given word range falls entirely within
	the first line of the Display. */

	/* StackInterpreter>>#reverseDisplayFrom:to: */
static sqInt NoDbgRegParms
reverseDisplayFromto(sqInt startIndex, sqInt endIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt primFailCodeValue;
    sqInt ptr;
    unsigned int reversed;
    sqInt wordEndIndex;
    sqInt wordStartIndex;

	if (!(postGCUpdateDisplayBits(self))) {
		return 0;
	}
	if ((displayBits == 0)
	 || ((isImmediate(((sqInt)displayBits), self))
	 || (displayDepth <= 0))) {
		return null;
	}
	wordStartIndex = ((((startIndex < 0) ? 0 : startIndex)) * displayDepth) / 32;
	wordEndIndex = ((((endIndex < displayWidth) ? endIndex : displayWidth)) * displayDepth) / 32;
	for (ptr = ((((sqInt)displayBits)) + (wordStartIndex * 4)); ptr <= ((((sqInt)displayBits)) + (wordEndIndex * 4)); ptr += 4) {
		reversed = (long32At(ptr)) ^ 0xFFFFFFFFU;
		long32Atput(ptr, reversed);
	}
	primFailCodeValue = GIV(primFailCode);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	updateDisplayLeftTopRightBottom(0, 0, displayWidth, 1, self);
	ioForceDisplayUpdate(self);
	GIV(primFailCode) = primFailCodeValue;
	return 0;
}


/*	Rewrite an existing entry in the method cache with a new primitive
	function address.
	Used by primitiveExternalCall to make direct calls to found external
	prims, or quickly
	fail not found external prims. */

	/* StackInterpreter>>#rewriteMethodCacheEntryForExternalPrimitiveToFunction: */
static void NoDbgRegParms
rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void), struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCacheMethod]) == GIV(newMethod)) {
		GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCachePrimFunction] = (((sqIntptr_t) localPrimAddress));
	}
}


/*	Answer if there is room to push n arguments onto the current stack. We
	assume this is called by primitives that check there is enough room in any
	new context, and
	won't actually push the arguments in the current context if the primitive
	fails. With
	this assumption it is safe to answer based on the maximum argument count,
	/not/ the ammount of space in the current frame were it converted to a
	context..  */

	/* StackInterpreter>>#roomToPushNArgs: */
static sqInt NoDbgRegParms
roomToPushNArgs(sqInt n, struct foo * self)
{
	
	/* simpler code that simply insists args are <= max arg count */
	return n <= (LargeContextSlots - CtxtTempFrameStart);
}


/*	Safe version of methodClassOf: that deals with malformed compiled methods,
	etc, and does not fixup forwarding pointers.. */

	/* StackInterpreter>>#safeMethodClassOf: */
static sqInt NoDbgRegParms
safeMethodClassOf(sqInt methodPointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt maybeClass;
    sqInt offset;
    sqInt referent;
    sqInt referent1;

	/* begin literal:ofMethod: */
	offset = ((assert((((((assert(isCompiledMethod(methodPointer, self)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(methodPointer, self)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
	/* begin fetchPointer:ofObject: */
	literal = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
	if (((literal & (tagMask(self))) == 0)
	 && (((longAt(literal)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(literal, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((literal + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		literal = referent;
	}
	if (!((((literal & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(literal))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */))
		 && ((numSlotsOf(literal, self)) > ValueIndex))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	/* begin fetchPointer:ofObject: */
	maybeClass = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	if (((maybeClass & (tagMask(self))) == 0)
	 && (((longAt(maybeClass)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(maybeClass, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent1 = longAt((maybeClass + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent1 & (tagMask(self))) == 0)
		 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		maybeClass = referent1;
	}
	return maybeClass;
}

	/* StackInterpreter>>#saneFunctionPointerForFailureOfPrimIndex: */
static sqInt NoDbgRegParms
saneFunctionPointerForFailureOfPrimIndex(sqInt primIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*basePrimitive)(void);
    sqInt theClass;

	/* begin functionPointerFor:inClass: */
	theClass = GIV(nilObj);
	basePrimitive = ((void (*)(void)) ((primIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIndex])));
	return (GIV(primitiveFunctionPointer) == basePrimitive)
	 || (((basePrimitive == primitiveExternalCall)
	 && (!((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex)))
	 || (((primIndex == PrimNumberDoPrimitive)
	 || (primIndex == PrimNumberDoExternalCall))
	 && (GIV(metaAccessorDepth) > -2)));
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the 1 arg
	invokeCallbackContext: or the 4 arg invokeCallback:stack:registers:jmpbuf:
	message, depending on what selector is installed in the
	specialObjectsArray. Note that if invoking the
	legacy invokeCallback:stack:registers:jmpbuf: we pass the
	vmCallbackContext as the jmpbuf
	argument (see reestablishContextPriorToCallback:). The arguments are raw C
	addresses and
	are converted to integer objects on the way. sendInvokeCallbackContext: &
	returnAs:ThroughCallback:Context: along with ownVM: and disownVM: conspire
	to save and
	restore newMethod, argumentCount and primitiveFunctionPointer around a
	callback. The VM depends on argumentCount being correct to cut-back the
	correct number of
	arguments on primitive return. If a primitive that invokes a callback
	fails after invoking a
	callback (a bad idea, but s**t happens during development) then newMethod
	is required to
	activate the right faling method, and Spur expects
	primitiveFunctionPointer to be valid, so
	asserts will fail misleadingly if not. */

	/* StackInterpreter>>#sendInvokeCallbackContext: */
EXPORT(sqInt)
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt obj;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;

	(vmCallbackContext->savedPrimFunctionPointer = GIV(primitiveFunctionPointer));
	/* begin fetchClassTagOfNonImm: */
	obj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord(self))))));
	/* begin classIndexOf: */
	classTag = (longAt(obj)) & (classIndexMask(self));
	/* begin splObj: */
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorInvokeCallback) << (shiftForWord(self))))));
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag, self))) {
		if ((lookupOrdinaryNoMNUEtcInClass(classAtIndex(classTag, self), self)) != 0) {
			return 0;
		}
	}
	if (GIV(primitiveFunctionPointer) != 0) {
		GIV(primitiveFunctionPointer) = (vmCallbackContext->savedPrimFunctionPointer);
		return 0;
	}
	assert(((debugCallbackInvokes += 1)) > 0);
	/* begin saveCStackStateForCallbackContext: */
	memcpy(((void *)((vmCallbackContext->savedReenterInterpreter))), reenterInterpreter, sizeof(jmp_buf));
	/* begin push: */
	object3 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord(self))))));
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp3;
	if ((argumentCountOf(GIV(newMethod), self)) == 4) {
		/* begin push: */
		object = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->thunkp))), self);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin push: */
		object1 = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->stackp))), self);
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		object2 = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->intregargsp))), self);
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
		GIV(stackPointer) = sp2;
	}
	/* begin push: */
	object4 = positiveMachineIntegerFor(((usqInt)vmCallbackContext), self);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp4;
	/* begin justActivateNewMethod: */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr, self)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object5 = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object5);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader, self);
		}
	}
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow(self);
	}
	assert((frameReceiver(GIV(framePointer), self)) == (splObj(ClassAlien, self)));
	/* begin enterSmalltalkExecutiveFromCallback */
	enterSmalltalkExecutive(self);
	return 1;
}


/*	Send the 4 argument callback message
	invokeCallback:stack:registers:jmpbuf: to Alien class with the supplied
	args. The arguments are raw C addresses
	and are converted to integer objects on the way. */

	/* StackInterpreter>>#sendInvokeCallback:Stack:Registers:Jmpbuf: */
EXPORT(sqInt)
sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt obj;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;

	/* begin fetchClassTagOfNonImm: */
	obj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord(self))))));
	/* begin classIndexOf: */
	classTag = (longAt(obj)) & (classIndexMask(self));
	/* begin splObj: */
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorInvokeCallback) << (shiftForWord(self))))));
	GIV(argumentCount) = 4;
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag, self))) {
		if ((lookupOrdinaryNoMNUEtcInClass(classAtIndex(classTag, self), self)) != 0) {
			return 0;
		}
	}
	if (!(((argumentCountOf(GIV(newMethod), self)) == 4)
		 && (GIV(primitiveFunctionPointer) == 0))) {
		return 0;
	}
	/* begin push: */
	object = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord(self))))));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	/* begin push: */
	object1 = positiveMachineIntegerFor(thunkPtr, self);
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp1;
	/* begin push: */
	object2 = positiveMachineIntegerFor(stackPtr, self);
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
	GIV(stackPointer) = sp2;
	/* begin push: */
	object3 = positiveMachineIntegerFor(regsPtr, self);
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object4 = positiveMachineIntegerFor(jmpBufPtr, self);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp4;
	/* begin justActivateNewMethod: */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr, self)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object5 = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object5);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader, self);
		}
	}
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow(self);
	}
	/* begin enterSmalltalkExecutiveFromCallback */
	enterSmalltalkExecutive(self);
	return 1;
}

	/* StackInterpreter>>#setBreakMNUSelector: */
void
setBreakMNUSelector(char *aString, struct foo * self)
{
	if (((breakSelector = aString)) == null) {
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = -(strlen(aString));
	}
}

	/* StackInterpreter>>#setBreakSelector: */
void
setBreakSelector(char *aString, struct foo * self)
{
	if (((breakSelector = aString)) == null) {
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = strlen(aString);
	}
}

	/* StackInterpreter>>#setFullScreenFlag: */
void
setFullScreenFlag(sqInt value, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(fullScreenFlag) = value;
}

	/* StackInterpreter>>#setInterruptCheckChain: */
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))())

{
    void (*prevFunction)();

	prevFunction = interruptCheckChain;
	interruptCheckChain = aFunction;
	return prevFunction;
}

	/* StackInterpreter>>#setInterruptKeycode: */
void
setInterruptKeycode(sqInt value, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interruptKeycode) = value;
}

	/* StackInterpreter>>#setInterruptPending: */
void
setInterruptPending(sqInt value, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	forceInterruptCheck(self);
	GIV(interruptPending) = value;
}

	/* StackInterpreter>>#setMyCurrentThread:_: */
void
setMyCurrentThread(pthread_t aThread, size_t index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	all_threads_global[index].myCurrentThread=aThread;
}

	/* StackInterpreter>>#setNextWakeupUsecs: */
void
setNextWakeupUsecs(usqLong value, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(nextWakeupUsecs) = value;
}

	/* StackInterpreter>>#setNumberOfImage: */
static void NoDbgRegParms
setNumberOfImage(int numberImages)
{
	numberOfImage = numberImages;
}

	/* StackInterpreter>>#setSavedWindowSize: */
void
setSavedWindowSize(sqInt value, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(savedWindowSize) = value;
}


/*	The low space semaphore is about to be signaled. Set the signalLowSpace
	flag, and force an interrupt check. Save the currently active process in
	the special
	objects array so that the low space handler will be able to determine the
	process that first triggered a low space condition. The image's low space
	handler is expected
	to nil out the special objects array slot when it handles the low space
	condition.  */

	/* StackInterpreter>>#setSignalLowSpaceFlagAndSaveProcess */
static void
setSignalLowSpaceFlagAndSaveProcess(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt lastSavedProcess;
    sqInt objOop;
    sqInt objOop1;

	/* begin signalLowSpace: */
	GIV(signalLowSpace) = 1;
	/* begin lowSpaceThreshold: */

	/* N.B. The threshold > 0 guard eliminates a warning when
	   self lowSpaceThreshold: 0
	   is inlined into setSignalLowSpaceFlagAndSaveProcess */
	GIV(lowSpaceThreshold) = 0;
	assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
	/* begin splObj: */
	lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessSignalingLowSpace) << (shiftForWord(self))))));
	if (lastSavedProcess == GIV(nilObj)) {
		/* begin memoryActiveProcess */
		objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
		objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop), self)));
		if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
		oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((activeProc & (tagMask(self))) == 0)
			 && (oopisLessThan(activeProc, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(GIV(specialObjectsOop), self);
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessSignalingLowSpace) << (shiftForWord(self))))), activeProc);
	}
	forceInterruptCheck(self);
}

	/* StackInterpreter>>#setTraceFlagOnContextsFramesPageIfNeeded: */
static void NoDbgRegParms
setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    void *pointer;
    sqInt senderOop;
    StackPage *thePage;

	if ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContextDuringGC(aContext, self)))) {
		/* begin stackPageFor: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		pointer = pointerForOop(senderOop - 1);
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		assert(((((thePage->trace)) >= StackPageUnreached) && (((thePage->trace)) <= StackPageTraced)));
		if (((thePage->trace)) == StackPageUnreached) {
			(thePage->trace = StackPageReachedButUntraced);
		}
	}
}

	/* StackInterpreter>>#shortPrintContext: */
static sqInt NoDbgRegParms
shortPrintContext(sqInt aContext, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt home;
    sqInt senderOop;
    char *theFP;

	if (!(((aContext & (tagMask(self))) == 0)
		 && (((longAt(aContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
		printHex(aContext, self);
		print(" is not a context", self);
		/* begin cr */
		printf("\n");
		return null;
	}
	printHex(aContext, self);
	if (((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer), self)) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
			assert((((senderOop) & 7) == 1));
			theFP = pointerForOop(senderOop - 1);
			print(" I (", self);
			printHex(((usqIntptr_t)theFP), self);
			print(") ", self);
		}
		else {
			print(" w ", self);
		}
	}
	else {
		print(" s ", self);
	}
	home = findHomeForContext(aContext, self);
	if (home == null) {
		print(" BOGUS CONTEXT (can't determine home)", self);
	}
	else {
		printActivationNameForreceiverisBlockfirstTemporary(fetchPointerofObject(MethodIndex, (!(home)
			? aContext
			: home), self), (home == null
			? /* begin nilObject */ GIV(nilObj)
			: (longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord(self)))))))), home != aContext, longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)((0 + CtxtTempFrameStart)) << (shiftForWord(self)))))), self);
	}
	/* begin cr */
	printf("\n");
	return 0;
}

	/* StackInterpreter>>#shortPrintFrameAndCallers: */
static sqInt NoDbgRegParms
shortPrintFrameAndCallers(char *theFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	shortPrintFrame(theFP, self);
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		shortPrintFrameAndCallers(pointerForOop(longAt(theFP + FoxSavedFP)), self);
	}
	return 0;
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

	/* StackInterpreter>>#shortPrintFramesInPage: */
EXPORT(void)
shortPrintFramesInPage(StackPage *thePage, struct foo * self)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 1, self);
}

	/* StackInterpreter>>#shortPrintFramesOnStackPageListInUse */
EXPORT(void)
shortPrintFramesOnStackPageListInUse(struct foo * self)
{
    usqInt n;
    StackPage *page;

	page = mostRecentlyUsedPage(self);
	do {
		if (!(isFree(page, self))) {
			print("page ", self);
			/* begin printHexPtrnp: */
			n = oopForPointer(page);
			printf("0x%" PRIxSQINT "", n);
			/* begin cr */
			printf("\n");
			shortPrintFramesInPage(page, self);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage(self)));
}

	/* StackInterpreter>>#shortPrintFrame: */
static sqInt NoDbgRegParms
shortPrintFrame(char *theFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt frameNumArgs;
    sqInt rcvr;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		print("invalid frame pointer", self);
		/* begin cr */
		printf("\n");
		return null;
	}
	/* begin frameReceiver: */
	rcvr = longAt(theFP + FoxReceiver);
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP), self);
	/* begin space */
	putchar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(longAt(theFP + FoxMethod), rcvr, (byteAt((theFP + FoxFrameFlags) + 3)) != 0, (0 < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord))), self);
	/* begin space */
	putchar(' ');
	shortPrintOop(rcvr, self);
	return 0;
}

	/* StackInterpreter>>#shortPrintFrame:AndNCallers: */
void
shortPrintFrameAndNCallers(char *theFP, sqInt n, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((n != 0)
	 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		shortPrintFrame(theFP, self);
		shortPrintFrameAndNCallers(pointerForOop(longAt(theFP + FoxSavedFP)), n - 1, self);
	}
}

	/* StackInterpreter>>#shortPrintOop: */
static sqInt NoDbgRegParms
shortPrintOop(sqInt oop, struct foo * self)
{
	/* begin printHexnp: */
	printf("0x%" PRIxSQINT "", oop);
	if (oop & (tagMask(self))) {
		if ((((oop) & 7) == 1)) {
			printf("=%ld\n", (long)integerValueOf(oop, self));
		}
		if (oop & (characterTag(self))) {
			printf("=$%ld ($%lc)\n", (long)characterValueOf(oop, self), (wint_t)characterValueOf(oop, self));
		}
		if (oop & (smallFloatTag(self))) {
			printf("=%g\n", floatValueOf(oop, self));
		}
		return 0;
	}
	if (!(addressCouldBeObj(oop, self))) {
		return (print(((oop & (8 /* allocationUnit */ - 1)) != 0
					? " is misaligned"
					: whereIs(oop, self)), self),
			/* begin cr */
			printf("\n"));
	}
	if ((((longAt(oop)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self)))
	 || (((longAt(oop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		return printOop(oop, self);
	}
	print(": a(n) ", self);
	printNameOfClasscount(fetchClassOfNonImm(oop, self), 5, self);
	/* begin cr */
	printf("\n");
	return 0;
}

	/* StackInterpreter>>#shortReversePrintFrameAndCallers: */
static sqInt NoDbgRegParms
shortReversePrintFrameAndCallers(char *aFramePointer, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt caller;
    char *callerFP;
    sqInt referent;
    char *theFP;

	if (aFramePointer == 0) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	theFP = aFramePointer;
	while (1) {
		shortPrintFrame(theFP, self);
		/* begin frameCallerFP: */
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(callerFP != 0)) break;
		theFP = callerFP;
	}
	/* begin frameCallerContext: */
	caller = longAt(theFP + FoxCallerContext);
	if (((longAt(caller)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(caller, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((caller + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		caller = referent;
	}
	return caller;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

	/* StackInterpreter>>#showDisplayBits:Left:Top:Right:Bottom: */
sqInt
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b, struct foo * self)
{
	if (deferDisplayUpdates
	 || (aForm != (splObj(TheDisplay, self)))) {
		return null;
	}
	updateDisplayLeftTopRightBottom(l, t, r, b, self);
	return 0;
}


/*	Signal all requested semaphores. Answer if a context switch has occurred. */

	/* StackInterpreter>>#signalExternalSemaphores */
static sqInt
signalExternalSemaphores(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt xArray;

	/* begin splObj: */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord(self))))));
	return doSignalExternalSemaphores(numSlotsOf(xArray, self));
}


/*	Answer a full 32 bit integer object for the given integer value.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#signed32BitIntegerFor: */
sqInt
signed32BitIntegerFor(sqInt integerValue, struct foo * self)
{
	return (((usqInt)(((int) integerValue)) << 3) | 1);
}


/*	Answer a Large Integer object for the given integer value. N.B. will *not*
	cause a GC. */

	/* StackInterpreter>>#signed64BitIntegerFor: */
sqInt
signed64BitIntegerFor(sqLong integerValue, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt largeClass;
    usqLong magnitude;
    usqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt sz;
    sqLong value;

	if (integerValue < 0) {
		if (integerValue >= (MinSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 3) | 1);
		}
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		magnitude = 0 - (((usqLong) integerValue));
	}
	else {
		if (integerValue <= (MaxSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 3) | 1);
		}
		largeClass = ClassLargePositiveIntegerCompactIndex;
		magnitude = integerValue;
	}
	sz = 8;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat(self)) + ((8 - sz) & (BytesPerWord - 1));
	numSlots = (sz + 3) / BytesPerOop;
	assert((numSlots >= 0)
	 && ((largeClass != 0)
	 && ((knownClassAtIndex(largeClass, self)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(largeClass, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l4;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + largeClass);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
	l4:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	
	/* Memory is eight byte aligned in SPUR, so we are sure to have room for 64bits word whatever allocated sz */
	/* begin storeLong64:ofObject:withValue: */
	value = SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude);
	long64Atput((newLargeInteger + BaseHeaderSize) + (0U << 3), value);
	return newLargeInteger;
}


/*	Answer the size of the CallPrimitive bytecode that may be used to store a
	method's primitive.
 */
/*	NewsqueakV4:	249	11111001	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */
/*	SistaV1:		248	11111000 iiiiiiii	mssjjjjj	Call Primitive #iiiiiiii + (
	jjjjj * 256) */
/*	V3+Closures:	139	11101111	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

	/* StackInterpreter>>#sizeOfCallPrimitiveBytecode: */
sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader, struct foo * self)
{
	return 3;
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#sizeOfLongStoreTempBytecode: */
sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader, struct foo * self)
{
	return 2;
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

	/* StackInterpreter>>#sizeOfSTArrayFromCPrimitive: */
sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(((oop & (tagMask(self))) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self)), self)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord(self))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat(self))) {
		return (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		return numSlots;
	}
	return 0;
}


/*	update state of active context */

	/* StackInterpreter>>#snapshot: */
static sqInt NoDbgRegParms
snapshot(sqInt embedded, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt rcvr;
    sqInt rcvr1;
    sqInt savedTenuringThreshold;
    void *setMacType;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt stackIndex;
    sqInt valuePointer;

	rcvr = 0;
	if (GIV(argumentCount) != 0) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp2;

	/* update state of active process */
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(1, self);
	/* begin memoryActiveProcess */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(activeProc, self)));
	if ((assert(isNonImmediate(activeProc, self)),
	oopisGreaterThanOrEqualTo(activeProc, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((activeContext & (tagMask(self))) == 0)
		 && (oopisLessThan(activeContext, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(activeProc))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(activeProc, self);
			}
		}
	}
	longAtput((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))), activeContext);
	GIV(tempOop) = activeContext;
	/* begin garbageCollectForSnapshot */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge, self);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize(self)) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace(self)).start)));
	assert(GIV(freeStart) == (((eden(self)).start)));
	flag("If we wanted to shrink the rememberedSet prior to snapshot this is the place to do it.");
	/* begin biasForSnapshot */
	GIV(biasForGC) = 0;
	fullGC(self);
	/* begin biasForGC */
	GIV(biasForGC) = 1;
	prepareForSnapshot(self);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists(self));
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes(self)));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace, self);
	}
	activeContext = GIV(tempOop);
	GIV(tempOop) = 0;
	if (!GIV(primFailCode)) {

		/* Without contexts or stacks simulate
		   rcvr := self popStack. ''pop rcvr''
		   self push: trueObj.
		   to arrange that the snapshot resumes with true.  N.B. stackIndex is one-relative. */
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		assert((((oop) & 7) == 1));
		stackIndex = (oop >> 3);
		/* begin fetchPointer:ofObject: */
		rcvr = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord(self))))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(trueObj);
		assert(!(isOopForwarded(activeContext, self)));
		longAtput((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord(self))))), valuePointer);
		writeImageFileIO(self);
		if ((!GIV(primFailCode))
		 && (!embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */
			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin", self);
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(activeContext, self)));
		longAtput((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))), (((usqInt)(stackIndex - 1) << 3) | 1));
	}
	postSnapshot(self);
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext, self);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = GIV(falseObj);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {

		/* no point checking for machine code; there isn't any at this point */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp1;
		/* begin justActivateNewMethod: */
		assert(isCompiledMethod(GIV(newMethod), self));
		/* begin fetchPointer:ofObject: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
		/* begin argumentCountOfMethodHeader: */
		numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

		/* could new rcvr be set at point of send? */
		rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvr1, self)));
		/* begin push: */
		longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp11;
		/* begin push: */
		longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp21;
		GIV(framePointer) = GIV(stackPointer);
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp3;
		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method), self));
		assert((methodHeaderOf(GIV(method), self)) == methodHeader);
		
#    if MULTIPLEBYTECODESETS
		GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
			? 256
			: 0);
#    endif /* MULTIPLEBYTECODESETS */
		/* begin push: */
		object1 = (VMBIGENDIAN
			? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
			: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp5;
		/* begin push: */
		longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
		GIV(stackPointer) = sp6;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp7;
		}
		GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
		if ((/* begin alternateHeaderHasPrimitiveFlag: */
		methodHeader & AlternateHeaderHasPrimFlag)) {

			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			GIV(instructionPointer) += 3;
			if (GIV(primFailCode) != 0) {
				reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader, self);
			}
		}
	}
	return 0;
}

	/* StackInterpreter>>#space */
static void
space(struct foo * self)
{
	/* begin printChar: */
	putchar(' ');
}

	/* StackInterpreter>>#specialSelector: */
sqInt
specialSelector(sqInt index, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	/* begin fetchPointer:ofObject: */
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord(self))))));
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((index * 2)) << (shiftForWord(self))))));
}


/*	Insulate the stack zone from the effects of a become.
	All receivers must be unfollowed for two reasons:
	1. inst var access is direct with no read barrier
	2. super sends (always to the receiver) have no class check and so don't
	trap for forwarded receivers. This is an issue for primitives that assume
	their receiver
	is valid and don't validate.
	Super sends require an explicit check to ensure receivers in super sends
	are unforwarded.
	e.g. super doSomethingWith: (self become: other) forwards the receiver
	self pushed on the
	stack. So we could avoid following non-pointer receivers. But this is too
	tricky, Instead, we
	always follow receivers.
	Methods must be unfollowed since bytecode access is direct with no read
	barrier. But this only needs to be done if the becomeEffectsFlags indicate
	that a
	CompiledMethod was becommed.
	The scheduler state must be followed, but only if the becomeEffectsFlags
	indicate that a pointer object was becommed. */
/*	For VM profiling */

	/* StackInterpreter>>#spurPostBecomeAction: */
static void NoDbgRegParms
spurPostBecomeAction(sqInt theBecomeEffectsFlags, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    sqIntptr_t c1;
    sqInt first;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt last;
    sqInt list;
    sqIntptr_t m;
    sqInt next;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    sqInt obj3;
    sqInt obj4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt procLists;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent2;
    sqInt referent21;
    sqInt referent3;
    sqInt referent31;
    sqInt referent4;
    sqInt referent5;
    sqInt referent6;
    sqIntptr_t s;
    sqIntptr_t s1;
    sqInt sched;
    sqInt schedAssoc;
    sqInt xArray;

	/* begin flushAtCache */
	for (i = 1; i <= AtCacheTotalSize; i += 1) {
		GIV(atCache)[i] = 0;
	}
	if (theBecomeEffectsFlags != 0) {
		if (theBecomeEffectsFlags & BecameCompiledMethodFlag) {
			/* begin followForwardedMethodsInMethodCache */
			for (i1 = 0; i1 < MethodCacheSize; i1 += MethodCacheEntrySize) {
				c = GIV(methodCache)[i1 + MethodCacheClass];
				s = GIV(methodCache)[i1 + MethodCacheSelector];
				m = GIV(methodCache)[i1 + MethodCacheMethod];
				if ((c != 0)
				 && ((s != 0)
				 && ((m != 0)
				 && (((m & (tagMask(self))) == 0)
				 && (((longAt(m)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(m, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent = longAt((m + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent & (tagMask(self))) == 0)
					 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					m = referent;
					GIV(methodCache)[i1 + MethodCacheMethod] = m;
				}
			}
		}
		if (theBecomeEffectsFlags & BecameActiveClassFlag) {
			/* begin flushBecommedClassesInMethodCache */
			for (i2 = 0; i2 < MethodCacheSize; i2 += MethodCacheEntrySize) {
				c1 = GIV(methodCache)[i2 + MethodCacheClass];
				s1 = GIV(methodCache)[i2 + MethodCacheSelector];
				if ((c1 != 0)
				 && ((s1 != 0)
				 && (isForwarded(classOrNilAtIndex(c1, self), self)))) {
					GIV(methodCache)[i2 + MethodCacheClass] = 0;
					GIV(methodCache)[i2 + MethodCacheSelector] = 0;
				}
			}
			/* begin flushAtCache */
			for (i11 = 1; i11 <= AtCacheTotalSize; i11 += 1) {
				GIV(atCache)[i11] = 0;
			}
		}
		if (theBecomeEffectsFlags & BecamePointerObjectFlag) {
			/* begin followForwardingPointersInScheduler */
			schedAssoc = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
			assert(!(isForwarded(schedAssoc, self)));
			followForwardedObjectFieldstoDepth(schedAssoc, 1, self);
			/* begin fetchPointer:ofObject: */
			sched = longAt((schedAssoc + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
			/* begin followObjField:ofObject: */
			objOop4 = longAt((sched + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord(self))))));
			assert(isNonImmediate(objOop4, self));
			if (((longAt(objOop4)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				objOop4 = fixFollowedFieldofObjectwithInitialValue(ProcessListsIndex, sched, objOop4, self);
			}
			procLists = objOop4;
			for (i3 = 0, iLimiT = ((numSlotsOf(procLists, self)) - 1); i3 <= iLimiT; i3 += 1) {
				/* begin followObjField:ofObject: */
				objOop1 = longAt((procLists + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord(self))))));
				assert(isNonImmediate(objOop1, self));
				if (((longAt(objOop1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(i3, procLists, objOop1, self);
				}
				list = objOop1;
				/* begin followObjField:ofObject: */
				objOop2 = longAt((list + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))));
				assert(isNonImmediate(objOop2, self));
				if (((longAt(objOop2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(FirstLinkIndex, list, objOop2, self);
				}
				first = objOop2;
				/* begin followObjField:ofObject: */
				objOop3 = longAt((list + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord(self))))));
				assert(isNonImmediate(objOop3, self));
				if (((longAt(objOop3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(LastLinkIndex, list, objOop3, self);
				}
				last = objOop3;
				while (first != last) {
					/* begin followObjField:ofObject: */
					objOop = longAt((first + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord(self))))));
					assert(isNonImmediate(objOop, self));
					if (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
						objOop = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, first, objOop, self);
					}
					next = objOop;
					first = next;
				}
			}
			/* begin followForwardingPointersInSpecialObjectsArray */
			obj1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord(self))))));
			if (((longAt(obj1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj1, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent21 = longAt((obj1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent21 & (tagMask(self))) == 0)
				 && (((longAt(referent21)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent21 = longAt((referent21 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				obj1 = referent21;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop), self)));
				if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
				oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((obj1 & (tagMask(self))) == 0)
					 && (oopisLessThan(obj1, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(GIV(specialObjectsOop), self);
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord(self))))), obj1);
			}
			/* begin followSemaphoreIn:at: */
			obj2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord(self))))));
			if (((longAt(obj2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj2, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent31 = longAt((obj2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent31 & (tagMask(self))) == 0)
				 && (((longAt(referent31)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent31 = longAt((referent31 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				obj2 = referent31;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop), self)));
				if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
				oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((obj2 & (tagMask(self))) == 0)
					 && (oopisLessThan(obj2, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(GIV(specialObjectsOop), self);
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord(self))))), obj2);
			}
			/* begin followSemaphoreIn:at: */
			obj3 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord(self))))));
			if (((longAt(obj3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj3, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent4 = longAt((obj3 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent4 & (tagMask(self))) == 0)
				 && (((longAt(referent4)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent4 = longAt((referent4 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				obj3 = referent4;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop), self)));
				if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
				oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((obj3 & (tagMask(self))) == 0)
					 && (oopisLessThan(obj3, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(GIV(specialObjectsOop), self);
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord(self))))), obj3);
			}
			/* begin followSemaphoreIn:at: */
			obj4 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheFinalizationSemaphore) << (shiftForWord(self))))));
			if (((longAt(obj4)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj4, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent5 = longAt((obj4 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent5 & (tagMask(self))) == 0)
				 && (((longAt(referent5)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent5 = longAt((referent5 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				obj4 = referent5;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop), self)));
				if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
				oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((obj4 & (tagMask(self))) == 0)
					 && (oopisLessThan(obj4, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(GIV(specialObjectsOop), self);
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheFinalizationSemaphore) << (shiftForWord(self))))), obj4);
			}
			/* begin splObj: */
			xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord(self))))));
			if (((longAt(xArray)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(xArray, self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent6 = longAt((xArray + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent6 & (tagMask(self))) == 0)
				 && (((longAt(referent6)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent6 = longAt((referent6 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				xArray = referent6;
				/* begin splObj:put: */
				assert(!(isForwarded(GIV(specialObjectsOop), self)));
				if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
				oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((xArray & (tagMask(self))) == 0)
					 && (oopisLessThan(xArray, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(GIV(specialObjectsOop), self);
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord(self))))), xArray);
			}
			for (i4 = 0, iLimiT1 = ((numSlotsOf(xArray, self)) - 1); i4 <= iLimiT1; i4 += 1) {
				/* begin followSemaphoreIn:at: */
				obj = longAt((xArray + BaseHeaderSize) + (((sqInt)((usqInt)(i4) << (shiftForWord(self))))));
				if (((longAt(obj)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(obj, self));
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent11 = longAt((obj + BaseHeaderSize) + (0U << (shiftForWord(self))));
					while (((referent11 & (tagMask(self))) == 0)
					 && (((longAt(referent11)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
						/* begin fetchPointer:ofMaybeForwardedObject: */
						referent11 = longAt((referent11 + BaseHeaderSize) + (0U << (shiftForWord(self))));
					}
					obj = referent11;
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(xArray, self)));
					if ((assert(isNonImmediate(xArray, self)),
					oopisGreaterThanOrEqualTo(xArray, GIV(oldSpaceStart), self))) {

						/* most stores into young objects */
						if (((obj & (tagMask(self))) == 0)
						 && (oopisLessThan(obj, GIV(newSpaceLimit), self))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(xArray))) >> (rememberedBitShift(self))) & 1) != 0)) {
								remember(xArray, self);
							}
						}
					}
					longAtput((xArray + BaseHeaderSize) + (((sqInt)((usqInt)(i4) << (shiftForWord(self))))), obj);
				}
			}
		}
		if (theBecomeEffectsFlags & (BecamePointerObjectFlag + BecameCompiledMethodFlag)) {
			/* begin followForwardingPointersInProfileState */
			if (((longAt(GIV(profileProcess))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileProcess), self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent3 = longAt((GIV(profileProcess) + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent3 & (tagMask(self))) == 0)
				 && (((longAt(referent3)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				GIV(profileProcess) = referent3;
			}
			if (((longAt(GIV(profileMethod))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileMethod), self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent1 = longAt((GIV(profileMethod) + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent1 & (tagMask(self))) == 0)
				 && (((longAt(referent1)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				GIV(profileMethod) = referent1;
			}
			if (((longAt(GIV(profileProcess))) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileSemaphore), self));
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent2 = longAt((GIV(profileSemaphore) + BaseHeaderSize) + (0U << (shiftForWord(self))));
				while (((referent2 & (tagMask(self))) == 0)
				 && (((longAt(referent2)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
					/* begin fetchPointer:ofMaybeForwardedObject: */
					referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord(self))));
				}
				GIV(profileSemaphore) = referent2;
			}
		}
	}
	followForwardingPointersInStackZone(theBecomeEffectsFlags, self);
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackFloatValue: */
double
stackFloatValue(sqInt offset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return floatValueOf(longAt(GIV(stackPointer) + (offset * BytesPerWord)), self);
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackIntegerValue: */
sqInt
stackIntegerValue(sqInt offset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		return (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Answer the actual stackLimit offset in a page. Since stackPageByteSize may
	have chosen to shrink a page
	this may be less than stackPageFrameBytes, but it should be no more than
	stackPageFrameBytes. 
 */

	/* StackInterpreter>>#stackLimitBytes */
static sqInt
stackLimitBytes(struct foo * self)
{
	return (((stackPageFrameBytes(self)) < (((stackPageByteSize(self)) - ((FrameSlots + 64) * BytesPerWord)))) ? (stackPageFrameBytes(self)) : (((stackPageByteSize(self)) - ((FrameSlots + 64) * BytesPerWord))));
}


/*	Answer the amount of slots needed to fit a new frame at the point the
	stack limit is checked. A frame looks like this at the point the stack
	limit is checked:
	stacked receiver/closure
	arg0
	...
	argN
	caller's method ip/base frame's sender context
	fp->	saved fp
	method
	method header fields
	context (uninitialized)
	receiver
	first temp
	...
	sp->	Nth temp
	So the amount of headroom is
	the maximum number of arguments + 1 (for stacked receiver and arguments)
	+ the frame size
	+ the max number of temps.
	Since a method's number of temps includes its arguments the actual offset
	is:  */

	/* StackInterpreter>>#stackLimitOffset */
static sqInt
stackLimitOffset(struct foo * self)
{
	return (FrameSlots + 64) * BytesPerWord;
}


/*	Ensures that the given object is a real object, not a SmallInteger. */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackObjectValue: */
sqInt
stackObjectValue(sqInt offset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if (oop & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Answer a page size that is a power-of-two and contains a useful number of
	frames. Room for 256 slots for frames gives around 40 frames a page which
	is a
	good compromise between overflow rate and latency in divorcing a page. */

	/* StackInterpreter>>#stackPageByteSize */
static sqInt
stackPageByteSize(struct foo * self)
{
    int largeSize;
    sqInt pageBytes;
    int smallSize;

	pageBytes = ((stackPageFrameBytes(self)) + ((FrameSlots + 64) * BytesPerWord));
	if ((pageBytes & (pageBytes - 1)) == 0) {

		/* = 0 => a power of two */
		return pageBytes;
	}
	largeSize = 1ULL << (highBit(pageBytes, self));
	smallSize = 1ULL << ((highBit(pageBytes, self)) - 1);
	assert((largeSize > pageBytes)
	 && (pageBytes > smallSize));
	return ((pageBytes - smallSize) <= (smallSize / 8)
		? smallSize
		: largeSize);
}


/*	Return a minimum amount of headroom for each stack page (in bytes).
	In a JIT the stack has to have room for interrupt handlers which will run
	on the
	stack. In the interpreter we don't actually need any headroom. */

	/* StackInterpreter>>#stackPageHeadroom */
static sqInt
stackPageHeadroom(struct foo * self)
{
	return 0;
}


/*	Return the stackPointer of a Context or BlockContext. */

	/* StackInterpreter>>#stackPointerForMaybeMarriedContext: */
static sqInt NoDbgRegParms
stackPointerForMaybeMarriedContext(sqInt aContext, struct foo * self)
{
    sqInt sp;
    sqInt sp1;

	if ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(aContext, self)))) {
		sp = stackPointerIndexForFrame(frameOfMarriedContext(aContext, self), self);
		assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext, self)));
		return sp;
	}
	/* begin fetchStackPointerOf: */
	sp1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
	if (!((((sp1) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext, self)));
	return (sp1 >> 3);
}


/*	Return the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPointerIndexForFrame: */
static sqInt NoDbgRegParms
stackPointerIndexForFrame(char *theFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    StackPage *thePage;
    char *theSP;

	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);
	theSP = findSPOfon(theFP, thePage, self);
	return (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord(self))) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPositiveMachineIntegerValue: */
usqIntptr_t
stackPositiveMachineIntegerValue(sqInt offset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt integerPointer;
    sqInt ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		value = (integerPointer >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	if (integerPointer & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(integerPointer, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(integerPointer)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(integerPointer))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt >= (firstByteFormat(self)));
	bs = ((numSlotsOf(integerPointer, self)) << (shiftForWord(self))) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((integerPointer + BaseHeaderSize) + (0U << 3))));
	}
	else {

		/* ] */
		return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerPointer + BaseHeaderSize) + (0U << 2))))));
	}
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackSignedMachineIntegerValue: */
sqIntptr_t
stackSignedMachineIntegerValue(sqInt offset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	return signedMachineIntegerValueOf(integerPointer, self);
}

	/* StackInterpreter>>#stackTop */
sqInt
stackTop(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackValue: */
sqInt
stackValue(sqInt offset, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer) + (offset * BytesPerWord));
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* StackInterpreter>>#startPCOfMethod: */
sqInt
startPCOfMethod(sqInt aCompiledMethod, struct foo * self)
{
	return (((assert((((((assert(isCompiledMethod(aCompiledMethod, self)),
/* begin fetchPointer:ofObject: */
longAt((aCompiledMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(aCompiledMethod, self)),
/* begin fetchPointer:ofObject: */
longAt((aCompiledMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
}


/*	Return what ST would return for <obj> at: index. */

	/* StackInterpreter>>#stObject:at: */
sqInt
stObjectat(sqInt array, sqInt index, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    unsigned int integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt reasonCode;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;

	/* begin baseHeader: */
	hdr = long64At(array);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(array + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l6;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l6;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l6;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l6;
	}
	totalLength = 0;
	l6:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l7;
	}
	class = fetchClassOfNonImm(array, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(array, self)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array, self), self);
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array, self)));
			stSize = sp;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(array, self)));
		stSize = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1, self))
		 && ((oopisLessThanOrEqualTo(index, stSize, self))
		 && ((((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(array, self)))))) {
			return noInlineTemporaryin(index - 1, frameOfMarriedContext(array, self), self);
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat(self))
		? (((literalCountOf(array, self)) + LiteralStart) * BytesPerOop) + 1
		: 1), self))
	 && (oopisLessThanOrEqualTo(index, stSize, self))) {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin fetchPointer:ofObject: */
			return longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord(self))))));
		}
		if (fmt >= (firstByteFormat(self))) {
			return (((usqInt)(byteAt((array + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
		}
		if (fmt >= (firstShortFormat(self))) {
			return (((usqInt)(((unsigned short) (shortAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			return positive64BitIntegerFor(long64At((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))), self);
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		return ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	return 0;
}


/*	Do what ST would return for <obj> at: index put: value. */

	/* StackInterpreter>>#stObject:at:put: */
sqInt
stObjectatput(sqInt array, sqInt index, sqInt value, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt reasonCode;
    sqInt signedValueToStore;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;
    usqLong unsigned64BitValueToStore;
    unsigned int unsignedValueToStore;

	/* begin baseHeader: */
	hdr = long64At(array);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(array + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l6;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l6;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l6;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l6;
	}
	totalLength = 0;
	l6:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l7;
	}
	class = fetchClassOfNonImm(array, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(array, self)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array, self), self);
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array, self)));
			stSize = sp;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(array, self)));
		stSize = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1, self))
		 && ((oopisLessThanOrEqualTo(index, stSize, self))
		 && ((((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(array, self)))))) {
			return noInlineTemporaryinput(index - 1, frameOfMarriedContext(array, self), value, self);
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat(self))
		? (((literalCountOf(array, self)) + LiteralStart) * BytesPerOop) + 1
		: 1), self))
	 && (oopisLessThanOrEqualTo(index, stSize, self))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(array, self)));
			if ((assert(isNonImmediate(array, self)),
			oopisGreaterThanOrEqualTo(array, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((value & (tagMask(self))) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(array))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(array, self);
					}
				}
			}
			longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord(self))))), value);
			goto l13;
		}
		if (fmt >= (firstByteFormat(self))) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((array + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l13;
		}
		if (fmt >= (firstShortFormat(self))) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))), signedValueToStore);
			goto l13;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			unsigned64BitValueToStore = positive64BitValueOf(value, self);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l13;
		}
		unsignedValueToStore = positive32BitValueOf(value, self);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l13:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
	return value;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#storeInteger:ofObject:withValue: */
sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((((usqInt) integerValue) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(objectPointer, self)));
		longAtput((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord(self))))), (((usqInt)integerValue << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return null;
}


/*	Set the sender of a frame. If the frame is a base frame then this is
	trivial; merely store into the FoxCallerSavedIP/FoxCallerContext field. If
	not, then
	split the stack at the frame, moving the frame and those hotter than it to
	a new stack page. In the new stack page the frame will be the base frame
	and storing trivial. Answer the possibly changed location of theFP. */

	/* StackInterpreter>>#storeSenderOfFrame:withValue: */
static char * NoDbgRegParms
storeSenderOfFramewithValue(char *theFP, sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    int onCurrentPage;
    char *theMovedFP;
    StackPage *thePage;

	if ((longAt(theFP + FoxSavedFP)) == 0) {
		/* begin frameCallerContext:put: */
		assert((anOop == (nilObject(self)))
		 || (isContext(anOop, self)));
		longAtput(theFP + FoxCallerContext, anOop);
		return theFP;
	}
	/* begin ensureCallerContext: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		longAt(theFP + FoxCallerContext);
		goto l4;
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP, self), self));
		longAt(callerFP + FoxThisContext);
		goto l4;
	}
	marryFrameSP(callerFP, (assert(!(isBaseFrame(theFP, self))),
	(theFP + (frameStackedReceiverOffset(theFP, self))) + BytesPerWord), self);
	l4:	/* end ensureCallerContext: */;
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
	thePage = stackPageAtpages(index, GIV(pages), self);
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	onCurrentPage = thePage == GIV(stackPage);
	if (!onCurrentPage) {

		/* Make sure the frame's page isn't divorced when a new page is allocated. */
		markStackPageNextMostRecentlyUsed(thePage, self);
	}
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree, self);
	newPage = lruOrFree;
	l2:	/* end newStackPage */;
	theMovedFP = moveFramesInthroughtoPage(thePage, theFP, newPage, self);
	if (onCurrentPage) {
		/* begin setStackPageAndLimit: */
		assert(newPage != 0);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage, self);
	}
	else {
		markStackPageMostRecentlyUsed(newPage, self);
	}
	assert(isBaseFrame(theMovedFP, self));
	/* begin frameCallerContext:put: */
	assert((anOop == (nilObject(self)))
	 || (isContext(anOop, self)));
	longAtput(theMovedFP + FoxCallerContext, anOop);
	return theMovedFP;
}


/*	Return the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not a SmallInteger! */

	/* StackInterpreter>>#stSizeOf: */
sqInt
stSizeOf(sqInt oop, struct foo * self)
{
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt totalLength;

	/* begin baseHeader: */
	hdr = long64At(oop);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l3;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l3;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l3;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l3;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l3;
	}
	totalLength = 0;
	l3:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l4;
	}
	class = fetchClassOfNonImm(oop, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l4:	/* end fixedFieldsOf:format:length: */;
	if (fmt == (indexablePointersFormat(self))) {
		assert(!(isContextHeader(hdr, self)));
	}
	return totalLength - fixedFields;
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little because the class index and superclass almost certainly share
	a cache line. */

	/* StackInterpreter>>#superclassOf: */
sqInt
superclassOf(sqInt classPointer, struct foo * self)
{
    sqInt objOop;

	/* begin followField:ofObject: */
	objOop = longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord(self))))));
	if (((objOop & (tagMask(self))) == 0)
	 && (((longAt(objOop)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop, self);
	}
	return objOop;
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted. */

	/* StackInterpreter>>#synchronousSignal: */
static sqInt NoDbgRegParms
synchronousSignal(sqInt aSemaphore, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt excessSignals;
    sqInt proc;
    sqInt referent;

	if ((assert(!(isForwarded(aSemaphore, self))),
	(longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))))) == GIV(nilObj))) {

		/* no process is waiting on this semaphore */
		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore, self);
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt) (excessSignals + 1)) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(aSemaphore, self)));
			longAtput((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(ExcessSignalsIndex) << (shiftForWord(self))))), (((usqInt)(excessSignals + 1) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		return 0;
	}
	/* begin ensureSemaphoreUnforwardedThroughContext: */
	proc = longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))));
	if (((longAt(proc)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		followForwardedObjectFieldstoDepth(aSemaphore, 1, self);
		proc = longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))));
	}
	assert(!((isForwarded(proc, self))));
	ctxt = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))));
	if (((longAt(ctxt)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(ctxt, self));
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((ctxt + BaseHeaderSize) + (0U << (shiftForWord(self))));
		while (((referent & (tagMask(self))) == 0)
		 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
		}
		ctxt = referent;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(proc, self)));
		if ((assert(isNonImmediate(proc, self)),
		oopisGreaterThanOrEqualTo(proc, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((ctxt & (tagMask(self))) == 0)
			 && (oopisLessThan(ctxt, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(proc))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(proc, self);
				}
			}
		}
		longAtput((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))), ctxt);
	}
	return resumepreemptedYieldingIf(removeFirstLinkOfList(aSemaphore, self), GIV(preemptionYields), self);
}

	/* StackInterpreter>>#tempCountOf: */
sqInt
tempCountOf(sqInt methodPointer, struct foo * self)
{
    sqInt header;

	/* begin temporaryCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	return (((usqInt) header) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#temporaryCountOfMethodHeader: */
sqInt
temporaryCountOfMethodHeader(sqInt header, struct foo * self)
{
	return (((usqInt) header) >> MethodHeaderTempCountShift) & 0x3F;
}


/*	Record a process to be awoken on the next interpreter cycle. */

	/* StackInterpreter>>#transferTo: */
static void NoDbgRegParms
transferTo(sqInt newProc, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt aMethodObj;
    sqInt index;
    StackPage *lastUsedPage;
    usqInt lip;
    StackPage *lruOrFree;
    sqInt newContext;
    StackPage *newPage;
    sqInt objOop;
    sqInt oldProc;
    sqInt sched;
    sqInt senderOop;
    char *sp;
    char *theFrame;
    StackPage *thePage;
    sqInt top;
    sqInt valuePointer;
    sqInt valuePointer1;

	GIV(statProcessSwitch) += 1;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	/* begin assertValidExecutionPointe:r:s: */
	lip = GIV(instructionPointer) + 1;
	assertValidExecutionPointersimbarline(lip, GIV(framePointer), GIV(stackPointer), !0, __LINE__, self);
	/* begin schedulerPointer */
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	sched = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	/* begin fetchPointer:ofObject: */
	oldProc = longAt((sched + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))));
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer), self), self));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l3;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord, self);
	l3:	/* end ensureFrameIsMarried:SP: */;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(oldProc, self)));
	if ((assert(isNonImmediate(oldProc, self)),
	oopisGreaterThanOrEqualTo(oldProc, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((activeContext & (tagMask(self))) == 0)
		 && (oopisLessThan(activeContext, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(oldProc))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(oldProc, self);
			}
		}
	}
	longAtput((oldProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))), activeContext);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(sched, self)));
	if ((assert(isNonImmediate(sched, self)),
	oopisGreaterThanOrEqualTo(sched, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((newProc & (tagMask(self))) == 0)
		 && (oopisLessThan(newProc, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(sched))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(sched, self);
			}
		}
	}
	longAtput((sched + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord(self))))), newProc);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = GIV(nilObj);
	assert(!(isOopForwarded(newProc, self)));
	longAtput((newProc + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord(self))))), valuePointer);
	/* begin externalSetStackPageAndPointersForSuspendedContextOfProcess: */
	newContext = longAt((newProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))));
	assert(isContext(newContext, self));
	if (((((longAt((newContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
		assert(checkIsStillMarriedContextcurrentFP(newContext, GIV(framePointer), self));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = GIV(nilObj);
	assert(!(isOopForwarded(newProc, self)));
	longAtput((newProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))), valuePointer1);
	if ((((((longAt((newContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(newContext, self)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((newContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		theFrame = pointerForOop(senderOop - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		if (theFrame != ((thePage->headFP))) {

			/* explicit assignment of suspendedContext can cause switch to interior frame. */
			/* begin newStackPage */
			lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
			if (((lruOrFree->baseFP)) == 0) {
				newPage = lruOrFree;
				goto l14;
			}
			divorceFramesIn(lruOrFree, self);
			newPage = lruOrFree;
	l14:	/* end newStackPage */;
			moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFrame, thePage, self), newPage, self);
			/* begin markStackPageLeastMostRecentlyUsed: */
			assert(newPage == ((GIV(mostRecentlyUsedPage)->nextPage)));
			lastUsedPage = (newPage->nextPage);
			while (((lastUsedPage->baseFP)) == 0) {
				lastUsedPage = (lastUsedPage->nextPage);
			}
			if (((lastUsedPage->nextPage)) == newPage) {
				goto l10;
			}
			(((newPage->prevPage))->nextPage = (newPage->nextPage));
			(((newPage->nextPage))->prevPage = (newPage->prevPage));
			(((lastUsedPage->prevPage))->nextPage = newPage);
			(newPage->prevPage = (lastUsedPage->prevPage));
			(newPage->nextPage = lastUsedPage);
			(lastUsedPage->prevPage = newPage);
			assert(pageListIsWellFormed(self));
	l10:	/* end markStackPageLeastMostRecentlyUsed: */;
		}
		assert(((thePage->headFP)) == theFrame);
	}
	else {
		thePage = makeBaseFrameFor(newContext, self);
		theFrame = (thePage->baseFP);
	}
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage, self);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	/* begin setMethod: */
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method), self));
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method), self)
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
;
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !0, __LINE__, self);
}

	/* StackInterpreter>>#ultimateLiteralOf: */
sqInt
ultimateLiteralOf(sqInt aMethodOop, struct foo * self)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop, self));
	/* begin literal:ofMethod: */
	offset = ((assert((((((assert(isCompiledMethod(aMethodOop, self)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
((((assert(isCompiledMethod(aMethodOop, self)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) - 1;
	/* begin fetchPointer:ofObject: */
	return longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord(self))))));
}


/*	So rare it mustn't bulk up the common path */

	/* StackInterpreter>>#unfollow:atIndex: */
static sqInt NoDbgRegParms NeverInline
unfollowatIndex(sqInt litVar, sqInt literalIndex, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followed;
    sqInt referent;

	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(litVar, self));
	/* begin fetchPointer:ofMaybeForwardedObject: */
	referent = longAt((litVar + BaseHeaderSize) + (0U << (shiftForWord(self))));
	while (((referent & (tagMask(self))) == 0)
	 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin fetchPointer:ofMaybeForwardedObject: */
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
	}
	followed = referent;
	/* begin literal:ofMethod:put: */
	assert(!(isForwarded(GIV(method), self)));
	if ((assert(isNonImmediate(GIV(method), self)),
	oopisGreaterThanOrEqualTo(GIV(method), GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((followed & (tagMask(self))) == 0)
		 && (oopisLessThan(followed, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(GIV(method)))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(GIV(method), self);
			}
		}
	}
	longAtput((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << (shiftForWord(self))))), followed);
	return followed;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object. */

	/* StackInterpreter>>#updateDisplayLeft:Top:Right:Bottom: */
static sqInt NoDbgRegParms
updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt left;
    sqInt right;
    sqInt surfaceHandle;
    sqInt top;

	left = ((l < 0) ? 0 : l);
	right = ((r < displayWidth) ? r : displayWidth);
	top = ((t < 0) ? 0 : t);
	bottom = ((b < displayHeight) ? b : displayHeight);
	if (!((left <= right)
		 && (top <= bottom))) {
		return null;
	}
	if (((((((sqInt)displayBits))) & 7) == 1)) {
		surfaceHandle = ((((sqInt)displayBits)) >> 3);
		if (showSurfaceFn == 0) {
			showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin", self);
			if (showSurfaceFn == 0) {
				/* begin primitiveFailFor: */
				return (GIV(primFailCode) = PrimErrNotFound);
			}
		}
		showSurfaceFn(surfaceHandle, left, top, right - left, bottom - top);
	}
	else {
		assert(isNonImmediate(((sqInt)displayBits), self));
		ioShowDisplay(((sqInt)displayBits), displayWidth, displayHeight, displayDepth, left, right, top, bottom);
	}
	return 0;
}


/*	Update the frame's spouse context with the frame's current state except
	for the
	sender and instruction pointer, which are used to mark the context as
	married. 
 */

	/* StackInterpreter>>#updateStateOfSpouseContextForFrame:WithSP: */
static void NoDbgRegParms
updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *pointer;
    sqInt tempIndex;
    sqInt theContext;

	assert(frameHasContext(theFP, self));
	/* begin frameContext: */
	theContext = longAt(theFP + FoxThisContext);
	assert((frameReceiver(theFP, self)) == (fetchPointerofObject(ReceiverIndex, theContext, self)));
	/* begin frameNumArgs: */
	tempIndex = byteAt((theFP + FoxFrameFlags) + 1);
	pointer = theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(tempIndex) << (shiftForWord(self))))));
	for (i = 1; i <= tempIndex; i += 1) {
		pointer -= BytesPerWord;
		assert(addressCouldBeOop(longAt(pointer), self));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext, self)));
		if ((assert(isNonImmediate(theContext, self)),
		oopisGreaterThanOrEqualTo(theContext, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if ((((longAt(pointer)) & (tagMask(self))) == 0)
			 && (oopisLessThan(longAt(pointer), GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(theContext, self);
				}
			}
		}
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord(self))))), longAt(pointer));
	}
	pointer = (theFP + FoxReceiver) - BytesPerWord;
	while (pointer >= theSP) {
		assert(addressCouldBeOop(longAt(pointer), self));
		tempIndex += 1;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext, self)));
		if ((assert(isNonImmediate(theContext, self)),
		oopisGreaterThanOrEqualTo(theContext, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if ((((longAt(pointer)) & (tagMask(self))) == 0)
			 && (oopisLessThan(longAt(pointer), GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(theContext, self);
				}
			}
		}
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + tempIndex)) << (shiftForWord(self))))), longAt(pointer));
		pointer -= BytesPerWord;
	}
	assert((ReceiverIndex + tempIndex) < (lengthOf(theContext, self)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext, self)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))), (((usqInt)tempIndex << 3) | 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */

	/* StackInterpreter>>#validInstructionPointer:inFrame: */
static sqInt NoDbgRegParms
validInstructionPointerinFrame(usqInt anInstrPointer, char *fp, struct foo * self)
{
	return (anInstrPointer >= ((((longAt(fp + FoxMethod)) + (lastPointerOf(longAt(fp + FoxMethod), self))) + BytesPerOop) - 1))
	 && (anInstrPointer < ((((longAt(fp + FoxMethod)) + (numBytesOfBytes(longAt(fp + FoxMethod), self))) + BaseHeaderSize) - 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */
/*	-1 for pre-increment in fetchNextBytecode */

	/* StackInterpreter>>#validInstructionPointer:inMethod:framePointer: */
sqInt
validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp, struct foo * self)
{
	return (theInstrPointer >= (((aMethod + (lastPointerOf(aMethod, self))) + BytesPerOop) - 1))
	 && (theInstrPointer < (((aMethod + (numBytesOfBytes(aMethod, self))) + BaseHeaderSize) - 1));
}


/*	Check that the base frames in all in-use stack pages have a sender and a
	saved context.
 */

	/* StackInterpreter>>#validStackPageBaseFrames */
static sqInt
validStackPageBaseFrames(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages), self);
		if (!(isFree(aPage, self))) {
			if (!(validStackPageBaseFrame(aPage, self))) {
				return 0;
			}
		}
	}
	return 1;
}


/*	Check that the base frame in the stack page has a valid sender context. */

	/* StackInterpreter>>#validStackPageBaseFrame: */
static sqInt NoDbgRegParms
validStackPageBaseFrame(StackPage *aPage, struct foo * self)
{
    sqInt senderContextOrNil;
    char *theFP;

	if (!(asserta(isBaseFrame((aPage->baseFP), self)))) {
		return 0;
	}
	/* begin frameCallerContext: */
	theFP = (aPage->baseFP);
	senderContextOrNil = longAt(theFP + FoxCallerContext);
	if (!(asserta(addressCouldBeObj(senderContextOrNil, self)))) {
		return 0;
	}
	if (!(asserta((senderContextOrNil == (nilObject(self)))
		 || (isContext(senderContextOrNil, self))))) {
		return 0;
	}
	return 1;
}


/*	Void the state associated with the long-running primitive check.
	This is done when a new semaphore is installed or when it appears
	that is longRunningPrimitiveCheckMethod is invalid, e.g. because it
	has eben sampled in the middle of a GC. */

	/* StackInterpreter>>#voidLongRunningPrimitive: */
static void NoDbgRegParms NeverInline
voidLongRunningPrimitive(char *reason, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(longRunningPrimitiveCheckMethod) = null;
	GIV(longRunningPrimitiveStartUsecs) = (GIV(longRunningPrimitiveStopUsecs) = 0);
	GIV(longRunningPrimitiveSignalUndelivered) = 1;
	sqLowLevelMFence(self);
}


/*	Make sure that all VM state that affects the heap contents is voided so
	that the heap is
	ready to be snapshotted. If flushExtPrims is true, flush references to
	external primitives in methods. Answer the activeContext that should be
	stored in the snapshot. */

	/* StackInterpreter>>#voidVMStateForSnapshotFlushingExternalPrimitivesIf: */
static sqInt NoDbgRegParms
voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt address;
    sqInt address1;
    sqInt fmt;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt objOop11;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	activeContext = divorceAllFrames(self);
	/* begin bereaveAllMarriedContextsForSnapshotFlushingExternalPrimitivesIf: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit, self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self));
		if ((fmt == (indexablePointersFormat(self)))
		 && (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			makeContextSnapshotSafe(objOop1, self);
		}
		if (flushExtPrims
		 && (fmt >= (firstCompiledMethodFormat(self)))) {
			flushExternalPrimitiveOf(objOop1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart), self)) {
		assert(isEnumerableObjectNoAssert(objOop1, self));
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift(self))) & (formatMask(self));
		if ((fmt == (indexablePointersFormat(self)))
		 && (((longAt(objOop1)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			makeContextSnapshotSafe(objOop1, self);
		}
		if (flushExtPrims
		 && (fmt >= (firstCompiledMethodFormat(self)))) {
			flushExternalPrimitiveOf(objOop1, self);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory), self))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11, self)) {
			fmt = (((usqInt) (longAt(objOop11))) >> (formatShift(self))) & (formatMask(self));
			if ((fmt == (indexablePointersFormat(self)))
			 && (((longAt(objOop11)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
				makeContextSnapshotSafe(objOop11, self);
			}
			if (flushExtPrims
			 && (fmt >= (firstCompiledMethodFormat(self)))) {
				flushExternalPrimitiveOf(objOop11, self);
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop11, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	return activeContext;
}


/*	Return the highest priority process that is ready to run.
	To save time looking at many empty lists before finding a
	runnable process the VM maintains a variable holding the
	highest priority runnable process. If this variable is 0 then the
	VM does not know the highest priority and must search all lists.
	Note: It is a fatal VM error if there is no runnable process. */

	/* StackInterpreter>>#wakeHighestPriority */
static sqInt
wakeHighestPriority(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt p;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	/* begin fetchPointer:ofObject: */
	objOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord(self))))));
	objOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord(self))))));
	schedLists = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord(self))))));
	if (GIV(highestRunnableProcessPriority) == 0) {
		/* begin numSlotsOf: */
		assert((classIndexOf(schedLists, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots = byteAt(schedLists + 7);
		p = (numSlots == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(schedLists - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
	}
	else {
		p = GIV(highestRunnableProcessPriority);
	}
	while (((p -= 1)) >= 0) {
		/* begin fetchPointer:ofObject: */
		processList = longAt((schedLists + BaseHeaderSize) + (((sqInt)((usqInt)(p) << (shiftForWord(self))))));
		while (!((assert(!(isForwarded(processList, self))),
		(longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord(self))))))) == GIV(nilObj)))) {

			/* Only answer processes with a runnable suspendedContext.
			   Discard those that aren't; the VM would crash otherwise. */
			proc = removeFirstLinkOfList(processList, self);
			/* begin fetchPointer:ofObject: */
			ctxt = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord(self))))));
			if (isLiveContext(ctxt, self)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
			
#      if SPURVM

			/* This is uncommon, so we can deal with forwarders here instead of assuming there isn't. */
			if (((ctxt & (tagMask(self))) == 0)
			 && (((longAt(ctxt)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				ctxt = fixFollowedFieldofObjectwithInitialValue(SuspendedContextIndex, proc, ctxt, self);
			}
			if (isLiveContext(ctxt, self)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
#      endif /* SPURVM */
			warning("evicted zombie process from run queue");
		}
	}
	error("scheduler could not find a runnable process");
	return null;
}

	/* StackInterpreter>>#whereIs: */
char *
whereIs(sqInt anOop, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *where;

	/* begin whereIsMaybeHeapThing: */
	if ((oopisLessThan(anOop, GIV(newSpaceLimit), self))
	 && (oopisGreaterThanOrEqualTo(anOop, GIV(newSpaceStart), self))) {
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((eden(self)).start), GIV(freeStart), self)) {
			where = " is in eden";
			goto l1;
		}
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((futureSpace(self)).start), futureSurvivorStart(self), self)) {
			where = " is in future space";
			goto l1;
		}
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((pastSpace(self)).start), GIV(pastSpaceStart), self)) {
			where = " is in past space";
			goto l1;
		}
		where = " is in new space";
		goto l1;
	}
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(oldSpaceStart), GIV(endOfMemory), self)) {
		if (segmentContainingObj(anOop, self)) {
			where = " is in old space";
			goto l1;
		}
		where = " is between old space segments";
		goto l1;
	}
	where = null;
	l1:	/* end whereIsMaybeHeapThing: */;
	if (!(where == null)) {
		return where;
	}
	/* begin whereIsMaybeStackThing: */
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(stackMemory), GIV(pages), self)) {
		where = " is in the stack zone";
		goto l2;
	}
	where = null;
	l2:	/* end whereIsMaybeStackThing: */;
	if (!(where == null)) {
		return where;
	}
	return " is no where obvious";
}


/*	Write the image header and heap contents to imageFile for snapshot. c.f.
	writeImageFileIOSimulation. The game below is to maintain 64-bit alignment
	for all putLong:toFile: occurrences. */

	/* StackInterpreter>>#writeImageFileIO */
static sqInt NeverInline
writeImageFileIO(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    int headerSize;
    squeakFileOffsetType headerStart;
    sqInt i;
    sqInt imageBytes;
    extern char imageName[];
    sqInt okToWrite;
    void *sCWIfn;
    sqInt total;

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin", self);
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!okToWrite) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	headerStart = 0;

	/* header size in bytes; do not change! */
	headerSize = 128;
	f = sqImageFileOpen(imageName, "wb", self);
	if (f == null) {

		/* could not open the image file for writing */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	assert(newSpaceIsEmpty(self));
	/* begin totalBytesInNonEmptySegments */
	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		if ((((GIV(segments)[i]).segSize)) > (2 * BaseHeaderSize)) {
			total += ((GIV(segments)[i]).segSize);
		}
	}
	imageBytes = total;
	headerStart = sqImageFileStartLocation(f, imageName, headerSize + imageBytes, self);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart, self);
	putWord32toFile(68021 /* imageFormatVersion */, f, self);
	putWord32toFile(headerSize, f, self);
	putLongtoFile(imageBytes, f, self);
	putLongtoFile(GIV(oldSpaceStart), f, self);
	putLongtoFile(GIV(specialObjectsOop), f, self);
	putLongtoFile(newObjectHash(self), f, self);
	putLongtoFile(getSnapshotScreenSize(self), f, self);
	putLongtoFile(((((GIV(fullScreenFlag) + ((VMBIGENDIAN
	? 0
	: 2))) + ((GIV(preemptionYields)
	? 0
	: 16))) + ((GIV(newFinalization)
	? 64
	: 0))) + ((sendWheelEvents
	? 128
	: 0))) + (((GIV(imageHeaderFlags) | 211) - 211)), f, self);
	putWord32toFile(extraVMMemory, f, self);
	putShorttoFile(desiredNumStackPages, f, self);
	putShorttoFile(GIV(theUnknownShort), f, self);
	putWord32toFile(desiredEdenBytes, f, self);
	putShorttoFile((GIV(maxExtSemTabSizeSet)
		? ioGetMaxExtSemTableSize(self)
		: 0), f, self);
	putShorttoFile(GIV(the2ndUnknownShort), f, self);
	putLongtoFile(((GIV(segments)[0]).segSize), f, self);
	putLongtoFile(GIV(totalFreeOldSpace), f, self);
	
	/* Pad the rest of the header. */
	putLongtoFile(0, f, self);

	/* Pad the rest of the header. */
	putLongtoFile(0, f, self);
	putLongtoFile(0, f, self);
	putLongtoFile(0, f, self);
	putLongtoFile(0, f, self);
	assert((headerStart + headerSize) == (sqImageFilePosition(f, self)));
	sqImageFileSeek(f, headerStart + headerSize, self);
	if (GIV(primFailCode)) {

		/* file write or seek failure */
		sqImageFileClose(f, self);
		return null;
	}
	bytesWritten = writeImageSegmentsToFile(f, self);
	/* begin success: */
	if (!(bytesWritten == imageBytes)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	sqImageFileClose(f, self);
	return 0;
}

	/* StackInterpreterPrimitives>>#cloneContext: */
static sqInt NoDbgRegParms
cloneContext(sqInt aContext, struct foo * self)
{
    sqInt cloned;
    sqInt frameNumArgs;
    sqInt i;
    usqInt numSlots;
    sqInt senderOop;
    sqInt sp;
    char *spouseFP;
    usqInt sz;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;

	/* begin numSlotsOf: */
	assert((classIndexOf(aContext, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(aContext + 7);
	sz = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	cloned = allocateNewSpaceSlotsformatclassIndex(sz, indexablePointersFormat(self), ClassMethodContextCompactIndex, self);
	if (cloned != 0) {
		for (i = 0; i <= StackPointerIndex; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer = externalInstVarofContext(i, aContext, self);
			assert(!(isOopForwarded(cloned, self)));
			longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
		}
		for (i = MethodIndex; i <= ReceiverIndex; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
			assert(!(isOopForwarded(cloned, self)));
			longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer1);
		}
		if ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(aContext, self)))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
			assert((((senderOop) & 7) == 1));
			spouseFP = pointerForOop(senderOop - 1);
			sp = (stackPointerIndexForFrame(spouseFP, self)) - 1;
			for (i = 0; i <= sp; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer2 = (i < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
					? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - i) * BytesPerWord))
					: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - i) * BytesPerWord)));
				assert(!(isOopForwarded(cloned, self)));
				longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord(self))))), valuePointer2);
			}
		}
		else {
			sp = (fetchStackPointerOf(aContext, self)) - 1;
			for (i = 0; i <= sp; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer3 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord(self))))));
				assert(!(isOopForwarded(cloned, self)));
				longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord(self))))), valuePointer3);
			}
		}
	}
	return cloned;
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#fieldOrSenderFP:ofContext: */
static sqInt NoDbgRegParms
fieldOrSenderFPofContext(sqInt index, sqInt contextObj, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderOop;
    char *spouseFP;
    sqInt tempIndex;

	tempIndex = index - CtxtTempFrameStart;
	if (!((((((longAt((contextObj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(contextObj, self))))) {
		return (tempIndex >= (fetchStackPointerOf(contextObj, self))
			? /* begin nilObject */ GIV(nilObj)
			: (longAt((contextObj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))))));
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((contextObj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - 1);
	if (tempIndex >= (stackPointerIndexForFrame(spouseFP, self))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	return fieldofFrame(index, spouseFP, self);
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#field:ofFrame: */
static sqInt NoDbgRegParms
fieldofFrame(sqInt index, char *theFP, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt frameNumArgs;
    sqInt numArgs;

	
	switch (index) {
	case SenderIndex:
		/* begin frameCallerFP: */
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		return (callerFP == 0
			? (/* begin frameCallerContext: */
				longAt(theFP + FoxCallerContext))
			: ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0
					? (assert(checkIsStillMarriedContextcurrentFP(frameContext(callerFP, self), null, self)),
						/* begin frameContext: */
						longAt(callerFP + FoxThisContext))
					: ((sqInt)callerFP)));

	case StackPointerIndex:
	case InstructionPointerIndex:
		return ConstZero;

	case MethodIndex:
		/* begin frameMethodObject: */
		return longAt(theFP + FoxMethod);

	case ClosureIndex:
		return ((byteAt((theFP + FoxFrameFlags) + 3)) != 0
			? (/* begin frameStackedReceiver:numArgs: */
				(numArgs = byteAt((theFP + FoxFrameFlags) + 1)),
				longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord(self))))))))
			: /* begin nilObject */ GIV(nilObj));

	case ReceiverIndex:
		/* begin frameReceiver: */
		return longAt(theFP + FoxReceiver);

	default:
		assert((((index - CtxtTempFrameStart) >= 0) && ((index - CtxtTempFrameStart) <= (stackPointerIndexForFrame(theFP, self)))));
		/* begin temporary:in: */
		return ((index - CtxtTempFrameStart) < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
			? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord))
			: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord)));

	}
}

	/* StackInterpreterPrimitives>>#isAppropriateForCopyObject: */
static sqInt NoDbgRegParms
isAppropriateForCopyObject(sqInt oop, struct foo * self)
{
	if (!(((((usqInt) (longAt(oop))) >> (formatShift(self))) & (formatMask(self))) <= 5 /* lastPointerFormat */)) {
		return 0;
	}
	if (((oop & (tagMask(self))) == 0)
	 && (((longAt(oop)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		return !((((((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(oop, self))));
	}
	return 1;
}

	/* StackInterpreterPrimitives>>#noInlineLoadFloatOrIntFrom: */
static double NoDbgRegParms NeverInline
noInlineLoadFloatOrIntFrom(sqInt floatOrInt, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    double result;
    usqLong rot;
    sqInt shift;
    sqInt tagBits;
    double value;

	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrInt & (tagMask(self)))) != 0) {
		if (tagBits == (smallFloatTag(self))) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrInt, self));
			rot = ((usqInt) (((usqInt)floatOrInt))) >> (numTagBits(self));
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset(self))) << ((smallFloatMantissaBits(self)) + 1)));
			}
			/* begin rotateRight: */
			rot = (rot << 0x3F) + (((usqInt) (((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			return value;
		}
		if ((tagBits == (smallIntegerTag(self)))
		 && (((shift = (64 - (numTagBits(self))) - (smallFloatMantissaBits(self))),
		(((sqInt) (((sqInt)((usqInt)(floatOrInt) << shift)))) >> shift) == floatOrInt))) {
			return ((double) ((floatOrInt >> 3)) );
		}
	}
	else {
		if (((longAt(floatOrInt)) & (classIndexMask(self))) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrInt + BaseHeaderSize, result);
			return result;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	See primitiveVMParameter method comment */

	/* StackInterpreterPrimitives>>#primitiveAllVMParameters: */
static void NoDbgRegParms
primitiveAllVMParameters(sqInt paramsArraySize, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt result;
    char *sp;
    sqInt valuePointer1;
    sqInt valuePointer10;
    sqInt valuePointer11;
    sqInt valuePointer12;
    sqInt valuePointer13;
    sqInt valuePointer14;
    sqInt valuePointer15;
    sqInt valuePointer16;
    sqInt valuePointer17;
    sqInt valuePointer18;
    sqInt valuePointer19;
    sqInt valuePointer2;
    sqInt valuePointer20;
    sqInt valuePointer21;
    sqInt valuePointer22;
    sqInt valuePointer23;
    sqInt valuePointer24;
    sqInt valuePointer25;
    sqInt valuePointer26;
    sqInt valuePointer27;
    sqInt valuePointer28;
    sqInt valuePointer29;
    sqInt valuePointer3;
    sqInt valuePointer30;
    sqInt valuePointer31;
    sqInt valuePointer32;
    sqInt valuePointer33;
    sqInt valuePointer34;
    sqInt valuePointer35;
    sqInt valuePointer36;
    sqInt valuePointer37;
    sqInt valuePointer38;
    sqInt valuePointer39;
    sqInt valuePointer4;
    sqInt valuePointer40;
    sqInt valuePointer41;
    sqInt valuePointer42;
    sqInt valuePointer43;
    sqInt valuePointer44;
    sqInt valuePointer45;
    sqInt valuePointer46;
    sqInt valuePointer47;
    sqInt valuePointer48;
    sqInt valuePointer49;
    sqInt valuePointer5;
    sqInt valuePointer50;
    sqInt valuePointer51;
    sqInt valuePointer52;
    sqInt valuePointer53;
    sqInt valuePointer54;
    sqInt valuePointer55;
    sqInt valuePointer56;
    sqInt valuePointer57;
    sqInt valuePointer58;
    sqInt valuePointer59;
    sqInt valuePointer6;
    sqInt valuePointer7;
    sqInt valuePointer8;
    sqInt valuePointer9;

	result = instantiateClassindexableSize(splObj(ClassArray, self), paramsArraySize, self);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer9 = positiveMachineIntegerFor(totalBytesInSegments(self), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (0U << (shiftForWord(self))), valuePointer9);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer10 = (((usqInt)((GIV(freeStart) - (((eden(self)).start))) + (GIV(pastSpaceStart) - (((pastSpace(self)).start)))) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (1U << (shiftForWord(self))), valuePointer10);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer11 = positiveMachineIntegerFor((newSpaceCapacity(self)) + (totalBytesInSegments(self)), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (2U << (shiftForWord(self))), valuePointer11);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer12 = (((usqInt)(((sqInt)(((scavengerTenuringThreshold(self)) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (5U << (shiftForWord(self))), valuePointer12);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer13 = (((usqInt)GIV(statFullGCs) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (6U << (shiftForWord(self))), valuePointer13);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer14 = ((((GIV(statFullGCUsecs) + 500) / 1000) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (7U << (shiftForWord(self))), valuePointer14);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer15 = (((usqInt)(/* begin statScavenges */ GIV(statScavenges)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (8U << (shiftForWord(self))), valuePointer15);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer16 = (((((/* begin statScavengeGCUsecs */ GIV(statScavengeGCUsecs)) + 500) / 1000) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (9U << (shiftForWord(self))), valuePointer16);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer17 = (((usqInt)GIV(statTenures) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (10U << (shiftForWord(self))), valuePointer17);
	for (i = 11; i <= 18; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result, self)));
		longAtput((result + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), ConstZero);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer18 = positive64BitIntegerFor(GIV(statIdleUsecs), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (15U << (shiftForWord(self))), valuePointer18);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = ((((GIV(statCompactionUsecs) + 500) / 1000) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (17U << (shiftForWord(self))), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer2 = (((usqInt)(GIV(scavengeThreshold) - (((eden(self)).start))) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (18U << (shiftForWord(self))), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer19 = positive64BitIntegerFor(ioUTCStartMicroseconds(self), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (19U << (shiftForWord(self))), valuePointer19);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer20 = (((usqInt)(rootTableCount(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (20U << (shiftForWord(self))), valuePointer20);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer21 = (((usqInt)GIV(statRootTableOverflows) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (21U << (shiftForWord(self))), valuePointer21);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (22U << (shiftForWord(self))), (((usqInt)extraVMMemory << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer22 = (((usqInt)GIV(shrinkThreshold) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (23U << (shiftForWord(self))), valuePointer22);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer23 = (((usqInt)GIV(growHeadroom) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (24U << (shiftForWord(self))), valuePointer23);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer24 = (((usqInt)(ioHeartbeatMilliseconds(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (25U << (shiftForWord(self))), valuePointer24);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer25 = (((usqInt)GIV(statMarkCount) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (26U << (shiftForWord(self))), valuePointer25);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer26 = (((usqInt)0 /* statSweepCount */ << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (27U << (shiftForWord(self))), valuePointer26);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer27 = (((usqInt)0 /* statMkFwdCount */ << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (28U << (shiftForWord(self))), valuePointer27);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer28 = (((usqInt)GIV(statCompactPassCount) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (29U << (shiftForWord(self))), valuePointer28);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer29 = (((usqInt)GIV(statGrowMemory) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (30U << (shiftForWord(self))), valuePointer29);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer30 = (((usqInt)GIV(statShrinkMemory) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (0x1FU << (shiftForWord(self))), valuePointer30);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer31 = (((usqInt)GIV(statRootTableCount) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (32U << (shiftForWord(self))), valuePointer31);
	
	/* was statAllocationCount */
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer3 = positive64BitIntegerFor(currentAllocatedBytes(self), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (33U << (shiftForWord(self))), valuePointer3);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer32 = (((usqInt)GIV(statSurvivorCount) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (34U << (shiftForWord(self))), valuePointer32);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer33 = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (35U << (shiftForWord(self))), valuePointer33);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer34 = (((usqInt)0 /* statSpecialMarkCount */ << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (36U << (shiftForWord(self))), valuePointer34);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer35 = ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (37U << (shiftForWord(self))), valuePointer35);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (38U << (shiftForWord(self))), (((usqInt)GIV(statPendingFinalizationSignals) << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (39U << (shiftForWord(self))), (((usqInt)BytesPerWord << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer36 = (((usqInt)68021 /* imageFormatVersion */ << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (40U << (shiftForWord(self))), valuePointer36);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (41U << (shiftForWord(self))), (((usqInt)GIV(numStackPages) << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (42U << (shiftForWord(self))), (((usqInt)desiredNumStackPages << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer37 = (((usqInt)(((GIV(eden).limit)) - ((GIV(eden).start))) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (43U << (shiftForWord(self))), valuePointer37);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (44U << (shiftForWord(self))), (((usqInt)desiredEdenBytes << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer38 = GIV(nilObj);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (45U << (shiftForWord(self))), valuePointer38);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer39 = GIV(nilObj);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (46U << (shiftForWord(self))), valuePointer39);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer40 = (((usqInt)(((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((sendWheelEvents
	? 32
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | ((4 + 16) + 32)) - ((4 + 16) + 32)))) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (47U << (shiftForWord(self))), valuePointer40);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer41 = (((usqInt)(ioGetMaxExtSemTableSize(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (48U << (shiftForWord(self))), valuePointer41);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer42 = (((usqInt)(rootTableCapacity(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (51U << (shiftForWord(self))), valuePointer42);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer4 = (((usqInt)(numSegments(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (52U << (shiftForWord(self))), valuePointer4);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer5 = ((GIV(totalFreeOldSpace) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (53U << (shiftForWord(self))), valuePointer5);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer6 = floatObjectOf(getHeapGrowthToSizeGCRatio(self), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (54U << (shiftForWord(self))), valuePointer6);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer43 = positive64BitIntegerFor(GIV(statProcessSwitch), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (55U << (shiftForWord(self))), valuePointer43);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer44 = positive64BitIntegerFor(GIV(statIOProcessEvents), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (56U << (shiftForWord(self))), valuePointer44);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer45 = positive64BitIntegerFor(GIV(statForceInterruptCheck), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (57U << (shiftForWord(self))), valuePointer45);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer46 = positive64BitIntegerFor(GIV(statCheckForEvents), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (58U << (shiftForWord(self))), valuePointer46);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer47 = positive64BitIntegerFor(GIV(statStackOverflow), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (59U << (shiftForWord(self))), valuePointer47);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer48 = positive64BitIntegerFor(GIV(statStackPageDivorce), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (60U << (shiftForWord(self))), valuePointer48);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer49 = GIV(nilObj);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (61U << (shiftForWord(self))), valuePointer49);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer50 = GIV(nilObj);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (0x3EU << (shiftForWord(self))), valuePointer50);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer51 = ConstZero;
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (0x3FU << (shiftForWord(self))), valuePointer51);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer52 = (((usqInt)(((1) + ((IMMUTABILITY
	? 2
	: 0))) + (
#if ITIMER_HEARTBEAT
	4
#else /* ITIMER_HEARTBEAT */
	0
#endif /* ITIMER_HEARTBEAT */
	)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (64U << (shiftForWord(self))), valuePointer52);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer53 = (((usqInt)(stackPageByteSize(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (65U << (shiftForWord(self))), valuePointer53);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer7 = (((maxOldSpaceSize(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (66U << (shiftForWord(self))), valuePointer7);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer54 = floatObjectOf(statAverageLivePagesWhenMapping(self), self);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (67U << (shiftForWord(self))), valuePointer54);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer55 = (((usqInt)(statMaxPageCountWhenMapping(self)) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (68U << (shiftForWord(self))), valuePointer55);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer56 = (((usqInt)(VM_PROXY_MAJOR) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (69U << (shiftForWord(self))), valuePointer56);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer57 = (((usqInt)(VM_PROXY_MINOR) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (70U << (shiftForWord(self))), valuePointer57);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer58 = ((((GIV(statMarkUsecs) + 500) / 1000) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (71U << (shiftForWord(self))), valuePointer58);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer59 = ((((GIV(statSweepUsecs) + 500) / 1000) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (72U << (shiftForWord(self))), valuePointer59);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer8 = (((usqInt)((GIV(statMaxAllocSegmentTime) + 500) / 1000) << 3) | 1);
	assert(!(isOopForwarded(result, self)));
	longAtput((result + BaseHeaderSize) + (73U << (shiftForWord(self))), valuePointer8);
	beRootIfOld(result, self);
	/* begin methodReturnValue: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveChannelBootstrap */
static void
primitiveChannelBootstrap(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aChannel;
    sqInt anExternalAddress;
    sqInt externalAddressClass;
    sqInt interpreterState;
    char *sp;
    sqInt tagBits;

	/* begin stackTop */
	anExternalAddress = longAt(GIV(stackPointer));
	/* begin fetchClassOf: */
	externalAddressClass = (((tagBits = anExternalAddress & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(anExternalAddress, self));
	if (!(externalAddressClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord(self))))))))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	/* begin fetchPointer:ofObject: */
	interpreterState = longAt((anExternalAddress + BaseHeaderSize) + (0U << (shiftForWord(self))));
	aChannel = channelIn(interpreterState, self);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), aChannel);
	GIV(stackPointer) = sp;
}


/*	Return a shallow copy of the receiver.
	Special-case non-single contexts (because of context-to-stack mapping).
	Can't fail for contexts cuz of image context instantiation code (sigh). */

	/* StackInterpreterPrimitives>>#primitiveClone */
static void
primitiveClone(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newCopy;
    sqInt rcvr;
    char *sp;

	/* begin stackTop */
	rcvr = longAt(GIV(stackPointer));
	if (rcvr & (tagMask(self))) {
		newCopy = rcvr;
	}
	else {
		if (((longAt(rcvr)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
			newCopy = cloneContext(rcvr, self);
		}
		else {
			if ((GIV(argumentCount) == 0)
			 || (!(((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
				newCopy = clone(rcvr, self);
			}
			else {
				newCopy = 0;
			}
		}
		if (newCopy == 0) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newCopy);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveClosureCopyWithCopiedValues */
static void
primitiveClosureCopyWithCopiedValues(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copiedValues;
    sqInt i;
    sqInt integerPointer;
    usqInt newClosure;
    usqInt newClosure1;
    usqInt newObj;
    sqInt numArgs;
    usqInt numBytes;
    usqInt numCopied;
    usqInt numSlots;
    sqInt numSlots1;
    sqInt objFormat;
    char *sp;
    sqInt valuePointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		numArgs = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		numArgs = 0;
		goto l1;
	}
	l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin closureIn:numArgs:instructionPointer:copiedValues: */
	copiedValues = longAt(GIV(stackPointer));
	/* begin numSlotsOf: */
	assert((classIndexOf(copiedValues, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(copiedValues + 7);
	numCopied = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(copiedValues - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = indexablePointersFormat(self);
	numSlots1 = ClosureFirstCopiedValueIndex + numCopied;
	assert((numSlots1 >= 0)
	 && ((knownClassAtIndex(ClassBlockClosureCompactIndex, self)) != GIV(nilObj)));
	assert(((objFormat < (firstByteFormat(self))
		? objFormat
		: objFormat & (byteFormatMask(self)))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex, self), self)));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots1 < (numSlotsMask(self)));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots1 < 1
	? 8 /* allocationUnit */
	: numSlots1 * BytesPerOop));
	assert((numBytes % (allocationUnit(self))) == 0);
	assert((newObj % (allocationUnit(self))) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck(self);
		}
		if ((GIV(freeStart) + numBytes) > (((eden(self)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newClosure1 = 0;
			goto l6;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots1)) << (numSlotsFullShift(self))) + (((sqInt)((usqInt)(objFormat) << (formatShift(self)))))) + ClassBlockClosureCompactIndex);
	GIV(freeStart) += numBytes;
	newClosure1 = newObj;
	l6:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(newClosure1, self)));
	longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord(self))))), longAt(GIV(stackPointer) + (2 * BytesPerWord)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(newClosure1, self)));
	longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord(self))))), (((usqInt)((GIV(instructionPointer) + 2) - (GIV(method) + BaseHeaderSize)) << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(newClosure1, self)));
	longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord(self))))), (((usqInt)numArgs << 3) | 1));
	for (i = 0; i < numCopied; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = longAt((copiedValues + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		assert(!(isOopForwarded(newClosure1, self)));
		longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord(self))))), valuePointer);
	}
	newClosure = newClosure1;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newClosure);
	GIV(stackPointer) = sp;
}


/*	Special version of primitiveAt for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAt */
static void
primitiveContextAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt fixedFields;
    sqInt fixedFields1;
    usqLong fmt;
    usqLong fmt1;
    sqInt frameNumArgs;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    unsigned int integerValue;
    unsigned int integerValue1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt reasonCode;
    sqInt senderOop;
    char *sp;
    char *sp1;
    sqInt sp11;
    char *sp2;
    sqInt sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;

	/* begin stackTop */
	index = longAt(GIV(stackPointer));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 3);
	/* begin stackValue: */
	aContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin baseHeader: */
	hdr = long64At(aContext);
	if (!((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at: */
		hdr1 = long64At(aContext);
		fmt1 = (((unsigned sqLong)hdr1) >> (formatShift(self))) & (formatMask(self));
		/* begin lengthOf:format: */
		numSlots11 = byteAt(aContext + 7);
		numSlots2 = (numSlots11 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots11);
		if (fmt1 <= 5 /* ephemeronFormat */) {
			totalLength1 = numSlots2;
			goto l22;
		}
		if (fmt1 >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			totalLength1 = (numSlots2 << (shiftForWord(self))) - (fmt1 & 7);
			goto l22;
		}
		if (fmt1 >= (firstShortFormat(self))) {
			totalLength1 = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
			goto l22;
		}
		if (fmt1 >= (firstLongFormat(self))) {
			totalLength1 = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
			goto l22;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
			totalLength1 = numSlots2;
			goto l22;
		}
		totalLength1 = 0;
	l22:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 >= (sixtyFourBitIndexableFormat(self)))
		 || (fmt1 == 2 /* arrayFormat */)) {
			fixedFields1 = 0;
			goto l18;
		}
		if (fmt1 < 2 /* arrayFormat */) {
			fixedFields1 = totalLength1;
			goto l18;
		}
		class1 = fetchClassOfNonImm(aContext, self);
		/* begin fixedFieldsOfClassFormat: */
		classFormat1 = ((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		fixedFields1 = classFormat1 & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l18:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat(self)))
		 && ((hdr1 & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext, self)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext, self), self);
				assert((ReceiverIndex + ((sp4 >> 3))) < (lengthOf(aContext, self)));
				stSize1 = sp4;
				goto l16;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
			if (!((((sp11) & 7) == 1))) {
				stSize1 = 0;
				goto l16;
			}
			assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(aContext, self)));
			stSize1 = (sp11 >> 3);
	l16:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1, self))
			 && ((oopisLessThanOrEqualTo(index, stSize1, self))
			 && ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext, self)))))) {
				value = noInlineTemporaryin(index - 1, frameOfMarriedContext(aContext, self), self);
				goto l23;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat(self))
			? (((literalCountOf(aContext, self)) + LiteralStart) * BytesPerOop) + 1
			: 1), self))
		 && (oopisLessThanOrEqualTo(index, stSize1, self))) {
			/* begin subscript:with:format: */
			if (fmt1 <= 5 /* lastPointerFormat */) {
				/* begin fetchPointer:ofObject: */
				value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord(self))))));
				goto l23;
			}
			if (fmt1 >= (firstByteFormat(self))) {
				value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1))) << 3) | 1);
				goto l23;
			}
			if (fmt1 >= (firstShortFormat(self))) {
				value = (((usqInt)(((unsigned short) (shortAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 1))))))) << 3) | 1);
				goto l23;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
				value = positive64BitIntegerFor(long64At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 3)))), self);
				goto l23;
			}
			/* begin positive32BitIntegerFor: */
			integerValue1 = long32At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))));
			value = ((((((usqInt)integerValue1)) & 0xFFFFFFFFU) << 3) | 1);
			goto l23;
		}
		/* begin primitiveFailFor: */
		reasonCode = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
		value = 0;
	l23:	/* end stObject:at: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (!((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(aContext, self))))) {
		fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
		/* begin lengthOf:format: */
		numSlots1 = byteAt(aContext + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 5 /* ephemeronFormat */) {
			totalLength = numSlots;
			goto l11;
		}
		if (fmt >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
			goto l11;
		}
		if (fmt >= (firstShortFormat(self))) {
			totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
			goto l11;
		}
		if (fmt >= (firstLongFormat(self))) {
			totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
			goto l11;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			totalLength = numSlots;
			goto l11;
		}
		totalLength = 0;
	l11:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt >= (sixtyFourBitIndexableFormat(self)))
		 || (fmt == 2 /* arrayFormat */)) {
			fixedFields = 0;
			goto l12;
		}
		if (fmt < 2 /* arrayFormat */) {
			fixedFields = totalLength;
			goto l12;
		}
		class = fetchClassOfNonImm(aContext, self);
		/* begin fixedFieldsOfClassFormat: */
		classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l12:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp3 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp3) & 7) == 1))) {
			stSize = 0;
			goto l14;
		}
		assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(aContext, self)));
		stSize = (sp3 >> 3);
	l14:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin fetchPointer:ofObject: */
			value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord(self))))));
			goto l15;
		}
		if (fmt >= (firstByteFormat(self))) {
			value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l15;
		}
		if (fmt >= (firstShortFormat(self))) {
			value = (((usqInt)(((unsigned short) (shortAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
			goto l15;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			value = positive64BitIntegerFor(long64At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))), self);
			goto l15;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		value = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
		goto l15;
	l15:	/* end subscript:with:format: */;
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP, self)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin temporary:in: */
	value = ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
		? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord))
		: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord)));
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp2;
}


/*	Special version of primitiveAtPut for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAtPut */
static void
primitiveContextAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt fixedFields;
    sqInt fixedFields1;
    usqLong fmt;
    usqLong fmt1;
    sqInt frameNumArgs;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt reasonCode;
    sqInt senderOop;
    sqInt signedValueToStore;
    sqInt signedValueToStore1;
    char *sp;
    char *sp1;
    sqInt sp11;
    char *sp2;
    sqInt sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    usqLong unsigned64BitValueToStore;
    usqLong unsigned64BitValueToStore1;
    unsigned int unsignedValueToStore;
    unsigned int unsignedValueToStore1;
    sqInt value;

	/* begin stackTop */
	value = longAt(GIV(stackPointer));
	/* begin stackValue: */
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackValue: */
	aContext = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* begin baseHeader: */
	hdr = long64At(aContext);
	index = (index >> 3);
	if (!((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at:put: */
		hdr1 = long64At(aContext);
		fmt1 = (((unsigned sqLong)hdr1) >> (formatShift(self))) & (formatMask(self));
		/* begin lengthOf:format: */
		numSlots11 = byteAt(aContext + 7);
		numSlots2 = (numSlots11 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots11);
		if (fmt1 <= 5 /* ephemeronFormat */) {
			totalLength1 = numSlots2;
			goto l24;
		}
		if (fmt1 >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			totalLength1 = (numSlots2 << (shiftForWord(self))) - (fmt1 & 7);
			goto l24;
		}
		if (fmt1 >= (firstShortFormat(self))) {
			totalLength1 = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
			goto l24;
		}
		if (fmt1 >= (firstLongFormat(self))) {
			totalLength1 = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
			goto l24;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
			totalLength1 = numSlots2;
			goto l24;
		}
		totalLength1 = 0;
	l24:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 >= (sixtyFourBitIndexableFormat(self)))
		 || (fmt1 == 2 /* arrayFormat */)) {
			fixedFields1 = 0;
			goto l30;
		}
		if (fmt1 < 2 /* arrayFormat */) {
			fixedFields1 = totalLength1;
			goto l30;
		}
		class1 = fetchClassOfNonImm(aContext, self);
		/* begin fixedFieldsOfClassFormat: */
		classFormat1 = ((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		fixedFields1 = classFormat1 & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l30:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat(self)))
		 && ((hdr1 & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext, self)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext, self), self);
				assert((ReceiverIndex + ((sp4 >> 3))) < (lengthOf(aContext, self)));
				stSize1 = sp4;
				goto l31;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
			if (!((((sp11) & 7) == 1))) {
				stSize1 = 0;
				goto l31;
			}
			assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(aContext, self)));
			stSize1 = (sp11 >> 3);
	l31:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1, self))
			 && ((oopisLessThanOrEqualTo(index, stSize1, self))
			 && ((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext, self)))))) {
				noInlineTemporaryinput(index - 1, frameOfMarriedContext(aContext, self), value, self);
				goto l35;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat(self))
			? (((literalCountOf(aContext, self)) + LiteralStart) * BytesPerOop) + 1
			: 1), self))
		 && (oopisLessThanOrEqualTo(index, stSize1, self))) {
			/* begin subscript:with:storing:format: */
			if (fmt1 <= 5 /* lastPointerFormat */) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(aContext, self)));
				if ((assert(isNonImmediate(aContext, self)),
				oopisGreaterThanOrEqualTo(aContext, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((value & (tagMask(self))) == 0)
					 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(aContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(aContext, self);
						}
					}
				}
				longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord(self))))), value);
				goto l25;
			}
			if (fmt1 >= (firstByteFormat(self))) {
				if (!((((value) & 7) == 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l25;
				}
				signedValueToStore1 = (value >> 3);
				if (!((signedValueToStore1 >= 0)
					 && (signedValueToStore1 <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l25;
				}
				/* begin storeByte:ofObject:withValue: */
				byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
				goto l25;
			}
			if (fmt1 >= (firstShortFormat(self))) {
				if (!((((value) & 7) == 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l25;
				}
				signedValueToStore1 = (value >> 3);
				if (!((signedValueToStore1 >= 0)
					 && (signedValueToStore1 <= 0xFFFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l25;
				}
				/* begin storeShort16:ofObject:withValue: */
				shortAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 1))), signedValueToStore1);
				goto l25;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
				unsigned64BitValueToStore1 = positive64BitValueOf(value, self);
				if (!GIV(primFailCode)) {
					/* begin storeLong64:ofObject:withValue: */
					long64Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 3))), unsigned64BitValueToStore1);
				}
				goto l25;
			}
			unsignedValueToStore1 = positive32BitValueOf(value, self);
			if (!GIV(primFailCode)) {
				/* begin storeLong32:ofObject:withValue: */
				long32Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))), unsignedValueToStore1);
			}
	l25:	/* end subscript:with:storing:format: */;
		}
		else {
			/* begin primitiveFailFor: */
			reasonCode = (fmt1 <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
			GIV(primFailCode) = reasonCode;
		}
	l35:	/* end stObject:at:put: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if (!((((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(aContext, self))))) {
		fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
		/* begin lengthOf:format: */
		numSlots1 = byteAt(aContext + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 5 /* ephemeronFormat */) {
			totalLength = numSlots;
			goto l12;
		}
		if (fmt >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
			goto l12;
		}
		if (fmt >= (firstShortFormat(self))) {
			totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
			goto l12;
		}
		if (fmt >= (firstLongFormat(self))) {
			totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
			goto l12;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			totalLength = numSlots;
			goto l12;
		}
		totalLength = 0;
	l12:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt >= (sixtyFourBitIndexableFormat(self)))
		 || (fmt == 2 /* arrayFormat */)) {
			fixedFields = 0;
			goto l13;
		}
		if (fmt < 2 /* arrayFormat */) {
			fixedFields = totalLength;
			goto l13;
		}
		class = fetchClassOfNonImm(aContext, self);
		/* begin fixedFieldsOfClassFormat: */
		classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
		fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l13:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp3 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp3) & 7) == 1))) {
			stSize = 0;
			goto l15;
		}
		assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(aContext, self)));
		stSize = (sp3 >> 3);
	l15:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aContext, self)));
			if ((assert(isNonImmediate(aContext, self)),
			oopisGreaterThanOrEqualTo(aContext, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((value & (tagMask(self))) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(aContext))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(aContext, self);
					}
				}
			}
			longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord(self))))), value);
			goto l21;
		}
		if (fmt >= (firstByteFormat(self))) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l21;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l21;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l21;
		}
		if (fmt >= (firstShortFormat(self))) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l21;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l21;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))), signedValueToStore);
			goto l21;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			unsigned64BitValueToStore = positive64BitValueOf(value, self);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l21;
		}
		unsignedValueToStore = positive32BitValueOf(value, self);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l21:	/* end subscript:with:storing:format: */;
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP, self)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin temporary:in:put: */
	if ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))) {
		longAtput((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	else {
		longAtput(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp2;
}


/*	Special version of primitiveSize for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextSize */
static void
primitiveContextSize(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt totalLength;

	/* begin stackTop */
	rcvr = longAt(GIV(stackPointer));
	/* begin baseHeader: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l6;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l6;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l6;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l6;
	}
	totalLength = 0;
	l6:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l7;
	}
	class = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
	if ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
		assert(!((isFree(GIV(stackPage), self))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed(self));
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr, self)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr, self), self);
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr, self)));
			sz = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
		if (!((((sp1) & 7) == 1))) {
			sz = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr, self)));
		sz = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
	}
	else {
		sz = totalLength - fixedFields;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)sz << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Lift the veil from a context and answer an integer describing its interior
	state. Used for e.g. VM tests so they can verify they're testing what they
	think they're testing.
	0 implies a vanilla heap context.
	Bit 0 = is or was married to a frame
	Bit 1 = is still married to a frame
	Bit 2 = frame is executing machine code
	Bit 3 = has machine code pc (as opposed to nil or a bytecode pc)
	Bit 4 = method is currently compiled to machine code */

	/* StackInterpreterPrimitives>>#primitiveContextXray */
static void
primitiveContextXray(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt flags;
    char *sp;

	/* begin stackTop */
	context = longAt(GIV(stackPointer));
	if (((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(context, GIV(framePointer), self)) {
			flags = 3;
		}
		else {
			flags = 1;
		}
	}
	else {
		flags = 0;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)flags << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

	/* StackInterpreterPrimitives>>#primitiveDeferDisplayUpdates */
static void
primitiveDeferDisplayUpdates(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	/* begin stackTop */
	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Simulate an primitiveExternalCall invocation (e.g. for the Debugger). Do
	not cache anything.
	e.g. ContextPart>>tryNamedPrimitiveIn: aCompiledMethod for: aReceiver
	withArgs: arguments */

	/* StackInterpreterPrimitives>>#primitiveDoNamedPrimitiveWithArgs */
static void
primitiveDoNamedPrimitiveWithArgs(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt argumentArray;
    usqInt arraySize;
    sqInt ccIndex;
    sqInt classOop;
    sqInt firstBytecode;
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt index;
    sqInt isArray;
    sqInt methodArg;
    sqInt methodHeader;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt nItems;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt primRcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt spec;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt top;
    sqInt top1;
    sqInt val;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;

	val = 0;
	
	/* See checkForAndFollowForwardedPrimitiveState */
	GIV(metaAccessorDepth) = -2;
	/* begin stackTop */
	argumentArray = longAt(GIV(stackPointer));
	/* begin stackValue: */
	methodArg = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((argumentArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && (((methodArg & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(methodArg))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self)))))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -2);
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(roomToPushNArgs(arraySize, self))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -2);
		return;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodArg, self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((methodArg + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	if (!(((assert((((methodHeader) & 7) == 1)),
		((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) > 2)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -3);
		return;
	}
	/* begin fetchPointer:ofObject: */
	spec = longAt((methodArg + BaseHeaderSize) + (1U << (shiftForWord(self))));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord(self))))));
	if (spec & (tagMask(self))) {
		isArray = 0;
		goto l16;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(spec, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(spec)) & (classIndexMask(self));
	isArray = ClassArrayCompactIndex == ccIndex;
	goto l16;
	l16:	/* end is:instanceOf:compactClassIndex: */;
	if (!(isArray
		 && (((numSlotsOf(spec, self)) == 4)
		 && (((methodHeader & AlternateHeaderHasPrimFlag
			? ((firstBytecode = (methodArg + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0)) == PrimNumberExternalCall)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -3);
		return;
	}
	if (!(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) == arraySize)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -2);
		return;
	}
	/* begin fetchPointer:ofObject: */
	moduleName = longAt((spec + BaseHeaderSize) + (0U << (shiftForWord(self))));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		/* begin success: */
		successBoolean = ((moduleName & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)));
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		/* begin lengthOf:format: */
		fmt = (((usqInt) (longAt(moduleName))) >> (formatShift(self))) & (formatMask(self));
		/* begin numSlotsOfAny: */
		numSlots1 = byteAt(moduleName + 7);
		numSlots2 = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(moduleName - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 5 /* ephemeronFormat */) {
			moduleLength = numSlots2;
			goto l14;
		}
		if (fmt >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			moduleLength = (numSlots2 << (shiftForWord(self))) - (fmt & 7);
			goto l14;
		}
		if (fmt >= (firstShortFormat(self))) {
			moduleLength = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt & 3);
			goto l14;
		}
		if (fmt >= (firstLongFormat(self))) {
			moduleLength = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt & 1);
			goto l14;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			moduleLength = numSlots2;
			goto l14;
		}
		moduleLength = 0;
	l14:	/* end lengthOf:format: */;
	}
	/* begin fetchPointer:ofObject: */
	functionName = longAt((spec + BaseHeaderSize) + (1U << (shiftForWord(self))));
	/* begin success: */
	successBoolean1 = ((functionName & (tagMask(self))) == 0)
	 && (((((usqInt) (longAt(functionName))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self)));
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin lengthOf:format: */
	fmt1 = (((usqInt) (longAt(functionName))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(functionName + 7);
	numSlots3 = (numSlots11 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(functionName - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt1 <= 5 /* ephemeronFormat */) {
		functionLength = numSlots3;
		goto l18;
	}
	if (fmt1 >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		functionLength = (numSlots3 << (shiftForWord(self))) - (fmt1 & 7);
		goto l18;
	}
	if (fmt1 >= (firstShortFormat(self))) {
		functionLength = (numSlots3 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
		goto l18;
	}
	if (fmt1 >= (firstLongFormat(self))) {
		functionLength = (numSlots3 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
		goto l18;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
		functionLength = numSlots3;
		goto l18;
	}
	functionLength = 0;
	l18:	/* end lengthOf:format: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -3);
		return;
	}
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLengthAccessorDepthInto(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength, (&GIV(metaAccessorDepth)), self);
	if (addr == 0) {
		GIV(metaAccessorDepth) = -2;
	}
	if (addr == 0) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -1);
		return;
	}
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((knownClassAtIndex(ClassArrayCompactIndex, self)) != GIV(nilObj));
	assert((2 /* arrayFormat */) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex, self), self)));
	GIV(tempOop) = allocateNewSpaceSlotsformatclassIndex(4, 2 /* arrayFormat */, ClassArrayCompactIndex, self);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (argumentArray = popStack(self));
	assert(!(isOopForwarded(GIV(tempOop), self)));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord(self))), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = (primRcvr = popStack(self));
	assert(!(isOopForwarded(GIV(tempOop), self)));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord(self))), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer2 = top;
	assert(!(isOopForwarded(GIV(tempOop), self)));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord(self))), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer3 = top1;
	assert(!(isOopForwarded(GIV(tempOop), self)));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord(self))), valuePointer3);
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), primRcvr);
	GIV(stackPointer) = sp5;
	GIV(argumentCount) = arraySize;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		object = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self))))));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	/* begin callExternalPrimitive: */
	GIV(primitiveFunctionPointer) = addr;
	dispatchFunctionPointer(addr, self);
	/* begin maybeFailForLastObjectOverwrite */
	if (checkAllocFiller(self)) {
		if (((freeStart(self)) < GIV(scavengeThreshold))
		 && ((longAt(freeStart(self))) != (freeStart(self)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrWritePastObject;
		}
	}
	if (GIV(primFailCode)) {

		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin push: */
		object1 = longAt((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord(self))));
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		object2 = longAt((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord(self))));
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
		GIV(stackPointer) = sp2;
		/* begin push: */
		object3 = longAt((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord(self))));
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object3);
		GIV(stackPointer) = sp3;
		/* begin push: */
		object4 = longAt((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord(self))));
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object4);
		GIV(stackPointer) = sp4;

		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(argumentCount) = 3;
		GIV(primitiveFunctionPointer) = primitiveDoNamedPrimitiveWithArgs;
		if (GIV(primFailCode) == 1) {
			GIV(primFailCode) = -1;
		}
	}
}


/*	Implement either ProtoObject>>tryPrimitive: primIndex withArgs: argArray
	or Context>>receiver: anObject tryPrimitive: primIndex withArgs: argArray.
	If this primitive fails, arrange that its error code is a negative
	integer, to
	distinguish between this failing and the primitive it invokes failing. */

	/* StackInterpreterPrimitives>>#primitiveDoPrimitiveWithArgs */
static void
primitiveDoPrimitiveWithArgs(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt index;
    sqInt nArgs;
    usqInt numSlots;
    sqInt object;
    sqInt primIdx;
    sqInt rcvr;
    sqInt referent;
    char *savedFramePointer;
    sqInt savedNumArgs;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	nArgs = 0;
	savedFramePointer = ((char *) 0);
	savedStackPointer = ((char *) 0);
	
	/* See checkForAndFollowForwardedPrimitiveState */
	GIV(metaAccessorDepth) = -2;
	if (!(((GIV(argumentCount) >= 2) && (GIV(argumentCount) <= 3)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrUnsupported);
		return;
	}
	/* begin stackTop */
	argumentArray = longAt(GIV(stackPointer));
	/* begin stackValue: */
	primIdx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((argumentArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
		 && ((((primIdx) & 7) == 1)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrBadArgument);
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray, self)) > (isForwardedObjectClassIndexPun(self)));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(roomToPushNArgs(arraySize, self))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrLimitExceeded);
		return;
	}
	primIdx = (primIdx >> 3);
	/* begin functionPointerFor:inClass: */
	GIV(primitiveFunctionPointer) = ((void (*)(void)) ((primIdx > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIdx])));
	if (GIV(primitiveFunctionPointer) == 0) {
		GIV(primitiveFunctionPointer) = primitiveDoPrimitiveWithArgs;
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrBadIndex);
		return;
	}
	if (((savedNumArgs = GIV(argumentCount))) == 3) {

		/* use first arg as receiver */
		/* ...and receiver if the three arg form */
		/* begin stackValue: */
		GIV(tempOop2) = longAt(GIV(stackPointer) + (4 * BytesPerWord));
		/* begin stackValue: */
		rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
		if (((rcvr & (tagMask(self))) == 0)
		 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(rcvr, self));
			/* begin fetchPointer:ofMaybeForwardedObject: */
			referent = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord(self))));
			while (((referent & (tagMask(self))) == 0)
			 && (((longAt(referent)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
				/* begin fetchPointer:ofMaybeForwardedObject: */
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord(self))));
			}
			rcvr = referent;
		}
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= arraySize) {
		/* begin push: */
		object = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self))))));
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp1;
		index += 1;
	}
	if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse(self);
		GIV(tempOop2) = 0;
		return;
	}

	/* prim might alloc/gc */
	/* Run the primitive (sets primFailCode) */
	GIV(tempOop) = argumentArray;
	
	/* See checkForAndFollowForwardedPrimitiveState */
	GIV(metaAccessorDepth) = primitiveAccessorDepthTable[primIdx];
	/* begin slowPrimitiveResponse */
	assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
	assert((remapBufferCount(self)) == 0);
	nArgs = GIV(argumentCount);
	savedStackPointer = GIV(stackPointer);
	savedFramePointer = GIV(framePointer);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
	assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
	/* begin maybeRetryPrimitiveOnFailure */
	if (GIV(primFailCode)) {
		retryPrimitiveOnFailure(self);
	}
	/* begin maybeFailForLastObjectOverwrite */
	if (checkAllocFiller(self)) {
		if (((freeStart(self)) < GIV(scavengeThreshold))
		 && ((longAt(freeStart(self))) != (freeStart(self)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrWritePastObject;
		}
	}
	if ((!GIV(primFailCode))
	 && ((GIV(framePointer) == savedFramePointer)
	 && (!0))) {

		/* Don't fail if primitive has done something radical, e.g. perform: */
		if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			failUnbalancedPrimitive(self);
			GIV(stackPointer) = savedStackPointer;
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod), self);
	}
	/* begin successful */
	!GIV(primFailCode);
	if (GIV(primFailCode)) {

		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		GIV(stackPointer) += arraySize * BytesPerWord;
		if (savedNumArgs == 3) {
			/* begin stackTop */
			rcvr = longAt(GIV(stackPointer));
			/* begin stackTopPut: */
			longAtPointerput(GIV(stackPointer), GIV(tempOop2));
			/* begin push: */
			longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
			GIV(stackPointer) = sp2;
		}
		/* begin pushInteger: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), (((usqInt)primIdx << 3) | 1));
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(tempOop));
		GIV(stackPointer) = sp3;
		GIV(primitiveFunctionPointer) = primitiveDoPrimitiveWithArgs;
		GIV(argumentCount) = savedNumArgs;
	}
	GIV(tempOop) = (GIV(tempOop2) = 0);
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethod */
static void
primitiveExecuteMethod(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt i;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt primitiveIndex;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt top;

	nArgs = 0;
	savedFramePointer = ((char *) 0);
	savedStackPointer = ((char *) 0);
	/* begin stackTop */
	methodArgument = longAt(GIV(stackPointer));
	if (!(((methodArgument & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (!((GIV(argumentCount) - 1) == (argumentCountOf(methodArgument, self)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = top;
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	if (methodHeader & AlternateHeaderHasPrimFlag) {
		firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primitiveIndex = (byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8)));
	}
	else {
		primitiveIndex = 0;
	}
	/* begin functionPointerFor:inClass: */
	GIV(primitiveFunctionPointer) = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) -= 1;
	/* begin executeNewMethod */
	if (GIV(primitiveFunctionPointer) != 0) {
		if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse(self);
			goto l13;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
		assert((remapBufferCount(self)) == 0);
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
		/* begin maybeRetryPrimitiveOnFailure */
		if (GIV(primFailCode)) {
			retryPrimitiveOnFailure(self);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller(self)) {
			if (((freeStart(self)) < GIV(scavengeThreshold))
			 && ((longAt(freeStart(self))) != (freeStart(self)))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if ((!GIV(primFailCode))
		 && ((GIV(framePointer) == savedFramePointer)
		 && (!0))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */
			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				failUnbalancedPrimitive(self);
				GIV(stackPointer) = savedStackPointer;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod), self);
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l13;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr, self)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader1 & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader1, self);
		}
	}
	methodHeader2 = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader2, self), self);
	}
	l13:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args. Allow for up to two extra arguments (e.g. for
	mirror primitives).
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethodArgsArray */
static void
primitiveExecuteMethodArgsArray(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argCnt;
    sqInt argumentArray;
    sqInt firstBytecode;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt primitiveIndex;
    sqInt rcvr;
    sqInt rcvr1;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;

	nArgs = 0;
	savedFramePointer = ((char *) 0);
	savedStackPointer = ((char *) 0);
	/* begin stackTop */
	methodArgument = longAt(GIV(stackPointer));
	/* begin stackValue: */
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((methodArgument & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))
		 && (((argumentArray & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	/* begin argumentCountOf: */
	assert(isCompiledMethod(methodArgument, self));
	/* begin fetchPointer:ofObject: */
	header = longAt((methodArgument + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	argCnt = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
	if (!(argCnt == (numSlotsOf(argumentArray, self)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	if (GIV(argumentCount) > 2) {

		/* CompiledMethod class>>receiver:withArguments:executeMethod:
		   SqueakObjectPrimitives class>>receiver:withArguments:apply:
		   VMMirror>>ifFail:object:with:executeMethod: et al */
		/* begin stackValue: */
		rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
		if ((GIV(argumentCount) > 4)
		 || (((rcvr & (tagMask(self))) == 0)
		 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0))) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	for (i = 0; i < argCnt; i += 1) {
		/* begin push: */
		object = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	if (methodHeader & AlternateHeaderHasPrimFlag) {
		firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primitiveIndex = (byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8)));
	}
	else {
		primitiveIndex = 0;
	}
	/* begin functionPointerFor:inClass: */
	GIV(primitiveFunctionPointer) = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = argCnt;
	/* begin executeNewMethod */
	if (GIV(primitiveFunctionPointer) != 0) {
		if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse(self);
			goto l18;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
		assert((remapBufferCount(self)) == 0);
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
		/* begin maybeRetryPrimitiveOnFailure */
		if (GIV(primFailCode)) {
			retryPrimitiveOnFailure(self);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller(self)) {
			if (((freeStart(self)) < GIV(scavengeThreshold))
			 && ((longAt(freeStart(self))) != (freeStart(self)))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if ((!GIV(primFailCode))
		 && ((GIV(framePointer) == savedFramePointer)
		 && (!0))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */
			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				failUnbalancedPrimitive(self);
				GIV(stackPointer) = savedStackPointer;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod), self);
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l18;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr1, self)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object1 = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader1 & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader1, self);
		}
	}
	methodHeader2 = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader2, self), self);
	}
	l18:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Call an external primitive. External primitive methods first literals are
	an array of
	* The module name (String | Symbol)
	* The function name (String | Symbol)
	* The session ID (SmallInteger) [OBSOLETE], or in Spur, the accessorDepth
	(Integer) * The function index (Integer) in the externalPrimitiveTable
	For fast interpreter dispatch in subsequent invocations the
	primitiveFunctionPointer in the method cache is rewritten, either to the
	function itself, or to zero if the external
	function is not found. This allows for fast responses as long as the
	method stays in
	the cache. The cache rewrite relies on lastMethodCacheProbeWrite which is
	set in
	addNewMethodToCache:.
	Now that the VM flushes function addresses from its tables, the session ID
	is obsolete,
	but it is kept for backward compatibility. Also, a failed lookup is
	reported specially. If a
	method has been looked up and not been found, the function address is
	stored as -1
	(i.e., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be
	returned from
	lookup), and the primitive fails with PrimErrNotFound.
 */

	/* StackInterpreterPrimitives>>#primitiveExternalCall */
static void
primitiveExternalCall(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt accessorDepth;
    void (*addr)();
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt i;
    sqInt index;
    sqInt lit;
    sqInt moduleLength;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt val;

	accessorDepth = 0;
	val = 0;
	if (!((((GIV(newMethod) & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))
		 && ((((assert((((((assert(isCompiledMethod(GIV(newMethod), self)),
/* begin fetchPointer:ofObject: */
longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))))))) & 7) == 1)),
		((((assert(isCompiledMethod(GIV(newMethod), self)),
/* begin fetchPointer:ofObject: */
longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self)))))))) >> 3)) & AlternateHeaderNumLiteralsMask)) > 0)
		 && (((lit = literalofMethod(0, GIV(newMethod), self)),
		(((lit & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(lit))) >> (formatShift(self))) & (formatMask(self))) == 2 /* arrayFormat */))
			 && (((numSlotsOf(lit, self)) == 4)
			 && (((index = longAt((lit + BaseHeaderSize) + (3U << (shiftForWord(self))))),
			(((index) & 7) == 1))))))))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadMethod);
		return;
	}

	/* Check if we have already looked up the function and failed. */
	index = (index >> 3);
	if (index < 0) {

		/* Function address was not found in this session,
		   Void the primitive function. */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0, self);
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrNotFound);
		return;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = GIV(externalPrimitiveTable)[index - 1];
		if (addr != 0) {
			rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr, self);
			/* begin callExternalPrimitive: */
			GIV(primitiveFunctionPointer) = addr;
			dispatchFunctionPointer(addr, self);
			/* begin maybeFailForLastObjectOverwrite */
			if (checkAllocFiller(self)) {
				if (((freeStart(self)) < GIV(scavengeThreshold))
				 && ((longAt(freeStart(self))) != (freeStart(self)))) {
					/* begin primitiveFailFor: */
					GIV(primFailCode) = PrimErrWritePastObject;
				}
			}
			/* begin maybeRetryPrimitiveOnFailure */
			if (GIV(primFailCode)) {
				retryPrimitiveOnFailure(self);
			}
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrNamedInternal);
		return;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(lit, self)));
	longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord(self))), ConstZero);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(lit, self)));
	longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord(self))), ConstZero);
	/* begin fetchPointer:ofObject: */
	moduleName = longAt((lit + BaseHeaderSize) + (0U << (shiftForWord(self))));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		if (!(((moduleName & (tagMask(self))) == 0)
			 && (((((usqInt) (longAt(moduleName))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadMethod;
		}
		/* begin lengthOf:format: */
		fmt = (((usqInt) (longAt(moduleName))) >> (formatShift(self))) & (formatMask(self));
		/* begin numSlotsOfAny: */
		numSlots1 = byteAt(moduleName + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(moduleName - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 5 /* ephemeronFormat */) {
			moduleLength = numSlots;
			goto l15;
		}
		if (fmt >= (firstByteFormat(self))) {

			/* bytes, including CompiledMethod */
			moduleLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
			goto l15;
		}
		if (fmt >= (firstShortFormat(self))) {
			moduleLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
			goto l15;
		}
		if (fmt >= (firstLongFormat(self))) {
			moduleLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
			goto l15;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			moduleLength = numSlots;
			goto l15;
		}
		moduleLength = 0;
	l15:	/* end lengthOf:format: */;
	}
	/* begin fetchPointer:ofObject: */
	functionName = longAt((lit + BaseHeaderSize) + (1U << (shiftForWord(self))));
	if (!(((functionName & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(functionName))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadMethod;
	}
	/* begin lengthOf:format: */
	fmt1 = (((usqInt) (longAt(functionName))) >> (formatShift(self))) & (formatMask(self));
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(functionName + 7);
	numSlots2 = (numSlots11 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(functionName - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt1 <= 5 /* ephemeronFormat */) {
		functionLength = numSlots2;
		goto l18;
	}
	if (fmt1 >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		functionLength = (numSlots2 << (shiftForWord(self))) - (fmt1 & 7);
		goto l18;
	}
	if (fmt1 >= (firstShortFormat(self))) {
		functionLength = (numSlots2 << ((shiftForWord(self)) - 1)) - (fmt1 & 3);
		goto l18;
	}
	if (fmt1 >= (firstLongFormat(self))) {
		functionLength = (numSlots2 << ((shiftForWord(self)) - 2)) - (fmt1 & 1);
		goto l18;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat(self))) {
		functionLength = numSlots2;
		goto l18;
	}
	functionLength = 0;
	l18:	/* end lengthOf:format: */;
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLengthAccessorDepthInto(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength, (&accessorDepth), self);
	if (addr == 0) {
		index = -1;
	}
	else {

		/* add the function to the external primitive table */
		/* begin addToExternalPrimitiveTable: */
		for (i = GIV(externalPrimitiveTableFirstFreeIndex); i < MaxExternalPrimitiveTableSize; i += 1) {
			if ((GIV(externalPrimitiveTable)[i]) == 0) {
				GIV(externalPrimitiveTable)[i] = (((void *) addr));
				index = (GIV(externalPrimitiveTableFirstFreeIndex) = i + 1);
				goto l3;
			}
		}
		index = 0;
	l3:	/* end addToExternalPrimitiveTable: */;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(lit, self)));
		longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord(self))), (((usqInt)accessorDepth << 3) | 1));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(lit, self)));
	longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord(self))), (((usqInt)index << 3) | 1));
	if (index >= 0) {
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr, self);
		/* begin callExternalPrimitive: */
		GIV(primitiveFunctionPointer) = addr;
		dispatchFunctionPointer(addr, self);
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller(self)) {
			if (((freeStart(self)) < GIV(scavengeThreshold))
			 && ((longAt(freeStart(self))) != (freeStart(self)))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		/* begin maybeRetryPrimitiveOnFailure */
		if (GIV(primFailCode)) {
			retryPrimitiveOnFailure(self);
		}
	}
	else {

		/* Otherwise void the primitive function and fail */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0, self);
		assert((fetchPointerofObject(2, lit, self)) == ConstZero);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNotFound;
	}
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found */

	/* StackInterpreterPrimitives>>#primitiveFindHandlerContext */
static void
primitiveFindHandlerContext(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt handlerOrNilOrZero;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(199, longAt(GIV(stackPointer)), GIV(nilObj), self);
	if (handlerOrNilOrZero == 0) {
		/* begin nilObject */
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind
	handling from the receiver up to but not including the argument. Return
	nil if none found.
 */

	/* StackInterpreterPrimitives>>#primitiveFindNextUnwindContext */
static void
primitiveFindNextUnwindContext(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    sqInt handlerOrNilOrZero;
    sqInt senderContext;
    sqInt senderOop;
    char *sp;
    sqInt startContext;
    char *startFP;
    sqInt stopContext;
    char *theFP;
    char *theFP1;
    char *theFPAbove;
    sqInt theMethod;
    char *theSP;

	/* begin stackTop */
	stopContext = longAt(GIV(stackPointer));
	/* begin stackValue: */
	calleeContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((stopContext == GIV(nilObj))
		 || (((stopContext & (tagMask(self))) == 0)
		 && (((longAt(stopContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	assert(stopContext != calleeContext);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if ((((((longAt((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(calleeContext, self)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, longAt(theFP + FoxCallerContext), stopContext, self);
		}
		else {
			/* begin findMethodWithPrimitive:FromFP:UpToContext: */
			startFP = pointerForOop(longAt(theFP + FoxSavedFP));
			theFP1 = startFP;
			theFPAbove = startFP;
			do {
				if (((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0)
				 && (stopContext == (longAt(theFP1 + FoxThisContext)))) {
					handlerOrNilOrZero = 0;
					goto l7;
				}
				if (!((byteAt((theFP1 + FoxFrameFlags) + 3)) != 0)) {
					theMethod = longAt(theFP1 + FoxMethod);
					if ((primitiveIndexOfMethodheader(theMethod, methodHeaderOf(theMethod, self), self)) == 198) {
						if (theFP1 == theFPAbove) {
							theSP = findSPOfon(theFP1, stackPageFor(theFP1, self), self);
						}
						else {
							assert(!(isBaseFrame(theFPAbove, self)));
							theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove, self))) + BytesPerWord;
						}
						/* begin ensureFrameIsMarried:SP: */
						if ((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(theFP1, self), self));
							handlerOrNilOrZero = longAt(theFP1 + FoxThisContext);
							goto l7;
						}
						handlerOrNilOrZero = marryFrameSP(theFP1, theSP, self);
						goto l7;
					}
				}
				theFPAbove = theFP1;
				theFP1 = pointerForOop(longAt(theFP1 + FoxSavedFP));
			} while(theFP1 != 0);
			senderContext = longAt(theFPAbove + FoxCallerContext);
			if (!(((senderContext & (tagMask(self))) == 0)
				 && (((longAt(senderContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))) {
				/* begin nilObject */
				handlerOrNilOrZero = GIV(nilObj);
				goto l7;
			}
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, stopContext, self);
	l7:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
		}
	}
	else {
		/* begin fetchPointer:ofObject: */
		startContext = longAt((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		if (((startContext & (tagMask(self))) == 0)
		 && (((longAt(startContext)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, startContext, stopContext, self);
		}
		else {
			handlerOrNilOrZero = 0;
		}
	}
	if (handlerOrNilOrZero == 0) {
		/* begin nilObject */
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that refer to this method, presumably because it has been redefined,
	overridden or removed.
 */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheByMethod */
static void
primitiveFlushCacheByMethod(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt oldMethod;
    sqInt probe;

	/* begin flushMethodCacheForMethod: */
	oldMethod = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == oldMethod) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	flushExternalPrimitiveOf(oldMethod, self);
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined.  */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheBySelector */
static void
primitiveFlushCacheBySelector(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt probe;
    sqInt selector;

	/* begin stackTop */
	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (specialSelector(16, self)))
	 || (selector == (specialSelector(17, self)))) {
		/* begin flushAtCache */
		for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
			GIV(atCache)[i1] = 0;
		}
	}
}


/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */
/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */

	/* StackInterpreterPrimitives>>#primitiveFullGC */
static void
primitiveFullGC(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    sqInt integerVal1;
    char *sp;
    char *sp1;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	/* begin pop:thenPushInteger: */
	integerVal = fullGC(self);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
	GIV(stackPointer) = sp;
	return;
	/* begin incrementalGC */
	error("shouldNotImplement");
	fullGC(self);
	/* begin pop:thenPushInteger: */
	integerVal1 = (((GIV(totalFreeOldSpace) + ((((eden(self)).limit)) - GIV(freeStart))) + ((((pastSpace(self)).limit)) - GIV(pastSpaceStart))) + ((((futureSpace(self)).limit)) - (((futureSpace(self)).limit)))) - (interpreterAllocationReserveBytes(self));
	longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal1 << 3) | 1));
	GIV(stackPointer) = sp1;
}


/*	See primitiveVMParameter method comment.
	N.B. written as a returning case to avoid branch limits in the V3 bytecode
	set. 
 */

	/* StackInterpreterPrimitives>>#primitiveGetVMParameter: */
static sqInt NoDbgRegParms
primitiveGetVMParameter(sqInt arg, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	
	switch (arg) {
	case 1:
		return positiveMachineIntegerFor(totalBytesInSegments(self), self);

	case 2:
		return (((usqInt)((GIV(freeStart) - (((eden(self)).start))) + (GIV(pastSpaceStart) - (((pastSpace(self)).start)))) << 3) | 1);

	case 3:
		return positiveMachineIntegerFor((newSpaceCapacity(self)) + (totalBytesInSegments(self)), self);

	case 6:
		return (((usqInt)(((sqInt)(((scavengerTenuringThreshold(self)) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);

	case 7:
		return (((usqInt)GIV(statFullGCs) << 3) | 1);

	case 8:
		return ((((GIV(statFullGCUsecs) + 500) / 1000) << 3) | 1);

	case 9:
		return (((usqInt)(/* begin statScavenges */ GIV(statScavenges)) << 3) | 1);

	case 10:
		return (((((/* begin statScavengeGCUsecs */ GIV(statScavengeGCUsecs)) + 500) / 1000) << 3) | 1);

	case 11:
		return (((usqInt)GIV(statTenures) << 3) | 1);

	case 12:
	case 13:
	case 14:
	case 15:
		return ConstZero;

	case 16:
		return positive64BitIntegerFor(GIV(statIdleUsecs), self);

	case 17:
		return ConstZero;

	case 18:
		return ((((GIV(statCompactionUsecs) + 500) / 1000) << 3) | 1);

	case 19:
		return (((usqInt)(GIV(scavengeThreshold) - (((eden(self)).start))) << 3) | 1);

	case 20:
		return positive64BitIntegerFor(ioUTCStartMicroseconds(self), self);

	case 21:
		return (((usqInt)(rootTableCount(self)) << 3) | 1);

	case 22:
		return (((usqInt)GIV(statRootTableOverflows) << 3) | 1);

	case 23:
		return (((usqInt)extraVMMemory << 3) | 1);

	case 24:
		return (((usqInt)GIV(shrinkThreshold) << 3) | 1);

	case 25:
		return (((usqInt)GIV(growHeadroom) << 3) | 1);

	case 26:
		return (((usqInt)(ioHeartbeatMilliseconds(self)) << 3) | 1);

	case 27:
		return (((usqInt)GIV(statMarkCount) << 3) | 1);

	case 28:
		return (((usqInt)0 /* statSweepCount */ << 3) | 1);

	case 29:
		return (((usqInt)0 /* statMkFwdCount */ << 3) | 1);

	case 30:
		return (((usqInt)GIV(statCompactPassCount) << 3) | 1);

	case 0x1F:
		return (((usqInt)GIV(statGrowMemory) << 3) | 1);

	case 32:
		return (((usqInt)GIV(statShrinkMemory) << 3) | 1);

	case 33:
		return (((usqInt)GIV(statRootTableCount) << 3) | 1);

	case 34:
		return positive64BitIntegerFor(currentAllocatedBytes(self), self);

	case 35:
		return (((usqInt)GIV(statSurvivorCount) << 3) | 1);

	case 36:
		return ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 3) | 1);

	case 37:
		return (((usqInt)0 /* statSpecialMarkCount */ << 3) | 1);

	case 38:
		return ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 3) | 1);

	case 39:
		return (((usqInt)GIV(statPendingFinalizationSignals) << 3) | 1);

	case 40:
		return (((usqInt)BytesPerWord << 3) | 1);

	case 41:
		return (((usqInt)68021 /* imageFormatVersion */ << 3) | 1);

	case 42:
		return (((usqInt)GIV(numStackPages) << 3) | 1);

	case 43:
		return (((usqInt)desiredNumStackPages << 3) | 1);

	case 44:
		return (((usqInt)(((GIV(eden).limit)) - ((GIV(eden).start))) << 3) | 1);

	case 45:
		return (((usqInt)desiredEdenBytes << 3) | 1);

	case 46:
		/* begin getCogCodeSize */
		return GIV(nilObj);

	case 47:
		/* begin getDesiredCogCodeSize */
		return GIV(nilObj);

	case 48:
		return (((usqInt)(((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((sendWheelEvents
	? 32
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | ((4 + 16) + 32)) - ((4 + 16) + 32)))) << 3) | 1);

	case 49:
		return (((usqInt)(ioGetMaxExtSemTableSize(self)) << 3) | 1);

	case 52:
		return (((usqInt)(rootTableCapacity(self)) << 3) | 1);

	case 53:
		return (((usqInt)(numSegments(self)) << 3) | 1);

	case 54:
		return ((GIV(totalFreeOldSpace) << 3) | 1);

	case 55:
		return floatObjectOf(getHeapGrowthToSizeGCRatio(self), self);

	case 56:
		return positive64BitIntegerFor(GIV(statProcessSwitch), self);

	case 57:
		return positive64BitIntegerFor(GIV(statIOProcessEvents), self);

	case 58:
		return positive64BitIntegerFor(GIV(statForceInterruptCheck), self);

	case 59:
		return positive64BitIntegerFor(GIV(statCheckForEvents), self);

	case 60:
		return positive64BitIntegerFor(GIV(statStackOverflow), self);

	case 61:
		return positive64BitIntegerFor(GIV(statStackPageDivorce), self);

	case 0x3E:
		/* begin getCodeCompactionCount */
		return GIV(nilObj);

	case 0x3F:
		/* begin getCodeCompactionMSecs */
		return GIV(nilObj);

	case 64:
		/* begin getCogMethodCount */
		return ConstZero;

	case 65:
		return (((usqInt)(((1) + ((IMMUTABILITY
	? 2
	: 0))) + (
#if ITIMER_HEARTBEAT
	4
#else /* ITIMER_HEARTBEAT */
	0
#endif /* ITIMER_HEARTBEAT */
	)) << 3) | 1);

	case 66:
		return (((usqInt)(stackPageByteSize(self)) << 3) | 1);

	case 67:
		return (((maxOldSpaceSize(self)) << 3) | 1);

	case 68:
		return floatObjectOf(statAverageLivePagesWhenMapping(self), self);

	case 69:
		return (((usqInt)(statMaxPageCountWhenMapping(self)) << 3) | 1);

	case 70:
		return (((usqInt)(VM_PROXY_MAJOR) << 3) | 1);

	case 71:
		return (((usqInt)(VM_PROXY_MINOR) << 3) | 1);

	case 72:
		return ((((GIV(statMarkUsecs) + 500) / 1000) << 3) | 1);

	case 73:
		return ((((GIV(statSweepUsecs) + 500) / 1000) << 3) | 1);

	case 74:
		return (((usqInt)((GIV(statMaxAllocSegmentTime) + 500) / 1000) << 3) | 1);

	default:
		return null;

	}
	return 0;
}

	/* StackInterpreterPrimitives>>#primitiveGIVElementOfInterpreter */
static void
primitiveGIVElementOfInterpreter(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt anExternalAddress;
    char * GIVElement;
    sqInt interpreterState;
    char *sp;

	/* begin stackTop */
	anExternalAddress = longAt(GIV(stackPointer));
	GIVElement = cStringOrNullFor(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	/* begin fetchPointer:ofObject: */
	interpreterState = longAt((anExternalAddress + BaseHeaderSize) + (0U << (shiftForWord(self))));
	address = addressOfinGIV(GIVElement, interpreterState, self);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), address);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveHaltInterpreter */
static void
primitiveHaltInterpreter(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anExternalAddress;
    sqInt integerVal;
    sqInt interpreterState;
    char *sp;

	/* begin stackTop */
	anExternalAddress = longAt(GIV(stackPointer));
	/* begin fetchPointer:ofObject: */
	interpreterState = longAt((anExternalAddress + BaseHeaderSize) + (0U << (shiftForWord(self))));
	/* begin pop:thenPushInteger: */
	integerVal = haltIn(interpreterState, self);
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */
/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */

	/* StackInterpreterPrimitives>>#primitiveIncrementalGC */
static void
primitiveIncrementalGC(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	/* begin scavengingGC */
	scavengingGCTenuringIf(TenureByAge, self);
	/* begin pop:thenPushInteger: */
	integerVal = (((GIV(totalFreeOldSpace) + ((((eden(self)).limit)) - GIV(freeStart))) + ((((pastSpace(self)).limit)) - GIV(pastSpaceStart))) + ((((futureSpace(self)).limit)) - (((futureSpace(self)).limit)))) - (interpreterAllocationReserveBytes(self));
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAt */
static void
primitiveInstVarAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    unsigned int integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;
    sqInt value;

	/* begin stackTop */
	index = longAt(GIV(stackPointer));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & (smallIntegerTag(self))) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (((rcvr & (tagMask(self))) == 0)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	index = (index >> 3);
	/* begin baseHeader: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l6;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l6;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l6;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l6;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l6;
	}
	totalLength = 0;
	l6:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l7;
	}
	class = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		value = externalInstVarofContext(index - 1, rcvr, self);
	}
	else {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin fetchPointer:ofObject: */
			value = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self))))));
			goto l4;
		}
		if (fmt >= (firstByteFormat(self))) {
			value = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 3) | 1);
			goto l4;
		}
		if (fmt >= (firstShortFormat(self))) {
			value = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))))))) << 3) | 1);
			goto l4;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			value = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 3)))), self);
			goto l4;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2))));
		value = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
		goto l4;
	l4:	/* end subscript:with:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAtPut */
static void
primitiveInstVarAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    sqInt newValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    sqInt totalLength;
    usqLong unsigned64BitValueToStore;
    unsigned int unsignedValueToStore;

	/* begin stackTop */
	newValue = longAt(GIV(stackPointer));
	/* begin stackValue: */
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (((index & (smallIntegerTag(self))) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (((rcvr & (tagMask(self))) == 0)
	 && (((longAt(rcvr)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	index = (index >> 3);
	/* begin baseHeader: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift(self))) & (formatMask(self));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask(self))
		? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* ephemeronFormat */) {
		totalLength = numSlots;
		goto l7;
	}
	if (fmt >= (firstByteFormat(self))) {

		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord(self))) - (fmt & 7);
		goto l7;
	}
	if (fmt >= (firstShortFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 1)) - (fmt & 3);
		goto l7;
	}
	if (fmt >= (firstLongFormat(self))) {
		totalLength = (numSlots << ((shiftForWord(self)) - 2)) - (fmt & 1);
		goto l7;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		totalLength = numSlots;
		goto l7;
	}
	totalLength = 0;
	l7:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat(self)))
	 || (fmt == 2 /* arrayFormat */)) {
		fixedFields = 0;
		goto l8;
	}
	if (fmt < 2 /* arrayFormat */) {
		fixedFields = totalLength;
		goto l8;
	}
	class = fetchClassOfNonImm(rcvr, self);
	/* begin fixedFieldsOfClassFormat: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord(self))))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth(self))) - 1);
	l8:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == (indexablePointersFormat(self)))
	 && ((hdr & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
		externalInstVarofContextput(index - 1, rcvr, newValue, self);
	}
	else {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr, self)));
			if ((assert(isNonImmediate(rcvr, self)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((newValue & (tagMask(self))) == 0)
				 && (oopisLessThan(newValue, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(rcvr, self);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord(self))))), newValue);
			goto l14;
		}
		if (fmt >= (firstByteFormat(self))) {
			if (!((((newValue) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l14;
			}
			signedValueToStore = (newValue >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l14;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + (index - 1), signedValueToStore);
			goto l14;
		}
		if (fmt >= (firstShortFormat(self))) {
			if (!((((newValue) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l14;
			}
			signedValueToStore = (newValue >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l14;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))), signedValueToStore);
			goto l14;
		}
		if (fmt == (sixtyFourBitIndexableFormat(self))) {
			unsigned64BitValueToStore = positive64BitValueOf(newValue, self);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l14;
		}
		unsignedValueToStore = positive32BitValueOf(newValue, self);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2))), unsignedValueToStore);
		}
	l14:	/* end subscript:with:storing:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer an Array with the current long-running primitive method
	identified by
	the heartbeat, the minimum number of milliseconds it was active for, and
	the milliseconds
	of GC activity there-in, or nil if none. Since the
	longRunningPrimitiveCheckMethod is
	sampled at interrupt time be careful to validate it before returning it. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitive */
EXPORT(sqInt)
primitiveLongRunningPrimitive(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong gcms;
    sqInt lrpcm;
    sqLong primms;
    sqInt result;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	sqLowLevelMFence(self);
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((((lrpcm = GIV(longRunningPrimitiveCheckMethod))) != null)
	 && ((addressCouldBeObj(lrpcm, self))
	 && ((!(((longAt(lrpcm)) & (classIndexMask(self))) == (isFreeObjectClassIndexPun(self))))
	 && (((((usqInt) (longAt(lrpcm))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))))) {
		result = instantiateClassindexableSize(splObj(ClassArray, self), 3, self);
		primms = ((GIV(longRunningPrimitiveStopUsecs) - GIV(longRunningPrimitiveStartUsecs)) + 500) / 1000;
		gcms = (GIV(longRunningPrimitiveGCUsecs) + 500) / 1000;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(result, self)));
		if ((assert(isNonImmediate(result, self)),
		oopisGreaterThanOrEqualTo(result, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((lrpcm & (tagMask(self))) == 0)
			 && (oopisLessThan(lrpcm, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(result, self);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (0U << (shiftForWord(self))), lrpcm);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result, self)));
		longAtput((result + BaseHeaderSize) + (1U << (shiftForWord(self))), (((usqInt)primms << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result, self)));
		longAtput((result + BaseHeaderSize) + (2U << (shiftForWord(self))), ((gcms << 3) | 1));
	}
	else {
		/* begin nilObject */
		result = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
	voidLongRunningPrimitive("get", self);
	return 0;
}


/*	Primitive. Install the semaphore to be used for collecting long-running
	primitives, 
	or nil if no semaphore should be used. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitiveSemaphore */
EXPORT(sqInt)
primitiveLongRunningPrimitiveSemaphore(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;

	/* begin stackValue: */
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((((sema) & 7) == 1))
	 || (GIV(argumentCount) != 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (sema == GIV(nilObj)) {
		GIV(longRunningPrimitiveCheckSemaphore) = null;
	}
	else {
		if (!(((sema & (tagMask(self))) == 0)
			 && (((longAt(sema)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self))))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		GIV(longRunningPrimitiveCheckSemaphore) = sema;
	}
	voidLongRunningPrimitive("install", self);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}

	/* StackInterpreterPrimitives>>#primitiveNextInInterpreter */
static void
primitiveNextInInterpreter(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anExternalAddress;
    sqInt externalAddressClass;
    sqInt integerVal;
    sqInt interpreterState;
    char *sp;
    sqInt tagBits;

	/* begin stackTop */
	anExternalAddress = longAt(GIV(stackPointer));
	/* begin fetchClassOf: */
	externalAddressClass = (((tagBits = anExternalAddress & (tagMask(self)))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord(self))))))
		: fetchClassOfNonImm(anExternalAddress, self));
	if (!(externalAddressClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord(self))))))))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	/* begin fetchPointer:ofObject: */
	interpreterState = longAt((anExternalAddress + BaseHeaderSize) + (0U << (shiftForWord(self))));
	/* begin pop:thenPushInteger: */
	integerVal = nextInInterpreter(interpreterState, self);
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	This primitive is assumed to be fast (see e.g.
	MethodDictionary>>includesKey:) so make it so.
	N.B. Works forrectly for cogged methods too. */

	/* StackInterpreterPrimitives>>#primitiveObjectPointsTo */
static void
primitiveObjectPointsTo(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong fmt;
    sqLong header;
    sqInt i;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt thang;
    sqInt trueOrFalse;

	/* begin stackTop */
	thang = longAt(GIV(stackPointer));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (rcvr & (tagMask(self))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin baseHeader: */
	header = long64At(rcvr);
	fmt = (((unsigned sqLong)header) >> (formatShift(self))) & (formatMask(self));
	if (fmt <= 5 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat(self)))
		 && ((header & (classIndexMask(self))) == ClassMethodContextCompactIndex)) {
			if (((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
				assert(!((isFree(GIV(stackPage), self))));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed(self));
				if ((((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
				 && (!(isWidowedContext(rcvr, self)))) {
					/* begin pop:thenPushBool: */
					trueOrFalse = marriedContextpointsTostackDeltaForCurrentFrame(rcvr, thang, 2, self);
					longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (trueOrFalse
						? GIV(trueObj)
						: GIV(falseObj)));
					GIV(stackPointer) = sp1;
					return;
				}
			}
			numSlots = CtxtTempFrameStart + (fetchStackPointerOf(rcvr, self));
		}
		else {
			/* begin numSlotsOf: */
			assert((classIndexOf(rcvr, self)) > (isForwardedObjectClassIndexPun(self)));
			numSlots1 = byteAt(rcvr + 7);
			numSlots = (numSlots1 == (numSlotsMask(self))
				? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots1);
		}
	}
	else {
		if (fmt < (firstCompiledMethodFormat(self))) {
			/* begin pop:thenPushBool: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(rcvr, self));
		/* begin fetchPointer:ofObject: */
		methodHeader = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
		if (methodHeader == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp3;
			return;
		}
		numSlots = ((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart;
	}
	assert((((numSlots - 1) * BytesPerOop) + BaseHeaderSize) == (lastPointerOf(rcvr, self)));
	for (i = BaseHeaderSize; i <= (((numSlots - 1) * BytesPerOop) + BaseHeaderSize); i += BytesPerOop) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp4 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp4;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp5 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp5;
}


/*	Start a new thread allocating new space; loading an image and running an
	interpreter on it
 */

	/* StackInterpreterPrimitives>>#primitiveOpenNewImage */
static void
primitiveOpenNewImage(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char * imageArguments;
    char * imagePath;
    struct foo * interpreterState;
    sqInt newExternalAddress;
    struct foo **onlySlot;
    sqInt receiver;
    char *sp;

	/* begin stackValue: */
	receiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	imagePath = cStringOrNullFor(longAt(GIV(stackPointer) + (1 * BytesPerWord)), self);
	imageArguments = cStringOrNullFor(longAt(GIV(stackPointer)), self);
	interpreterState = newImageWithArguments(imagePath, imageArguments, self);
	newExternalAddress = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord(self)))))), BytesPerWord, self);
	onlySlot = firstIndexableField(newExternalAddress, self);
	onlySlot[0] = interpreterState;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(receiver, self)));
	if ((assert(isNonImmediate(receiver, self)),
	oopisGreaterThanOrEqualTo(receiver, GIV(oldSpaceStart), self))) {

		/* most stores into young objects */
		if (((newExternalAddress & (tagMask(self))) == 0)
		 && (oopisLessThan(newExternalAddress, GIV(newSpaceLimit), self))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(receiver))) >> (rememberedBitShift(self))) & 1) != 0)) {
				remember(receiver, self);
			}
		}
	}
	longAtput((receiver + BaseHeaderSize) + (0U << (shiftForWord(self))), newExternalAddress);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((4 - 1) * BytesPerWord)), receiver);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveOwnInterpreterState */
static void
primitiveOwnInterpreterState(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    struct foo *interpreterState;
    sqInt newExternalAddress;
    struct foo **onlySlot;
    char *sp;

	interpreterState = self;
	newExternalAddress = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord(self)))))), BytesPerWord, self);
	onlySlot = firstIndexableField(newExternalAddress, self);
	onlySlot[0] = interpreterState;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), newExternalAddress);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitivePerform */
static void
primitivePerform(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt newReceiver;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    usqInt performMethod;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt tagBits;

	nArgs = 0;
	savedFramePointer = ((char *) 0);
	savedStackPointer = ((char *) 0);
	performMethod = GIV(newMethod);
	/* begin stackValue: */
	GIV(messageSelector) = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	/* begin stackValue: */
	newReceiver = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	for (i = GIV(argumentCount); i >= 1; i += -1) {
		longAtput(GIV(stackPointer) + (i * BytesPerWord), longAt(GIV(stackPointer) + ((i - 1) * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	lookupClassTag = (((tagBits = newReceiver & (tagMask(self)))) != 0
		? tagBits
		: (longAt(newReceiver)) & (classIndexMask(self)));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector), self), lengthOfMaybeImmediate(GIV(messageSelector), self), newReceiver, self);
	findNewMethodInClassTag(lookupClassTag, self);
	if (!((((GIV(newMethod) & (tagMask(self))) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift(self))) & (formatMask(self))) >= (firstCompiledMethodFormat(self))))
		 && ((argumentCountOf(GIV(newMethod), self)) == GIV(argumentCount)))) {

		/* Slide the args back up (sigh) and re-insert the selector. */
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			longAtput(GIV(stackPointer) + ((i - 1) * BytesPerWord), longAt(GIV(stackPointer) + (i * BytesPerWord)));
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), GIV(messageSelector));
		GIV(argumentCount) += 1;

		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(newMethod) = performMethod;
		GIV(primitiveFunctionPointer) = primitivePerform;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	/* begin executeNewMethod */
	if (GIV(primitiveFunctionPointer) != 0) {
		if ((((usqIntptr_t) GIV(primitiveFunctionPointer))) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse(self);
			goto l12;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount), self), self)));
		assert((remapBufferCount(self)) == 0);
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(GIV(primitiveFunctionPointer), self);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod), self));
		/* begin maybeRetryPrimitiveOnFailure */
		if (GIV(primFailCode)) {
			retryPrimitiveOnFailure(self);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller(self)) {
			if (((freeStart(self)) < GIV(scavengeThreshold))
			 && ((longAt(freeStart(self))) != (freeStart(self)))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if ((!GIV(primFailCode))
		 && ((GIV(framePointer) == savedFramePointer)
		 && (!0))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */
			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				failUnbalancedPrimitive(self);
				GIV(stackPointer) = savedStackPointer;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod), self);
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l12;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod), self));
	/* begin fetchPointer:ofObject: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord(self))))));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr, self)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method), self));
	assert((methodHeaderOf(GIV(method), self)) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
		? 256
		: 0);
#  endif /* MULTIPLEBYTECODESETS */
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if ((/* begin alternateHeaderHasPrimitiveFlag: */
	methodHeader1 & AlternateHeaderHasPrimFlag)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader1, self);
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader, self), self);
	}
	l12:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Pin or unpin the receiver, i.e. make it immobile or mobile, based on the
	argument. Answer whether the object was already pinned. N.B. pinning does
	*not* prevent
	an object from being garbage collected. */

	/* StackInterpreterPrimitives>>#primitivePin */
static void
primitivePin(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt boolean;
    sqInt obj;
    char *sp;
    sqInt wasPinned;

	/* begin stackValue: */
	obj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((obj & (tagMask(self)))
	 || (((longAt(obj)) & ((classIndexMask(self)) - (isForwardedObjectClassIndexPun(self)))) == 0)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	/* begin stackTop */
	boolean = longAt(GIV(stackPointer));
	if (!((boolean == GIV(falseObj))
		 || (boolean == GIV(trueObj)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (((((usqInt) (longAt(obj))) >> (pinnedBitShift(self))) & 1) != 0) {
		/* begin trueObject */
		wasPinned = GIV(trueObj);
		if (boolean != wasPinned) {
			/* begin setIsPinnedOf:to: */
			longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1U << (pinnedBitShift(self)))));
		}
	}
	else {
		/* begin falseObject */
		wasPinned = GIV(falseObj);
		if (boolean == GIV(trueObj)) {
			if ((((obj & (tagMask(self))) == 0)
			 && (((longAt(obj)) & (classIndexMask(self))) == ClassMethodContextCompactIndex))
			 && ((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
			 && (!(isWidowedContext(obj, self))))) {
				/* begin primitiveFailFor: */
				(GIV(primFailCode) = PrimErrBadReceiver);
				return;
			}
			if ((pinObject(obj, self)) == 0) {
				/* begin primitiveFailFor: */
				(GIV(primFailCode) = PrimErrNoMemory);
				return;
			}
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), wasPinned);
	GIV(stackPointer) = sp;
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

	/* StackInterpreterPrimitives>>#primitiveSetGCSemaphore */
EXPORT(void)
primitiveSetGCSemaphore(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
	l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcSemaphoreIndex) = index;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtMilliseconds */
static void
primitiveSignalAtMilliseconds(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong deltaMsecs;
    usqInt msecs;
    sqInt msecsObj;
    sqInt sema;

	/* begin stackTop */
	msecsObj = longAt(GIV(stackPointer));
	/* begin stackValue: */
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	msecs = positive32BitValueOf(msecsObj, self);
	if (!GIV(primFailCode)) {
		if (((sema & (tagMask(self))) == 0)
		 && (((longAt(sema)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self)))) {
			/* begin splObj:put: */
			assert(!(isForwarded(GIV(specialObjectsOop), self)));
			if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
			oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((sema & (tagMask(self))) == 0)
				 && (oopisLessThan(sema, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(GIV(specialObjectsOop), self);
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord(self))))), sema);
			deltaMsecs = msecs - ((ioMSecs(self)) & MillisecondClockMask);
			if (deltaMsecs < 0) {
				deltaMsecs = (deltaMsecs + MillisecondClockMask) + 1;
			}
			GIV(nextWakeupUsecs) = (ioUTCMicroseconds(self)) + (deltaMsecs * 1000);
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(specialObjectsOop), self)));
			if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
			oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((GIV(nilObj) & (tagMask(self))) == 0)
				 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(GIV(specialObjectsOop), self);
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord(self))))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtUTCMicroseconds */
static void
primitiveSignalAtUTCMicroseconds(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    usqLong usecs;
    sqInt usecsObj;

	/* begin stackTop */
	usecsObj = longAt(GIV(stackPointer));
	/* begin stackValue: */
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	usecs = positive64BitValueOf(usecsObj, self);
	if (!GIV(primFailCode)) {
		if (((sema & (tagMask(self))) == 0)
		 && (((longAt(sema)) & (classIndexMask(self))) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord(self)))))), self)))) {
			/* begin splObj:put: */
			assert(!(isForwarded(GIV(specialObjectsOop), self)));
			if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
			oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((sema & (tagMask(self))) == 0)
				 && (oopisLessThan(sema, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(GIV(specialObjectsOop), self);
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord(self))))), sema);
			GIV(nextWakeupUsecs) = usecs;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(specialObjectsOop), self)));
			if ((assert(isNonImmediate(GIV(specialObjectsOop), self)),
			oopisGreaterThanOrEqualTo(GIV(specialObjectsOop), GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((GIV(nilObj) & (tagMask(self))) == 0)
				 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(GIV(specialObjectsOop), self);
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord(self))))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Answer a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive answers the raw integral value
	at each slot. 
	e.g. for Strings it answers the character code, not the Character object
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAt */
static void
primitiveSlotAt(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt integerVal;
    unsigned int integerValue;
    sqInt numLiveSlots;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    sqInt value;

	/* begin stackTop */
	index = longAt(GIV(stackPointer));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
	index = ((index >> 3)) - 1;
	if (fmt <= 5 /* lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(rcvr + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if ((((usqInt)index)) < numSlots) {
			if (((longAt(rcvr)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
				assert(!((isFree(GIV(stackPage), self))));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed(self));
				numLiveSlots = (stackPointerForMaybeMarriedContext(rcvr, self)) + CtxtTempFrameStart;
				if ((((usqInt)index)) < numLiveSlots) {
					value = externalInstVarofContext(index, rcvr, self);
				}
				else {
					/* begin nilObject */
					value = GIV(nilObj);
				}
			}
			else {
				/* begin fetchPointer:ofObject: */
				value = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))));
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstByteFormat(self))) {
		if (fmt >= (firstCompiledMethodFormat(self))) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
		assert(fmt1 >= (firstByteFormat(self)));
		numSlots = ((numSlotsOf(rcvr, self)) << (shiftForWord(self))) - (fmt1 & 7);
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(byteAt((rcvr + BaseHeaderSize) + index)) << 3) | 1));
			GIV(stackPointer) = sp3;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstShortFormat(self))) {
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 1;
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			integerVal = ((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 1))))));
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
			GIV(stackPointer) = sp4;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPush: */
			oop = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3)))), self);
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstLongFormat(self))) {
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPush: */
			integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))));
			oop1 = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
			goto l7;
	l7:	/* end positive32BitIntegerFor: */;
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop1);
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin primitiveFailFor: */
	(GIV(primFailCode) = PrimErrBadReceiver);
	return;
}


/*	Assign a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive assigns a raw integral value
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAtPut */
static void
primitiveSlotAtPut(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt index;
    sqInt newValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt ok;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    usqIntptr_t value;
    sqInt value1;

	/* begin stackTop */
	newValue = longAt(GIV(stackPointer));
	/* begin stackValue: */
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (rcvr & (tagMask(self))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if (
#  if IMMUTABILITY
		(/* begin isImmutable: */
			((((usqInt) (longAt(rcvr))) >> (immutableBitShift(self))) & 1) != 0)
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
	index = ((index >> 3)) - 1;
	if (fmt <= 5 /* lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr, self)) > (isForwardedObjectClassIndexPun(self)));
		numSlots1 = byteAt(rcvr + 7);
		numSlots = (numSlots1 == (numSlotsMask(self))
			? ((usqInt) (((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if ((((usqInt)index)) < numSlots) {
			if (((longAt(rcvr)) & (classIndexMask(self))) == ClassMethodContextCompactIndex) {
				externalInstVarofContextput(index, rcvr, newValue, self);
			}
			else {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr, self)));
				if ((assert(isNonImmediate(rcvr, self)),
				oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart), self))) {

					/* most stores into young objects */
					if (((newValue & (tagMask(self))) == 0)
					 && (oopisLessThan(newValue, GIV(newSpaceLimit), self))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift(self))) & 1) != 0)) {
							remember(rcvr, self);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord(self))))), newValue);
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin positiveMachineIntegerValueOf: */
	if ((((newValue) & 7) == 1)) {
		value1 = (newValue >> 3);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = null;
			goto l15;
		}
		value = value1;
		goto l15;
	}
	if (newValue & (tagMask(self))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l15;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(newValue, self)));
	/* begin classIndexOf: */
	ccIndex = (longAt(newValue)) & (classIndexMask(self));
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l12;
	l12:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l15;
	}
	/* begin numBytesOfBytes: */
	fmt2 = (((usqInt) (longAt(newValue))) >> (formatShift(self))) & (formatMask(self));
	assert(fmt2 >= (firstByteFormat(self)));
	bs = ((numSlotsOf(newValue, self)) << (shiftForWord(self))) - (fmt2 & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l15;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((newValue + BaseHeaderSize) + (0U << 3))));
		goto l15;
	}
	else {

		/* ] */
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((newValue + BaseHeaderSize) + (0U << 2))))));
		goto l15;
	}
	l15:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (fmt >= (firstByteFormat(self))) {
		if (fmt >= (firstCompiledMethodFormat(self))) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		if ((((usqInt)value)) > 0xFF) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift(self))) & (formatMask(self));
		assert(fmt1 >= (firstByteFormat(self)));
		numSlots = ((numSlotsOf(rcvr, self)) << (shiftForWord(self))) - (fmt1 & 7);
		if ((((usqInt)index)) < numSlots) {
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + index, value);
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstShortFormat(self))) {
		if ((((usqInt)value)) > 0xFFFF) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 1;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 1))), value);
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt == (sixtyFourBitIndexableFormat(self))) {
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeLong64:ofObject:withValue: */
			long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3))), value);
			/* begin pop:thenPush: */
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp3;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstLongFormat(self))) {
		if ((((usqInt)value)) > 0xFFFFFFFFU) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		numSlots = ((usqInt) (numBytesOf(rcvr, self))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))), value);
			/* begin pop:thenPush: */
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp4;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin primitiveFailFor: */
	(GIV(primFailCode) = PrimErrBadReceiver);
	return;
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

	/* StackInterpreterPrimitives>>#primitiveStoreStackp */
static void
primitiveStoreStackp(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt newStackp;
    int onCurrentPage;
    sqInt senderOop;
    sqInt sp;
    sqInt stackp;
    char *theFP;
    StackPage *thePage;
    sqInt valuePointer;

	/* begin stackValue: */
	ctxt = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		newStackp = (integerPointer >> 3);
		goto l7;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		newStackp = 0;
		goto l7;
	}
	l7:	/* end stackIntegerValue: */;
	if (!((!GIV(primFailCode))
		 && (((newStackp >= 0) && (newStackp <= ((numSlotsOf(ctxt, self)) - CtxtTempFrameStart)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if ((((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(ctxt, self)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
		thePage = stackPageAtpages(index, GIV(pages), self);
		if (((onCurrentPage = thePage == GIV(stackPage)))
		 && (theFP == GIV(framePointer))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		externalDivorceFrameandContext(theFP, ctxt, self);
		if (onCurrentPage) {
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (GIV(stackPage)->headSP);
			GIV(framePointer) = (GIV(stackPage)->headFP);
		}
		else {
			assert(GIV(stackPage) == (stackPageFor(GIV(framePointer), self)));
			markStackPageMostRecentlyUsed(GIV(stackPage), self);
		}
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))));
	if (!((((sp) & 7) == 1))) {
		stackp = 0;
		goto l9;
	}
	assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(ctxt, self)));
	stackp = (sp >> 3);
	l9:	/* end fetchStackPointerOf: */;
	for (i = (stackp + 1); i <= newStackp; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		assert(!(isOopForwarded(ctxt, self)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(((i + CtxtTempFrameStart) - 1)) << (shiftForWord(self))))), valuePointer);
	}
	/* begin storeStackPointerValue:inContext: */
	assert((ReceiverIndex + newStackp) < (lengthOf(ctxt, self)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(ctxt, self)));
	longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord(self))))), (((usqInt)newStackp << 3) | 1));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my
	sender. This prim has to shadow the code in ContextPart>terminateTo: to be
	correct. 
 */

	/* StackInterpreterPrimitives>>#primitiveTerminateTo */
static void
primitiveTerminateTo(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContextOrNil;
    char *callerFP;
    char *callerFP1;
    char *callerFP2;
    char *contextsFP;
    usqInt contextsIP;
    char *contextsSP;
    sqInt currentCtx;
    char *fp;
    char *fp1;
    char *fp2;
    char *frameAbove;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt index3;
    char *newFP;
    char *newSP;
    sqInt nextCntx;
    sqInt numArgs;
    StackPage *pageToStopOn;
    sqInt senderOop;
    sqInt senderOop1;
    sqInt senderOop2;
    sqInt senderOop3;
    sqInt senderOop4;
    sqInt senderOop5;
    char *source;
    sqInt stackedReceiverOffset;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    sqInt thisCtx;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer11;
    sqInt valuePointer2;

	contextsFP = ((char *) 0);
	/* begin stackTop */
	aContextOrNil = longAt(GIV(stackPointer));
	if (!((aContextOrNil == GIV(nilObj))
		 || (((aContextOrNil & (tagMask(self))) == 0)
		 && (((longAt(aContextOrNil)) & (classIndexMask(self))) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackValue: */
	thisCtx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (thisCtx == aContextOrNil) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
	assert(!((isFree(GIV(stackPage), self))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed(self));
	if ((aContextOrNil != GIV(nilObj))
	 && ((((((longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(aContextOrNil, self))))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop) & 7) == 1));
		contextsFP = pointerForOop(senderOop - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage), self);
		pageToStopOn = stackPageAtpages(index, GIV(pages), self);
	}
	else {
		pageToStopOn = 0;
	}
	if ((((((longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
	 && (!(isWidowedContext(thisCtx, self)))) {
		/* begin frameOfMarriedContext: */
		senderOop2 = longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop2) & 7) == 1));
		theFP = pointerForOop(senderOop2 - 1);
		if ((theFP == GIV(framePointer))
		 && (pageToStopOn == GIV(stackPage))) {
			if ((pointerForOop(longAt(theFP + FoxSavedFP))) != contextsFP) {
				/* begin frameStackedReceiverOffset: */
				numArgs = byteAt((theFP + FoxFrameFlags) + 1);
				stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord(self)))));
				/* begin findFrameAbove:inPage: */
				fp = (pageToStopOn->headFP);
				if (fp == contextsFP) {
					frameAbove = 0;
					goto l4;
				}
				while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
					if (callerFP == contextsFP) {
						frameAbove = fp;
						goto l4;
					}
					fp = callerFP;
				}
				error("did not find theFP in stack page");
				frameAbove = 0;
	l4:	/* end findFrameAbove:inPage: */;
				contextsIP = ((usqInt)(pointerForOop(longAt(frameAbove + FoxCallerSavedIP))));
				assert(!(isBaseFrame(frameAbove, self)));
				newSP = (frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord(self))))))) + BytesPerWord;
				newFP = (newSP - stackedReceiverOffset) - BytesPerWord;
				for (source = (theFP + stackedReceiverOffset); source >= GIV(stackPointer); source += (-BytesPerWord)) {
					newSP -= BytesPerWord;
					longAtput(newSP, longAt(source));
				}
				longAtput(newFP + FoxSavedFP, contextsFP);
				longAtput(newFP + FoxCallerSavedIP, contextsIP);
				assert(isContext(thisCtx, self));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(((oopForPointer(newFP)) & (BytesPerWord - 1)) == 0);
				valuePointer = (oopForPointer(newFP)) + (smallIntegerTag(self));
				assert(!(isOopForwarded(thisCtx, self)));
				longAtput((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(((oopForPointer(contextsFP)) & (BytesPerWord - 1)) == 0);
				valuePointer1 = (oopForPointer(contextsFP)) + (smallIntegerTag(self));
				assert(!(isOopForwarded(thisCtx, self)));
				longAtput((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer1);
				GIV(framePointer) = newFP;
				GIV(stackPointer) = newSP;
			}
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
			return;
		}

		/* May cause a GC!! */
		theFP = externalEnsureIsBaseFrame(theFP, self);
		/* begin frameCallerContext: */
		currentCtx = longAt(theFP + FoxCallerContext);
		if ((aContextOrNil != GIV(nilObj))
		 && ((((((longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
		 && (!(isWidowedContext(aContextOrNil, self))))) {
			/* begin frameOfMarriedContext: */
			senderOop1 = longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
			assert((((senderOop1) & 7) == 1));
			contextsFP = pointerForOop(senderOop1 - 1);
			/* begin stackPageFor: */
			index1 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage), self);
			pageToStopOn = stackPageAtpages(index1, GIV(pages), self);
		}
		else {
			pageToStopOn = 0;
		}
	}
	else {
		/* begin fetchPointer:ofObject: */
		currentCtx = longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
	}
	if (contexthasSender(thisCtx, aContextOrNil, self)) {

		/* Need to walk the stack freeing stack pages and nilling contexts. */
		while (!((currentCtx == aContextOrNil)
		 || (currentCtx == GIV(nilObj)))) {
			assert(isContext(currentCtx, self));
			if (((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
				/* begin frameOfMarriedContext: */
				senderOop4 = longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
				assert((((senderOop4) & 7) == 1));
				theFP = pointerForOop(senderOop4 - 1);
				/* begin stackPageFor: */
				index3 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
				thePage = stackPageAtpages(index3, GIV(pages), self);
				if (thePage == GIV(stackPage)) {
					/* begin findFrameAbove:inPage: */
					fp1 = (thePage->headFP);
					if (fp1 == theFP) {
						frameAbove = 0;
						goto l16;
					}
					while (((callerFP1 = pointerForOop(longAt(fp1 + FoxSavedFP)))) != 0) {
						if (callerFP1 == theFP) {
							frameAbove = fp1;
							goto l16;
						}
						fp1 = callerFP1;
					}
					error("did not find theFP in stack page");
					frameAbove = 0;
	l16:	/* end findFrameAbove:inPage: */;
					assert(frameAbove != 0);

					/* May cause a GC!! May also reclaim aContextOrNil's page, hence... */
					frameAbove = externalEnsureIsBaseFrame(frameAbove, self);
					if ((aContextOrNil != GIV(nilObj))
					 && ((((((longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1))
					 && (!(isWidowedContext(aContextOrNil, self))))) {
						/* begin frameOfMarriedContext: */
						senderOop3 = longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
						assert((((senderOop3) & 7) == 1));
						contextsFP = pointerForOop(senderOop3 - 1);
						/* begin stackPageFor: */
						index2 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage), self);
						pageToStopOn = stackPageAtpages(index2, GIV(pages), self);
					}
					else {
						pageToStopOn = 0;
					}
				}
				else {
					if (thePage == pageToStopOn) {

						/* We're here.  Cut back the stack to aContextOrNil's frame,
						   push its instructionPointer if it's not already a head frame,
						   and we're done. */
						/* begin findFrameAbove:inPage: */
						fp2 = (thePage->headFP);
						if (fp2 == contextsFP) {
							frameAbove = 0;
							goto l17;
						}
						while (((callerFP2 = pointerForOop(longAt(fp2 + FoxSavedFP)))) != 0) {
							if (callerFP2 == contextsFP) {
								frameAbove = fp2;
								goto l17;
							}
							fp2 = callerFP2;
						}
						error("did not find theFP in stack page");
						frameAbove = 0;
	l17:	/* end findFrameAbove:inPage: */;
						if (frameAbove != 0) {
							contextsSP = ((assert(!(isBaseFrame(frameAbove, self))),
(frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord(self))))))) + BytesPerWord)) - BytesPerWord;
							longAtput(contextsSP, pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
							/* begin setHeadFP:andSP:inPage: */
							assert(contextsSP < contextsFP);
							assert((contextsSP < ((thePage->baseAddress)))
							 && (contextsSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
							assert((contextsFP < ((thePage->baseAddress)))
							 && (contextsFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
							(thePage->headFP = contextsFP);
							(thePage->headSP = contextsSP);
						}
						currentCtx = aContextOrNil;
					}
					else {

						/* We can free the entire page without further ado. */
						/* begin frameCallerContext: */
						theFP1 = (thePage->baseFP);
						currentCtx = longAt(theFP1 + FoxCallerContext);
						freeStackPageNoAssert(thePage, self);
					}
				}
			}
			else {
				/* begin fetchPointer:ofObject: */
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx, self));
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer2 = GIV(nilObj);
				assert(!(isOopForwarded(currentCtx, self)));
				longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), valuePointer2);
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer11 = GIV(nilObj);
				assert(!(isOopForwarded(currentCtx, self)));
				longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord(self))))), valuePointer11);
				currentCtx = nextCntx;
			}
		}
	}
	assert(pageListIsWellFormed(self));
	if (((((longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self)))))))) & 7) == 1)) {
		assert(checkIsStillMarriedContextcurrentFP(thisCtx, GIV(framePointer), self));
		assert(isBaseFrame(frameOfMarriedContext(thisCtx, self), self));
		/* begin frameOfMarriedContext: */
		senderOop5 = longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))));
		assert((((senderOop5) & 7) == 1));
		theFP = pointerForOop(senderOop5 - 1);
		/* begin frameCallerContext:put: */
		assert((aContextOrNil == (nilObject(self)))
		 || (isContext(aContextOrNil, self)));
		longAtput(theFP + FoxCallerContext, aContextOrNil);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(thisCtx, self)));
		if ((assert(isNonImmediate(thisCtx, self)),
		oopisGreaterThanOrEqualTo(thisCtx, GIV(oldSpaceStart), self))) {

			/* most stores into young objects */
			if (((aContextOrNil & (tagMask(self))) == 0)
			 && (oopisLessThan(aContextOrNil, GIV(newSpaceLimit), self))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(thisCtx))) >> (rememberedBitShift(self))) & 1) != 0)) {
					remember(thisCtx, self);
				}
			}
		}
		longAtput((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord(self))))), aContextOrNil);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	assert(GIV(stackPage) == (mostRecentlyUsedPage(self)));
}

	/* StackInterpreterPrimitives>>#primitiveTopFrameInInterpreter */
static void
primitiveTopFrameInInterpreter(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anExternalAddress;
    sqInt externalAddressOop;
    struct foo *interpreterState;
    sqInt *ptr;
    sqInt receiver;
    char *sp;

	/* begin stackTop */
	receiver = longAt(GIV(stackPointer));
	/* begin fetchPointer:ofObject: */
	anExternalAddress = longAt((receiver + BaseHeaderSize) + (0U << (shiftForWord(self))));
	/* begin fetchPointer:ofObject: */
	interpreterState = longAt((anExternalAddress + BaseHeaderSize) + (0U << (shiftForWord(self))));
	externalAddressOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord(self)))))), BytesPerWord, self);
	ptr = firstIndexableField(externalAddressOop, self);
	ptr[0] = (((sqInt) (interpreterState->framePointer)));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), externalAddressOop);
	GIV(stackPointer) = sp;
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end (v3)/size(Spur) of old-space (0-based, read-only)
	2	end (v3)/size(Spur) of young/new-space (read-only)
	3	end (v3)/size(Spur) of heap (read-only)
	4	nil (was allocationCount (read-only))
	5	nil (was allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs (SqueakV3) or scavenges (Spur) since startup (read-only)
	10	total milliseconds in incremental GCs (SqueakV3) or scavenges (Spur)
	since startup (read-only)
	11	tenures of surving objects since startup or reset (read-write)
	12-20 were specific to ikp's JITTER VM, now 12-15 are open for use
	16	total microseconds at idle since start-up (if non-zero)
	17	fraction of the code zone to use (Sista only; used to control code zone
	use to preserve sendAndBranchData on counter tripped callback)
	18	total milliseconds in compaction phase of full GC since start-up (Spur
	only) 19	scavenge threshold, the effective size of eden. When eden fills
	to the threshold a scavenge is scheduled. Newer Spur VMs only.
	20	utc microseconds at VM start-up (actually at time initialization, which
	precedes image load).
	21	root/remembered table size (occupancy) (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored
	in image file header).
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds
	(rw) 27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	Spur: bytes allocated in total since start-up or reset (read-write)
	(Used to be number of allocations done before current IGC/FGC (read-only))
	35	number of survivor objects after current IGC/FGC (read-only)
	36	millisecond clock when current IGC/FGC completed (read-only)
	37	number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38	milliseconds taken by current IGC (read-only)
	39	Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40	BytesPerOop for this image
	41	imageFormatVersion for the VM
	42	number of stack pages in use
	43	desired number of stack pages (stored in image file header, max 65535)
	44	size of eden, in bytes
	45	desired size of eden, in bytes (stored in image file header)
	46	machine code zone size, in bytes (Cog only; otherwise nil)
	47	desired machine code zone size (stored in image file header; Cog only;
	otherwise nil)
	48	various header flags. See getCogVMFlags.
	49	max size the image promises to grow the external semaphore table to (0
	sets to default, which is 256 as of writing)
	50-51 nil; reserved for VM parameters that persist in the image (such as
	eden above)
	52	root/remembered table capacity
	53	number of segments (Spur only; otherwise nil)
	54	total size of free old space (Spur only, otherwise nil)
	55	ratio of growth and image size at or above which a GC will be performed
	post scavenge
	56	number of process switches since startup (read-only)
	57	number of ioProcessEvents calls since startup (read-only)
	58	number of ForceInterruptCheck calls since startup (read-only)
	59	number of check event calls since startup (read-only)
	60	number of stack page overflows since startup (read-only)
	61	number of stack page divorces since startup (read-only)
	62	compiled code compactions since startup (read-only; Cog only; otherwise
	nil) 63	total milliseconds in compiled code compactions since startup
	(read-only; Cog only; otherwise nil)
	64	the number of methods that currently have jitted machine-code
	65	whether the VM supports a certain feature, MULTIPLE_BYTECODE_SETS is
	bit 0, IMMUTABILITY is bit 1
	66	the byte size of a stack page
	67	the max allowed size of old space (Spur only; nil otherwise; 0 implies
	no limit except that of the underlying platform)
	68	the average number of live stack pages when scanned by GC (at
	scavenge/gc/become et al) (read-write)
	69	the maximum number of live stack pages when scanned by GC (at
	scavenge/gc/become et al) (read-write)
	70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
	71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
	72 total milliseconds in full GCs Mark phase since startup (read-only)
	73 total milliseconds in full GCs Sweep phase since startup (read-only,
	can be 0 depending on compactors)
	74 maximum pause time due to segment allocation
	
	Note: Thanks to Ian Piumarta for this primitive. */

	/* StackInterpreterPrimitives>>#primitiveVMParameter */
static void
primitiveVMParameter(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double aDouble;
    double aFloat;
    double aProportion;
    sqInt arg;
    sqInt argOop;
    sqLong delta;
    sqInt index;
    sqInt offset;
    sqInt oop;
    sqInt paramsArraySize;
    sqInt result;
    sqInt result1;
    char *sp;
    char *sp1;
    sqInt tagBits;

	arg = 0;
	paramsArraySize = 74;
	if (GIV(argumentCount) == 0) {
		primitiveAllVMParameters(paramsArraySize, self);
		return;
	}
	if (GIV(argumentCount) > 2) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	/* begin stackValue: */
	offset = (GIV(argumentCount) == 1
		? 0
		: 1);
	index = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 3);
	if ((index < 1)
	 || (index > paramsArraySize)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* read VM parameter; written this way to avoid branch limits in V3 bytecode set */
		result = primitiveGetVMParameter(index, self);
		/* begin methodReturnValue: */
		oop = (!(result)
			? /* begin nilObject */ GIV(nilObj)
			: result);
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return;
	}
	/* begin primitiveSetVMParameter:arg: */
	argOop = longAt(GIV(stackPointer));
	if ((index == 17)
	 || ((index == 55)
	 || (index == 68))) {
		if (!(((((tagBits = argOop & (tagMask(self)))) != 0
				? tagBits == (smallFloatTag(self))
				: ((longAt(argOop)) & (classIndexMask(self))) == ClassFloatCompactIndex))
			 || ((((argOop) & 7) == 1)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l12;
		}
	}
	else {
		if (!((((argOop) & 7) == 1))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l12;
		}
		arg = (argOop >> 3);
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	
	switch (index) {
	case 5:
				break;
	case 6:
		result1 = (((usqInt)(((sqInt)(((scavengerTenuringThreshold(self)) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
		/* begin tenuringThreshold: */
		if (arg < 0) {
			GIV(primFailCode) = PrimErrBadArgument;
			goto l8;
		}
		/* begin scavengerTenuringThreshold: */
		aProportion = (((double) (arg * (8 * BytesPerOop)) )) / (((double) (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) ));
		GIV(tenuringProportion) = aProportion;
		GIV(tenureThreshold) = (aProportion == 0.0
			? 0
			: (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - aProportion)))) + ((GIV(pastSpace).start)));
		GIV(primFailCode) = 0;
	l8:	/* end tenuringThreshold: */;
		break;
	case 11:
		if (arg >= 0) {
			result1 = (((usqInt)GIV(statTenures) << 3) | 1);
			/* begin statTenures: */
			GIV(statTenures) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 17:
				break;
	case 23:
		result1 = (((usqInt)extraVMMemory << 3) | 1);
		extraVMMemory = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		break;
	case 24:
		if (arg > 0) {
			result1 = (((usqInt)GIV(shrinkThreshold) << 3) | 1);
			/* begin shrinkThreshold: */
			GIV(shrinkThreshold) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 25:
		if (arg > 0) {
			result1 = (((usqInt)GIV(growHeadroom) << 3) | 1);
			/* begin growHeadroom: */
			GIV(growHeadroom) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 26:
		if (arg >= 0) {

			/* 0 turns off the heartbeat */
			result1 = (((usqInt)(ioHeartbeatMilliseconds(self)) << 3) | 1);
			ioSetHeartbeatMilliseconds(arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 34:
		if (arg >= 0) {
			result1 = positive64BitIntegerFor(currentAllocatedBytes(self), self);
			/* begin setCurrentAllocatedBytesTo: */
			delta = (currentAllocatedBytes(self)) - GIV(statAllocatedBytes);
			GIV(statAllocatedBytes) = arg;
			GIV(oldSpaceUsePriorToScavenge) += delta;
			assert((currentAllocatedBytes(self)) == arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 43:
		if (((arg >= 0) && (arg <= 0xFFFF))) {
			result1 = (((usqInt)desiredNumStackPages << 3) | 1);
			desiredNumStackPages = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 45:
		if (arg >= 0) {
			result1 = (((usqInt)desiredEdenBytes << 3) | 1);
			desiredEdenBytes = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 47:
				break;
	case 48:
		if (arg >= 0) {
			result1 = (((usqInt)((((usqInt)(((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((sendWheelEvents
	? 32
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | ((4 + 16) + 32)) - ((4 + 16) + 32)))) << 3) | 1)) << 3) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setCogVMFlags: */
			if ((((usqInt)arg)) > 0x3F) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrUnsupported;
				goto l3;
			}

			/* noThreadingOfGUIThread := flags anyMask: 8.. specific to CoInterpreterMT */
			GIV(preemptionYields) = (arg & 4) == 0;
			GIV(newFinalization) = arg & 16;
			sendWheelEvents = arg & 32;
	l3:	/* end setCogVMFlags: */;
		}
		break;
	case 49:
		if (((arg >= 0) && (arg <= 0xFFFF))) {
			result1 = (((usqInt)(ioGetMaxExtSemTableSize(self)) << 3) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setMaxExtSemSizeTo: */
			GIV(maxExtSemTabSizeSet) = 1;
			ioSetMaxExtSemTableSize(arg);
		}
		break;
	case 55:
		result1 = floatObjectOf(getHeapGrowthToSizeGCRatio(self), self);
		/* begin setHeapGrowthToSizeGCRatio: */
		aDouble = noInlineLoadFloatOrIntFrom(argOop, self);
		GIV(heapGrowthToSizeGCRatio) = aDouble;
		GIV(primFailCode) = 0;
		break;
	case 67:
		if ((arg >= 0)
		 && (1)) {
			result1 = (((maxOldSpaceSize(self)) << 3) | 1);
			/* begin setMaxOldSpaceSize: */
			maxOldSpaceSize = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 68:
		result1 = floatObjectOf(statAverageLivePagesWhenMapping(self), self);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		/* begin statAverageLivePagesWhenMapping: */
		aFloat = noInlineLoadFloatOrIntFrom(argOop, self);
		if (aFloat == 0.0) {
			GIV(statPageCountWhenMappingSum) = (GIV(statNumMaps) = 0);
		}
		else {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		break;
	case 69:
		if (arg >= 0) {
			result1 = (((usqInt)(statMaxPageCountWhenMapping(self)) << 3) | 1);
			/* begin statMaxPageCountWhenMapping: */
			GIV(statMaxPageCountWhenMapping) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 74:
		if ((arg >= 0)
		 && (1)) {
			result1 = (((usqInt)((GIV(statMaxAllocSegmentTime) + 500) / 1000) << 3) | 1);
			/* begin statMaxAllocSegmentTime: */
			GIV(statMaxAllocSegmentTime) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	default:
		;
	}
	if (!GIV(primFailCode)) {

		/* return old value */
		/* begin methodReturnValue: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result1);
		GIV(stackPointer) = sp1;
	}
	else {

		/* attempting to write a read-only or non-existent parameter */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
	}
	l12:	/* end primitiveSetVMParameter:arg: */;
}


/*	Potentially crash the VM by voiding the receiver. A subsequent inst var
	access in the caller's frame should indirect through a null pointer. */

	/* StackInterpreterPrimitives>>#primitiveVoidReceiver */
EXPORT(void)
primitiveVoidReceiver(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	longAtPointerput(GIV(framePointer) + FoxReceiver, 0);
}


/*	Void all internal VM state in the stack and machine code zones */

	/* StackInterpreterPrimitives>>#primitiveVoidVMState */
static void
primitiveVoidVMState(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(0, self);
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext, self);
}


/*	Prune the stack to contain only the path, removing stacked indices
	and mapping frame pointers to contexts The issue here is that a
	GC can occur during ensureFrameIsMarried:SP:, but frame pointers
	are not valid objects. So first prune back to objects and framePointers
	as integers, and then replace frame pointers as integers by contexts. */

	/* StackInterpreterPrimitives>>#pruneStack:stackp: */
static void NoDbgRegParms
pruneStackstackp(sqInt stack, sqInt stackp, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt finger;
    char *fp;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt objOrFP;
    sqInt oop;
    sqInt oop1;
    char *theFP;
    char *theFPAbove;
    StackPage *thePage;
    char *theSP;
    sqInt theStack;
    sqInt valuePointer;

	finger = 1;
	for (i = 2; i < stackp; i += 2) {
		/* begin fetchPointer:ofObject: */
		objOrFP = longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if ((((((usqInt)(((char *) objOrFP)))) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)(((char *) objOrFP)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) objOrFP)))) <= (((usqInt)GIV(pages))))))) {
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(((char *) objOrFP))) & (BytesPerWord - 1)) == 0);
			objOrFP = (oopForPointer(((char *) objOrFP))) + (smallIntegerTag(self));
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(stack, self)));
		longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(finger) << (shiftForWord(self))))), objOrFP);
		finger += 1;
	}
	for (i = finger, iLimiT = ((lengthOfformat(stack, (((usqInt) (longAt(stack))) >> (formatShift(self))) & (formatMask(self)), self)) - 1); i <= iLimiT; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		assert(!(isOopForwarded(stack, self)));
		longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))), valuePointer);
	}
	/* begin pushRemappableOop: */
	oop = (theStack = stack);
	assert(addressCouldBeOop(oop, self));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	for (i = 1; i < finger; i += 1) {
		/* begin fetchPointer:ofObject: */
		objOrFP = longAt((theStack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord(self))))));
		if ((((objOrFP) & 7) == 1)) {
			/* begin withoutSmallIntegerTags: */
			assert((((objOrFP) & 7) == 1));
			theFP = pointerForOop(objOrFP - 1);
			/* begin stackPageFor: */
			index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage), self);
			thePage = stackPageAtpages(index, GIV(pages), self);
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == theFP) {
				theFPAbove = 0;
				goto l6;
			}
			while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
				if (callerFP == theFP) {
					theFPAbove = fp;
					goto l6;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			theFPAbove = 0;
	l6:	/* end findFrameAbove:inPage: */;
			/* begin ensureFrameIsMarried:SP: */
			assert(!(isBaseFrame(theFPAbove, self)));
			theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord(self))))))) + BytesPerWord;
			if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
				assert(isContext(frameContext(theFP, self), self));
				objOrFP = longAt(theFP + FoxThisContext);
				goto l7;
			}
			objOrFP = marryFrameSP(theFP, theSP, self);
	l7:	/* end ensureFrameIsMarried:SP: */;
			/* begin topRemappableOop */
			theStack = GIV(remapBuffer)[GIV(remapBufferCount)];
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(theStack, self)));
			if ((assert(isNonImmediate(theStack, self)),
			oopisGreaterThanOrEqualTo(theStack, GIV(oldSpaceStart), self))) {

				/* most stores into young objects */
				if (((objOrFP & (tagMask(self))) == 0)
				 && (oopisLessThan(objOrFP, GIV(newSpaceLimit), self))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(theStack))) >> (rememberedBitShift(self))) & 1) != 0)) {
						remember(theStack, self);
					}
				}
			}
			longAtput((theStack + BaseHeaderSize) + (((sqInt)((usqInt)(finger) << (shiftForWord(self))))), objOrFP);
		}
	}
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
}

	/* StackInterpreterPrimitives>>#unmarkAfterPathTo */
static void
unmarkAfterPathTo(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	unmarkAllFrames(self);
	/* begin unmarkAllObjects */
	assert(isOldObject(GIV(nilObj), self));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit(self))) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory), self))) break;
		assert((long64At(objOop1)) != 0);
		if (((((usqInt) (longAt(objOop1))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((longAt(objOop1)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1, self)));
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			else {
				if (!(((longAt(objOop1)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop1, self)));
					longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop1, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory), self)) {
			objOop1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace(self)).start)) < (((eden(self)).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace(self)).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask(self))
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit, self)) {
		if (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((longAt(objOop)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop, self)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			else {
				if (!(((longAt(objOop)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop, self)));
					longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit, self)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden(self)).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask(self))
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart), self)) {
		if (((((usqInt) (longAt(objOop))) >> (markedBitFullShift(self))) & 1) != 0) {
			if (((longAt(objOop)) & (classIndexMask(self))) > (lastClassIndexPun(self))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop, self)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
			}
			else {
				if (!(((longAt(objOop)) & (classIndexMask(self))) == (segmentBridgePun(self)))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop, self)));
					longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift(self)))));
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop, self);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart), self)) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift(self))) == (numSlotsMask(self))
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}

	/* StackInterpreterPrimitives>>#unmarkAllFrames */
static void
unmarkAllFrames(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    sqInt i;
    char *theFP;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages), self);
		if (!(isFree(thePage, self))) {
			theFP = (thePage->headFP);
			do {
				flags = longAt(theFP + FoxFrameFlags);
				if ((flags & 2) != 0) {
					longAtput(theFP + FoxFrameFlags, flags - 2);
				}
			} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
		}
	}
}

	/* TheoStackInterpreter>>#getFirstModule */
ModuleEntry * 
getFirstModule(struct foo * self)
{
	return GIV(firstModule);
}

	/* TheoStackInterpreter>>#getInterpreterProxy */
VirtualMachine * 
getInterpreterProxy(struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interpreterProxy);
}

	/* TheoStackInterpreter>>#getSqueakModule */
ModuleEntry * 
getSqueakModule(struct foo * self)
{
	return GIV(squeakModule);
}

	/* TheoStackInterpreter>>#initMutexForFetchNextBytecode:andCond: */
void
initMutexForFetchNextBytecodeandCond(pthread_mutex_t *aMutex, pthread_cond_t **aCond, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	
	if(pthread_mutex_init(aMutex, NULL) != 0){
		printf("Mutex init error: %s\n", strerror(errno));
		exit(1);
	}
	
	* aCond = malloc(sizeof(pthread_cond_t));
	if(pthread_cond_init(* aCond, NULL) != 0){
		printf("Cond init error: %s\n", strerror(errno));
		abort();
	}
	
	//Init so we can use the first interpreter normally but he can become stepable too
	//if(forStepping != 1){
		GIV(isStepable) = 0;
		//forStepping = 1;
	//}else{
		//GIV(isStepable) = 1;
	//};
	
}

	/* TheoStackInterpreter>>#mutexLock:andCond: */
void
mutexLockandCond(pthread_mutex_t *aMutex, pthread_cond_t **aCond)
{
	
		if(pthread_mutex_lock(aMutex) != 0){
			printf("Mutex lock error: %s\n", strerror(errno));
			abort();
		}
		if(pthread_cond_wait(* aCond, aMutex) != 0){
			printf("Cond lock error: %s\n", strerror(errno));
			abort();
		}
		pthread_mutex_unlock(aMutex);
}

	/* TheoStackInterpreter>>#printMethodCacheFor: */
void
printMethodCacheFor(sqInt thing, struct foo * self)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    sqInt i;
    sqIntptr_t m;
    sqInt n;
    sqIntptr_t p;
    sqIntptr_t s;

	n = 0;
	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = GIV(methodCache)[i + MethodCacheSelector];
		c = GIV(methodCache)[i + MethodCacheClass];
		m = GIV(methodCache)[i + MethodCacheMethod];
		p = GIV(methodCache)[i + MethodCachePrimFunction];
		if (((thing == -1)
		 || ((s == thing)
		 || ((c == thing)
		 || ((p == thing)
		 || (m == thing)))))
		 && (((s & (tagMask(self)))
		 || (addressCouldBeObj(s, self)))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c, self))
		 || (addressCouldBeClassObj(classAtIndex(c, self), self)))))) {
			printNum(i, self);
			/* begin space */
			putchar(' ');
			/* begin printHexnp: */
			printf("0x%" PRIxSQINT "", i);
			/* begin cr */
			printf("\n");
			/* begin tab */
			putchar('	');
			if (((((usqInt) (longAt(s))) >> (formatShift(self))) & (formatMask(self))) >= (firstByteFormat(self))) {
				printf("%" PRIxSQPTR " %.*s\n", s, (int)(numBytesOf(s,0)), (char *)firstIndexableField(s,0));
			}
			else {
				shortPrintOop(s, self);
			}
			/* begin tab */
			putchar('	');
			if (addressCouldBeClassObj(c, self)) {
				shortPrintOop(c, self);
			}
			else {
				printNum(c, self);
				/* begin space */
				putchar(' ');
				shortPrintOop(classAtIndex(c, self), self);
			}
			/* begin tab */
			putchar('	');
			shortPrintOop(m, self);
			/* begin tab */
			putchar('	');
			if (p > 1024) {
				/* begin printHexnp: */
				printf("0x%" PRIxSQINT "", p);
			}
			else {
				printNum(p, self);
			}
			/* begin cr */
			printf("\n");
		}
	}
	if (n > 1) {
		printNum(n, self);
		/* begin cr */
		printf("\n");
	}
}

	/* TheoStackInterpreter>>#setFirstModule: */
void
setFirstModule(ModuleEntry *aModuleEntry, struct foo * self)
{
	GIV(firstModule) = aModuleEntry;
}

	/* TheoStackInterpreter>>#setSqueakModule: */
void
setSqueakModule(ModuleEntry *aModuleEntry, struct foo * self)
{
	GIV(squeakModule) = aModuleEntry;
}


static char _m[] = "";
void* vm_exports[][3] = {
	{(void*)_m, "callbackEnter", (void*)callbackEnter},
	{(void*)_m, "callbackLeave", (void*)callbackLeave},
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveAddLargeIntegers\000\377", (void*)primitiveAddLargeIntegers},
	{(void*)_m, "primitiveAllInstances\000\377", (void*)primitiveAllInstances},
	{(void*)_m, "primitiveAllObjects\000\377", (void*)primitiveAllObjects},
	{(void*)_m, "primitiveBitAndLargeIntegers\000\377", (void*)primitiveBitAndLargeIntegers},
	{(void*)_m, "primitiveBitOrLargeIntegers\000\377", (void*)primitiveBitOrLargeIntegers},
	{(void*)_m, "primitiveBitShiftLargeIntegers\000\377", (void*)primitiveBitShiftLargeIntegers},
	{(void*)_m, "primitiveBitXorLargeIntegers\000\377", (void*)primitiveBitXorLargeIntegers},
	{(void*)_m, "primitiveClockLogAddresses\000\377", (void*)primitiveClockLogAddresses},
	{(void*)_m, "primitiveCompareBytes\000\377", (void*)primitiveCompareBytes},
	{(void*)_m, "primitiveCompareWith\000\377", (void*)primitiveCompareWith},
	{(void*)_m, "primitiveCrashVM\000\377", (void*)primitiveCrashVM},
	{(void*)_m, "primitiveDisablePowerManager\000\377", (void*)primitiveDisablePowerManager},
	{(void*)_m, "primitiveDivideLargeIntegers\000\377", (void*)primitiveDivideLargeIntegers},
	{(void*)_m, "primitiveDivLargeIntegers\000\377", (void*)primitiveDivLargeIntegers},
	{(void*)_m, "primitiveEqualLargeIntegers\000\377", (void*)primitiveEqualLargeIntegers},
	{(void*)_m, "primitiveEventProcessingControl\000\377", (void*)primitiveEventProcessingControl},
	{(void*)_m, "primitiveGetenv\000\377", (void*)primitiveGetenv},
	{(void*)_m, "primitiveGetLogDirectory\000\377", (void*)primitiveGetLogDirectory},
	{(void*)_m, "primitiveGetWindowLabel\000\377", (void*)primitiveGetWindowLabel},
	{(void*)_m, "primitiveGetWindowSize\000\377", (void*)primitiveGetWindowSize},
	{(void*)_m, "primitiveGreaterOrEqualLargeIntegers\000\377", (void*)primitiveGreaterOrEqualLargeIntegers},
	{(void*)_m, "primitiveGreaterThanLargeIntegers\000\377", (void*)primitiveGreaterThanLargeIntegers},
	{(void*)_m, "primitiveHeartbeatFrequency\000\377", (void*)primitiveHeartbeatFrequency},
	{(void*)_m, "primitiveHighResClock\000\377", (void*)primitiveHighResClock},
	{(void*)_m, "primitiveImageFormatVersion\000\377", (void*)primitiveImageFormatVersion},
	{(void*)_m, "primitiveInterruptChecksPerMSec\000\377", (void*)primitiveInterruptChecksPerMSec},
	{(void*)_m, "primitiveIsBigEnder\000\377", (void*)primitiveIsBigEnder},
	{(void*)_m, "primitiveIsWindowObscured\000\377", (void*)primitiveIsWindowObscured},
	{(void*)_m, "primitiveLessOrEqualLargeIntegers\000\377", (void*)primitiveLessOrEqualLargeIntegers},
	{(void*)_m, "primitiveLessThanLargeIntegers\000\377", (void*)primitiveLessThanLargeIntegers},
	{(void*)_m, "primitiveLongRunningPrimitive\000\377", (void*)primitiveLongRunningPrimitive},
	{(void*)_m, "primitiveLongRunningPrimitiveSemaphore\000\377", (void*)primitiveLongRunningPrimitiveSemaphore},
	{(void*)_m, "primitiveMillisecondClockMask\000\377", (void*)primitiveMillisecondClockMask},
	{(void*)_m, "primitiveModLargeIntegers\000\377", (void*)primitiveModLargeIntegers},
	{(void*)_m, "primitiveMultiplyLargeIntegers\000\377", (void*)primitiveMultiplyLargeIntegers},
	{(void*)_m, "primitiveNotEqualLargeIntegers\000\377", (void*)primitiveNotEqualLargeIntegers},
	{(void*)_m, "primitivePathToUsing\000\377", (void*)primitivePathToUsing},
	{(void*)_m, "primitiveProfilePrimitive\000\377", (void*)primitiveProfilePrimitive},
	{(void*)_m, "primitiveProfileSample\000\377", (void*)primitiveProfileSample},
	{(void*)_m, "primitiveProfileSemaphore\000\377", (void*)primitiveProfileSemaphore},
	{(void*)_m, "primitiveProfileStart\000\377", (void*)primitiveProfileStart},
	{(void*)_m, "primitiveQuoLargeIntegers\000\377", (void*)primitiveQuoLargeIntegers},
	{(void*)_m, "primitiveRemLargeIntegers\000\377", (void*)primitiveRemLargeIntegers},
	{(void*)_m, "primitiveScreenDepth\000\377", (void*)primitiveScreenDepth},
	{(void*)_m, "primitiveScreenScaleFactor\000\377", (void*)primitiveScreenScaleFactor},
	{(void*)_m, "primitiveSetGCSemaphore\000\377", (void*)primitiveSetGCSemaphore},
	{(void*)_m, "primitiveSetLogDirectory\000\377", (void*)primitiveSetLogDirectory},
	{(void*)_m, "primitiveSetWindowLabel\000\377", (void*)primitiveSetWindowLabel},
	{(void*)_m, "primitiveSetWindowSize\000\377", (void*)primitiveSetWindowSize},
	{(void*)_m, "primitiveSubtractLargeIntegers\000\377", (void*)primitiveSubtractLargeIntegers},
	{(void*)_m, "primitiveUtcWithOffset\000\377", (void*)primitiveUtcWithOffset},
	{(void*)_m, "primitiveVoidReceiver\000\377", (void*)primitiveVoidReceiver},
	{(void*)_m, "printFramesInPage", (void*)printFramesInPage},
	{(void*)_m, "printFramesOnStackPageListInUse\000\377", (void*)printFramesOnStackPageListInUse},
	{(void*)_m, "reestablishContextPriorToCallback", (void*)reestablishContextPriorToCallback},
	{(void*)_m, "returnAsThroughCallbackContext", (void*)returnAsThroughCallbackContext},
	{(void*)_m, "segmentContainingObj", (void*)segmentContainingObj},
	{(void*)_m, "sendInvokeCallbackContext", (void*)sendInvokeCallbackContext},
	{(void*)_m, "sendInvokeCallbackStackRegistersJmpbuf", (void*)sendInvokeCallbackStackRegistersJmpbuf},
	{(void*)_m, "setInterruptCheckChain", (void*)setInterruptCheckChain},
	{(void*)_m, "shortPrintFramesInPage", (void*)shortPrintFramesInPage},
	{(void*)_m, "shortPrintFramesOnStackPageListInUse\000\377", (void*)shortPrintFramesOnStackPageListInUse},
	{(void*)_m, "statNumGCs\000\377", (void*)statNumGCs},
	{NULL, NULL, NULL}
};

void initGlobalStructure(void) {
#if SQ_USE_GLOBAL_STRUCT_REG
foo = &fum;
#endif
}
