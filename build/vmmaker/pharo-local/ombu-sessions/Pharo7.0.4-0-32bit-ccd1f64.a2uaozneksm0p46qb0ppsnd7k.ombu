OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T09:43:43.795691+01:00' ],		#prior : OmReference [ 'Pharo7.0.4-0-32bit-ccd1f64.5lupmvvd4zm3y62y31e9t9siv', '7' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGenerator,				#isMetaSide : false			},			#name : #'generateNotEqual:on:indent:',			#protocol : #public,			#sourceCode : 'generateNotEqual: msgNode on: aStream indent: level\r    "Generate the C code for this message onto the given stream."\r\tself haltIf: [ (msgNode receiver isVariable ifTrue:[msgNode receiver name]) == #primitiveFunctionPointer ].\r    self emitCExpression: msgNode receiver on: aStream indent: level.\r    aStream nextPutAll: \' != \'.\r    self emitCExpression: msgNode args first on: aStream indent: level',			#stamp : 'Pablo 10/31/2019 10:59',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGenerator,				#isMetaSide : false			},			#name : #'generateNotEqual:on:indent:',			#protocol : #public,			#sourceCode : 'generateNotEqual: msgNode on: aStream indent: level\r    "Generate the C code for this message onto the given stream."\r    self emitCExpression: msgNode receiver on: aStream indent: level.\r    aStream nextPutAll: \' != \'.\r    self emitCExpression: msgNode args first on: aStream indent: level',			#stamp : 'Pablo 11/13/2019 09:43',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:14:47.047555+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #InterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'sound primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'if(pthread_create(&thread_id[i], &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 10:14',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:15:24.95189+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #InterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'sound primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'if(pthread_create(&thread_id[i], &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 10:14',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #InterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'sound primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'if(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 10:15',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:19:26.1837+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'struct foo  all_threads_global[2];\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 10/30/2019 16:06',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'struct foo * all_threads_global;\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 11/13/2019 10:19',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:25:18.34987+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'struct foo * all_threads_global;\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 11/13/2019 10:19',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'int numberOfImage;\'; cr;\r\t\tnextPutAll: \'struct foo * all_threads_global;\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 11/13/2019 10:25',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:27:36.073397+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'int numberOfImage;\'; cr;\r\t\tnextPutAll: \'struct foo * all_threads_global;\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 11/13/2019 10:25',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'size_t numberOfImage;\'; cr;\r\t\tnextPutAll: \'struct foo * all_threads_global;\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 11/13/2019 10:27',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:30:23.815692+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'setNumberOfImage:',			#protocol : #simulation,			#sourceCode : 'setNumberOfImage: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'numberOfImage = numberImages\'\r',			#stamp : 'Pablo 11/13/2019 10:30',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:32:19.586485+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'setNumberOfImage:',			#protocol : #simulation,			#sourceCode : 'setNumberOfImage: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'numberOfImage = numberImages\'\r',			#stamp : 'Pablo 11/13/2019 10:30',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'setNumberOfImage:',			#protocol : #simulation,			#sourceCode : 'setNumberOfImage: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'numberOfImage = numberImages\'',			#stamp : 'Pablo 11/13/2019 10:32',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:33:12.946249+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'initializeAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'initializeAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'numberOfImage = numberImages\'',			#stamp : 'Pablo 11/13/2019 10:33',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:34:13.166818+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'initializeAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'initializeAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'numberOfImage = numberImages\'',			#stamp : 'Pablo 11/13/2019 10:33',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'initializeAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'initializeAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'setNumberOfImage(numberImages);\r\tall_threads_global = malloc(sizeof(struct foo) * numberImages);\'',			#stamp : 'Pablo 11/13/2019 10:34',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:59:12.746268+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'growAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'growAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \r\t\t\'setNumberOfImage(numberImages);\r\t\t all_threads_global = malloc(sizeof(struct foo) * numberImages);\'',			#stamp : 'Pablo 11/13/2019 10:59',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T10:59:37.213078+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'growAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'growAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \r\t\t\'setNumberOfImage(numberImages);\r\t\t all_threads_global = malloc(sizeof(struct foo) * numberImages);\'',			#stamp : 'Pablo 11/13/2019 10:59',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'growAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'growAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \r\t\t\'setNumberOfImage(numberImages);\r\t\t all_threads_global = realloc(sizeof(struct foo) * numberImages);\'',			#stamp : 'Pablo 11/13/2019 10:59',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:05:20.837592+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #InterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'sound primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'if(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 10:15',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #InterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'as yet unclassified',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'if(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 10:15',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:05:20.856407+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #InterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'sound primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'if(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 10:15',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:05:46.777148+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\t\r\r\tself cCode: \'if(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:05',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:12:22.121514+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\t\r\r\tself cCode: \'if(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:05',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\tgrowAllGlobalsStruct: numberImages;\r\t\r\tif(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:12',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:13:20.634661+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\tgrowAllGlobalsStruct: numberImages;\r\t\r\tif(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:12',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tif(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:13',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:15:10.825523+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tif(pthread_create(thread, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:13',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:15',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:17:36.881989+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id[i], i);\'',			#stamp : 'Pablo 11/13/2019 11:15',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:17',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:17:42.337459+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\t\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:17',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:17',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:20:55.636346+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageLocation:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageLocation: anImageLocation withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:20',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:28:05.933199+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:17',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'as yet unclassified',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:17',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:28:05.943283+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageNamed:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageNamed: anImageName withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:17',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T11:32:58.579906+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageLocation:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageLocation: anImageLocation withArguments: anArrayOfArgs\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberImages);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:20',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageLocation:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageLocation: anImageLocation withArguments: anArrayOfArgs\r\t<var: #aThread type: \'pthread_t\'>\r\t<var: #index type: \'size_t\'>\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberOfImage);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:32',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T12:02:17.222949+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageLocation:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageLocation: anImageLocation withArguments: anArrayOfArgs\r\t<var: #aThread type: \'pthread_t\'>\r\t<var: #index type: \'size_t\'>\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberOfImage);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecuteVM, &parameters.vmparameters[i])){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 11:32',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreterPrimitives,				#isMetaSide : false			},			#name : #'newImageLocation:withArguments:',			#protocol : #'object access primitives',			#sourceCode : 'newImageLocation: anImageLocation withArguments: anArrayOfArgs\r\t<var: #aThread type: \'pthread_t\'>\r\t<var: #index type: \'size_t\'>\r\r\tself cCode: \'\r\tnumberOfImage = numberOfImage++;\r\t\r\t//Pointers to the old struc will be lost\r\t\r\tgrowAllGlobalsStruct(numberOfImage);\r\t\r\tpthread_attr_t tattr;\r\r\tpthread_attr_init(&tattr);\r\r\tpthread_t thread_id;\r\r\tsize_t size;\r\tpthread_attr_getstacksize(&tattr, &size);\r\r   if(pthread_attr_setstacksize(&tattr, size*4)){\r\t\tperror("Thread attr");\r   }\r\t\r\tif(pthread_create(&thread_id, &tattr, loadAndExecute, &param){\r\t\t\tperror("Thread creation");\r\t\t}\r\tsetMyCurrentThread(thread_id,numberOfImage - 1);\'',			#stamp : 'Pablo 11/13/2019 12:02',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T12:03:16.064453+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: fileLocation\r\r\r',			#stamp : 'Pablo 11/13/2019 12:03',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T12:05:07.430699+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: fileLocation\r\r\r',			#stamp : 'Pablo 11/13/2019 12:03',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\r\r\r',			#stamp : 'Pablo 11/13/2019 12:05',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T12:08:05.79505+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\r\r\r',			#stamp : 'Pablo 11/13/2019 12:05',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\t\r\tself cCode: \'\r\tinitGlobalStructure;\r\tioInitTime();\r\r   ioVMThread = ioCurrentOSThread();\r\tioInitExternalSemaphores();\r\r\taioInit();\r\t\r\tFILE* imageFile = NULL;\r\r   /* Open the image file. */\r   imageFile = fopen(fileName, "rb");\r   if(!imageFile){\r    perror("Opening Image");\r       return false;\r    }\r\r    /* Get the size of the image file*/\r    fseek(imageFile, 0, SEEK_END);\r    imageSize = ftell(imageFile);\r    fseek(imageFile, 0, SEEK_SET);\r\r    readImageFromFileHeapSizeStartingAt(imageFile, 0, 0);\r    fclose(imageFile);\r\r    setImageName(fileName);\r\r    return true;\r\t\r\t\'\r\r\r\r',			#stamp : 'Pablo 11/13/2019 12:08',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T12:59:53.662823+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\t\r\tself cCode: \'\r\tinitGlobalStructure;\r\tioInitTime();\r\r   ioVMThread = ioCurrentOSThread();\r\tioInitExternalSemaphores();\r\r\taioInit();\r\t\r\tFILE* imageFile = NULL;\r\r   /* Open the image file. */\r   imageFile = fopen(fileName, "rb");\r   if(!imageFile){\r    perror("Opening Image");\r       return false;\r    }\r\r    /* Get the size of the image file*/\r    fseek(imageFile, 0, SEEK_END);\r    imageSize = ftell(imageFile);\r    fseek(imageFile, 0, SEEK_SET);\r\r    readImageFromFileHeapSizeStartingAt(imageFile, 0, 0);\r    fclose(imageFile);\r\r    setImageName(fileName);\r\r    return true;\r\t\r\t\'\r\r\r\r',			#stamp : 'Pablo 11/13/2019 12:08',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\t\r\tself cCode: \'\r\tinitGlobalStructure;\r\tioInitTime();\r\r   ioVMThread = ioCurrentOSThread();\r\tioInitExternalSemaphores();\r\r\taioInit();\r\t\r\tFILE* imageFile = NULL;\r\r   /* Open the image file. */\r   imageFile = fopen(aFileLocation, "rb");\r   if(!imageFile){\r    \tperror("Opening Image");\r       return false;\r    }\r\r    /* Get the size of the image file*/\r    fseek(imageFile, 0, SEEK_END);\r    imageSize = ftell(imageFile);\r    fseek(imageFile, 0, SEEK_SET);\r\r    readImageFromFileHeapSizeStartingAt(imageFile, 0, 0);\r    fclose(imageFile);\r\r    setImageName(fileName);\r\r    interpret();\r\t\r\t\'\r\r\r\r',			#stamp : 'Pablo 11/13/2019 12:59',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T13:01:36.200212+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\t\r\tself cCode: \'\r\tinitGlobalStructure;\r\tioInitTime();\r\r   ioVMThread = ioCurrentOSThread();\r\tioInitExternalSemaphores();\r\r\taioInit();\r\t\r\tFILE* imageFile = NULL;\r\r   /* Open the image file. */\r   imageFile = fopen(aFileLocation, "rb");\r   if(!imageFile){\r    \tperror("Opening Image");\r       return false;\r    }\r\r    /* Get the size of the image file*/\r    fseek(imageFile, 0, SEEK_END);\r    imageSize = ftell(imageFile);\r    fseek(imageFile, 0, SEEK_SET);\r\r    readImageFromFileHeapSizeStartingAt(imageFile, 0, 0);\r    fclose(imageFile);\r\r    setImageName(fileName);\r\r    interpret();\r\t\r\t\'\r\r\r\r',			#stamp : 'Pablo 11/13/2019 12:59',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\t\r\tself cCode: \'\r\tinitGlobalStructure;\r\tioInitTime();\r\r   ioVMThread = ioCurrentOSThread();\r\tioInitExternalSemaphores();\r\r\taioInit();\r\tstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\r\tif(pthread_mutex_lock(&mutex) == 0){\r\t\r\t\tFILE* imageFile = NULL;\r\r   \t\t/* Open the image file. */\r   \t\timageFile = fopen(aFileLocation, "rb");\r   \t\tif(!imageFile){\r    \t\tperror("Opening Image");\r       \treturn false;\r    \t}\r\t\r    \t/* Get the size of the image file*/\r    \tfseek(imageFile, 0, SEEK_END);\r    \timageSize = ftell(imageFile);\r    \tfseek(imageFile, 0, SEEK_SET);\r\r    \treadImageFromFileHeapSizeStartingAt(imageFile, 0, 0);\r    \tfclose(imageFile);\r\r    \tsetImageName(fileName);\r\t}\r\r    interpret();\r\t\r\t\'\r\r\r\r',			#stamp : 'Pablo 11/13/2019 13:01',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T13:01:56.910308+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\t\r\tself cCode: \'\r\tinitGlobalStructure;\r\tioInitTime();\r\r   ioVMThread = ioCurrentOSThread();\r\tioInitExternalSemaphores();\r\r\taioInit();\r\tstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\r\tif(pthread_mutex_lock(&mutex) == 0){\r\t\r\t\tFILE* imageFile = NULL;\r\r   \t\t/* Open the image file. */\r   \t\timageFile = fopen(aFileLocation, "rb");\r   \t\tif(!imageFile){\r    \t\tperror("Opening Image");\r       \treturn false;\r    \t}\r\t\r    \t/* Get the size of the image file*/\r    \tfseek(imageFile, 0, SEEK_END);\r    \timageSize = ftell(imageFile);\r    \tfseek(imageFile, 0, SEEK_SET);\r\r    \treadImageFromFileHeapSizeStartingAt(imageFile, 0, 0);\r    \tfclose(imageFile);\r\r    \tsetImageName(fileName);\r\t}\r\r    interpret();\r\t\r\t\'\r\r\r\r',			#stamp : 'Pablo 11/13/2019 13:01',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'loadAndExecute:',			#protocol : #'process primitive support',			#sourceCode : 'loadAndExecute: aFileLocation\r\t<var: #aFileLocation type: \'char*\'>\r\t\r\tself cCode: \'\r\tinitGlobalStructure;\r\tioInitTime();\r\r   ioVMThread = ioCurrentOSThread();\r\tioInitExternalSemaphores();\r\r\taioInit();\r\tstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\r\tif(pthread_mutex_lock(&mutex) == 0){\r\t\r\t\tFILE* imageFile = NULL;\r\r   \t\t/* Open the image file. */\r   \t\timageFile = fopen(aFileLocation, "rb");\r   \t\tif(!imageFile){\r    \t\tperror("Opening Image");\r       \treturn false;\r    \t}\r\t\r    \t/* Get the size of the image file*/\r    \tfseek(imageFile, 0, SEEK_END);\r    \timageSize = ftell(imageFile);\r    \tfseek(imageFile, 0, SEEK_SET);\r\r    \treadImageFromFileHeapSizeStartingAt(imageFile, 0, 0);\r    \tfclose(imageFile);\r\r    \tsetImageName(fileName);\r\t}\r\r    interpret();\t\r\t\'\r\r\r\r',			#stamp : 'Pablo 11/13/2019 13:01',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T13:11:37.571709+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'StackInterpreter class',				#isMetaSide : true			},			#name : #'requiredMethodNames:',			#protocol : #translation,			#sourceCode : 'requiredMethodNames: options\r\t"Answer the list of method names that should be retained for export or other support reasons"\r\t| requiredList |\r\t"A number of methods required by VM support code, specific platforms, etc"\r\trequiredList := #(\r\t\tassertValidExecutionPointe:r:s:\r\t\tcharacterForAscii:\r\t\tfindClassOfMethod:forReceiver: findSelectorOfMethod:\r\t\t\tforceInterruptCheck forceInterruptCheckFromHeartbeat fullDisplayUpdate\r\t\tgetCurrentBytecode getFullScreenFlag getInterruptKeycode getInterruptPending\r\t\t\tgetSavedWindowSize getThisSessionID\r\t\tinterpret\r\t\tloadInitialContext\r\t\tprimitiveFail primitiveFailFor: primitiveFlushExternalPrimitives printAllStacks printCallStack printContext:\r\t\t\tprintExternalHeadFrame printFramesInPage: printFrame: printHeadFrame printMemory printOop:\r\t\t\t\tprintStackPages printStackPageList printStackPagesInUse printStackPageListInUse\r\t\treadableFormat: readImageFromFile:HeapSize:StartingAt:\r\t\tsetFullScreenFlag: setInterruptKeycode: setInterruptPending: setInterruptCheckChain:\r\t\t\tsetSavedWindowSize: success:\r\t\treturnGlobalStructForCurrentThread\r\t\tsetMyCurrentThread:_:\r\t\tvalidInstructionPointer:inMethod:framePointer:) asSet.\r\r\t"Nice to actually have all the primitives available"\r\trequiredList addAll: (self primitiveTable select: [:each| each isSymbol]).\r\r\t"InterpreterProxy is the internal analogue of sqVirtualMachine.c, so make sure to keep all those"\r\tInterpreterProxy organization categories do:\r\t\t[:cat |\r\t\t((cat ~= \'initialize\') and: [cat ~= \'private\']) ifTrue:\r\t\t\t[requiredList addAll: (InterpreterProxy organization listAtCategoryNamed: cat)]].\r\r\t^requiredList',			#stamp : 'Pablo 10/30/2019 16:02',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'StackInterpreter class',				#isMetaSide : true			},			#name : #'requiredMethodNames:',			#protocol : #translation,			#sourceCode : 'requiredMethodNames: options\r\t"Answer the list of method names that should be retained for export or other support reasons"\r\t| requiredList |\r\t"A number of methods required by VM support code, specific platforms, etc"\r\trequiredList := #(\r\t\tassertValidExecutionPointe:r:s:\r\t\tcharacterForAscii:\r\t\tfindClassOfMethod:forReceiver: findSelectorOfMethod:\r\t\t\tforceInterruptCheck forceInterruptCheckFromHeartbeat fullDisplayUpdate\r\t\tgetCurrentBytecode getFullScreenFlag getInterruptKeycode getInterruptPending\r\t\t\tgetSavedWindowSize getThisSessionID\r\t\tinterpret\r\t\tloadInitialContext\r\t\tprimitiveFail primitiveFailFor: primitiveFlushExternalPrimitives printAllStacks printCallStack printContext:\r\t\t\tprintExternalHeadFrame printFramesInPage: printFrame: printHeadFrame printMemory printOop:\r\t\t\t\tprintStackPages printStackPageList printStackPagesInUse printStackPageListInUse\r\t\treadableFormat: readImageFromFile:HeapSize:StartingAt:\r\t\tsetFullScreenFlag: setInterruptKeycode: setInterruptPending: setInterruptCheckChain:\r\t\t\tsetSavedWindowSize: success:\r\t\treturnGlobalStructForCurrentThread\r\t\tsetMyCurrentThread:_:\r\t\tsetNumberOfImage:\r\t\tinitializeAllGlobalsStruct:\r\t\t\r\t\tvalidInstructionPointer:inMethod:framePointer:) asSet.\r\r\t"Nice to actually have all the primitives available"\r\trequiredList addAll: (self primitiveTable select: [:each| each isSymbol]).\r\r\t"InterpreterProxy is the internal analogue of sqVirtualMachine.c, so make sure to keep all those"\r\tInterpreterProxy organization categories do:\r\t\t[:cat |\r\t\t((cat ~= \'initialize\') and: [cat ~= \'private\']) ifTrue:\r\t\t\t[requiredList addAll: (InterpreterProxy organization listAtCategoryNamed: cat)]].\r\r\t^requiredList',			#stamp : 'Pablo 11/13/2019 13:11',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T13:39:55.310574+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'size_t numberOfImage;\'; cr;\r\t\tnextPutAll: \'struct foo * all_threads_global;\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 11/13/2019 10:27',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #CCodeGeneratorGlobalStructure,				#isMetaSide : false			},			#name : #'emitCVariablesOn:',			#protocol : #'C code generator',			#sourceCode : 'emitCVariablesOn: aStream\r\t"Store the global variable declarations on the given stream.\r\t Break logic into vars for structure and vars for non-structure."\r\t| structure nonstruct |\r\r\tstructure := WriteStream on: (String new: 32768).\r\tnonstruct := WriteStream on: (String new: 32768).\r\taStream nextPutAll: \'/*** Variables ***/\'; cr.\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'# define _iss /* define in-struct static as void */\'; cr;\r\t\tnextPutAll: \'static struct foo {\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define _iss static\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\tself buildSortedVariablesCollection do:\r\t\t[ :var | | decl varString inStruct target |\r\t\ttarget := (inStruct := self placeInStructure: (varString := var asString)) \r\t\t\t\t\tifTrue: [structure]\r\t\t\t\t\tifFalse: [nonstruct].\r\t\tdecl := variableDeclarations at: varString ifAbsent: [\'sqInt \' , varString].\r\t\tdecl first == $# "support cgen var: #bytecodeSetSelector declareC: \'#define bytecodeSetSelector 0\' hack"\r\t\t\tifTrue:\r\t\t\t\t[target nextPutAll: decl; cr]\r\t\t\tifFalse:\r\t\t\t\t[self isGeneratingPluginCode\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[varString = \'interpreterProxy\'\r\t\t\t\t\t\t\tifTrue: "quite special..."\r\t\t\t\t\t\t\t\t[self preDeclareInterpreterProxyOn: target]\r\t\t\t\t\t\t\tifFalse: [target nextPutAll: \'static \']]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(vmClass mustBeGlobal: varString) ifFalse:\r\t\t\t\t\t\t\t[target nextPutAll: (inStruct ifTrue: [\'_iss \'] ifFalse: [\'static \'])]].\r\t\t\t\ttarget nextPutAll: decl; nextPut: $;; cr]].\r\tstructure\r\t\tnextPutAll: \'#undef _iss\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \' } fum;\'; cr;\r\t\tnextPutAll: \' #if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */\'; cr;\r\t\tnextPutAll:\'#else\';cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\';cr;\r\t\tnextPutAll: \'int numberOfImage;\'; cr;\r\t\tnextPutAll: \'struct foo * all_threads_global;\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) (returnGlobalStructForCurrentThread()->interpreterInstVar)\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */\'; cr;\r\t\tnextPutAll: \'# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */\'; cr;\r\t\tnextPutAll: \'# define GIV(interpreterInstVar) interpreterInstVar\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\t"if the machine needs the fum structure defining locally, do it now; global register users don\'t need that, but DO need some batshit insane C macro fudging in order to convert the define of USE_GLOBAL_STRUCT_REG into a simple string to use in the asm clause below. Sigh."\r\tstructure\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT\'; cr;\r\t\tnextPutAll: \'#if SQ_USE_GLOBAL_STRUCT_REG\';cr;\r\t\tnextPutAll: \'#define fooxstr(s) foostr(s)\'; cr;\r\t\tnextPutAll: \'#define foostr(s)  #s\'; cr;\r\t\tnextPutAll: \'register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));\'; cr;\r\t\tnextPutAll: \'#else\'; cr;\r\t\tnextPutAll: \'static struct foo * foo = &fum;\'; cr;\r\t\tnextPutAll: \'#endif\'; cr;\r\t\tnextPutAll: \'#endif\'; cr.\r\r\taStream\r\t\tnextPutAll: structure contents;\r\t\tnextPutAll: nonstruct contents;\r\t\tcr',			#stamp : 'Pablo 11/13/2019 13:39',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T13:40:09.895504+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'setNumberOfImage:',			#protocol : #simulation,			#sourceCode : 'setNumberOfImage: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'numberOfImage = numberImages\'',			#stamp : 'Pablo 11/13/2019 10:32',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'setNumberOfImage:',			#protocol : #simulation,			#sourceCode : 'setNumberOfImage: numberImages\r\t<var: #numberImages type: \'int\'>\r\r\tself\r\t\tcCode: \'numberOfImage = numberImages\'',			#stamp : 'Pablo 11/13/2019 13:40',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T13:46:40.133112+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'initializeAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'initializeAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'size_t\'>\r\r\tself\r\t\tcCode: \'setNumberOfImage(numberImages);\r\tall_threads_global = malloc(sizeof(struct foo) * numberImages);\'',			#stamp : 'Pablo 11/13/2019 10:34',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #'initializeAllGlobalsStruct:',			#protocol : #simulation,			#sourceCode : 'initializeAllGlobalsStruct: numberImages\r\t<var: #numberImages type: \'int\'>\r\r\tself\r\t\tcCode: \'setNumberOfImage(numberImages);\r\tall_threads_global = malloc(sizeof(struct foo) * numberImages);\'',			#stamp : 'Pablo 11/13/2019 13:46',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T13:54:31.140201+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #returnGlobalStructForCurrentThread,			#protocol : #utilities,			#sourceCode : 'returnGlobalStructForCurrentThread\r\t<returnTypeC: #\'struct foo *\'>\r\tself\r\t\tcCode:\'\r\tpthread_t selfThread = pthread_self();\r\tfor(int i=0; i<2; i++){\r\t\tif(all_threads_global[i].myCurrentThread==selfThread){\r\t\t\treturn &all_threads_global[i];\r\t\t}\r\t}\'',			#stamp : 'Pablo 10/30/2019 16:17',			#package : #VMMaker		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StackInterpreter,				#isMetaSide : false			},			#name : #returnGlobalStructForCurrentThread,			#protocol : #utilities,			#sourceCode : 'returnGlobalStructForCurrentThread\r""\r\t<returnTypeC: #\'struct foo *\'>\r\tself\r\t\tcCode:\'\r\t\tpthread_t selfThread = pthread_self();\r\t\tfor(int i=0; i<numberOfImage; i++){\r\t\t\tif(pthread_equal(all_threads_global[i].myCurrentThread,selfThread)){\r\t\t\t\treturn &all_threads_global[i];\r\t\t\t}\r\t\t}\r\t\treturn 0;\'',			#stamp : 'Pablo 11/13/2019 13:54',			#package : #VMMaker		}	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T14:03:16.209873+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMonticelloVersionSave {		#versionName : 'VMMaker-CompatibleUserName.1573201464',		#repositoryDescription : '/Users/theo/opensmalltalk-vm-1/build/vmmaker/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T14:03:29.425181+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMonticelloVersionSave {		#versionName : 'VMMakerCompatibilityForPharo6-CompatibleUserName.1573201464',		#repositoryDescription : '/Users/theo/opensmalltalk-vm-1/build/vmmaker/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T14:03:44.676435+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMonticelloVersionSave {		#versionName : 'VMMakerTests-CompatibleUserName.1573201464',		#repositoryDescription : '/Users/theo/opensmalltalk-vm-1/build/vmmaker/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T14:04:03.270559+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMonticelloVersionSave {		#versionName : 'BaselineOfVMMaker-CompatibleUserName.1573201464',		#repositoryDescription : '/Users/theo/opensmalltalk-vm-1/build/vmmaker/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T14:07:46.333161+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMonticelloVersionSave {		#versionName : 'VMMakerTests-CompatibleUserName.1573650466',		#repositoryDescription : '/Users/theo/opensmalltalk-vm-1/build/vmmaker/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T14:08:01.941982+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMonticelloVersionSave {		#versionName : 'VMMaker-CompatibleUserName.1573650466',		#repositoryDescription : '/Users/theo/opensmalltalk-vm-1/build/vmmaker/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'Pablo',		#time : DateAndTime [ '2019-11-13T14:08:05.415712+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMonticelloVersionSave {		#versionName : 'VMMakerCompatibilityForPharo6-CompatibleUserName.1573650466',		#repositoryDescription : '/Users/theo/opensmalltalk-vm-1/build/vmmaker/pharo-local/package-cache'	}}