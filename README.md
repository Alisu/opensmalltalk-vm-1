Headless OpenSmalltalk-VM for Pharo
-----------------------------------

This is the branch of the Headless VM used for Pharo.
This branch has the modifications required to run Pharo in a true headless environment.
The image running on the VM is responsible of handling the UI and the events. 

The image includes a default implementation of the handling of UI through the use of SDL2.

CI
---

This project is continuously built and test in the CI infrastructure located at:

[https://ci.inria.fr/pharo-ci-jenkins2/job/pharo-vm/job/headless/](https://ci.inria.fr/pharo-ci-jenkins2/job/pharo-vm/job/headless/)


Building
--------

For building the VM it is required the following set of tools:

- A working Pharo
- CMake (at least version 2.8.4)
- CLang 
- Binutils (make and friends) 
- wget
- unzip

Building in OSX / Linux:

```bash
$ cmake . 
$ make install
```

Building in Windows:

The build in Windows, uses Cygwin. This tool should be installed, and the following Cygwin packages are needed:

cmake
mingw64-x86_64-clang
zip
unzip
wget

```bash
$ cmake . -DWIN=1
$ make install
```

The VM is built from generated code and code written by hand.
The generated code is the result of converting Smalltalk code into C.
This conversion is performed during the *cmake* process. 

This will generate the VM in *build/dist/*

Debug in Visual Studio Code
---------------------------
Visual Studio Code (VS Code) offers integrated support for debugging tools.
For using gdb (or lldb) in our project it is 1st recommended to download:

- the extension for c/c++ in VS Code.
- a debugger (gdb for example), optionnal add the debugger to your path variable

Steps: 

- Open your project as a workspace in VS Code.
- In the menu bar (top bar) choose Debug>>Add configuration.
- It will generate a .vscode folder in your workspace with a launch.json file.
- The content of the launch.json file is:
```{
    "version": "0.2.0",
    "configurations": [   
        {
            "name": "Name of your configuration", <<=(ex: Launch gdb)
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}\\build\\dist\\PharoConsole.exe", <<=generated to this path by default
            "args": ["path/to/the/image/you/want/to/open"], <<=(ex: ${workspaceFolder}\\Pharo\\images\\TestImage\\TestImage.image)
            "stopAtEntry": true, <<=to have a breakpoint at the start of the program
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false, <<= to use the internal console of VSCode
            "MIMode": "gdb", <<= lldb if you want to use lldb
            "miDebuggerPath": "path/to/your/debbuger", <<=(ex: .\\Git\\mingw64\\bin\\gdb.exe or lldb.exe)
            "setupCommands": [
                {
                    "description": "Activer l'impression en mode Pretty pour gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ]
        }
    ]
}
```
See https://code.visualstudio.com/docs/cpp/launch-json-reference for more configuration.
Save your file and choose start debugging (your configuration) :).

Source Directory Structure
--------------------------

The headless mode is developed on top of code of the Cog branch of Opensmalltalk-vm.
The code that is used without changes is stored in the *extracted* directory. 
This allows us to easy integrate changes from and to the Cog branch.

The code that has been specially created or modified for this branch is stored in *src* / *include* and *plugins*.


- smalltalksrc: includes the tonel repository with the code in Slang.
- generated: here VMMaker will generate the VM code.
- includes: All non generated includes required by headless mode
- src: All non generated code required by headless mode.
- extracted: This code is literally the same code base used in the normal OpenSmalltalk-VM build.
- plugins: The code of the different plugins developed for headless mode.


Overview of OpenSmalltalk-VM
----------------------------

This branch is based on the open-smalltalk vm (https://github.com/OpenSmalltalk/opensmalltalk-vm).
Opensmalltalk-vm (a.k.a. the Cog VM) is the virtual machine beneath the
Cuis, Pharo and Squeak Smalltalk dialects and one of the VMs beneath the
Newspeak language.  For issues related to these systems that are unrelated to
the VM itself, please use their forums:
* http://www.cuis-smalltalk.org
* http://pharo.org/community
* http://squeak.org/community/
* http://newspeaklanguage.org

Second, the core VM, which comprises the execution engine and garbage collector,
and the core plugins, is developed in Smalltalk, using the *VM Simulator*.  This
repository contains the code generated by the Simulator, and the platform support
code for the entire VM, its CI infrastructure and so on.  The core VM **should
not** be developed by editing the generated code.  The core VM should be
developed using Smalltalk.  You can find scripts to build a Smalltalk image in
which to do core VM development in the [image](https://github.com/OpenSmalltalk/opensmalltalk-vm/tree/Cog/image) directory in this repository.
You can read about the Simulator here:
* https://www.researchgate.net/publication/328509577_Two_Decades_of_Smalltalk_VM_Development_Live_VM_Development_through_Simulation_Tools
* https://hal.archives-ouvertes.fr/hal-01883380/document

Cog is an evolution of the Squeak Back-to-the-future Smalltalk virtual machine
that provides a number of different Smalltalk virtual machines.  The VMs are
developed in Smalltalk, using all the dynamic and reflective facilities of the
Squeak/Pharo Smalltalk system.  As such, developing in Cog is a delight.  The
Smalltalk framework comprising the various Cog VMs is translated into C by its
Slang component to produce VM source that is combined with platform-specific
support sources and compiled via a C compiler to obtain a fast production VM.
This directory tree includes the output of Slang for various configurations of
"Cog VM" and the associated platform support code, plus build directories that
can be used to produce production VMs.

This directory tree also includes an instance of the Smalltalk Cog development
system, suitable for developing the VM in Smalltalk, and for generating new
VM sources.

The "Cog VM" comes in a bewildering variety of forms.  The first distinction
is between Squeak/Croquet VMs that run Squeak, Pharo, Cuis, Croquet images
and their ilk, and between Newspeak VMs that run Newspeak.

Another distinction is between Stack, Cog and Sista VMs.  Stack VMs are those
with context-to-stack mapping that optimise message sending by keeping method
activations on a stack instead of in contexts.  These are pure interpreters but
are significantly faster than the standard context-based Interpreter VM.  Cog
VMs add a JIT to the mix, compiling methods used more than once to machine code
on the fly.  Sista VMs, as yet unrealised and in development, add support for
adaptive optimization that does speculative inlining at the bytecode-to-bytecode
level.  These are under development and targeted for release in 2015.

Another distinction is between "v3" VMs and Spur VMs.  "v3" is the original
object representation for Squeak as described in the back-to-the-future paper.
Spur, as described on the www.mirandabanda.org blog, is a faster object
representation which uses generation scavenging, lazy forwarding for fast
become, a single object header format common to 32 and 64 bit versions, and a
segmented heap that can grow and shrink, releasing memory back to the host OS.
Newspeak, Squeak 5.0 and Pharo 5 use Spur.

Another distinction is between normal single-threaded VMs that schedule "green"
Smalltalk light-weight processes above a single-threaded VM, and multi-threaded
VMs that share the VM between any number of native threads such that only one
native thread owns the VM at any one time, switching between threads on FFI
calls and callbacks or on Smalltalk process switches when Smalltalk processes
are owned by threads.  This architecture offers non-blocking FFI calls and
interoperability with multiple native threads, but does /not/ provide true
concurrency.  This multi-threaded support is as yet experimental.


