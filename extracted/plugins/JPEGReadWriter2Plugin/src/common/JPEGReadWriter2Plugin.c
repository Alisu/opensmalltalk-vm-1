/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-eem.2493 uuid: d7437cc5-75c7-4a43-af6b-0f85bf0cebe6
   from
	JPEGReadWriter2Plugin VMMaker.oscog-eem.2493 uuid: d7437cc5-75c7-4a43-af6b-0f85bf0cebe6
 */
static char __buildInfo[] = "JPEGReadWriter2Plugin VMMaker.oscog-eem.2493 uuid: d7437cc5-75c7-4a43-af6b-0f85bf0cebe6 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "JPEGReadWriter2Plugin.h"
#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) primImageHeight(void);
EXPORT(sqInt) primImageNumComponents(void);
EXPORT(sqInt) primImageWidth(void);
EXPORT(sqInt) primJPEGCompressStructSize(void);
EXPORT(sqInt) primJPEGDecompressStructSize(void);
EXPORT(sqInt) primJPEGErrorMgr2StructSize(void);
EXPORT(sqInt) primJPEGPluginIsPresent(void);
EXPORT(sqInt) primJPEGReadHeaderfromByteArrayerrorMgr(void);
EXPORT(sqInt) primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr(void);
EXPORT(sqInt) primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr(void);
EXPORT(sqInt) primSupports8BitGrayscaleJPEGs(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt sqAssert(sqInt aBool);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj, struct foo * self);
static sqInt (*byteSizeOf)(sqInt oop, struct foo * self);
static sqInt (*failed)(struct foo * self);
static sqInt (*falseObject)(struct foo * self);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop, struct foo * self);
static void * (*firstIndexableField)(sqInt oop, struct foo * self);
static sqInt (*integerObjectOf)(sqInt value, struct foo * self);
static sqInt (*isKindOf)(sqInt oop, char *aString, struct foo * self);
static sqInt (*isBooleanObject)(sqInt oop, struct foo * self);
static sqInt (*isBytes)(sqInt oop, struct foo * self);
static sqInt (*isIntegerObject)(sqInt objectPointer, struct foo * self);
static sqInt (*isWordsOrBytes)(sqInt oop, struct foo * self);
static sqInt (*pop)(sqInt nItems, struct foo * self);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop, struct foo * self);
static sqInt (*primitiveFail)(struct foo * self);
static sqInt (*primitiveFailFor)(sqInt reasonCode, struct foo * self);
static sqInt (*stSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stackIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackValue)(sqInt offset, struct foo * self);
static sqInt (*success)(sqInt aBoolean, struct foo * self);
static sqInt (*trueObject)(struct foo * self);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj, struct foo * self);
extern sqInt byteSizeOf(sqInt oop, struct foo * self);
extern sqInt failed(struct foo * self);
extern sqInt falseObject(struct foo * self);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop, struct foo * self);
extern void * firstIndexableField(sqInt oop, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern sqInt isKindOf(sqInt oop, char *aString, struct foo * self);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
extern sqInt isBooleanObject(sqInt oop, struct foo * self);
#else
# define isBooleanObject(oop) 0
#endif
extern sqInt isBytes(sqInt oop, struct foo * self);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer, struct foo * self);
#endif
extern sqInt isWordsOrBytes(sqInt oop, struct foo * self);
extern sqInt pop(sqInt nItems, struct foo * self);
extern sqInt popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt primitiveFail(struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
extern sqInt stSizeOf(sqInt oop, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt success(sqInt aBoolean, struct foo * self);
extern sqInt trueObject(struct foo * self);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"JPEGReadWriter2Plugin VMMaker.oscog-eem.2493 (i)"
#else
	"JPEGReadWriter2Plugin VMMaker.oscog-eem.2493 (e)"
#endif
;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* JPEGReadWriter2Plugin>>#primImageHeight: */
EXPORT(sqInt)
primImageHeight(void)
{
	char *aJPEGDecompressStruct;
	sqInt _return_value;

	if (!(isBytes(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState))) {
		primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		return null;
	}
	aJPEGDecompressStruct = ((char *) (firstIndexableField(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	if (!((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGDecompressStruct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct jpeg_decompress_struct)))) {
		primitiveFail(interpreterProxy->interpreterState);
		return null;
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		_return_value = integerObjectOf((((j_decompress_ptr)aJPEGDecompressStruct)->image_height), interpreterProxy->interpreterState);
		if (!(failed(interpreterProxy->interpreterState))) {
			popthenPush(2, _return_value, interpreterProxy->interpreterState);
		}
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primImageNumComponents: */
EXPORT(sqInt)
primImageNumComponents(void)
{
	char *aJPEGDecompressStruct;
	sqInt _return_value;

	if (!(isBytes(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState))) {
		primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		return null;
	}
	aJPEGDecompressStruct = ((char *) (firstIndexableField(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	if (!((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGDecompressStruct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct jpeg_decompress_struct)))) {
		primitiveFail(interpreterProxy->interpreterState);
		return null;
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		_return_value = integerObjectOf((((j_decompress_ptr)aJPEGDecompressStruct)->num_components), interpreterProxy->interpreterState);
		if (!(failed(interpreterProxy->interpreterState))) {
			popthenPush(2, _return_value, interpreterProxy->interpreterState);
		}
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primImageWidth: */
EXPORT(sqInt)
primImageWidth(void)
{
	char *aJPEGDecompressStruct;
	sqInt _return_value;

	if (!(isBytes(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState))) {
		primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		return null;
	}
	aJPEGDecompressStruct = ((char *) (firstIndexableField(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	if (!((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGDecompressStruct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct jpeg_decompress_struct)))) {
		primitiveFail(interpreterProxy->interpreterState);
		return null;
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		_return_value = integerObjectOf((((j_decompress_ptr)aJPEGDecompressStruct)->image_width), interpreterProxy->interpreterState);
		if (!(failed(interpreterProxy->interpreterState))) {
			popthenPush(2, _return_value, interpreterProxy->interpreterState);
		}
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primJPEGCompressStructSize */
EXPORT(sqInt)
primJPEGCompressStructSize(void)
{
	sqInt _return_value;

	_return_value = integerObjectOf((sizeof(struct jpeg_compress_struct)), interpreterProxy->interpreterState);
	if (!(failed(interpreterProxy->interpreterState))) {
		popthenPush(1, _return_value, interpreterProxy->interpreterState);
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primJPEGDecompressStructSize */
EXPORT(sqInt)
primJPEGDecompressStructSize(void)
{
	sqInt _return_value;

	_return_value = integerObjectOf((sizeof(struct jpeg_decompress_struct)), interpreterProxy->interpreterState);
	if (!(failed(interpreterProxy->interpreterState))) {
		popthenPush(1, _return_value, interpreterProxy->interpreterState);
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primJPEGErrorMgr2StructSize */
EXPORT(sqInt)
primJPEGErrorMgr2StructSize(void)
{
	sqInt _return_value;

	_return_value = integerObjectOf((sizeof(struct error_mgr2)), interpreterProxy->interpreterState);
	if (!(failed(interpreterProxy->interpreterState))) {
		popthenPush(1, _return_value, interpreterProxy->interpreterState);
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primJPEGPluginIsPresent */
EXPORT(sqInt)
primJPEGPluginIsPresent(void)
{
	sqInt _return_value;

	_return_value = ((1) ? trueObject(interpreterProxy->interpreterState) : falseObject(interpreterProxy->interpreterState));
	if (!(failed(interpreterProxy->interpreterState))) {
		popthenPush(1, _return_value, interpreterProxy->interpreterState);
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primJPEGReadHeader:fromByteArray:errorMgr: */
EXPORT(sqInt)
primJPEGReadHeaderfromByteArrayerrorMgr(void)
{
	char *aJPEGDecompressStruct;
	char *aJPEGErrorMgr2Struct;
	char *source;
	sqInt sourceSize;

	if (!((isBytes(stackValue(2, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && ((isBytes(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && (isBytes(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState))))) {
		primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		return null;
	}
	aJPEGDecompressStruct = ((char *) (firstIndexableField(stackValue(2, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	source = ((char *) (firstIndexableField(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	aJPEGErrorMgr2Struct = ((char *) (firstIndexableField(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	if (!(((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGDecompressStruct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct jpeg_decompress_struct)))
		 && ((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGErrorMgr2Struct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct error_mgr2))))) {
		primitiveFail(interpreterProxy->interpreterState);
		return null;
	}
	sourceSize = byteSizeOf(((sqInt)(sqIntptr_t)(source) - BaseHeaderSize), interpreterProxy->interpreterState);
	if (sourceSize > 0) {
		primJPEGReadHeaderfromByteArraysizeerrorMgrReadHeader(aJPEGDecompressStruct, source, sourceSize, aJPEGErrorMgr2Struct);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(3, interpreterProxy->interpreterState);
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primJPEGReadImage:fromByteArray:onForm:doDithering:errorMgr: */
EXPORT(sqInt)
primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr(void)
{
	char *aJPEGDecompressStruct;
	char *aJPEGErrorMgr2Struct;
	sqInt ditherFlag;
	sqInt form;
	unsigned int *formBitmap;
	sqInt formBitmapOOP;
	sqInt formBitmapSizeInBytes;
	int formComponentBitSize;
	int formComponents;
	sqInt formDepth;
	sqInt formHeight;
	sqInt formNativeDepth;
	sqInt formPitch;
	sqInt formWidth;
	int pixelsPerWord;
	char *source;
	sqInt sourceSize;
	sqInt wordsPerRow;

	if (!((isBytes(stackValue(4, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && ((isBytes(stackValue(3, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && ((isKindOf(stackValue(2, interpreterProxy->interpreterState), "Form", interpreterProxy->interpreterState))
		 && ((isBooleanObject(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && (isBytes(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState))))))) {
		primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		return null;
	}
	aJPEGDecompressStruct = ((char *) (firstIndexableField(stackValue(4, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	source = ((char *) (firstIndexableField(stackValue(3, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	form = stackValue(2, interpreterProxy->interpreterState);
	ditherFlag = booleanValueOf(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	aJPEGErrorMgr2Struct = ((char *) (firstIndexableField(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	formBitmapOOP = fetchPointerofObject(0, form, interpreterProxy->interpreterState);
	formNativeDepth = fetchIntegerofObject(3, form, interpreterProxy->interpreterState);
	formWidth = fetchIntegerofObject(1, form, interpreterProxy->interpreterState);
	formHeight = fetchIntegerofObject(2, form, interpreterProxy->interpreterState);

	/* Various parameter checks */
	formDepth = SQABS(formNativeDepth);
	if (!(((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGDecompressStruct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct jpeg_decompress_struct)))
		 && ((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGErrorMgr2Struct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct error_mgr2))))) {
		primitiveFail(interpreterProxy->interpreterState);
		return null;
	}
	formComponents = (formDepth != 8
		? 4
		: 1);
	formComponentBitSize = (formDepth != 16
		? 8
		: 4);
	pixelsPerWord = 32 / (formComponents * formComponentBitSize);
	wordsPerRow = ((formWidth + pixelsPerWord) - 1) / pixelsPerWord;
	formPitch = ((formWidth + (pixelsPerWord - 1)) / pixelsPerWord) * 4;
	formBitmapSizeInBytes = byteSizeOf(formBitmapOOP, interpreterProxy->interpreterState);
	success((isWordsOrBytes(formBitmapOOP, interpreterProxy->interpreterState))
	 && (formBitmapSizeInBytes >= (formPitch * formHeight)), interpreterProxy->interpreterState);
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	sourceSize = stSizeOf(stackValue(3, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	success(sourceSize != 0, interpreterProxy->interpreterState);
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	formBitmap = firstIndexableField(formBitmapOOP, interpreterProxy->interpreterState);
	primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgrReadScanlines(aJPEGDecompressStruct, aJPEGErrorMgr2Struct, source, sourceSize, ditherFlag, formBitmap, pixelsPerWord, wordsPerRow, formNativeDepth);
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(5, interpreterProxy->interpreterState);
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primJPEGWriteImage:onByteArray:form:quality:progressiveJPEG:errorMgr: */
EXPORT(sqInt)
primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr(void)
{
	char *aJPEGCompressStruct;
	char *aJPEGErrorMgr2Struct;
	char *destination;
	unsigned int destinationSize;
	sqInt form;
	unsigned int *formBitmap;
	sqInt formBitmapOOP;
	sqInt formBitmapSizeInBytes;
	int formComponentBitSize;
	int formComponents;
	sqInt formDepth;
	sqInt formHeight;
	sqInt formNativeDepth;
	sqInt formPitch;
	sqInt formWidth;
	int pixelsPerWord;
	sqInt progressiveFlag;
	sqInt quality;
	sqInt v;
	sqInt wordsPerRow;
	sqInt _return_value;

	v = 0;
	if (!((isBytes(stackValue(5, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && ((isBytes(stackValue(4, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && ((isKindOf(stackValue(3, interpreterProxy->interpreterState), "Form", interpreterProxy->interpreterState))
		 && ((isIntegerObject(stackValue(2, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && ((isBooleanObject(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState))
		 && (isBytes(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)))))))) {
		primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		return null;
	}
	aJPEGCompressStruct = ((char *) (firstIndexableField(stackValue(5, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	destination = ((char *) (firstIndexableField(stackValue(4, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	form = stackValue(3, interpreterProxy->interpreterState);
	quality = stackIntegerValue(2, interpreterProxy->interpreterState);
	progressiveFlag = booleanValueOf(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	aJPEGErrorMgr2Struct = ((char *) (firstIndexableField(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)));
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	formBitmapOOP = fetchPointerofObject(0, form, interpreterProxy->interpreterState);
	formWidth = fetchIntegerofObject(1, form, interpreterProxy->interpreterState);
	formHeight = fetchIntegerofObject(2, form, interpreterProxy->interpreterState);
	formNativeDepth = fetchIntegerofObject(3, form, interpreterProxy->interpreterState);

	/* Various parameter checks */
	formDepth = SQABS(formNativeDepth);
	if (!(((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGCompressStruct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct jpeg_compress_struct)))
		 && ((byteSizeOf(((sqInt)(sqIntptr_t)(aJPEGErrorMgr2Struct) - BaseHeaderSize), interpreterProxy->interpreterState)) >= (sizeof(struct error_mgr2))))) {
		primitiveFail(interpreterProxy->interpreterState);
		return null;
	}
	formComponents = (formDepth != 8
		? 4
		: 1);
	formComponentBitSize = (formDepth != 16
		? 8
		: 4);
	pixelsPerWord = 32 / (formComponents * formComponentBitSize);
	wordsPerRow = ((formWidth + pixelsPerWord) - 1) / pixelsPerWord;
	formPitch = wordsPerRow * 4;
	formBitmapSizeInBytes = byteSizeOf(formBitmapOOP, interpreterProxy->interpreterState);
	success((isWordsOrBytes(formBitmapOOP, interpreterProxy->interpreterState))
	 && (formBitmapSizeInBytes >= (formPitch * formHeight)), interpreterProxy->interpreterState);
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	formBitmap = firstIndexableField(formBitmapOOP, interpreterProxy->interpreterState);
	destinationSize = stSizeOf(stackValue(4, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	if (destinationSize > 0) {
		primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgrWriteScanlines(formWidth, formHeight, formNativeDepth, formBitmap, aJPEGCompressStruct, aJPEGErrorMgr2Struct, quality, progressiveFlag, pixelsPerWord, wordsPerRow, destination, (&destinationSize));
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		_return_value = integerObjectOf(destinationSize, interpreterProxy->interpreterState);
		if (!(failed(interpreterProxy->interpreterState))) {
			popthenPush(7, _return_value, interpreterProxy->interpreterState);
		}
	}
	return null;
}

	/* JPEGReadWriter2Plugin>>#primSupports8BitGrayscaleJPEGs */
EXPORT(sqInt)
primSupports8BitGrayscaleJPEGs(void)
{
	sqInt _return_value;

	_return_value = ((1) ? trueObject(interpreterProxy->interpreterState) : falseObject(interpreterProxy->interpreterState));
	if (!(failed(interpreterProxy->interpreterState))) {
		popthenPush(1, _return_value, interpreterProxy->interpreterState);
	}
	return null;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		integerObjectOf = interpreterProxy->integerObjectOf;
		isKindOf = interpreterProxy->isKindOf;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
		isBooleanObject = interpreterProxy->isBooleanObject;
#else
#if !defined(isBooleanObject)
		isBooleanObject = 0;
#endif
#endif
		isBytes = interpreterProxy->isBytes;
		isIntegerObject = interpreterProxy->isIntegerObject;
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		success = interpreterProxy->success;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* SmartSyntaxInterpreterPlugin>>#sqAssert: */
static sqInt
sqAssert(sqInt aBool)
{
	/* missing DebugCode */;
	return aBool;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "JPEGReadWriter2Plugin";
void* JPEGReadWriter2Plugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primImageHeight\000\377", (void*)primImageHeight},
	{(void*)_m, "primImageNumComponents\000\377", (void*)primImageNumComponents},
	{(void*)_m, "primImageWidth\000\377", (void*)primImageWidth},
	{(void*)_m, "primJPEGCompressStructSize\000\377", (void*)primJPEGCompressStructSize},
	{(void*)_m, "primJPEGDecompressStructSize\000\377", (void*)primJPEGDecompressStructSize},
	{(void*)_m, "primJPEGErrorMgr2StructSize\000\377", (void*)primJPEGErrorMgr2StructSize},
	{(void*)_m, "primJPEGPluginIsPresent\000\377", (void*)primJPEGPluginIsPresent},
	{(void*)_m, "primJPEGReadHeaderfromByteArrayerrorMgr\000\377", (void*)primJPEGReadHeaderfromByteArrayerrorMgr},
	{(void*)_m, "primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr\000\002", (void*)primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr},
	{(void*)_m, "primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr\000\002", (void*)primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr},
	{(void*)_m, "primSupports8BitGrayscaleJPEGs\000\377", (void*)primSupports8BitGrayscaleJPEGs},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgrAccessorDepth = 2;
signed char primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgrAccessorDepth = 2;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
