/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2518 uuid: 33deb326-de86-45aa-be20-d64c10de4e70
   from
	UnixOSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-dtl.66 uuid: a8a2bf10-e7b3-4963-90b3-d69a2bee77bb
 */
static char __buildInfo[] = "UnixOSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-dtl.66 uuid: a8a2bf10-e7b3-4963-90b3-d69a2bee77bb " __DATE__ ;
/* D T Lewis - UnixOSProcessPlugin.c translated from class
   UnixOSProcessPlugin of OSProcessPlugin version 4.6.4 Cog */



#include "config.h"

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#ifdef __OpenBSD__
# include <sys/signalvar.h>
#endif


/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "FilePlugin.h"
#include "SocketPlugin.h"
#include "sqaio.h"
#include "sqMemoryAccess.h"


/*** Constants ***/
#define FILEHANDLETYPE FILE *  /* the type of low level stream to be used in a struct SQFile */
#define PrimErrBadArgument 3
#define PrimErrBadNumArgs 5
#define PrimErrNoMemory 9
#define PrimErrNotFound 11
#define PrimErrUnsupported 7
#define SESSIONIDENTIFIERTYPE int

EXPORT(int) getProcessArgumentCount();
EXPORT(char**) getProcessArgumentVector();
EXPORT(char**) getProcessEnvironmentVector();

/*** Function Prototypes ***/
static sqInt argumentAtAsType(sqInt classIdentifier, struct foo * self);
static void * callocWrappersize(sqInt count, sqInt objectSize, struct foo * self);
static sqInt copyBytesFromtolength(void *charArray1, void *charArray2, sqInt len, struct foo * self);
static sqInt createPipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr, struct foo * self);
static char * cStringFromString(sqInt aString, struct foo * self);
static sqInt cStringasCollection(const char *aCString, sqInt classIdentifier, struct foo * self);
static sqInt descriptorTableSize(struct foo * self);
static void dupToStdErr(sqInt anSQFileDataStructure, struct foo * self);
static void dupToStdIn(sqInt anSQFileDataStructure, struct foo * self);
static void dupToStdOut(sqInt anSQFileDataStructure, struct foo * self);
static sqInt environmentAtAsType(sqInt classIdentifier, struct foo * self);
static sqInt environmentAtSymbolAsType(sqInt classIdentifier, struct foo * self);
static sqInt fileDescriptorFrom(sqInt aSQFileByteArray, struct foo * self);
static FILEHANDLETYPE fileHandleFrom(sqInt sqFileStructByteArray, struct foo * self);
static usqIntptr_t fileRecordSize(struct foo * self);
static SQFile * fileValueOf(sqInt anSQFileRecord, struct foo * self);
static char ** fixPointersInArrayOfStringswithOffsets(sqInt flattenedStrings, sqInt offsets, struct foo * self);
static sqInt forkAndExecInDirectory(sqInt useSignalHandler, struct foo * self);
EXPORT(pid_t) forkSqueak(sqInt useSignalHandler, struct foo * self);
static void * forwardSignaltoSemaphoreAt(sqInt sigNum, sqInt semaphoreIndex, struct foo * self);
EXPORT(sqInt) getCurrentWorkingDirectoryAsType(sqInt classIdentifier, struct foo * self);
static char ** getEnvironmentVector(struct foo * self);
EXPORT(const char*) getModuleName(void);
static sqInt getStdHandle(sqInt n, struct foo * self);
static sqInt getThisSessionIdentifier(struct foo * self);
static void * handleSignalFunctionAddress(struct foo * self);
static void handleSignal(int sigNum, struct foo * self);
EXPORT(sqInt) initialiseModule(struct foo * self);
static sqInt initializeModuleForPlatform(struct foo * self);
static sqInt isNonNullSQFile(sqInt objectPointer, struct foo * self);
static sqInt isNullSQSocket(sqInt objectPointer, struct foo * self);
static sqInt isSQFileObject(sqInt objectPointer, struct foo * self);
static sqInt isSQSocketObject(sqInt objectPointer, struct foo * self);
static sqInt isValidFileSession(sqInt objectPointer, struct foo * self);
static sqInt isVmThread(struct foo * self);
static sqInt makePipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr, struct foo * self);
static sqInt maskForThisThreadAndResend(int sigNum, struct foo * self);
static sqInt maskSignalForThisThread(int sigNum, struct foo * self);
EXPORT(sqInt) moduleUnloaded(char *aModuleName, struct foo * self);
static sqInt msg(char *s, struct foo * self);
static sqInt needSigaltstack(struct foo * self);
static sqInt newPthreadTypeByteArray(pthread_t aPthreadType, struct foo * self);
static sqInt newSQFileByteArray(struct foo * self);
static sqInt newSQSocketByteArray(struct foo * self);
static void ** originalSignalHandlers(void);
static void * pointerFrom(sqInt aByteArray, struct foo * self);
EXPORT(sqInt) primitiveArgumentAt(struct foo * self);
EXPORT(sqInt) primitiveArgumentAtAsBytes(struct foo * self);
EXPORT(sqInt) primitiveCanReceiveSignals(struct foo * self);
EXPORT(sqInt) primitiveChdir(struct foo * self);
EXPORT(sqInt) primitiveCreatePipe(struct foo * self);
EXPORT(sqInt) primitiveCreatePipeWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveDup(sqInt fileDescriptor, struct foo * self);
EXPORT(sqInt) primitiveDupTo(sqInt oldFileDescriptor, sqInt newFileDescriptor, struct foo * self);
EXPORT(sqInt) primitiveEnvironmentAt(struct foo * self);
EXPORT(sqInt) primitiveEnvironmentAtAsBytes(struct foo * self);
EXPORT(sqInt) primitiveEnvironmentAtSymbol(struct foo * self);
EXPORT(sqInt) primitiveEnvironmentAtSymbolAsBytes(struct foo * self);
EXPORT(sqInt) primitiveErrorMessageAt(struct foo * self);
EXPORT(sqInt) primitiveFileProtectionMask(struct foo * self);
EXPORT(sqInt) primitiveFileStat(struct foo * self);
EXPORT(sqInt) primitiveFixPointersInArrayOfStrings(struct foo * self);
EXPORT(sqInt) primitiveForkAndExecInDirectory(struct foo * self);
EXPORT(sqInt) primitiveForkExec(struct foo * self);
EXPORT(sqInt) primitiveForkSqueak(struct foo * self);
EXPORT(sqInt) primitiveForkSqueakWithoutSigHandler(struct foo * self);
EXPORT(sqInt) primitiveForwardSignalToSemaphore(struct foo * self);
EXPORT(sqInt) primitiveGetCurrentWorkingDirectory(struct foo * self);
EXPORT(sqInt) primitiveGetCurrentWorkingDirectoryAsBytes(struct foo * self);
EXPORT(sqInt) primitiveGetEGid(struct foo * self);
EXPORT(sqInt) primitiveGetEUid(struct foo * self);
EXPORT(sqInt) primitiveGetGid(struct foo * self);
EXPORT(sqInt) primitiveGetPGid(struct foo * self);
EXPORT(sqInt) primitiveGetPGrp(struct foo * self);
EXPORT(sqInt) primitiveGetPid(struct foo * self);
EXPORT(sqInt) primitiveGetPPid(struct foo * self);
EXPORT(sqInt) primitiveGetSession(struct foo * self);
EXPORT(sqInt) primitiveGetStdErrHandle(struct foo * self);
EXPORT(sqInt) primitiveGetStdErrHandleWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveGetStdInHandle(struct foo * self);
EXPORT(sqInt) primitiveGetStdInHandleWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveGetStdOutHandle(struct foo * self);
EXPORT(sqInt) primitiveGetStdOutHandleWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveGetThreadID(struct foo * self);
EXPORT(sqInt) primitiveGetUid(struct foo * self);
EXPORT(sqInt) primitiveIsAtEndOfFile(struct foo * self);
EXPORT(sqInt) primitiveKillOnExit(struct foo * self);
EXPORT(sqInt) primitiveLockFileRegion(struct foo * self);
EXPORT(sqInt) primitiveMakePipe(struct foo * self);
EXPORT(sqInt) primitiveMakePipeWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveModuleName(struct foo * self);
EXPORT(sqInt) primitiveNice(struct foo * self);
EXPORT(sqInt) primitivePutEnv(struct foo * self);
EXPORT(sqInt) primitiveRealpath(struct foo * self);
EXPORT(sqInt) primitiveRealpathAsBytes(struct foo * self);
EXPORT(sqInt) primitiveReapChildProcess(struct foo * self);
EXPORT(sqInt) primitiveSemaIndexFor(struct foo * self);
EXPORT(sqInt) primitiveSendSigabrtTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigalrmTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigchldTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigcontTo(struct foo * self);
EXPORT(sqInt) primitiveSendSighupTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigintTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigkillTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigpipeTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigquitTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigstopTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigtermTo(struct foo * self);
EXPORT(sqInt) primitiveSendSigusr1To(struct foo * self);
EXPORT(sqInt) primitiveSendSigusr2To(struct foo * self);
EXPORT(sqInt) primitiveSetPGid(struct foo * self);
EXPORT(sqInt) primitiveSetPGrp(struct foo * self);
EXPORT(sqInt) primitiveSetSemaIndex(struct foo * self);
EXPORT(sqInt) primitiveSetSid(struct foo * self);
EXPORT(sqInt) primitiveSigChldNumber(struct foo * self);
EXPORT(sqInt) primitiveSigHupNumber(struct foo * self);
EXPORT(sqInt) primitiveSigIntNumber(struct foo * self);
EXPORT(sqInt) primitiveSigKillNumber(struct foo * self);
EXPORT(sqInt) primitiveSigPipeNumber(struct foo * self);
EXPORT(sqInt) primitiveSigQuitNumber(struct foo * self);
EXPORT(sqInt) primitiveSigTermNumber(struct foo * self);
EXPORT(sqInt) primitiveSigUsr1Number(struct foo * self);
EXPORT(sqInt) primitiveSigUsr2Number(struct foo * self);
EXPORT(sqInt) primitiveSizeOfInt(struct foo * self);
EXPORT(sqInt) primitiveSizeOfPointer(struct foo * self);
EXPORT(sqInt) primitiveSQFileFlush(struct foo * self);
EXPORT(sqInt) primitiveSQFileFlushWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveSQFileSetBlocking(struct foo * self);
EXPORT(sqInt) primitiveSQFileSetBlockingWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveSQFileSetNonBlocking(struct foo * self);
EXPORT(sqInt) primitiveSQFileSetNonBlockingWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveSQFileSetUnbuffered(struct foo * self);
EXPORT(sqInt) primitiveSQFileSetUnbufferedWithSessionIdentifier(struct foo * self);
EXPORT(sqInt) primitiveTestEndOfFileFlag(struct foo * self);
EXPORT(sqInt) primitiveTestLockableFileRegion(struct foo * self);
EXPORT(sqInt) primitiveUnixFileClose(sqInt anIntegerFileNumber, struct foo * self);
EXPORT(sqInt) primitiveUnixFileNumber(struct foo * self);
EXPORT(sqInt) primitiveUnlockFileRegion(struct foo * self);
EXPORT(sqInt) primitiveUnsetEnv(struct foo * self);
EXPORT(sqInt) primitiveVersionString(struct foo * self);
static sqInt realpathAsType(sqInt classIdentifier, struct foo * self);
static void reapChildProcess(int sigNum, struct foo * self);
static sqInt resendSignal(int sigNum, struct foo * self);
static void restoreDefaultSignalHandlers(struct foo * self);
static sqInt sandboxSecurity(struct foo * self);
static sqInt securityHeurisitic(struct foo * self);
static void sendSignalToPids(struct foo * self);
static sqInt sendSignaltoPid(sqInt sig, sqInt pid, struct foo * self);
static SESSIONIDENTIFIERTYPE sessionIdentifierFrom(sqInt aByteArray, struct foo * self);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static void setSigChldHandler(struct foo * self);
static void setSigIntDefaultHandler(struct foo * self);
static void setSigIntIgnore(struct foo * self);
static void * setSignalNumberhandler(sqInt signalNumber, void *signalHandlerAddress, struct foo * self);
static void setSigPipeDefaultHandler(struct foo * self);
static sqInt setSigPipeHandler(struct foo * self);
static void setSigPipeIgnore(struct foo * self);
EXPORT(sqInt) shutdownModule(struct foo * self);
static sqInt sigAbrtNumber(struct foo * self);
static sqInt sigAlrmNumber(struct foo * self);
static sqInt sigChldNumber(struct foo * self);
static sqInt sigContNumber(struct foo * self);
static void * sigDefaultNumber(struct foo * self);
static void * sigErrorNumber(struct foo * self);
static void * sigHoldNumber(struct foo * self);
static sqInt sigHupNumber(struct foo * self);
static void * sigIgnoreNumber(struct foo * self);
static sqInt sigIntNumber(struct foo * self);
static sqInt sigKillNumber(struct foo * self);
static sqInt signalArraySize(struct foo * self);
static sqInt sigPipeNumber(struct foo * self);
static sqInt sigQuitNumber(struct foo * self);
static sqInt sigStopNumber(struct foo * self);
static sqInt sigTermNumber(struct foo * self);
static sqInt sigUsr1Number(struct foo * self);
static sqInt sigUsr2Number(struct foo * self);
static usqIntptr_t sizeOfInt(struct foo * self);
static usqIntptr_t sizeOfPointer(struct foo * self);
static sqInt sizeOfSession(struct foo * self);
static int socketDescriptorFrom(sqInt sqSocketOop, struct foo * self);
static usqIntptr_t socketRecordSize(struct foo * self);
static SocketPtr socketValueOf(sqInt anSQSocketRecord, struct foo * self);
static sqInt stringFromCString(const char *aCString, struct foo * self);
static char * transientCStringFromString(sqInt aString, struct foo * self);
static int unixFileNumber(FILEHANDLETYPE fileHandle);
static char * versionString(void);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop, struct foo * self);
static sqInt (*byteSizeOf)(sqInt oop, struct foo * self);
static sqInt (*checkedIntegerValueOf)(sqInt intOop, struct foo * self);
static sqInt (*classArray)(struct foo * self);
static sqInt (*classByteArray)(struct foo * self);
static sqInt (*classString)(struct foo * self);
static sqInt (*failed)(struct foo * self);
static sqInt (*falseObject)(struct foo * self);
static void * (*firstIndexableField)(sqInt oop, struct foo * self);
static sqInt (*getThisSessionID)(struct foo * self);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size, struct foo * self);
static sqInt (*integerObjectOf)(sqInt value, struct foo * self);
static sqInt (*integerValueOf)(sqInt oop, struct foo * self);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName, struct foo * self);
static sqInt (*isBytes)(sqInt oop, struct foo * self);
static sqInt (*isIntegerObject)(sqInt objectPointer, struct foo * self);
static sqInt (*methodArgumentCount)(struct foo * self);
static sqInt (*methodReturnValue)(sqInt oop, struct foo * self);
static sqInt (*nilObject)(struct foo * self);
static sqInt (*pop)(sqInt nItems, struct foo * self);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop, struct foo * self);
static sqInt (*popRemappableOop)(struct foo * self);
static sqInt (*primitiveFail)(struct foo * self);
static sqInt (*primitiveFailFor)(sqInt reasonCode, struct foo * self);
static sqInt (*push)(sqInt object, struct foo * self);
static sqInt (*pushInteger)(sqInt integerValue, struct foo * self);
static sqInt (*pushRemappableOop)(sqInt oop, struct foo * self);
static sqInt (*signalSemaphoreWithIndex)(sqInt semaIndex);
static sqInt (*sizeOfSTArrayFromCPrimitive)(void *cPtr, struct foo * self);
static sqInt (*stObjectatput)(sqInt array, sqInt index, sqInt value, struct foo * self);
static sqInt (*stSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stackIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackObjectValue)(sqInt offset, struct foo * self);
static sqInt (*stackValue)(sqInt offset, struct foo * self);
static sqInt (*trueObject)(struct foo * self);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop, struct foo * self);
extern sqInt byteSizeOf(sqInt oop, struct foo * self);
extern sqInt checkedIntegerValueOf(sqInt intOop, struct foo * self);
extern sqInt classArray(struct foo * self);
extern sqInt classByteArray(struct foo * self);
extern sqInt classString(struct foo * self);
extern sqInt failed(struct foo * self);
extern sqInt falseObject(struct foo * self);
extern void * firstIndexableField(sqInt oop, struct foo * self);
extern sqInt getThisSessionID(struct foo * self);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern sqInt integerValueOf(sqInt oop, struct foo * self);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName, struct foo * self);
extern sqInt isBytes(sqInt oop, struct foo * self);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer, struct foo * self);
#endif
extern sqInt methodArgumentCount(struct foo * self);
extern sqInt methodReturnValue(sqInt oop, struct foo * self);
extern sqInt nilObject(struct foo * self);
extern sqInt pop(sqInt nItems, struct foo * self);
extern sqInt popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt popRemappableOop(struct foo * self);
extern sqInt primitiveFail(struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
extern sqInt push(sqInt object, struct foo * self);
extern sqInt pushInteger(sqInt integerValue, struct foo * self);
extern sqInt pushRemappableOop(sqInt oop, struct foo * self);
extern sqInt signalSemaphoreWithIndex(sqInt semaIndex);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr, struct foo * self);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value, struct foo * self);
extern sqInt stSizeOf(sqInt oop, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackObjectValue(sqInt offset, struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt trueObject(struct foo * self);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"UnixOSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-dtl.66 (i)"
#else
	"UnixOSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-dtl.66 (e)"
#endif
;
static void *originalSigHandlers[NSIG + 1];
static int osprocessSandboxSecurity;
static pid_t *pidArray = NULL;
static sqInt pidCount;
static unsigned char semaIndices[NSIG + 1];
static sqInt sigChldSemaIndex;
static int sigNumToSend = SIGTERM;
static sqInt useSignalStack;
static pthread_t vmThread;


/*** Macros ***/
#define sessionIdentifierFromSqFile(sqFile) (((SQFile *)(sqFile))->sessionID)



/*	Answer a string containing the OS process argument at index (an Integer)
	in the
	argument list.
 */

	/* UnixOSProcessPlugin>>#argumentAtAsType: */
static sqInt
argumentAtAsType(sqInt classIdentifier, struct foo * self)
{
    extern char **argVec;
    sqInt index;
    sqInt len;
    sqInt newString;
    sqInt s;
    char *sPtr;

    int argCnt = getProcessArgumentCount();

	index = stackIntegerValue(0, self);
	if ((index > argCnt) || (index < 1)) {
		popthenPush(2, nilObject(self), self);
	}
	else {
		sPtr = argVec[index - 1];
		/* begin cString:asCollection: */
		len = strlen(sPtr);
		newString = instantiateClassindexableSize(classIdentifier, len, self);
		strncpy(arrayValueOf(newString, self), sPtr, len);
		s = newString;
		popthenPush(2, s, self);
	}
	return 0;
}


/*	Using malloc() and calloc() is something I would like to avoid, since it
	is likely to cause problems some time in the future if somebody redesigns
	object memory allocation. This wrapper just makes it easy to find senders
	of calloc() in my code. -dtl */

	/* OSProcessPlugin>>#callocWrapper:size: */
static void *
callocWrappersize(sqInt count, sqInt objectSize, struct foo * self)
{
	return calloc(count, objectSize);
}


/*	self cCode: 'memcpy(charArray2, charArray1, len' */

	/* OSProcessPlugin>>#copyBytesFrom:to:length: */
static sqInt
copyBytesFromtolength(void *charArray1, void *charArray2, sqInt len, struct foo * self)
{
	memcpy(charArray2, charArray1, len);
	return 0;
}


/*	Create a pipe and populate the readerIOStream and writerIOStream
	variables. The SIGPIPE handler must have been set before creating the
	pipe. Answer true for
	success, else false.
 */

	/* UnixOSProcessPlugin>>#createPipeForReader:writer: */
static sqInt
createPipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr, struct foo * self)
{
    int filedes[2];

	if ((pipe(filedes)) == -1) {

		/* Translates to a pipe() system call */
		return 0;
	}
	else {
		*writerIOStreamPtr= (FILE *) fdopen (filedes[1], "a");
		*readerIOStreamPtr= (FILE *) fdopen (filedes[0], "r");
		return 1;
	}
}


/*	Answer a new null-terminated C string copied from aString. The C string
	is allocated from the C runtime heap. See transientCStringFromString for
	a version which allocates from object memory.
	Caution: This may invoke the garbage collector. */

	/* OSProcessPlugin>>#cStringFromString: */
static char *
cStringFromString(sqInt aString, struct foo * self)
{
    char *cString;
    sqInt len;
    char *sPtr;

	sPtr = arrayValueOf(aString, self);
	len = sizeOfSTArrayFromCPrimitive(sPtr, self);

	/* Space for a null terminated C string. */
	cString = callocWrappersize(len + 1, 1, self);
	(char *) strncpy (cString, sPtr, len);
	return cString;
}


/*	Answer a new collection, usually of type ByteArray or ByteString copied
	from a null-terminated C string. Caution: This may invoke the garbage
	collector. 
 */

	/* OSProcessPlugin>>#cString:asCollection: */
static sqInt
cStringasCollection(const char *aCString, sqInt classIdentifier, struct foo * self)
{
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(classIdentifier, len, self);
	strncpy(arrayValueOf(newString, self), aCString, len);
	return newString;
}


/*	dtl:
	Answer the size of the file descriptor table for a process. I am not sure
	of the most portable
	way to do this. If this implementation does not work on your Unix
	platform, try changing
	it to answer the value of FOPEN:=MAX, which will hopefully be defined in
	stdio.h. 
	eem:
	If we know that (e.g.) stdin is open we can use fd=dup(0);close(fd);fd
	instead. 
 */

	/* UnixOSProcessPlugin>>#descriptorTableSize */
static sqInt
descriptorTableSize(struct foo * self)
{
	return getdtablesize();
}


/*	Dup a file descriptor to allow it to be attached as the standard error
	when we
	exec() a new executable. This is Unix specific, in that it assumes that
	file descriptor
	0 is stdin, 1 is stdout, and 2 is stderr. The dup2() call is used to copy
	the open file
	descriptors into file descriptors 0, 1 and 2 so that the image which we
	execute will
	use them as stdin, stdout, and stderr.
 */

	/* UnixOSProcessPlugin>>#dupToStdErr: */
static void
dupToStdErr(sqInt anSQFileDataStructure, struct foo * self)
{
    sqInt filenoToDup;

	/* begin fileDescriptorFrom: */
	if (!((((isBytes(anSQFileDataStructure, self))
		 && ((byteSizeOf(anSQFileDataStructure, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(anSQFileDataStructure, self)))))
		 && (isNonNullSQFile(anSQFileDataStructure, self)))) {
		filenoToDup = -1;
		goto l1;
	}
	filenoToDup = fileno(fileHandleFrom(anSQFileDataStructure, self));
	l1:	/* end fileDescriptorFrom: */;
	if (!(filenoToDup < 0)) {
		if (!(filenoToDup == 2)) {
			fflush(stderr);
			dup2(filenoToDup, 2);
		}
	}
}


/*	Dup a file descriptor to allow it to be attached as the standard input
	when we
	exec() a new executable. This is Unix specific, in that it assumes that
	file descriptor
	0 is stdin, 1 is stdout, and 2 is stderr. The dup2() call is used to copy
	the open file
	descriptors into file descriptors 0, 1 and 2 so that the image which we
	execute will
	use them as stdin, stdout, and stderr.
 */

	/* UnixOSProcessPlugin>>#dupToStdIn: */
static void
dupToStdIn(sqInt anSQFileDataStructure, struct foo * self)
{
    sqInt filenoToDup;

	/* begin fileDescriptorFrom: */
	if (!((((isBytes(anSQFileDataStructure, self))
		 && ((byteSizeOf(anSQFileDataStructure, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(anSQFileDataStructure, self)))))
		 && (isNonNullSQFile(anSQFileDataStructure, self)))) {
		filenoToDup = -1;
		goto l1;
	}
	filenoToDup = fileno(fileHandleFrom(anSQFileDataStructure, self));
	l1:	/* end fileDescriptorFrom: */;
	if (!(filenoToDup < 0)) {
		if (!(filenoToDup == 0)) {
			fflush(stdin);
			dup2(filenoToDup, 0);
			rewind(stdin);
		}
	}
}


/*	Dup a file descriptor to allow it to be attached as the standard output
	when we
	exec() a new executable. This is Unix specific, in that it assumes that
	file descriptor
	0 is stdin, 1 is stdout, and 2 is stderr. The dup2() call is used to copy
	the open file
	descriptors into file descriptors 0, 1 and 2 so that the image which we
	execute will
	use them as stdin, stdout, and stderr.
 */

	/* UnixOSProcessPlugin>>#dupToStdOut: */
static void
dupToStdOut(sqInt anSQFileDataStructure, struct foo * self)
{
    sqInt filenoToDup;

	/* begin fileDescriptorFrom: */
	if (!((((isBytes(anSQFileDataStructure, self))
		 && ((byteSizeOf(anSQFileDataStructure, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(anSQFileDataStructure, self)))))
		 && (isNonNullSQFile(anSQFileDataStructure, self)))) {
		filenoToDup = -1;
		goto l1;
	}
	filenoToDup = fileno(fileHandleFrom(anSQFileDataStructure, self));
	l1:	/* end fileDescriptorFrom: */;
	if (!(filenoToDup < 0)) {
		if (!(filenoToDup == 1)) {
			fflush(stdout);
			dup2(filenoToDup, 1);
		}
	}
}


/*	Answer a string containing the OS process environment string at index (an
	Integer) in the environment list. */

	/* UnixOSProcessPlugin>>#environmentAtAsType: */
static sqInt
environmentAtAsType(sqInt classIdentifier, struct foo * self)
{
    sqInt envCnt;
    sqInt index;
    sqInt len;
    sqInt newString;
    char **p;
    sqInt s;
    char *sPtr;


	/* Count number of environment variables. */
	p = getEnvironmentVector(self);
	if (p == null) {
		return primitiveFail(self);
	}
	envCnt = 0;
	while (*p++) envCnt++;

	/* restore pointer */
	p = getEnvironmentVector(self);
	index = stackIntegerValue(0, self);
	if ((index > envCnt) || (index < 1)) {
		pop(2, self);
		push(nilObject(self), self);
	}
	else {
		sPtr = p[index - 1];
		/* begin cString:asCollection: */
		len = strlen(sPtr);
		newString = instantiateClassindexableSize(classIdentifier, len, self);
		strncpy(arrayValueOf(newString, self), sPtr, len);
		s = newString;
		pop(2, self);
		push(s, self);
	}
	return 0;
}


/*	Answer the value of an environment variable keyed by a Symbol. */

	/* UnixOSProcessPlugin>>#environmentAtSymbolAsType: */
static sqInt
environmentAtSymbolAsType(sqInt classIdentifier, struct foo * self)
{
    char * getenvResult;

	getenvResult = getenv(transientCStringFromString(stackObjectValue(0, self), self));
	if (getenvResult == 0) {
		return primitiveFail(self);
	}
	else {
		pop(2, self);
		push(cStringasCollection(getenvResult, classIdentifier, self), self);
	}
	return 0;
}


/*	Answer the OS file descriptor, an integer value, from a SQFile data
	structure byte array, or answer -1 if unable to obtain the file descriptor
	(probably due
	to receiving an incorrect type of object as aFileHandle).
 */
/*	return type should be int, but skip the declaration to permit inlining */

	/* UnixOSProcessPlugin>>#fileDescriptorFrom: */
static sqInt
fileDescriptorFrom(sqInt aSQFileByteArray, struct foo * self)
{
	if (!((((isBytes(aSQFileByteArray, self))
		 && ((byteSizeOf(aSQFileByteArray, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(aSQFileByteArray, self)))))
		 && (isNonNullSQFile(aSQFileByteArray, self)))) {
		return -1;
	}
	return fileno(fileHandleFrom(aSQFileByteArray, self));
}


/*	Answer a file handle from a SQFile structure. On most platforms, this
	will be a (FILE *). On Win32, it is a HANDLE. */

	/* OSProcessPlugin>>#fileHandleFrom: */
static FILEHANDLETYPE
fileHandleFrom(sqInt sqFileStructByteArray, struct foo * self)
{
    SQFile *sqFile;

	sqFile = arrayValueOf(sqFileStructByteArray, self);
	return sqFile->file;
}


/*	Return the size of a Smalltalk file record in bytes. */

	/* OSProcessPlugin>>#fileRecordSize */
static usqIntptr_t
fileRecordSize(struct foo * self)
{
	return sizeof(SQFile);
}


/*	Return a pointer to the first byte of of the SQFile data structure file
	record within
	anSQFileRecord, which is expected to be a ByteArray of size
	self>>fileRecordSize. 
 */

	/* OSProcessPlugin>>#fileValueOf: */
static SQFile *
fileValueOf(sqInt anSQFileRecord, struct foo * self)
{
	return arrayValueOf(anSQFileRecord, self);
}


/*	The image constructs a flattened string of all the argument and/or
	environment strings.
	There is room at the beginning for the null-terminated array of pointers
	to strings.
	The rest of the string contains the null-terminated strings. */
/*	Use the address offsets in offsetArray to fix up the pointers in
	cStringArray. The result is a C array of pointers to char, used for argv
	and env vectors.
 */

	/* OSProcessPlugin>>#fixPointersInArrayOfStrings:withOffsets: */
static char **
fixPointersInArrayOfStringswithOffsets(sqInt flattenedStrings, sqInt offsets, struct foo * self)
{
    sqInt count;
    sqInt idx;
    sqInt *offsetArray;
    char **ptr;
    usqInt sz;
    sqInt val;

	count = stSizeOf(offsets, self);
	offsetArray = firstIndexableField(offsets, self);
	sz = ((usqInt)(byteSizeOf(flattenedStrings, self)));
	if ((count * (sizeof(char *))) >= sz) {
		primitiveFailFor(PrimErrBadArgument, self);
		return 0;
	}
	ptr = ((char **) (arrayValueOf(flattenedStrings, self)));
	idx = 0;
	while (idx < count) {
		val = integerValueOf(offsetArray[idx], self);
		if ((((usqInt)val)) >= sz) {
			primitiveFailFor(PrimErrBadArgument, self);
			return 0;
		}
		ptr[idx] = ((((char *) ptr)) + val);
		idx += 1;
	}
	if ((ptr[idx]) != 0) {
		primitiveFailFor(PrimErrBadArgument, self);
	}
	return (failed(self)
		? 0
		: ptr);
}


/*	Fork a child OS process, and do an exec in the child. The parent continues
	on in
	Smalltalk, and this method answers the pid of the child which was created.
	If useSignalHandler is true, set the signal handler for SIGCHLD.
	Otherwise, assume
	that death of child events are handled through some other mechanism.
	
	In this implementation, memory for the argument and environment arrays is
	allocated in the image prior to calling this primitive. This allows us to
	avoid invoking the
	garbage collector in this primitive (thereby moving the locations of
	environment and argument memory), but comes at the cost of twiddling C
	pointers here in the
	primitive. An alternative to this whole mess is just to malloc the
	environment and
	argument vectors, but I think it is a good idea to avoid malloc as much as
	possible so as not to limit future ObjectMemory implementations.
	
	This primitive replaces #primitiveForkAndExec from earlier versions of the
	plugin. The new name permits backward compatibility for an image running
	on a VM
	which does not yet have the updated plugin. This implementation uses a
	different argument format on the stack, and differs functionally in that
	the child now closes
	all file descriptors (including sockets) not required (that is, everything
	except stdin,
	stdout, and stderr on descriptors 0, 1 and 2). This eliminates some flakey
	behavior in child processes connected to Squeak by pipes, which failed to
	exit at expected times
	due to the old file descriptors remaining open. This is also cleaner in
	that garbage
	descriptors are not left hanging around the the child.
	
	On entry, the stack contains:
	0: workingDir, a null terminated string specifying the working directory
	to use, or nil.
	1: envOffsets, an array of integers for calculating environment string
	address offsets.
	2: envVecBuffer, a String buffer containing environment strings arranged
	to look like char **.
	3: argOffsets, an array of integers for calculating argument string
	address offsets.
	4: argVecBuffer, a String buffer containing argument strings arranged to
	look like char **.
	5: stdErr, a ByteArray handle.
	6: stdOut, a ByteArray handle.
	7: stdIn, a ByteArray handle.
	8: executableFile, a null terminated string with the name of the file to
	execute. 9: the sender
 */

	/* UnixOSProcessPlugin>>#forkAndExecInDirectory: */
static sqInt
forkAndExecInDirectory(sqInt useSignalHandler, struct foo * self)
{
    sqInt argOffsets;
    char **args;
    sqInt argVecBuffer;
    char **env;
    sqInt envOffsets;
    sqInt envVecBuffer;
    sqInt executableFile;
    sqInt fd;
    sqInt fdLimiT;
    struct itimerval intervalTimer;
    pid_t pid;
    char *progNamePtr;
    char *pwdPtr;
    struct itimerval saveIntervalTimer;
    sqInt sigNum;
    sqInt stdErr;
    sqInt stdIn;
    sqInt stdOut;
    sqInt workingDir;

    char **envVec = getProcessEnvironmentVector();

    if ((methodArgumentCount(self)) != 9) {
		return primitiveFailFor(PrimErrBadNumArgs, self);
	}
	if (useSignalHandler) {
		setSigChldHandler(self);
	}
	if ((sandboxSecurity(self)) == 1) {
		pop(10, self);
		pushInteger(-1, self);
		return null;
	}
	workingDir = stackObjectValue(0, self);
	envOffsets = stackObjectValue(1, self);
	envVecBuffer = stackObjectValue(2, self);
	argOffsets = stackObjectValue(3, self);
	argVecBuffer = stackObjectValue(4, self);
	stdErr = stackObjectValue(5, self);
	stdOut = stackObjectValue(6, self);
	stdIn = stackObjectValue(7, self);
	executableFile = stackObjectValue(8, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	intervalTimer.it_interval.tv_sec = 0;
	intervalTimer.it_interval.tv_usec = 0;
	intervalTimer.it_value.tv_sec = 0;
	intervalTimer.it_value.tv_usec = 0;
	setitimer (ITIMER_REAL, &intervalTimer, &saveIntervalTimer);
	if (((pid = vfork())) != 0) {

		/* Normal return to Smalltalk - this is the old parent process. */
		/* Enable the timer again before resuming Smalltalk. */
		setitimer (ITIMER_REAL, &saveIntervalTimer, 0L);
		if (!(failed(self))) {

			/* Pop 9 arguments plus receiver, push pid. */
			pop(10, self);
			pushInteger(pid, self);
		}
		return null;
	}
	if (workingDir != (nilObject(self))) {
		pwdPtr = arrayValueOf(workingDir, self);
		if ((failed(self))
		 || (pwdPtr == 0)) {
			primitiveFailFor(PrimErrBadArgument, self);
			fprintf(stderr, "bad workingDir parameter\n");
			_exit(-1);
		}
		if ((chdir(pwdPtr)) != 0) {
			primitiveFailFor(PrimErrNotFound, self);
			perror("chdir");
			_exit(-1);
		}
	}

	/* Dup the file handles to attach the new child process to the right streams
	   on descriptors 0, 1 and 2. */
	progNamePtr = arrayValueOf(executableFile, self);
	if (!(stdErr == (nilObject(self)))) {
		dupToStdErr(stdErr, self);
	}
	if (!(stdOut == (nilObject(self)))) {
		dupToStdOut(stdOut, self);
	}
	if (!(stdIn == (nilObject(self)))) {
		dupToStdIn(stdIn, self);
	}
	for (fd = 3, fdLimiT = ((getdtablesize()) - 1); fd <= fdLimiT; fd += 1) {
		close(fd);
	}
	if (envVecBuffer == (nilObject(self))) {
		env = envVec;
	}
	else {
		env = ((char **) (fixPointersInArrayOfStringswithOffsets(envVecBuffer, envOffsets, self)));
	}
	args = ((char **) (fixPointersInArrayOfStringswithOffsets(argVecBuffer, argOffsets, self)));
	if ((env == 0)
	 || (args == 0)) {
		perror("bad env or bad args");
		_exit(-1);
	}
	/* begin restoreDefaultSignalHandlers */
	if (!(semaIndices == null)) {

		/* nil if in interpreter simulation */
		sigNum = 1;
		while (sigNum <= (signalArraySize(self))) {
			if ((semaIndices[sigNum]) > 0) {
				setSignalNumberhandler(sigNum, (originalSignalHandlers())[sigNum], self);
			}
			sigNum += 1;
		}
	}
	execve(progNamePtr, args, env);
	perror(progNamePtr);
	_exit(-1);
	return 0;
}


/*	Fork a child process, and continue running squeak in the child process.
	Answer the result of the fork() call, either the child pid or zero.
	
	After calling fork(), two OS processes exist, one of which is the child of
	the other. On
	systems which implement copy-on-write memory management, and which support
	the fork() system call, both processes will be running Smalltalk images,
	and will be sharing
	the same memory space. In the original OS process, the resulting value of
	pid is the
	process id of the child process (a non-zero integer). In the child
	process, the value of
	pid is zero.
	
	The child recreates sufficient external resources to continue running.
	This is done by
	attaching to a new X session. The child is otherwise a copy of the parent
	process, and
	will continue executing the Smalltalk image at the same point as its
	parent. The return
	value of this primitive may be used by the two running Smalltalk images to
	determine which is the parent and which is the child.
	
	The child should not depend on using existing connections to external
	resources. For
	example, the child may lose its connections to stdin, stdout, and stderr
	after its parent
	exits.
	
	The new child image does not start itself from the image in the file
	system; rather it is
	a clone of the parent image as it existed at the time of
	primitiveForkSqueak. For this
	reason, the parent and child should agree in advance as to whom is allowed
	to save the
	image to the file system, otherwise one Smalltalk may overwrite the image
	of the other.
	
	This is a simple call to fork(), rather than the more common idiom of
	vfork() followed
	by exec(). The vfork() call cannot be used here because it is designed to
	be followed by
	an exec(), and its semantics require the parent process to wait for the
	child to exit. See
	the BSD programmers documentation for details.
 */

	/* UnixOSProcessPlugin>>#forkSqueak: */
EXPORT(pid_t)
forkSqueak(sqInt useSignalHandler, struct foo * self)
{
    struct itimerval intervalTimer;
    pid_t pid;
    struct itimerval saveIntervalTimer;


	/* Turn off the interval timer. If this is not done, then the program which we exec in
	   the child process will receive a timer interrupt, and will not know how to handle it. */
	intervalTimer.it_interval.tv_sec = 0;
	intervalTimer.it_interval.tv_usec = 0;
	intervalTimer.it_value.tv_sec = 0;
	intervalTimer.it_value.tv_usec = 0;
	setitimer (ITIMER_REAL, &intervalTimer, &saveIntervalTimer);
	if (useSignalHandler) {
		setSigChldHandler(self);
	}

	/* Enable the timer again before resuming Smalltalk. */
	pid = fork();
	setitimer (ITIMER_REAL, &saveIntervalTimer, 0L);
	return pid;
}


/*	Set a signal handler in the VM which will signal a Smalltalk semaphore at
	semaphoreIndex whenever an external signal sigNum is received. Answer the
	prior value of the signal handler. If semaphoreIndex is zero, the handler
	is unregistered, and the VM returns to its default behavior for handling
	that signal. A handler must be unregistered before it can be registered
	again. 
	The Smalltalk semaphore is expected to be kept at the same index location
	indefinitely during the lifetime of a Squeak session. If that is not the
	case, the
	handler must be unregistered prior to unregistering the Smalltalk
	semaphore. 
 */

	/* UnixOSProcessPlugin>>#forwardSignal:toSemaphoreAt: */
static void *
forwardSignaltoSemaphoreAt(sqInt sigNum, sqInt semaphoreIndex, struct foo * self)
{
    void *oldHandler;

	if (semaIndices == null) {
		return null;
	}
	if (semaphoreIndex == 0) {

		/* Disable the handler */
		if ((semaIndices[sigNum]) != 0) {
			oldHandler = (originalSignalHandlers())[sigNum];
			oldHandler = setSignalNumberhandler(sigNum, oldHandler, self);
			semaIndices[sigNum] = 0;
			return oldHandler;
		}
		else {

			/* either -1 for printAllStacks or a positive integer for semaphore forwarding */
			/* Signal handler had not been set, answer an error */
			/* begin sigErrorNumber */
			return SIG_ERR;
		}
	}
	if ((semaIndices[sigNum]) > 0) {

		/* Handler is already set, answer an error */
		/* begin sigErrorNumber */
		return SIG_ERR;
	}
	oldHandler = setSignalNumberhandler(sigNum, handleSignalFunctionAddress(self), self);
	if (oldHandler != (sigErrorNumber(self))) {
		(originalSignalHandlers())[sigNum] = oldHandler;
		semaIndices[sigNum] = semaphoreIndex;
	}
	return oldHandler;
}


/*	Answer a string containing the current working directory. */

	/* UnixOSProcessPlugin>>#getCurrentWorkingDirectoryAsType: */
EXPORT(sqInt)
getCurrentWorkingDirectoryAsType(sqInt classIdentifier, struct foo * self)
{
    char *buffer;
    sqInt bufferSize;
    char *cwd;
    sqInt cwdString;
    sqInt incrementBy;
    sqInt len;
    sqInt maxSize;
    sqInt newString;

	bufferSize = 100;
	incrementBy = 100;
	maxSize = 5000;
	while (1) {
		cwdString = instantiateClassindexableSize(classString(self), bufferSize, self);
		if (cwdString == null) {
			primitiveFailFor(PrimErrNoMemory, self);
		}
		buffer = arrayValueOf(cwdString, self);

		/* getcwd(buffer, bufferSize) */
		cwd = getcwd(buffer, bufferSize);
		if (!((cwd == 0)
		 && (bufferSize < maxSize))) break;
		bufferSize += incrementBy;
	}
	if (cwd == 0) {
		primitiveFail(self);
	}
	else {
		/* begin cString:asCollection: */
		len = strlen(cwd);
		newString = instantiateClassindexableSize(classIdentifier, len, self);
		strncpy(arrayValueOf(newString, self), cwd, len);
		cwdString = newString;
		methodReturnValue(cwdString, self);
	}
	return 0;
}


/*	Answer a pointer to the environment vector. If the main module has
	exported a function called getEnvVec, call that function. Otherwise try to
	use a global
	reference to the variable envVec, which is expected to be declared in the
	main VM, and may or may not be visible depending on platform and compiler
	conventions. The value of the environment vector is cached in a static
	variable, so this method should not be inlined.
 */

	/* UnixOSProcessPlugin>>#getEnvironmentVector */
static char **
getEnvironmentVector(struct foo * self)
{
    char **envVec = getProcessEnvironmentVector();
    void (*func)(void);
    static char **ptr = null;

	if (ptr == null) {
		func = ioLoadFunctionFrom("ioGetEnvVec", "", self);
		if (!(func == null)) {
			ptr =  ((char ** (*) (void)) func)();
		}
	}
	if (ptr == null) {
		ptr = envVec;
	}
	return ptr;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}


/*	Answer the standard i/o file handle with the given index of my OS process.
	0 = stdin, 1 = stdout, 2 = stderr. */

	/* UnixOSProcessPlugin>>#getStdHandle: */
static sqInt
getStdHandle(sqInt n, struct foo * self)
{
    sqInt fileOop;
    SQFile fileRecords[3];
    sqInt validMask;

	validMask = sqFileStdioHandlesInto(fileRecords);
	if ((validMask & (1U << n)) == 0) {
		return primitiveFailFor(PrimErrUnsupported, self);
	}
	fileOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	memcpy(firstIndexableField(fileOop, self), &fileRecords[n], sizeof(SQFile));
	return popthenPush(1, fileOop, self);
}

	/* OSProcessPlugin>>#getThisSessionIdentifier */
static sqInt
getThisSessionIdentifier(struct foo * self)
{
	return getThisSessionID(self);
}

	/* UnixOSProcessPlugin>>#handleSignalFunctionAddress */
static void *
handleSignalFunctionAddress(struct foo * self)
{
	return handleSignal;
}


/*	This is a signal handler function which runs when a signal is received
	from the operating system. When the signal is received, a Smalltalk
	Semaphore is signaled. This effectively passes the external signal to
	Squeak to allow
	it to be handled in Smalltalk.
 */

	/* UnixOSProcessPlugin>>#handleSignal: */
static void
handleSignal(int sigNum, struct foo * self)
{
     char semaIndex;

	semaIndex = semaIndices[sigNum];
	forwardSignaltoSemaphoreAt(sigNum, semaIndex, self);
	if (isVmThread(self)) {
		if (semaIndex > 0) {
			signalSemaphoreWithIndex(semaIndex);
		}
	}
	else {
		/* begin maskForThisThreadAndResend: */
		maskSignalForThisThread(sigNum, self);
		resendSignal(sigNum, self);
	}
}

	/* OSProcessPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(struct foo * self)
{
	osprocessSandboxSecurity = -1;
	initializeModuleForPlatform(self);
	return 1;
}


/*	Platform specific initialization */

	/* UnixOSProcessPlugin>>#initializeModuleForPlatform */
static sqInt
initializeModuleForPlatform(struct foo * self)
{
	pidCount = 0;
	atexit(sendSignalToPids);
	vmThread = pthread_self();
	useSignalStack = -1;
	return 0;
}


/*	Check for the common failure mode of a SQFile record with all zeros. */

	/* OSProcessPlugin>>#isNonNullSQFile: */
static sqInt
isNonNullSQFile(sqInt objectPointer, struct foo * self)
{
    unsigned idx;
    unsigned char *sqFileBytes;

	sqFileBytes = arrayValueOf(objectPointer, self);
	idx = 0;
	while (idx < (sizeof(SQFile))) {
		if ((sqFileBytes[idx]) != 0) {
			return 1;
		}
		idx += 1;
	}
	return 0;
}


/*	Check for the common failure mode of a SQSocket record with all zeros. */

	/* OSProcessPlugin>>#isNullSQSocket: */
static sqInt
isNullSQSocket(sqInt objectPointer, struct foo * self)
{
    sqInt idx;
    unsigned char *sqSocketBytes;

	sqSocketBytes = arrayValueOf(objectPointer, self);
	idx = 0;
	while (idx < (sizeof(SQSocket))) {
		if ((sqSocketBytes[idx]) != 0) {
			return 0;
		}
		idx += 1;
	}
	return 1;
}


/*	Answer true if objectPointer appears to be a valid SQFile ByteArray.
	This check is appropriate if objectPointer has been passed as a parameter
	to a primitive, and is expected to represent a valid file reference. */

	/* OSProcessPlugin>>#isSQFileObject: */
static sqInt
isSQFileObject(sqInt objectPointer, struct foo * self)
{
	return (((isBytes(objectPointer, self))
	 && ((byteSizeOf(objectPointer, self)) == (sizeof(SQFile))))
	 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(objectPointer, self)))))
	 && (isNonNullSQFile(objectPointer, self));
}


/*	Answer true if objectPointer appears to be a valid SQSocket ByteArray.
	This check
	is appropriate if objectPointer has been passed as a parameter to a
	primitive, and
	is expected to represent a valid socket reference.
 */

	/* OSProcessPlugin>>#isSQSocketObject: */
static sqInt
isSQSocketObject(sqInt objectPointer, struct foo * self)
{
	return ((isBytes(objectPointer, self))
	 && ((byteSizeOf(objectPointer, self)) == (sizeof(SQSocket))))
	 && (!(isNullSQSocket(objectPointer, self)));
}


/*	Answer true if the file session matches the current interpreter session
	identifier. 
 */

	/* OSProcessPlugin>>#isValidFileSession: */
static sqInt
isValidFileSession(sqInt objectPointer, struct foo * self)
{
	return (getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(objectPointer, self)));
}


/*	Answer true if this method is executing in the context of the pthread in
	which the interpreter executes. */

	/* UnixOSProcessPlugin>>#isVmThread */
static sqInt
isVmThread(struct foo * self)
{
    pthread_t thisThread;

	thisThread = pthread_self();
	return pthread_equal(thisThread, vmThread);
}


/*	Create a pipe and populate the readerIOStream and writerIOStream
	variables. Make sure the SIGPIPE handler is set before creating the pipe.
	Answer true for
	success, else false
 */

	/* UnixOSProcessPlugin>>#makePipeForReader:writer: */
static sqInt
makePipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr, struct foo * self)
{
    int filedes[2];

	/* begin setSigPipeHandler */
	setSignalNumberhandler(SIGPIPE, sigIgnoreNumber(self), self);
	if ((pipe(filedes)) == -1) {

		/* Translates to a pipe() system call */
		return 0;
	}
	else {
		*writerIOStreamPtr= (FILE *) fdopen (filedes[1], "a");
		*readerIOStreamPtr= (FILE *) fdopen (filedes[0], "r");
		return 1;
	}
}


/*	Prevent any future instances of signal sigNum from being delivered
	to this pthread, and reschedule the current signal to be delivered to
	this OS process. Any pthread other than the interpreter thread will
	call this method. Eventually the signal will be delivered to the
	interpreter thread, which will handle it in the context of the interpreter
	thread. */

	/* UnixOSProcessPlugin>>#maskForThisThreadAndResend: */
static sqInt
maskForThisThreadAndResend(int sigNum, struct foo * self)
{
	maskSignalForThisThread(sigNum, self);
	resendSignal(sigNum, self);
	return 0;
}


/*	Prevent future invocations of signal sigNum from being delivered to this
	pthread. 
 */

	/* UnixOSProcessPlugin>>#maskSignalForThisThread: */
static sqInt
maskSignalForThisThread(int sigNum, struct foo * self)
{
    sigset_t sigset;

	sigemptyset(&sigset);
	sigaddset(&sigset, sigNum);
	pthread_sigmask(SIG_BLOCK, &sigset, NULL);
	return 0;
}


/*	The module with the given name was just unloaded.
	Make sure we have no dangling references. */

	/* OSProcessPlugin>>#moduleUnloaded: */
EXPORT(sqInt)
moduleUnloaded(char *aModuleName, struct foo * self)
{
	return 0;
}

	/* InterpreterPlugin>>#msg: */
static sqInt
msg(char *s, struct foo * self)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Answer if the plugin should use a signalstack to avoid delivering signals
	on the native stack, which can interfere with the JIT. As a side-effect,
	allocate one if one is not already available. We use GetAttributeString
	to detect the JIT, and if so detected we use a signalstack, We reuse
	any existing signalstack if available. */

	/* UnixOSProcessPlugin>>#needSigaltstack */
static sqInt
needSigaltstack(struct foo * self)
{
    char * (*GetAttributeString)(int);
    sqInt SigStackSize;
    stack_t sigstack;

	if (useSignalStack >= 0) {
		return useSignalStack != 0;
	}
	GetAttributeString = ioLoadFunctionFrom("GetAttributeString", "os_exports", self);
	if ((GetAttributeString == null)
	 || ((GetAttributeString(1008)) == null)) {
		useSignalStack = 0;
		return 0;
	}

	/* Now see if there's already a sigaltstack in place */
	useSignalStack = 1;
	if ((sigaltstack(0,&sigstack)) < 0) {
		perror("sigaltstack");
	}
	
#  if defined(SA_DISABLE)
	if (!(sigstack.ss_size == 0 || (sigstack.ss_flags & SA_DISABLE))) {
		return 1;
	}
#  else /* defined(SA_DISABLE) */

	/* e.g. Mac OS documents SA_DISABLE but defines SS_DISABLE */
	if (!(sigstack.ss_size == 0 || (sigstack.ss_flags & SS_DISABLE))) {
		return 1;
	}
#  endif /* defined(SA_DISABLE) */
	SigStackSize = ((((1024 * (sizeof(void *))) * 16) < MINSIGSTKSZ) ? MINSIGSTKSZ : ((1024 * (sizeof(void *))) * 16));
	if (null == (sigstack.ss_size = SigStackSize, sigstack.ss_sp = malloc(SigStackSize))) {
		msg("sigstack malloc failed", self);
		useSignalStack = 0;
		return 0;
	}
	if (sigaltstack(&sigstack, 0) < 0) {
		msg("sigaltstack install failed", self);
		(void)free(sigstack.ss_sp);
		useSignalStack = 0;
		return 0;
	}
	return 1;
}


/*	A pthread_t is an unsigned long, which may be 8 bytes on some 64 bit
	platforms. This stores the value in a byte array that can be easily
	passed to the image. */

	/* UnixOSProcessPlugin>>#newPthreadTypeByteArray: */
static sqInt
newPthreadTypeByteArray(pthread_t aPthreadType, struct foo * self)
{
    sqInt byteArray;
    sqInt len;
    pthread_t *ptr;

	len = sizeof(pthread_t);
	byteArray = instantiateClassindexableSize(classByteArray(self), len, self);
	ptr = arrayValueOf(byteArray, self);
	ptr[0] = aPthreadType;
	return byteArray;
}


/*	Answer a new ByteArray sized to contain a SQFile data structure. */

	/* OSProcessPlugin>>#newSQFileByteArray */
static sqInt
newSQFileByteArray(struct foo * self)
{
	return instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
}


/*	Answer a new ByteArray sized to contain a SQSocket data structure. */

	/* OSProcessPlugin>>#newSQSocketByteArray */
static sqInt
newSQSocketByteArray(struct foo * self)
{
	return instantiateClassindexableSize(classByteArray(self), sizeof(SQSocket), self);
}


/*	An array of signal handler function addresses, one for each signal type.
	The value at each entry is the address of the original signal handler
	function prior
	to having set a handler.
 */

	/* UnixOSProcessPlugin>>#originalSignalHandlers */
static void **
originalSignalHandlers(void)
{
	return originalSigHandlers;
}


/*	Answer the pointer represented by aByteArray. */

	/* OSProcessPlugin>>#pointerFrom: */
static void *
pointerFrom(sqInt aByteArray, struct foo * self)
{
    sqInt idx;
    union {void *address; unsigned char bytes[sizeof(void *)];} pointerUnion;
    unsigned char *ptr;

	if (!((isBytes(aByteArray, self))
		 && ((stSizeOf(aByteArray, self)) == (sizeof(void *))))) {
		return null;
	}
	ptr = arrayValueOf(aByteArray, self);
	idx = 0;
	while (idx < (sizeof(void *))) {
		pointerUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return pointerUnion.address;
}


/*	Answer a string containing the OS process argument at index (an Integer)
	in the
	argument list.
 */

	/* UnixOSProcessPlugin>>#primitiveArgumentAt */
EXPORT(sqInt)
primitiveArgumentAt(struct foo * self)
{
    sqInt classIdentifier;
    sqInt index;
    sqInt len;
    sqInt newString;
    sqInt s;
    char *sPtr;

    char **argVec = getProcessArgumentVector();
    int argCnt = getProcessArgumentCount();

	/* begin argumentAtAsType: */
	classIdentifier = classString(self);
	index = stackIntegerValue(0, self);
	if ((index > argCnt) || (index < 1)) {
		popthenPush(2, nilObject(self), self);
	}
	else {
		sPtr = argVec[index - 1];
		/* begin cString:asCollection: */
		len = strlen(sPtr);
		newString = instantiateClassindexableSize(classIdentifier, len, self);
		strncpy(arrayValueOf(newString, self), sPtr, len);
		s = newString;
		popthenPush(2, s, self);
	}
	return 0;
}


/*	Answer a byte array containing the OS process argument at index (an
	Integer) in the argument list. */

	/* UnixOSProcessPlugin>>#primitiveArgumentAtAsBytes */
EXPORT(sqInt)
primitiveArgumentAtAsBytes(struct foo * self)
{
    sqInt classIdentifier;
    sqInt index;
    sqInt len;
    sqInt newString;
    sqInt s;
    char *sPtr;

    char **argVec = getProcessArgumentVector();
    int argCnt = getProcessArgumentCount();

	/* begin argumentAtAsType: */
	classIdentifier = classByteArray(self);
	index = stackIntegerValue(0, self);
	if ((index > argCnt) || (index < 1)) {
		popthenPush(2, nilObject(self), self);
	}
	else {
		sPtr = argVec[index - 1];
		/* begin cString:asCollection: */
		len = strlen(sPtr);
		newString = instantiateClassindexableSize(classIdentifier, len, self);
		strncpy(arrayValueOf(newString, self), sPtr, len);
		s = newString;
		popthenPush(2, s, self);
	}
	return 0;
}


/*	Send a null signal to the OS process identified by the argument. Answer
	false for
	a bad parameter on the stack (the common case is for the argument equal to
	nil, for which case we should answer false). Answer true if the process
	exists and can
	receive signals from this process, otherwise false. This test is useful
	for determining
	if a child process still exists following a Squeak image restart.
 */

	/* UnixOSProcessPlugin>>#primitiveCanReceiveSignals */
EXPORT(sqInt)
primitiveCanReceiveSignals(struct foo * self)
{
    pid_t pidToSignal;
    int result;

	if (isIntegerObject(stackValue(0, self), self)) {
		pidToSignal = stackIntegerValue(0, self);
		result = kill(pidToSignal, 0);
		pop(2, self);
		if (result == 0) {
			push(trueObject(self), self);
		}
		else {
			push(falseObject(self), self);
		}
	}
	else {
		pop(2, self);
		push(falseObject(self), self);
	}
	return 0;
}


/*	Call chdir(2) to change current working directory to the specified path
	string. Answer
	nil for success, or errno on failure.
 */

	/* UnixOSProcessPlugin>>#primitiveChdir */
EXPORT(sqInt)
primitiveChdir(struct foo * self)
{
    extern int errno;
    char *path;

	path = transientCStringFromString(stackObjectValue(0, self), self);
	if (chdir(path)) {
		pop(2, self);
		pushInteger(errno, self);
	}
	else {
		pop(2, self);
		push(nilObject(self), self);
	}
	return 0;
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The readerIOStream and writerIOStream variables represent the low level
	pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

	/* OSProcessPlugin>>#primitiveCreatePipe */
EXPORT(sqInt)
primitiveCreatePipe(struct foo * self)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;

	/* begin getThisSessionIdentifier */
	thisSession = getThisSessionID(self);
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(createPipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr, self))) {
		return primitiveFail(self);
	}
	/* begin newSQFileByteArray */
	writer = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer, self);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer, self);
	/* begin newSQFileByteArray */
	reader = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader, self);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader, self);
	arrayResult = instantiateClassindexableSize(classArray(self), 2, self);
	stObjectatput(arrayResult, 1, popRemappableOop(self), self);
	stObjectatput(arrayResult, 2, popRemappableOop(self), self);
	popthenPush(1, arrayResult, self);
	return 0;
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The session identifier is passed as the parameter to this primitive. Use
	this variant
	if the session identifier is not available directly in the VM (as may be
	the case if
	it is not possible to link from this plugin to a variable elsewhere in the
	VM). The readerIOStream and writerIOStream variables represent the low
	level pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

	/* OSProcessPlugin>>#primitiveCreatePipeWithSessionIdentifier */
EXPORT(sqInt)
primitiveCreatePipeWithSessionIdentifier(struct foo * self)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;


	/* Create the anonymous OS pipe */
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(createPipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr, self))) {
		return primitiveFail(self);
	}
	/* begin newSQFileByteArray */
	writer = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer, self);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer, self);
	/* begin newSQFileByteArray */
	reader = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader, self);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader, self);
	arrayResult = instantiateClassindexableSize(classArray(self), 2, self);
	stObjectatput(arrayResult, 1, popRemappableOop(self), self);
	stObjectatput(arrayResult, 2, popRemappableOop(self), self);
	popthenPush(2, arrayResult, self);
	return 0;
}


/*	Call dup() to duplicate a file descriptor using the next available
	descriptor. Answer
	the new file descriptor or -1 on failure.
 */

	/* UnixOSProcessPlugin>>#primitiveDup: */
EXPORT(sqInt)
primitiveDup(sqInt fileDescriptor, struct foo * self)
{
    int fd;
    int result;

	fd = stackIntegerValue(0, self);
	result = dup(fd);
	pop(2, self);
	pushInteger(result, self);
	return 0;
}


/*	Call dup2() to duplicate a file descriptor. Answer the duplicated file
	descriptor or -1 on failure. */

	/* UnixOSProcessPlugin>>#primitiveDup:To: */
EXPORT(sqInt)
primitiveDupTo(sqInt oldFileDescriptor, sqInt newFileDescriptor, struct foo * self)
{
    int newfd;
    int oldfd;
    int result;

	newfd = stackIntegerValue(0, self);
	oldfd = stackIntegerValue(1, self);
	result = dup2(oldfd, newfd);
	pop(3, self);
	pushInteger(result, self);
	return 0;
}


/*	Answer a string containing the OS process environment string at index (an
	Integer) in the environment list. */

	/* UnixOSProcessPlugin>>#primitiveEnvironmentAt */
EXPORT(sqInt)
primitiveEnvironmentAt(struct foo * self)
{
	environmentAtAsType(classString(self), self);
	return 0;
}


/*	Answer a byte array containing the OS process environment string at index
	(an Integer) in the environment list. */

	/* UnixOSProcessPlugin>>#primitiveEnvironmentAtAsBytes */
EXPORT(sqInt)
primitiveEnvironmentAtAsBytes(struct foo * self)
{
	environmentAtAsType(classByteArray(self), self);
	return 0;
}


/*	Answer the value of an environment variable keyed by a Symbol. */

	/* UnixOSProcessPlugin>>#primitiveEnvironmentAtSymbol */
EXPORT(sqInt)
primitiveEnvironmentAtSymbol(struct foo * self)
{
    sqInt classIdentifier;
    char * getenvResult;

	/* begin environmentAtSymbolAsType: */
	classIdentifier = classString(self);
	getenvResult = getenv(transientCStringFromString(stackObjectValue(0, self), self));
	if (getenvResult == 0) {
		return primitiveFail(self);
	}
	else {
		pop(2, self);
		push(cStringasCollection(getenvResult, classIdentifier, self), self);
	}
	return null;
}


/*	Answer a byte array with the value of an environment variable keyed
	by a Symbol. */

	/* UnixOSProcessPlugin>>#primitiveEnvironmentAtSymbolAsBytes */
EXPORT(sqInt)
primitiveEnvironmentAtSymbolAsBytes(struct foo * self)
{
    sqInt classIdentifier;
    char * getenvResult;

	/* begin environmentAtSymbolAsType: */
	classIdentifier = classByteArray(self);
	getenvResult = getenv(transientCStringFromString(stackObjectValue(0, self), self));
	if (getenvResult == 0) {
		return primitiveFail(self);
	}
	else {
		pop(2, self);
		push(cStringasCollection(getenvResult, classIdentifier, self), self);
	}
	return null;
}


/*	Answer a string describing an error message */

	/* UnixOSProcessPlugin>>#primitiveErrorMessageAt */
EXPORT(sqInt)
primitiveErrorMessageAt(struct foo * self)
{
    sqInt classIdentifier;
    sqInt errMessage;
    sqInt index;
    sqInt len;
    sqInt newString;
    char *p;

	index = stackIntegerValue(0, self);
	p = ((char *) (strerror(index)));
	/* begin cString:asCollection: */
	classIdentifier = classString(self);
	len = strlen(p);
	newString = instantiateClassindexableSize(classIdentifier, len, self);
	strncpy(arrayValueOf(newString, self), p, len);
	errMessage = newString;
	pop(2, self);
	push(errMessage, self);
	return 0;
}


/*	Call stat(2) to obtain the file protection mask for a file. Answer an
	Array of
	four integers representing the protection mask, or answer errno on
	failure. The
	protection mask is four Integers, each of which may be considered an octal
	digit (0-7), with bit values 4, 2, and 1. The first digit selects the set
	user ID (4) and set
	group ID (2) and save text image (1) attributes. The second digit selects
	permissions for the user who owns the file: read (4), write (2), and
	execute (1); the third
	selects permissions for other users in the file's group, with the same
	values; and
	the fourth for other users not in the file's group, with the same values.
 */

	/* UnixOSProcessPlugin>>#primitiveFileProtectionMask */
EXPORT(sqInt)
primitiveFileProtectionMask(struct foo * self)
{
    sqInt buffer;
    extern int errno;
    sqInt mode;
    char *path;
    sqInt result;
    struct stat *statBuf;

	buffer = instantiateClassindexableSize(classByteArray(self), sizeof(struct stat), self);
	statBuf = arrayValueOf(buffer, self);
	path = transientCStringFromString(stackObjectValue(0, self), self);
	mode = stat(path, statBuf);
	if (mode == 0) {
		mode = statBuf->st_mode;
		result = instantiateClassindexableSize(classArray(self), 4, self);
		stObjectatput(result, 4, integerObjectOf(mode & 07, self), self);
		stObjectatput(result, 3, integerObjectOf((mode & 070) >> 3, self), self);
		stObjectatput(result, 2, integerObjectOf((mode & 0700) >> 6, self), self);
		stObjectatput(result, 1, integerObjectOf((mode & 07000) >> 9, self), self);
		pop(2, self);
		push(result, self);
	}
	else {
		pop(2, self);
		pushInteger(errno, self);
	}
	return 0;
}


/*	Call stat(2) to obtain the file protection mask for a file. Answer errno
	on failure,
	or on success answer an array with: UID with: GID with: protectionMask.
	The	 protectionMask is an Array of four integers representing the
	protection mask, or
	answer errno on failure. The protection mask is four Integers, each of
	which may
	be considered an octal digit (0-7), with bit values 4, 2, and 1. The first
	digit selects
	the set user ID (4) and set group ID (2) and save text image (1)
	attributes. The second
	digit selects permissions for the user who owns the file: read (4), write
	(2), and
	execute (1); the third selects permissions for other users in the file's
	group, with
	the same values; and the fourth for other users not in the file's group,
	with the
	same values.
 */

	/* UnixOSProcessPlugin>>#primitiveFileStat */
EXPORT(sqInt)
primitiveFileStat(struct foo * self)
{
    sqInt buffer;
    extern int errno;
    sqInt gid;
    sqInt mask;
    sqInt mode;
    char *path;
    sqInt result;
    struct stat *statBuf;
    sqInt uid;

	result = instantiateClassindexableSize(classArray(self), 3, self);
	uid = instantiateClassindexableSize(classByteArray(self), sizeof(uid_t), self);
	gid = instantiateClassindexableSize(classByteArray(self), sizeof(gid_t), self);
	mask = instantiateClassindexableSize(classArray(self), 4, self);
	buffer = instantiateClassindexableSize(classByteArray(self), sizeof(struct stat), self);
	statBuf = arrayValueOf(buffer, self);
	path = transientCStringFromString(stackObjectValue(0, self), self);
	mode = stat(path, statBuf);
	if (mode == 0) {
		mode = statBuf->st_mode;
		stObjectatput(mask, 4, integerObjectOf(mode & 07, self), self);
		stObjectatput(mask, 3, integerObjectOf((mode & 070) >> 3, self), self);
		stObjectatput(mask, 2, integerObjectOf((mode & 0700) >> 6, self), self);
		stObjectatput(mask, 1, integerObjectOf((mode & 07000) >> 9, self), self);
		stObjectatput(result, 3, mask, self);
		stObjectatput(result, 2, integerObjectOf(statBuf->st_gid, self), self);
		stObjectatput(result, 1, integerObjectOf(statBuf->st_uid, self), self);
		pop(2, self);
		push(result, self);
	}
	else {
		pop(2, self);
		pushInteger(errno, self);
	}
	return 0;
}


/*	This primitive exists only for purposes of testing the
	fixPointersInArrayOfStrings:withOffsets:count: method. I believe it to be
	reasonably machine and compiler independent, but have no way of verifying
	this on a variety of machines, so I'll leave this test method here in case
	someone runs into problems on other hardware or compilers. -dtl */

	/* OSProcessPlugin>>#primitiveFixPointersInArrayOfStrings */
EXPORT(sqInt)
primitiveFixPointersInArrayOfStrings(struct foo * self)
{
    sqInt count;
    sqInt cStringArray;
    sqInt offsetArray;

	count = stackIntegerValue(0, self);
	offsetArray = stackObjectValue(1, self);
	cStringArray = stackObjectValue(2, self);
	if ((failed(self))
	 || ((fixPointersInArrayOfStringswithOffsets(cStringArray, offsetArray, self)) == 0)) {
		primitiveFail(self);
	}
	else {
		popthenPush(4, cStringArray, self);
	}
	return 0;
}


/*	Fork a child OS process, and do an exec in the child. The parent continues
	on in
	Smalltalk, and this method answers the pid of the child which was created.
	
	On entry, the stack contains:
	0: workingDir, a null terminated string specifying the working directory
	to use, or nil.
	1: envOffsets, an array of integers for calculating environment string
	address offsets.
	2: envVecBuffer, a String buffer containing environment strings arranged
	to look like char **.
	3: argOffsets, an array of integers for calculating argument string
	address offsets.
	4: argVecBuffer, a String buffer containing argument strings arranged to
	look like char **.
	5: stdErr, a ByteArray handle.
	6: stdOut, a ByteArray handle.
	7: stdIn, a ByteArray handle.
	8: executableFile, a null terminated string with the name of the file to
	execute. 9: the sender */

	/* UnixOSProcessPlugin>>#primitiveForkAndExecInDirectory */
EXPORT(sqInt)
primitiveForkAndExecInDirectory(struct foo * self)
{
	return forkAndExecInDirectory(1, self);
}


/*	Fork a child OS process, and do an exec in the child. The parent continues
	on in
	Smalltalk, and this method answers the pid of the child which was created.
	
	On entry, the stack contains:
	0: workingDir, a null terminated string specifying the working directory
	to use, or nil.
	1: envOffsets, an array of integers for calculating environment string
	address offsets.
	2: envVecBuffer, a String buffer containing environment strings arranged
	to look like char **.
	3: argOffsets, an array of integers for calculating argument string
	address offsets.
	4: argVecBuffer, a String buffer containing argument strings arranged to
	look like char **.
	5: stdErr, a ByteArray handle.
	6: stdOut, a ByteArray handle.
	7: stdIn, a ByteArray handle.
	8: executableFile, a null terminated string with the name of the file to
	execute. 9: the sender */

	/* UnixOSProcessPlugin>>#primitiveForkExec */
EXPORT(sqInt)
primitiveForkExec(struct foo * self)
{
	return forkAndExecInDirectory(0, self);
}


/*	Fork a child process, and continue running squeak in the child process.
	Leave the
	X session connected to the parent process, but close its file descriptor
	for the child
	process. Open a new X session for the child.
	
	The child should not depend on using existing connections to external
	resources. For
	example, the child may lose its connections to stdin, stdout, and stderr
	after its parent
	exits.
 */

	/* UnixOSProcessPlugin>>#primitiveForkSqueak */
EXPORT(sqInt)
primitiveForkSqueak(struct foo * self)
{
    pid_t pid;


	/* Do not fork child if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(1, self);
		pushInteger(-1, self);
	}
	else {
		pid = forkSqueak(1, self);
		pop(1, self);
		pushInteger(pid, self);
	}
	return 0;
}


/*	Fork a child process, and continue running squeak in the child process.
	Leave the
	X session connected to the parent process, but close its file descriptor
	for the child
	process. Open a new X session for the child.
	
	The child should not depend on using existing connections to external
	resources. For
	example, the child may lose its connections to stdin, stdout, and stderr
	after its parent
	exits.
 */

	/* UnixOSProcessPlugin>>#primitiveForkSqueakWithoutSigHandler */
EXPORT(sqInt)
primitiveForkSqueakWithoutSigHandler(struct foo * self)
{
    pid_t pid;


	/* Do not fork child if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(1, self);
		pushInteger(-1, self);
	}
	else {
		pid = forkSqueak(0, self);
		pop(1, self);
		pushInteger(pid, self);
	}
	return 0;
}


/*	Set a signal handler in the VM which will signal a Smalltalk semaphore at
	semaphoreIndex whenever an external signal sigNum is received. Answer the
	prior value of the signal handler. If semaphoreIndex is zero or nil, the
	handler is unregistered, and the VM returns to its default behavior for
	handling that
	signal.
	
	The Smalltalk semaphore is expected to be kept at the same index location
	indefinitely during the lifetime of a Squeak session. If that is not the
	case, the
	handler must be unregistered prior to unregistering the Smalltalk
	semaphore. 
 */

	/* UnixOSProcessPlugin>>#primitiveForwardSignalToSemaphore */
EXPORT(sqInt)
primitiveForwardSignalToSemaphore(struct foo * self)
{
    void *handler;
    char *hPtr;
    sqInt idx;
    sqInt index;
    union {void *handler; unsigned char bytes[sizeof(void *)];} priorHandler;
    sqInt priorHandlerObject;
    sqInt semaphoreIndex;
    sqInt sigNum;

	semaphoreIndex = 0;
	index = stackValue(0, self);
	if (index == (nilObject(self))) {
		semaphoreIndex = 0;
	}
	else {
		if (isIntegerObject(index, self)) {
			semaphoreIndex = stackIntegerValue(0, self);
		}
		else {
			return primitiveFail(self);
		}
	}
	sigNum = stackIntegerValue(1, self);
	handler = forwardSignaltoSemaphoreAt(sigNum, semaphoreIndex, self);
	if (handler == (sigErrorNumber(self))) {
		return primitiveFail(self);
	}
	priorHandlerObject = instantiateClassindexableSize(classByteArray(self), sizeof(void *), self);
	hPtr = arrayValueOf(priorHandlerObject, self);
	priorHandler.handler = handler;
	idx = 0;
	while (idx < (sizeof(void *))) {
		hPtr[idx] = priorHandler.bytes[idx];
		idx += 1;
	}
	popthenPush(3, priorHandlerObject, self);
	return 0;
}


/*	Answer the current working directory. as a ByteString */

	/* UnixOSProcessPlugin>>#primitiveGetCurrentWorkingDirectory */
EXPORT(sqInt)
primitiveGetCurrentWorkingDirectory(struct foo * self)
{
	getCurrentWorkingDirectoryAsType(classString(self), self);
	return 0;
}


/*	Answer the current working directory as a ByteArray.. */

	/* UnixOSProcessPlugin>>#primitiveGetCurrentWorkingDirectoryAsBytes */
EXPORT(sqInt)
primitiveGetCurrentWorkingDirectoryAsBytes(struct foo * self)
{
	getCurrentWorkingDirectoryAsType(classByteArray(self), self);
	return 0;
}


/*	Answer the effective group ID of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetEGid */
EXPORT(sqInt)
primitiveGetEGid(struct foo * self)
{
    gid_t eGid;

	eGid = getegid();
	pop(1, self);
	pushInteger(eGid, self);
	return 0;
}


/*	Answer the effective user ID of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetEUid */
EXPORT(sqInt)
primitiveGetEUid(struct foo * self)
{
    uid_t eUid;

	eUid = geteuid();
	pop(1, self);
	pushInteger(eUid, self);
	return 0;
}


/*	Answer the group ID of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetGid */
EXPORT(sqInt)
primitiveGetGid(struct foo * self)
{
    gid_t gid;

	gid = getgid();
	pop(1, self);
	pushInteger(gid, self);
	return 0;
}


/*	Answer the process group ID of the process identified by pid */

	/* UnixOSProcessPlugin>>#primitiveGetPGid */
EXPORT(sqInt)
primitiveGetPGid(struct foo * self)
{
    pid_t pgid;
    pid_t pid;

	pid = stackIntegerValue(0, self);
	pgid = getpgid(pid);
	if (pgid == -1) {
		return primitiveFail(self);
	}
	pop(2, self);
	pushInteger(pgid, self);
	return 0;
}


/*	Answer the process group ID of this OS process */

	/* UnixOSProcessPlugin>>#primitiveGetPGrp */
EXPORT(sqInt)
primitiveGetPGrp(struct foo * self)
{
    pid_t pgid;

	pgid = getpgrp();
	if (pgid == -1) {
		return primitiveFail(self);
	}
	pop(1, self);
	pushInteger(pgid, self);
	return 0;
}


/*	Answer the process ID of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetPid */
EXPORT(sqInt)
primitiveGetPid(struct foo * self)
{
    pid_t pid;

	pid = getpid();
	pop(1, self);
	pushInteger(pid, self);
	return 0;
}


/*	Answer the process ID of the parent process of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetPPid */
EXPORT(sqInt)
primitiveGetPPid(struct foo * self)
{
    pid_t ppid;

	ppid = getppid();
	pop(1, self);
	pushInteger(ppid, self);
	return 0;
}


/*	Answer the unique session identifier for this Smalltalk instance running
	in this
	OS process. The C integer value is coerced into a Smalltalk ByteArray to
	preserve the full range of possible values.
 */

	/* OSProcessPlugin>>#primitiveGetSession */
EXPORT(sqInt)
primitiveGetSession(struct foo * self)
{
    void *charArray1;
    unsigned char *sessionByteArrayPointer;
    usqIntptr_t sessionIDSize;
    sqInt sessionOop;
    SESSIONIDENTIFIERTYPE thisSessionID;

	/* begin getThisSessionIdentifier */
	thisSessionID = getThisSessionID(self);
	sessionIDSize = sizeof(thisSessionID);
	sessionOop = instantiateClassindexableSize(classByteArray(self), sessionIDSize, self);
	sessionByteArrayPointer = arrayValueOf(sessionOop, self);
	if (thisSessionID == null) {
		return primitiveFail(self);
	}
	/* begin copyBytesFrom:to:length: */
	charArray1 = ((void *) ((unsigned char *)&thisSessionID));
	memcpy(sessionByteArrayPointer, charArray1, sessionIDSize);
	popthenPush(1, sessionOop, self);
	return 0;
}


/*	Answer the file handle for standard error of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetStdErrHandle */
EXPORT(sqInt)
primitiveGetStdErrHandle(struct foo * self)
{
	getStdHandle(2, self);
	return 0;
}


/*	Answer the file handle for standard error of my OS process. The session
	identifier is passed as the parameter to this primitive. Use this variant
	if the session identifier is not available directly in the VM (as may be
	the case if it is not possible to link from this plugin to a variable
	elsewhere in the VM). */

	/* UnixOSProcessPlugin>>#primitiveGetStdErrHandleWithSessionIdentifier */
EXPORT(sqInt)
primitiveGetStdErrHandleWithSessionIdentifier(struct foo * self)
{
    SQFile *file;
    sqInt fileOop;
    SESSIONIDENTIFIERTYPE thisSession;

	/* begin newSQFileByteArray */
	fileOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	file = arrayValueOf(fileOop, self);
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	file->file = stderr;
	file->sessionID = thisSession;
	file->writable = 1;
	file->lastOp = 0;
	pop(2, self);
	push(fileOop, self);
	return 0;
}


/*	Answer the file handle for standard input of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetStdInHandle */
EXPORT(sqInt)
primitiveGetStdInHandle(struct foo * self)
{
	getStdHandle(0, self);
	return 0;
}


/*	Answer the file handle for standard input of my OS process. The session
	identifier is passed as the parameter to this primitive. Use this variant
	if the session identifier is not available directly in the VM (as may be
	the case if it is not possible to link from this plugin to a variable
	elsewhere in the VM). */

	/* UnixOSProcessPlugin>>#primitiveGetStdInHandleWithSessionIdentifier */
EXPORT(sqInt)
primitiveGetStdInHandleWithSessionIdentifier(struct foo * self)
{
    SQFile *file;
    sqInt fileOop;
    SESSIONIDENTIFIERTYPE thisSession;

	/* begin newSQFileByteArray */
	fileOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	file = arrayValueOf(fileOop, self);
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	file->file = stdin;
	file->sessionID = thisSession;
	file->writable = 0;
	file->lastOp = 0;
	pop(2, self);
	push(fileOop, self);
	return 0;
}


/*	Answer the file handle for standard output of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetStdOutHandle */
EXPORT(sqInt)
primitiveGetStdOutHandle(struct foo * self)
{
	getStdHandle(1, self);
	return 0;
}


/*	Answer the file handle for standard output of my OS process. The session
	identifier is passed as the parameter to this primitive. Use this variant
	if the session identifier is not available directly in the VM (as may be
	the case if it is not possible to link from this plugin to a variable
	elsewhere in the VM). */

	/* UnixOSProcessPlugin>>#primitiveGetStdOutHandleWithSessionIdentifier */
EXPORT(sqInt)
primitiveGetStdOutHandleWithSessionIdentifier(struct foo * self)
{
    SQFile *file;
    sqInt fileOop;
    SESSIONIDENTIFIERTYPE thisSession;

	/* begin newSQFileByteArray */
	fileOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	file = arrayValueOf(fileOop, self);
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	file->file = stdout;
	file->sessionID = thisSession;
	file->writable = 1;
	file->lastOp = 0;
	pop(2, self);
	push(fileOop, self);
	return 0;
}


/*	Answer the ID of the pthread that is currently executing (the interpreter
	thread). A thread ID may be a 64 bit value on some platforms, so answer a
	byte array
	containing the value in machine-dependent byte order.
 */

	/* UnixOSProcessPlugin>>#primitiveGetThreadID */
EXPORT(sqInt)
primitiveGetThreadID(struct foo * self)
{
	popthenPush(1, newPthreadTypeByteArray(vmThread, self), self);
	return 0;
}


/*	Answer the user ID of my OS process */

	/* UnixOSProcessPlugin>>#primitiveGetUid */
EXPORT(sqInt)
primitiveGetUid(struct foo * self)
{
    uid_t uid;

	uid = getuid();
	pop(1, self);
	pushInteger(uid, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and call feof(3) to determine if the
	file has
	reached end of file.
 */
/*	Deprecated. The return values are reversed. Use
	primitiveTestEndOfFileFlag. 
 */

	/* UnixOSProcessPlugin>>#primitiveIsAtEndOfFile */
EXPORT(sqInt)
primitiveIsAtEndOfFile(struct foo * self)
{
    FILEHANDLETYPE file;
    sqInt result;
    sqInt sqFileOop;

	sqFileOop = stackValue(0, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	file = fileHandleFrom(sqFileOop, self);
	if (file == 0) {
		return primitiveFail(self);
	}
	if (feof(file)) {
		result = trueObject(self);
	}
	else {
		result = falseObject(self);
	}
	pop(2, self);
	push(result, self);
	return 0;
}


/*	Set a list of pids to kill with signum when VM exits. If the signum
	parameter is nil, the default value of SIGTERM will be used. */

	/* UnixOSProcessPlugin>>#primitiveKillOnExit */
EXPORT(sqInt)
primitiveKillOnExit(struct foo * self)
{
    sqInt count;
    pid_t *p;
    pid_t pid;
    sqInt *pidPointer;
    sqInt pids;
    sqInt signum;

	pids = stackValue(1, self);
	signum = stackValue(0, self);
	pidCount = stSizeOf(pids, self);
	if (failed(self)) {
		return null;
	}
	if (!(pidArray == 0)) {
		free(pidArray);
	}
	pidArray = malloc(pidCount * sizeof(pid_t));
	if (pidArray == 0) {
		pidCount = 0;
		return primitiveFail(self);
	}
	pidPointer = firstIndexableField(pids, self);
	count = 0;
	p = pidArray;
	while (count <= pidCount) {
		pid = integerValueOf(*pidPointer++, self);
		*p++ = pid;
		count += 1;
	}
	if (!(signum == (nilObject(self)))) {
		sigNumToSend = checkedIntegerValueOf(signum, self);
	}
	if (failed(self)) {
		pidCount = 0;
	}
	pop(2, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and request a lock on the specified
	region. If the exclusive flag is true, then request an exclusive (F_WRLCK)
	lock on the
	file. Otherwise, request a shared (F_RDLCK) lock. Any number of Unix
	processes may hold a read lock (shared lock) on a file region, but only
	one process may
	hold a write lock (exclusive lock). Answer the result of the call to
	fcntl(). 
	If length is zero, then the entire file will be locked, including region
	extents that
	have not yet been allocated for the file. */

	/* UnixOSProcessPlugin>>#primitiveLockFileRegion */
EXPORT(sqInt)
primitiveLockFileRegion(struct foo * self)
{
    int exclusive;
    FILEHANDLETYPE fileHandle;
    int fileNo;
    sqInt len;
    struct flock lockStruct;
    int result;
    sqInt sqFileOop;
    sqInt start;


	/* Get the parameters from the stack */
	exclusive = (stackValue(0, self)) == (trueObject(self));
	len = stackIntegerValue(1, self);
	start = stackIntegerValue(2, self);
	sqFileOop = stackValue(3, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	/* begin unixFileNumber: */
	fileHandle = fileHandleFrom(sqFileOop, self);
	fileNo = fileno(fileHandle);
	if (exclusive) {
		lockStruct.l_type = F_WRLCK;
	}
	else {
		lockStruct.l_type = F_RDLCK;
	}
	lockStruct.l_whence = SEEK_SET;
	lockStruct.l_start = start;
	lockStruct.l_len = len;
	lockStruct.l_pid = 0;
	result = fcntl(fileNo, F_SETLK, &lockStruct);
	pop(5, self);
	pushInteger(result, self);
	return 0;
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The readerIOStream and writerIOStream variables represent the low level
	pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

	/* OSProcessPlugin>>#primitiveMakePipe */
EXPORT(sqInt)
primitiveMakePipe(struct foo * self)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;

	/* begin getThisSessionIdentifier */
	thisSession = getThisSessionID(self);
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(makePipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr, self))) {
		return primitiveFail(self);
	}
	/* begin newSQFileByteArray */
	writer = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer, self);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer, self);
	/* begin newSQFileByteArray */
	reader = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader, self);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader, self);
	arrayResult = instantiateClassindexableSize(classArray(self), 2, self);
	stObjectatput(arrayResult, 1, popRemappableOop(self), self);
	stObjectatput(arrayResult, 2, popRemappableOop(self), self);
	pop(1, self);
	push(arrayResult, self);
	return 0;
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The session identifier is passed as the parameter to this primitive. Use
	this variant
	if the session identifier is not available directly in the VM (as may be
	the case if
	it is not possible to link from this plugin to a variable elsewhere in the
	VM). The readerIOStream and writerIOStream variables represent the low
	level pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

	/* OSProcessPlugin>>#primitiveMakePipeWithSessionIdentifier */
EXPORT(sqInt)
primitiveMakePipeWithSessionIdentifier(struct foo * self)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;


	/* Create the anonymous OS pipe */
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(makePipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr, self))) {
		return primitiveFail(self);
	}
	/* begin newSQFileByteArray */
	writer = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer, self);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer, self);
	/* begin newSQFileByteArray */
	reader = instantiateClassindexableSize(classByteArray(self), sizeof(SQFile), self);
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader, self);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader, self);
	arrayResult = instantiateClassindexableSize(classArray(self), 2, self);
	stObjectatput(arrayResult, 1, popRemappableOop(self), self);
	stObjectatput(arrayResult, 2, popRemappableOop(self), self);
	pop(2, self);
	push(arrayResult, self);
	return 0;
}


/*	Answer a string containing the module name string for this plugin. */

	/* OSProcessPlugin>>#primitiveModuleName */
EXPORT(sqInt)
primitiveModuleName(struct foo * self)
{
	popthenPush(1, stringFromCString(getModuleName(), self), self);
	return 0;
}


/*	Change the scheduling priority of this process by the given nice
	increment. A positive increment decreases the priority. Only the superuser
	can specify
	a negative value (to increase the priority). See man(2) nice.
	
	Different versions of Unix are inconsistent in their return values. The
	only reliable test for success is to clear errno prior to the call, and
	test its value
	if the result of nice() is -1.
 */

	/* UnixOSProcessPlugin>>#primitiveNice */
EXPORT(sqInt)
primitiveNice(struct foo * self)
{
    extern int errno;
    int niceIncrement;
    sqInt result;

	niceIncrement = stackIntegerValue(0, self);
	errno = 0;
	result = nice(niceIncrement);
	if (result == -1) {

		/* sys call may have failed, test errno to be sure */
		if (!(errno == 0)) {
			return primitiveFail(self);
		}
	}
	pop(2, self);
	pushInteger(result, self);
	return 0;
}


/*	Set an environment variable using a string of the form 'KEY=value'. This
	implementation allocates a C string using malloc to allocate from the C
	heap (using cStringFromString rather than transientCStringFromString).
	This is necessary because the C runtime library does not make a copy of
	the string into separately allocated environment memory. */

	/* UnixOSProcessPlugin>>#primitivePutEnv */
EXPORT(sqInt)
primitivePutEnv(struct foo * self)
{
    char *cStringPtr;
    sqInt keyValueString;

	keyValueString = stackObjectValue(0, self);
	cStringPtr = cStringFromString(keyValueString, self);
	if ((putenv(cStringPtr)) == 0) {

		/* Set environment variable. */
		pop(2, self);
		push(keyValueString, self);
	}
	else {
		return primitiveFail(self);
	}
	return 0;
}


/*	Answer the real path for a path string as determined by realpath(). */

	/* UnixOSProcessPlugin>>#primitiveRealpath */
EXPORT(sqInt)
primitiveRealpath(struct foo * self)
{
	return realpathAsType(classString(self), self);
}


/*	Answer a byte array with the real path for a path string as determined by
	realpath(). 
 */

	/* UnixOSProcessPlugin>>#primitiveRealpathAsBytes */
EXPORT(sqInt)
primitiveRealpathAsBytes(struct foo * self)
{
	return realpathAsType(classByteArray(self), self);
}


/*	Clean up after the death of a child, and answer an array with the pid and
	the exit status of the child process. Answer nil if the pidToHandle does
	not exist.
 */

	/* UnixOSProcessPlugin>>#primitiveReapChildProcess */
EXPORT(sqInt)
primitiveReapChildProcess(struct foo * self)
{
    sqInt *arrayPtr;
    int exitStatus;
    sqInt pid;
    pid_t pidResult;
    sqInt pidToHandle;
    sqInt resultArray;
    sqInt status;


	/* Force C code translator to declare the variable */
	exitStatus = 0;
	pidToHandle = stackIntegerValue(0, self);
	pidResult = waitpid ( pidToHandle, &exitStatus, WNOHANG );
	if (pidResult <= 0) {
		pop(2, self);
		push(nilObject(self), self);
	}
	else {

		/* Answer an array with pid and result status */
		pid = integerObjectOf(pidResult, self);
		status = integerObjectOf(exitStatus, self);
		resultArray = instantiateClassindexableSize(classArray(self), 2, self);
		arrayPtr = firstIndexableField(resultArray, self);
		arrayPtr[0] = pid;
		arrayPtr[1] = status;
		pop(2, self);
		push(resultArray, self);
	}
	return 0;
}


/*	Answer the registration index of the semaphore currently associated with
	the signal handler for sigNum. */

	/* UnixOSProcessPlugin>>#primitiveSemaIndexFor */
EXPORT(sqInt)
primitiveSemaIndexFor(struct foo * self)
{
    sqInt index;
    sqInt sigNum;

	sigNum = stackIntegerValue(0, self);
	if (semaIndices == null) {

		/* interpreter simulation */
		index = 0;
	}
	else {
		index = semaIndices[sigNum];
	}
	pop(2, self);
	pushInteger(index, self);
	return 0;
}


/*	Send SIGABRT (abort) to the OS process identified by the argument. Use an
	explicit check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigabrtTo */
EXPORT(sqInt)
primitiveSendSigabrtTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGABRT);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGALRM (alarm clock) to the OS process identified by the argument.
	Use an explicit
	check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigalrmTo */
EXPORT(sqInt)
primitiveSendSigalrmTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGALRM);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGCHLD (child status has changed, usually death of child) to the OS
	process identified by the argument. Use an explicit check for
	isIntegerObject so we can
	return -1 on error (the stackIntegerValue: method answers 1 on error, and
	1 is a
	valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigchldTo */
EXPORT(sqInt)
primitiveSendSigchldTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGCHLD);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGCONT (continue) to the OS process identified by the argument. Use
	an explicit
	check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigcontTo */
EXPORT(sqInt)
primitiveSendSigcontTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGCONT);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGHUP (hangup) to the OS process identified by the argument. Use an
	explicit check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSighupTo */
EXPORT(sqInt)
primitiveSendSighupTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGHUP);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGINT (interrupt) to the OS process identified by the argument. Use
	an explicit
	check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigintTo */
EXPORT(sqInt)
primitiveSendSigintTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGINT);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGKILL (kill, unblockable) to the OS process identified by the
	argument. Use an explicit
	check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigkillTo */
EXPORT(sqInt)
primitiveSendSigkillTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGKILL);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGPIPE (broken pipe) to the OS process identified by the argument.
	Use an explicit
	check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigpipeTo */
EXPORT(sqInt)
primitiveSendSigpipeTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGPIPE);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGQUIT (quit) to the OS process identified by the argument. Use an
	explicit check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigquitTo */
EXPORT(sqInt)
primitiveSendSigquitTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGQUIT);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGSTOP (stop, unblockable) to the OS process identified by the
	argument. Use an explicit
	check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigstopTo */
EXPORT(sqInt)
primitiveSendSigstopTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGSTOP);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGTERM (termination) to the OS process identified by the argument.
	Use an explicit
	check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method
	answers 1 on error, and 1 is a valid pid number).
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigtermTo */
EXPORT(sqInt)
primitiveSendSigtermTo(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGTERM);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGUSR1 (User-defined signal 1) to the OS process identified by the
	argument. Use
	an explicit check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method answers 1 on error, and 1 is a valid pid
	number). 
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigusr1To */
EXPORT(sqInt)
primitiveSendSigusr1To(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGUSR1);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Send SIGUSR2 (User-defined signal 2) to the OS process identified by the
	argument. Use
	an explicit check for isIntegerObject so we can return -1 on error (the
	stackIntegerValue: method answers 1 on error, and 1 is a valid pid
	number). 
 */

	/* UnixOSProcessPlugin>>#primitiveSendSigusr2To */
EXPORT(sqInt)
primitiveSendSigusr2To(struct foo * self)
{
    pid_t pidToSignal;
    int result;


	/* Do not allow signal sending if running in secure mode */
	if ((sandboxSecurity(self)) == 1) {
		pop(2, self);
		pushInteger(-1, self);
	}
	else {
		if (isIntegerObject(stackValue(0, self), self)) {
			pidToSignal = stackIntegerValue(0, self);
			/* begin sendSignal:toPid: */
			result = kill(pidToSignal, SIGUSR2);
			pop(2, self);
			pushInteger(result, self);
		}
		else {
			pop(2, self);
			pushInteger(-1, self);
		}
	}
	return 0;
}


/*	Set the process group ID of the process identified by pid to a new process
	group ID. */

	/* UnixOSProcessPlugin>>#primitiveSetPGid */
EXPORT(sqInt)
primitiveSetPGid(struct foo * self)
{
    pid_t pgid;
    pid_t pid;

	pid = stackIntegerValue(1, self);
	pgid = stackIntegerValue(0, self);
	if ((setpgid(pid, pgid)) == -1) {
		return primitiveFail(self);
	}
	pop(2, self);
	return 0;
}


/*	Set a new process group for this OS process. Newly created child processes
	will be members of the new process group. Note: Use setpgid(0,0) rather
	than the equivalent setpgrp() because setpgrp() is implemented differently
	on some flavors of Unix. */

	/* UnixOSProcessPlugin>>#primitiveSetPGrp */
EXPORT(sqInt)
primitiveSetPGrp(struct foo * self)
{
	if ((setpgid(0, 0)) == -1) {
		return primitiveFail(self);
	}
	return 0;
}


/*	Set the index of the semaphore used by the OSProcess with which I
	collaborate. My
	OSProcess should set this value so that I can use it when handling SIGCHLD
	signals (death of child). In the C translation this is a static int which
	would be shared by all
	instances of UnixOSProcessPlugin, which is expected to be a singleton.
	Answer the
	value of the semaphore index.
 */

	/* UnixOSProcessPlugin>>#primitiveSetSemaIndex */
EXPORT(sqInt)
primitiveSetSemaIndex(struct foo * self)
{
	sigChldSemaIndex = stackIntegerValue(0, self);
	pop(2, self);
	pushInteger(sigChldSemaIndex, self);
	return 0;
}


/*	Quoted from Linux man pages:
	setsid() creates a new session if the calling process is not a process
	group leader.
	The calling process is the leader of the new session, the process group
	leader of
	the new process group, and has no controlling tty. The process group ID
	and session
	ID of the calling process are set to the PID of the calling process. The
	calling process will be the only process in this new process group and in
	this new session. */

	/* UnixOSProcessPlugin>>#primitiveSetSid */
EXPORT(sqInt)
primitiveSetSid(struct foo * self)
{
    pid_t sessionId;

	sessionId = setsid();
	if (sessionId == -1) {
		return primitiveFail(self);
	}
	pop(1, self);
	pushInteger(sessionId, self);
	return 0;
}


/*	Integer value corresponding to SIGCHLD */

	/* UnixOSProcessPlugin>>#primitiveSigChldNumber */
EXPORT(sqInt)
primitiveSigChldNumber(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGCHLD, self);
	return 0;
}


/*	Integer value corresponding to SIGHUP */

	/* UnixOSProcessPlugin>>#primitiveSigHupNumber */
EXPORT(sqInt)
primitiveSigHupNumber(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGHUP, self);
	return 0;
}


/*	Integer value corresponding to SIGINT */

	/* UnixOSProcessPlugin>>#primitiveSigIntNumber */
EXPORT(sqInt)
primitiveSigIntNumber(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGINT, self);
	return 0;
}


/*	Integer value corresponding to SIGKILL */

	/* UnixOSProcessPlugin>>#primitiveSigKillNumber */
EXPORT(sqInt)
primitiveSigKillNumber(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGKILL, self);
	return 0;
}


/*	Integer value corresponding to SIGPIPE */

	/* UnixOSProcessPlugin>>#primitiveSigPipeNumber */
EXPORT(sqInt)
primitiveSigPipeNumber(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGPIPE, self);
	return 0;
}


/*	Integer value corresponding to SIGQUIT */

	/* UnixOSProcessPlugin>>#primitiveSigQuitNumber */
EXPORT(sqInt)
primitiveSigQuitNumber(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGQUIT, self);
	return 0;
}


/*	Integer value corresponding to SIGTERM */

	/* UnixOSProcessPlugin>>#primitiveSigTermNumber */
EXPORT(sqInt)
primitiveSigTermNumber(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGTERM, self);
	return 0;
}


/*	Integer value corresponding to SIGUSR1 */

	/* UnixOSProcessPlugin>>#primitiveSigUsr1Number */
EXPORT(sqInt)
primitiveSigUsr1Number(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGUSR1, self);
	return 0;
}


/*	Integer value corresponding to SIGUSR2 */

	/* UnixOSProcessPlugin>>#primitiveSigUsr2Number */
EXPORT(sqInt)
primitiveSigUsr2Number(struct foo * self)
{
	pop(1, self);
	pushInteger(SIGUSR2, self);
	return 0;
}


/*	Size in bytes of an integer, for this C compiler on this machine. */

	/* OSProcessPlugin>>#primitiveSizeOfInt */
EXPORT(sqInt)
primitiveSizeOfInt(struct foo * self)
{
	pop(1, self);
	pushInteger(sizeof(int), self);
	return 0;
}


/*	Size in bytes of a void pointer, for this C compiler on this machine. */

	/* OSProcessPlugin>>#primitiveSizeOfPointer */
EXPORT(sqInt)
primitiveSizeOfPointer(struct foo * self)
{
	pop(1, self);
	pushInteger(sizeof(void *), self);
	return 0;
}


/*	Take a struct SQFile from the stack, and call fflush() to flush the OS
	stream. This flushes the
	file stream in the C library, not the stream in Smalltalk. For output
	streams, consider setting
	the OS stream (C library) to unbuffered output, and letting Smalltalk do
	all the buffering.
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileFlush */
EXPORT(sqInt)
primitiveSQFileFlush(struct foo * self)
{
    int result;
    sqInt sqFileOop;

	sqFileOop = stackValue(0, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	result = fflush(fileHandleFrom(sqFileOop, self));
	pop(2, self);
	pushInteger(result, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and call fflush() to flush the OS
	stream. This flushes the
	file stream in the C library, not the stream in Smalltalk. For output
	streams, consider setting
	the OS stream (C library) to unbuffered output, and letting Smalltalk do
	all the buffering.
	The session identifier is passed as the parameter to this primitive. Use
	this variant if the session
	identifier is not available directly in the VM (as may be the case if it
	is not possible to link from
	this plugin to a variable elsewhere in the VM).
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileFlushWithSessionIdentifier */
EXPORT(sqInt)
primitiveSQFileFlushWithSessionIdentifier(struct foo * self)
{
    int result;
    sqInt sqFileOop;

	sqFileOop = stackValue(1, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	result = fflush(fileHandleFrom(sqFileOop, self));
	pop(3, self);
	pushInteger(result, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and call fcntl() to set the file for
	blocking I/O.
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileSetBlocking */
EXPORT(sqInt)
primitiveSQFileSetBlocking(struct foo * self)
{
    sqInt descriptor;
    int flags;
    sqInt retVal;
    sqInt sqFileOop;

	sqFileOop = stackValue(0, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	/* begin fileDescriptorFrom: */
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		descriptor = -1;
		goto l1;
	}
	descriptor = fileno(fileHandleFrom(sqFileOop, self));
	l1:	/* end fileDescriptorFrom: */;
	if (descriptor == -1) {
		return primitiveFail(self);
	}
	flags = fcntl(descriptor, F_GETFL);
	retVal = fcntl(descriptor, F_SETFL, flags & ~O_NONBLOCK);
	pop(2, self);
	pushInteger(retVal, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and call fcntl() to set the file for
	blocking I/O.
	Use this variant if the session identifier is not available directly in
	the VM (as may be
	the case if it is not possible to link from this plugin to a variable
	elsewhere in the VM).
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileSetBlockingWithSessionIdentifier */
EXPORT(sqInt)
primitiveSQFileSetBlockingWithSessionIdentifier(struct foo * self)
{
    sqInt descriptor;
    sqInt flags;
    sqInt retVal;
    SQFile *sqFile;
    sqInt sqFileOop;
    SESSIONIDENTIFIERTYPE thisSession;

	sqFileOop = stackValue(1, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	sqFile = arrayValueOf(sqFileOop, self);
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	if (thisSession == (sqFile->sessionID)) {
		/* begin fileDescriptorFrom: */
		if (!((((isBytes(sqFileOop, self))
			 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
			 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
			 && (isNonNullSQFile(sqFileOop, self)))) {
			descriptor = -1;
			goto l1;
		}
		descriptor = fileno(fileHandleFrom(sqFileOop, self));
	l1:	/* end fileDescriptorFrom: */;
		if (descriptor < 0) {
			return primitiveFail(self);
		}
		flags = fcntl(descriptor, F_GETFL);
		retVal = fcntl(descriptor, F_SETFL, flags & ~O_NONBLOCK);
		pop(3, self);
		pushInteger(retVal, self);
	}
	else {
		return primitiveFail(self);
	}
	return 0;
}


/*	Take a struct SQFile from the stack, and call fcntl() to set the file
	non-blocking I/O.
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileSetNonBlocking */
EXPORT(sqInt)
primitiveSQFileSetNonBlocking(struct foo * self)
{
    sqInt descriptor;
    sqInt flags;
    sqInt retVal;
    sqInt sqFileOop;

	sqFileOop = stackValue(0, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	/* begin fileDescriptorFrom: */
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		descriptor = -1;
		goto l1;
	}
	descriptor = fileno(fileHandleFrom(sqFileOop, self));
	l1:	/* end fileDescriptorFrom: */;
	if (descriptor < 0) {
		return primitiveFail(self);
	}
	flags = fcntl(descriptor, F_GETFL);
	retVal = fcntl(descriptor, F_SETFL, flags | O_NONBLOCK);
	pop(2, self);
	pushInteger(retVal, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and call fcntl() to set the file
	non-blocking I/O.
	Use this variant if the session identifier is not available directly in
	the VM (as may be
	the case if it is not possible to link from this plugin to a variable
	elsewhere in the VM).
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileSetNonBlockingWithSessionIdentifier */
EXPORT(sqInt)
primitiveSQFileSetNonBlockingWithSessionIdentifier(struct foo * self)
{
    sqInt descriptor;
    sqInt flags;
    sqInt retVal;
    SQFile *sqFile;
    sqInt sqFileOop;
    SESSIONIDENTIFIERTYPE thisSession;

	sqFileOop = stackValue(1, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	sqFile = arrayValueOf(sqFileOop, self);
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	if (thisSession == (sqFile->sessionID)) {
		/* begin fileDescriptorFrom: */
		if (!((((isBytes(sqFileOop, self))
			 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
			 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
			 && (isNonNullSQFile(sqFileOop, self)))) {
			descriptor = -1;
			goto l1;
		}
		descriptor = fileno(fileHandleFrom(sqFileOop, self));
	l1:	/* end fileDescriptorFrom: */;
		if (descriptor < 0) {
			return primitiveFail(self);
		}
		flags = fcntl(descriptor, F_GETFL);
		retVal = fcntl(descriptor, F_SETFL, flags | O_NONBLOCK);
		pop(3, self);
		pushInteger(retVal, self);
	}
	else {
		return primitiveFail(self);
	}
	return 0;
}


/*	Take a struct SQFile from the stack, and call setbuf() to set the OS file
	stream (implemented in the C library) for unbuffered I/O. Answers the
	result of a fflush()
	call, not the result of the setbuf() call (which is type void). This is
	nearly useless,
	but may at least provide an indicator that we are operating on a valid
	file stream.
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileSetUnbuffered */
EXPORT(sqInt)
primitiveSQFileSetUnbuffered(struct foo * self)
{
    FILEHANDLETYPE file;
    sqInt retVal;
    sqInt sqFileOop;

	sqFileOop = stackValue(0, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	file = fileHandleFrom(sqFileOop, self);
	retVal = fflush(file);
	setbuf(file, 0);
	pop(2, self);
	pushInteger(retVal, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and call setbuf() to set the OS file
	stream (implemented in
	the C library) for unbuffered I/O. Answers the result of a fflush() call,
	not the result of the
	setbuf() call (which is type void). This is nearly useless, but may at
	least provide an indicator
	that we are operating on a valid file stream. Use this variant if the
	session identifier is not
	available directly in the VM (as may be the case if it is not possible to
	link from this plugin
	to a variable elsewhere in the VM).
 */

	/* UnixOSProcessPlugin>>#primitiveSQFileSetUnbufferedWithSessionIdentifier */
EXPORT(sqInt)
primitiveSQFileSetUnbufferedWithSessionIdentifier(struct foo * self)
{
    sqInt retVal;
    SQFile *sqFile;
    sqInt sqFileOop;
    SESSIONIDENTIFIERTYPE thisSession;

	sqFileOop = stackValue(1, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	sqFile = arrayValueOf(sqFileOop, self);
	thisSession = sessionIdentifierFrom(stackObjectValue(0, self), self);
	if (thisSession == (sqFile->sessionID)) {
		retVal = fflush(sqFile->file);
		setbuf(sqFile->file, NULL);
		pop(3, self);
		pushInteger(retVal, self);
	}
	else {
		return primitiveFail(self);
	}
	return 0;
}


/*	Take a struct SQFile from the stack, and call feof(3) to determine if the
	file has
	reached end of file. The flag is set only by a previous read operation, so
	end of
	file is not detected until an actual EOF condition has been detected by a
	read attempt.
 */

	/* UnixOSProcessPlugin>>#primitiveTestEndOfFileFlag */
EXPORT(sqInt)
primitiveTestEndOfFileFlag(struct foo * self)
{
    FILEHANDLETYPE file;
    sqInt result;
    sqInt sqFileOop;

	sqFileOop = stackValue(0, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	file = fileHandleFrom(sqFileOop, self);
	if (file == 0) {
		return primitiveFail(self);
	}
	if (feof(file)) {
		result = trueObject(self);
	}
	else {
		result = falseObject(self);
	}
	pop(2, self);
	push(result, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and check for ability to lock the
	specified region.
	If the exclusive flag is true, then specify an exclusive (F_WRLCK) lock on
	the file. Otherwise, specify a shared (F_RDLCK) lock. Any number of Unix
	processes may hold a read lock (shared lock) on a file region, but only
	one process may
	hold a write lock (exclusive lock).
	
	If length is zero, then the request is for the entire file to be locked,
	including region extents that have not yet been allocated for the file.
	
	If the fcntl() call fails, answer -1 (the result of the failed call).
	Otherwise, answer an array with the following six fields:
	lockable (true or false)
	l_pid (pid of the process preventing this lock request, or nil)
	l_type (request type F_WRLCK or F_RDLOCK of the process preventing this
	lock request)
	l_whence (the SEEK_SET, SEEK_CUR, or SEEK_END value of the lock preventing
	this lock request).
	l_start (offset of the region lock preventing this lock request)
	l_len (length of the region lock preventing this lock request) */

	/* UnixOSProcessPlugin>>#primitiveTestLockableFileRegion */
EXPORT(sqInt)
primitiveTestLockableFileRegion(struct foo * self)
{
    sqInt canObtainLock;
    int exclusive;
    FILEHANDLETYPE fileHandle;
    int fileNo;
    sqInt len;
    struct flock lockStruct;
    int result;
    sqInt resultArray;
    sqInt sqFileOop;
    sqInt start;


	/* Get the parameters from the stack */
	exclusive = (stackValue(0, self)) == (trueObject(self));
	len = stackIntegerValue(1, self);
	start = stackIntegerValue(2, self);
	sqFileOop = stackValue(3, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	/* begin unixFileNumber: */
	fileHandle = fileHandleFrom(sqFileOop, self);
	fileNo = fileno(fileHandle);
	if (exclusive) {
		lockStruct.l_type = F_WRLCK;
	}
	else {
		lockStruct.l_type = F_RDLCK;
	}
	lockStruct.l_whence = SEEK_SET;
	lockStruct.l_start = start;
	lockStruct.l_len = len;
	lockStruct.l_pid = 0;
	result = fcntl(fileNo, F_GETLK, &lockStruct);
	if (result == -1) {
		pop(5, self);
		pushInteger(result, self);
	}
	else {
		if (lockStruct.l_type == F_UNLCK) {
			canObtainLock = trueObject(self);
		}
		else {
			canObtainLock = falseObject(self);
		}
		resultArray = instantiateClassindexableSize(classArray(self), 6, self);
		stObjectatput(resultArray, 1, canObtainLock, self);
		stObjectatput(resultArray, 2, integerObjectOf(lockStruct.l_pid, self), self);
		stObjectatput(resultArray, 3, integerObjectOf(lockStruct.l_type, self), self);
		stObjectatput(resultArray, 4, integerObjectOf(lockStruct.l_whence, self), self);
		stObjectatput(resultArray, 5, integerObjectOf(lockStruct.l_start, self), self);
		stObjectatput(resultArray, 6, integerObjectOf(lockStruct.l_len, self), self);
		popthenPush(5, resultArray, self);
	}
	return 0;
}


/*	Close a file handle at the close(2) level, using a handle returned by
	#primitiveUnixFileNumber. */

	/* UnixOSProcessPlugin>>#primitiveUnixFileClose: */
EXPORT(sqInt)
primitiveUnixFileClose(sqInt anIntegerFileNumber, struct foo * self)
{
    int handle;
    int result;

	handle = stackIntegerValue(0, self);
	result = close(handle);
	pop(2, self);
	pushInteger(result, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and answer the value of its Unix file
	number. The Unix file number is not directly useful to Squeak, but may be
	interesting for
	debugging problems involving failure to close unused file handles.
 */

	/* UnixOSProcessPlugin>>#primitiveUnixFileNumber */
EXPORT(sqInt)
primitiveUnixFileNumber(struct foo * self)
{
    FILEHANDLETYPE fileHandle;
    int fileNo;
    sqInt sqFileOop;

	sqFileOop = stackValue(0, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	/* begin unixFileNumber: */
	fileHandle = fileHandleFrom(sqFileOop, self);
	fileNo = fileno(fileHandle);
	pop(2, self);
	pushInteger(fileNo, self);
	return 0;
}


/*	Take a struct SQFile from the stack, and unlock the specified region.
	Answer the result of the call to fcntl(). If the region is in the file
	lock cache,
	remove it, but otherwise ignore the cache. The cache supports Win32
	semantics within a single Squeak image, but not across separate images,
	therefore the
	unlock should be attempted regardless of whether this image thinks that
	the region has previously been locked. Answer the result of the call to
	fcntl(). 
 */

	/* UnixOSProcessPlugin>>#primitiveUnlockFileRegion */
EXPORT(sqInt)
primitiveUnlockFileRegion(struct foo * self)
{
    FILEHANDLETYPE fileHandle;
    int fileNo;
    sqInt len;
    struct flock lockStruct;
    int result;
    sqInt sqFileOop;
    sqInt start;


	/* Get the parameters from the stack */
	len = stackIntegerValue(0, self);
	start = stackIntegerValue(1, self);
	sqFileOop = stackValue(2, self);
	if (!((((isBytes(sqFileOop, self))
		 && ((byteSizeOf(sqFileOop, self)) == (sizeof(SQFile))))
		 && ((getThisSessionID(self)) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop, self)))))
		 && (isNonNullSQFile(sqFileOop, self)))) {
		return primitiveFail(self);
	}
	/* begin unixFileNumber: */
	fileHandle = fileHandleFrom(sqFileOop, self);
	fileNo = fileno(fileHandle);
	lockStruct.l_type = F_UNLCK;
	lockStruct.l_whence = SEEK_SET;
	lockStruct.l_start = start;
	lockStruct.l_len = len;
	lockStruct.l_pid = 0;
	result = fcntl(fileNo, F_SETLK, &lockStruct);
	pop(4, self);
	pushInteger(result, self);
	return 0;
}


/*	Unset an environment variable. */
/*	FIXME: unsetenv() is not portable. For Solaris or any other system which
	does not
	support unsetenv(), just comment it out in this method and rebuild the
	plugin. 
 */

	/* UnixOSProcessPlugin>>#primitiveUnsetEnv */
EXPORT(sqInt)
primitiveUnsetEnv(struct foo * self)
{
	unsetenv(transientCStringFromString(stackObjectValue(0, self), self));
	pop(1, self);
	return 0;
}


/*	Answer a string containing the version string for this plugin. */

	/* OSProcessPlugin>>#primitiveVersionString */
EXPORT(sqInt)
primitiveVersionString(struct foo * self)
{
	pop(1, self);
	push(stringFromCString(versionString(), self), self);
	return 0;
}


/*	Answer the real path for a path string as determined by realpath(). */

	/* UnixOSProcessPlugin>>#realpathAsType: */
static sqInt
realpathAsType(sqInt classIdentifier, struct foo * self)
{
    char *buffer;
    sqInt bufferSize;
    sqInt len;
    sqInt newPathString;
    sqInt newString;
    char *pathString;
    char * realpathResult;
    sqInt s;

	bufferSize = 1024;
	newPathString = instantiateClassindexableSize(classString(self), bufferSize, self);
	pushRemappableOop(newPathString, self);
	pathString = transientCStringFromString(stackObjectValue(0, self), self);
	newPathString = popRemappableOop(self);
	buffer = arrayValueOf(newPathString, self);
	realpathResult = realpath(pathString, buffer);
	if (realpathResult == 0) {
		return primitiveFail(self);
	}
	else {
		if ((strlen(realpathResult)) >= 1024) {
			perror("warning: statically allocated array exceeded in UnixOSProcessPlugin>>primitiveRealPath, object memory may have been corrupted");
			return primitiveFail(self);
		}
		/* begin cString:asCollection: */
		len = strlen(realpathResult);
		newString = instantiateClassindexableSize(classIdentifier, len, self);
		strncpy(arrayValueOf(newString, self), realpathResult, len);
		s = newString;
		pop(2, self);
		push(s, self);
	}
	return 0;
}


/*	This is a signal handler for SIGCHLD. It is not meant to be called from
	Smalltalk, and should only be called indirectly as a result of a death of
	child signal from
	the operating system.
	
	Child processes must be cleaned up by the parent, otherwise they continue
	to exist as zombies until the parent exits. This handler resets the signal
	handler to catch the next SIGCHLD signal, then sets a semaphore to notify
	the system
	that a child process needs to be cleaned up. The actual clean up is done
	by a
	Smalltalk process which waits on the semaphore, then calls
	primitiveReapChildProcess. 
	Note: If child processes die faster than we can clean them up, signals
	will be lost
	and child processes will remain as zombies.
 */

	/* UnixOSProcessPlugin>>#reapChildProcess: */
static void
reapChildProcess(int sigNum, struct foo * self)
{
	
#if !defined(SA_NOCLDSTOP)
	setSigChldHandler(self);
	
#endif /* defined(SA_NOCLDSTOP) */
	if (sigChldSemaIndex > 0) {
		signalSemaphoreWithIndex(sigChldSemaIndex);
	}
}


/*	Signal sigNum has been caught by a thread other than the pthread in which
	the interpreter is executing. Rather than handling it in this thread,
	resend it to the interpreter thread. */

	/* UnixOSProcessPlugin>>#resendSignal: */
static sqInt
resendSignal(int sigNum, struct foo * self)
{
	pthread_kill(vmThread, sigNum);
	return 0;
}


/*	Restore signal handlers to their original behaviors. */

	/* UnixOSProcessPlugin>>#restoreDefaultSignalHandlers */
static void
restoreDefaultSignalHandlers(struct foo * self)
{
    sqInt sigNum;

	if (!(semaIndices == null)) {

		/* nil if in interpreter simulation */
		sigNum = 1;
		while (sigNum <= (signalArraySize(self))) {
			if ((semaIndices[sigNum]) > 0) {
				setSignalNumberhandler(sigNum, (originalSignalHandlers())[sigNum], self);
			}
			sigNum += 1;
		}
	}
}


/*	Answer 1 if running in secure mode, else 0. The osprocessSandboxSecurity
	variable is initialized to -1. On the first call to this method, set its
	value to
	either 0 (user has full access to the plugin) or 1 (user is not permitted
	to do
	dangerous things).
 */

	/* OSProcessPlugin>>#sandboxSecurity */
static sqInt
sandboxSecurity(struct foo * self)
{
	if (osprocessSandboxSecurity < 0) {
		osprocessSandboxSecurity = securityHeurisitic(self);
	}
	return osprocessSandboxSecurity;
}


/*	Answer 0 to permit full access to OSProcess functions, or 1 if access
	should be
	restricted for dangerous functions. The rules are:
	- If the security plugin is not present, grant full access
	- If the security plugin can be loaded, restrict access unless user has
	all of secCanWriteImage, secHasFileAccess and secHasSocketAccess */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check. If not, assume it's
	ok 
 */

	/* OSProcessPlugin>>#securityHeurisitic */
static sqInt
securityHeurisitic(struct foo * self)
{
    sqInt canWriteImage;
    sqInt hasFileAccess;
    sqInt hasSocketAccess;
    void (*sCWIfn)(void);
    void (*sHFAfn)(void);
    void (*sHSAfn)(void);

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin", self);
	if (sCWIfn == 0) {
		return 0;
	}
	canWriteImage = ((sqInt (*) (void)) sCWIfn)();
	sHFAfn = ioLoadFunctionFrom("secHasFileAccess", "SecurityPlugin", self);
	if (sHFAfn == 0) {
		return 0;
	}
	hasFileAccess = ((sqInt (*) (void)) sHFAfn)();
	sHSAfn = ioLoadFunctionFrom("secHasSocketAccess", "SecurityPlugin", self);
	if (sHSAfn == 0) {
		return 0;
	}
	hasSocketAccess = ((sqInt (*) (void)) sHSAfn)();
	return ((canWriteImage
	 && (hasFileAccess))
	 && (hasSocketAccess)
		? 0
		: 1);
}


/*	Exit function to be registered with atexit() to signal child processes on
	VM exit.
 */

	/* UnixOSProcessPlugin>>#sendSignalToPids */
static void
sendSignalToPids(struct foo * self)
{
    sqInt count;
    pid_t pid;

	count = 0;
	while (count < pidCount) {
		pid = pidArray[count];
		kill(pid, sigNumToSend);
		count += 1;
	}
}


/*	kill(pid, sig) */

	/* UnixOSProcessPlugin>>#sendSignal:toPid: */
static sqInt
sendSignaltoPid(sqInt sig, sqInt pid, struct foo * self)
{
	return kill(pid, sig);
}


/*	Answer a session ID represented by aByteArray. The session ID is used in
	the SQFile structure. If that data structure changes, we should see
	compiler warnings about type mismatch with SESSIONIDENTIFIERTYPE. */

	/* OSProcessPlugin>>#sessionIdentifierFrom: */
static SESSIONIDENTIFIERTYPE
sessionIdentifierFrom(sqInt aByteArray, struct foo * self)
{
    sqInt idx;
    unsigned char *session;
    union {SESSIONIDENTIFIERTYPE session; unsigned char bytes[sizeof(SESSIONIDENTIFIERTYPE)];} sessionUnion;

	if (!((isBytes(aByteArray, self))
		 && ((stSizeOf(aByteArray, self)) == (sizeOfSession(self))))) {
		return null;
	}
	session = arrayValueOf(aByteArray, self);
	idx = 0;
	while (idx < (sizeOfSession(self))) {
		sessionUnion.bytes[idx] = session[idx];
		idx += 1;
	}
	return sessionUnion.session;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
		checkedIntegerValueOf = interpreterProxy->checkedIntegerValueOf;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		getThisSessionID = interpreterProxy->getThisSessionID;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isBytes = interpreterProxy->isBytes;
		isIntegerObject = interpreterProxy->isIntegerObject;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnValue = interpreterProxy->methodReturnValue;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		push = interpreterProxy->push;
		pushInteger = interpreterProxy->pushInteger;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signalSemaphoreWithIndex = interpreterProxy->signalSemaphoreWithIndex;
		sizeOfSTArrayFromCPrimitive = interpreterProxy->sizeOfSTArrayFromCPrimitive;
		stObjectatput = interpreterProxy->stObjectatput;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Set the SIGCHLD signal handler in the virtual machine. */

	/* UnixOSProcessPlugin>>#setSigChldHandler */
static void
setSigChldHandler(struct foo * self)
{
    struct sigaction sigchldHandlerAction;

	
#  if defined(SA_NOCLDSTOP)
	sigchldHandlerAction.sa_sigaction = reapChildProcess;
	sigchldHandlerAction.sa_flags = SA_NODEFER | SA_NOCLDSTOP;
	if (needSigaltstack(self)) {
		sigchldHandlerAction.sa_flags |= SA_ONSTACK;
	}
	sigemptyset(&sigchldHandlerAction.sa_mask);
	if ((sigaction(SIGCHLD, &sigchldHandlerAction, 0)) == (sigErrorNumber(self))) {
		perror("signal");
	}
#  else /* defined(SA_NOCLDSTOP) */
	setSignalNumberhandler(SIGCHLD, reapChildProcess, self);
#  endif /* defined(SA_NOCLDSTOP) */
}

	/* UnixOSProcessPlugin>>#setSigIntDefaultHandler */
static void
setSigIntDefaultHandler(struct foo * self)
{
	setSignalNumberhandler(SIGINT, sigDefaultNumber(self), self);
}


/*	Set the SIGINT signal handler in the virtual machine to ignore interrupts. */

	/* UnixOSProcessPlugin>>#setSigIntIgnore */
static void
setSigIntIgnore(struct foo * self)
{
	setSignalNumberhandler(SIGINT, sigIgnoreNumber(self), self);
}


/*	Set a signal handler. The C code translator will convert #sig:nal: into
	'signal(parm1, parm2)'
 */

	/* UnixOSProcessPlugin>>#setSignalNumber:handler: */
static void *
setSignalNumberhandler(sqInt signalNumber, void *signalHandlerAddress, struct foo * self)
{
    struct sigaction oldHandlerAction;
    struct sigaction sigHandlerAction;

	if (!(needSigaltstack(self))) {
		return signal(signalNumber, signalHandlerAddress);
	}
	sigHandlerAction.sa_sigaction = signalHandlerAddress;
	sigHandlerAction.sa_flags = SA_ONSTACK | SA_RESTART;
	sigemptyset(&sigHandlerAction.sa_mask);
	if ((sigaction(signalNumber, (&sigHandlerAction), (&oldHandlerAction))) == (sigErrorNumber(self))) {
		perror("signal");
	}
	return oldHandlerAction.sa_sigaction;
}

	/* UnixOSProcessPlugin>>#setSigPipeDefaultHandler */
static void
setSigPipeDefaultHandler(struct foo * self)
{
	setSignalNumberhandler(SIGPIPE, sigDefaultNumber(self), self);
}


/*	Set the SIGPIPE signal handler in the virtual machine to ignore pipe error
	signals. If a pipe is opened to a child process, and the child exits, then
	subsequent writes to
	the pipe generate a SIGPIPE signal. If this signal is not handled, the VM
	will exit
	without warning.
 */

	/* UnixOSProcessPlugin>>#setSigPipeHandler */
static sqInt
setSigPipeHandler(struct foo * self)
{
	/* begin setSigPipeIgnore */
	setSignalNumberhandler(SIGPIPE, sigIgnoreNumber(self), self);
	return 0;
}


/*	Set the SIGPIPE signal handler in the virtual machine to ignore pipe error
	signals. 
 */

	/* UnixOSProcessPlugin>>#setSigPipeIgnore */
static void
setSigPipeIgnore(struct foo * self)
{
	setSignalNumberhandler(SIGPIPE, sigIgnoreNumber(self), self);
}

	/* UnixOSProcessPlugin>>#shutdownModule */
EXPORT(sqInt)
shutdownModule(struct foo * self)
{
    sqInt sigNum;

	/* begin restoreDefaultSignalHandlers */
	if (!(semaIndices == null)) {

		/* nil if in interpreter simulation */
		sigNum = 1;
		while (sigNum <= (signalArraySize(self))) {
			if ((semaIndices[sigNum]) > 0) {
				setSignalNumberhandler(sigNum, (originalSignalHandlers())[sigNum], self);
			}
			sigNum += 1;
		}
	}
	return 0;
}


/*	Abort signal from abort(3) */

	/* UnixOSProcessPlugin>>#sigAbrtNumber */
static sqInt
sigAbrtNumber(struct foo * self)
{
	return SIGABRT;
}


/*	Timer signal from alarm(2) */

	/* UnixOSProcessPlugin>>#sigAlrmNumber */
static sqInt
sigAlrmNumber(struct foo * self)
{
	return SIGALRM;
}


/*	Child status has changed (POSIX). */

	/* UnixOSProcessPlugin>>#sigChldNumber */
static sqInt
sigChldNumber(struct foo * self)
{
	return SIGCHLD;
}


/*	Continue if stopped */

	/* UnixOSProcessPlugin>>#sigContNumber */
static sqInt
sigContNumber(struct foo * self)
{
	return SIGCONT;
}


/*	Default action for a signal */

	/* UnixOSProcessPlugin>>#sigDefaultNumber */
static void *
sigDefaultNumber(struct foo * self)
{
	return SIG_DFL;
}


/*	Error return from signal() */

	/* UnixOSProcessPlugin>>#sigErrorNumber */
static void *
sigErrorNumber(struct foo * self)
{
	return SIG_ERR;
}


/*	Hold action for a signal */

	/* UnixOSProcessPlugin>>#sigHoldNumber */
static void *
sigHoldNumber(struct foo * self)
{
#ifdef SIG_HOLD
	return SIG_HOLD;
#else
	return -1;
#endif
}


/*	Hangup detected on controlling terminal or death of controlling process */

	/* UnixOSProcessPlugin>>#sigHupNumber */
static sqInt
sigHupNumber(struct foo * self)
{
	return SIGHUP;
}


/*	Ignore action for a signal */

	/* UnixOSProcessPlugin>>#sigIgnoreNumber */
static void *
sigIgnoreNumber(struct foo * self)
{
	return SIG_IGN;
}


/*	Interrupt (ANSI). */

	/* UnixOSProcessPlugin>>#sigIntNumber */
static sqInt
sigIntNumber(struct foo * self)
{
	return SIGINT;
}


/*	Kill signal */

	/* UnixOSProcessPlugin>>#sigKillNumber */
static sqInt
sigKillNumber(struct foo * self)
{
	return SIGKILL;
}


/*	Number of possible signals for this OS plus one. The signal handler arrays
	declared in #declareCVarsIn: are this size. */

	/* UnixOSProcessPlugin>>#signalArraySize */
static sqInt
signalArraySize(struct foo * self)
{
	return NSIG;
}


/*	Broken pipe (POSIX). */

	/* UnixOSProcessPlugin>>#sigPipeNumber */
static sqInt
sigPipeNumber(struct foo * self)
{
	return SIGPIPE;
}


/*	Quit from keyboard */

	/* UnixOSProcessPlugin>>#sigQuitNumber */
static sqInt
sigQuitNumber(struct foo * self)
{
	return SIGQUIT;
}


/*	Stop process */

	/* UnixOSProcessPlugin>>#sigStopNumber */
static sqInt
sigStopNumber(struct foo * self)
{
	return SIGSTOP;
}


/*	Termination signal. This is the default signal sent by the unix kill(1)
	command. 
 */

	/* UnixOSProcessPlugin>>#sigTermNumber */
static sqInt
sigTermNumber(struct foo * self)
{
	return SIGTERM;
}


/*	User defined signal number 1. This is value is platform-dependent, so the
	inSmalltalk default of 30 may be wrong on some platforms. */

	/* UnixOSProcessPlugin>>#sigUsr1Number */
static sqInt
sigUsr1Number(struct foo * self)
{
	return SIGUSR1;
}


/*	User defined signal number 2. This is value is platform-dependent, so the
	inSmalltalk default of 32 may be wrong on some platforms. */

	/* UnixOSProcessPlugin>>#sigUsr2Number */
static sqInt
sigUsr2Number(struct foo * self)
{
	return SIGUSR2;
}


/*	Size in bytes of an integer, for this C compiler on this machine. */

	/* OSProcessPlugin>>#sizeOfInt */
static usqIntptr_t
sizeOfInt(struct foo * self)
{
	return sizeof(int);
}


/*	Size in bytes of a void pointer, for this C compiler on this machine. */

	/* OSProcessPlugin>>#sizeOfPointer */
static usqIntptr_t
sizeOfPointer(struct foo * self)
{
	return sizeof(void *);
}


/*	Size of a SESSIONIDENTIFIERTYPE. Should match usage in the SQFile data
	structure, otherwise we should get compiler warnings. */

	/* OSProcessPlugin>>#sizeOfSession */
static sqInt
sizeOfSession(struct foo * self)
{
	return sizeof(SESSIONIDENTIFIERTYPE);
}


/*	Answer the OS file descriptor, an integer value, from a SQSocket data
	structure, or answer -1 if unable to obtain the file descriptor (probably
	due to receiving
	an incorrect type of object as aFileHandle).
	
	Warning: The first element of privateSocketStruct happens to be the Unix
	file number of the socket. See sqUnixSocket.c for the definition. This
	method takes
	advantage of this, and will break if anyone ever redefines the data
	structure. 
 */

	/* OSProcessPlugin>>#socketDescriptorFrom: */
static int
socketDescriptorFrom(sqInt sqSocketOop, struct foo * self)
{
    void *privateSocketStruct;
    SocketPtr sqSocket;

	/* begin socketValueOf: */
	sqSocket = arrayValueOf(sqSocketOop, self);
	privateSocketStruct = sqSocket->privateSocketPtr;
	if (privateSocketStruct == 0) {
		return -1;
	}
	return * (int *) privateSocketStruct;
}


/*	Answer the size of a SQSocket data structure in bytes. */

	/* OSProcessPlugin>>#socketRecordSize */
static usqIntptr_t
socketRecordSize(struct foo * self)
{
	return sizeof(SQSocket);
}


/*	Return a pointer to the first byte of of the SQsocket data structure
	socket record within
	anSQSocketRecord, which is expected to be a ByteArray of size
	self>>socketRecordSize. 
 */

	/* OSProcessPlugin>>#socketValueOf: */
static SocketPtr
socketValueOf(sqInt anSQSocketRecord, struct foo * self)
{
	return arrayValueOf(anSQSocketRecord, self);
}


/*	Answer a new ByteString copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* OSProcessPlugin>>#stringFromCString: */
static sqInt
stringFromCString(const char *aCString, struct foo * self)
{
    sqInt classIdentifier;
    sqInt len;
    sqInt newString;

	/* begin cString:asCollection: */
	classIdentifier = classString(self);
	len = strlen(aCString);
	newString = instantiateClassindexableSize(classIdentifier, len, self);
	strncpy(arrayValueOf(newString, self), aCString, len);
	return newString;
}


/*	Answer a new null-terminated C string copied from aString.
	The string is allocated in object memory, and will be moved
	without warning by the garbage collector. Any C pointer
	reference the the result is valid only until the garbage
	collector next runs. Therefore, this method should only be used
	within a single primitive in a section of code in which the
	garbage collector is guaranteed not to run. Note also that
	this method may itself invoke the garbage collector prior
	to allocating the new C string.
	
	Warning: The result of this method will be invalidated by the
	next garbage collection, including a GC triggered by creation
	of a new object within a primitive. Do not call this method
	twice to obtain two string pointers.
 */

	/* OSProcessPlugin>>#transientCStringFromString: */
static char *
transientCStringFromString(sqInt aString, struct foo * self)
{
    char *cString;
    sqInt len;
    sqInt newString;
    char *stringPtr;


	/* Allocate space for a null terminated C string. */
	len = sizeOfSTArrayFromCPrimitive(arrayValueOf(aString, self), self);
	pushRemappableOop(aString, self);
	newString = instantiateClassindexableSize(classString(self), len + 1, self);
	stringPtr = arrayValueOf(popRemappableOop(self), self);

	/* Point to the actual C string. */
	cString = arrayValueOf(newString, self);
	(char *)strncpy(cString, stringPtr, len);
	cString[len] = 0;
	return cString;
}


/*	Answer the integer Unix file number corresponding to a file handle (FILE*
	). 
 */

	/* UnixOSProcessPlugin>>#unixFileNumber: */
static int
unixFileNumber(FILEHANDLETYPE fileHandle)
{
	return fileno(fileHandle);
}


/*	Answer a string identifying the version level for this plugin. */

	/* OSProcessPlugin>>#versionString */
static char *
versionString(void)
{
    static char version[]= "4.6.4 Cog";

	return version;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "UnixOSProcessPlugin";
void* UnixOSProcessPlugin_exports[][3] = {
	{(void*)_m, "forkSqueak", (void*)forkSqueak},
	{(void*)_m, "getCurrentWorkingDirectoryAsType", (void*)getCurrentWorkingDirectoryAsType},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveArgumentAt\000\000", (void*)primitiveArgumentAt},
	{(void*)_m, "primitiveArgumentAtAsBytes\000\000", (void*)primitiveArgumentAtAsBytes},
	{(void*)_m, "primitiveCanReceiveSignals\000\000", (void*)primitiveCanReceiveSignals},
	{(void*)_m, "primitiveChdir\000\000", (void*)primitiveChdir},
	{(void*)_m, "primitiveCreatePipe\000\377", (void*)primitiveCreatePipe},
	{(void*)_m, "primitiveCreatePipeWithSessionIdentifier\000\001", (void*)primitiveCreatePipeWithSessionIdentifier},
	{(void*)_m, "primitiveDup", (void*)primitiveDup},
	{(void*)_m, "primitiveDupTo", (void*)primitiveDupTo},
	{(void*)_m, "primitiveEnvironmentAt\000\000", (void*)primitiveEnvironmentAt},
	{(void*)_m, "primitiveEnvironmentAtAsBytes\000\000", (void*)primitiveEnvironmentAtAsBytes},
	{(void*)_m, "primitiveEnvironmentAtSymbol\000\000", (void*)primitiveEnvironmentAtSymbol},
	{(void*)_m, "primitiveEnvironmentAtSymbolAsBytes\000\000", (void*)primitiveEnvironmentAtSymbolAsBytes},
	{(void*)_m, "primitiveErrorMessageAt\000\000", (void*)primitiveErrorMessageAt},
	{(void*)_m, "primitiveFileProtectionMask\000\000", (void*)primitiveFileProtectionMask},
	{(void*)_m, "primitiveFileStat\000\000", (void*)primitiveFileStat},
	{(void*)_m, "primitiveFixPointersInArrayOfStrings\000\001", (void*)primitiveFixPointersInArrayOfStrings},
	{(void*)_m, "primitiveForkAndExecInDirectory\000\001", (void*)primitiveForkAndExecInDirectory},
	{(void*)_m, "primitiveForkExec\000\001", (void*)primitiveForkExec},
	{(void*)_m, "primitiveForkSqueak\000\377", (void*)primitiveForkSqueak},
	{(void*)_m, "primitiveForkSqueakWithoutSigHandler\000\377", (void*)primitiveForkSqueakWithoutSigHandler},
	{(void*)_m, "primitiveForwardSignalToSemaphore\000\002", (void*)primitiveForwardSignalToSemaphore},
	{(void*)_m, "primitiveGetCurrentWorkingDirectory\000\377", (void*)primitiveGetCurrentWorkingDirectory},
	{(void*)_m, "primitiveGetCurrentWorkingDirectoryAsBytes\000\377", (void*)primitiveGetCurrentWorkingDirectoryAsBytes},
	{(void*)_m, "primitiveGetEGid\000\377", (void*)primitiveGetEGid},
	{(void*)_m, "primitiveGetEUid\000\377", (void*)primitiveGetEUid},
	{(void*)_m, "primitiveGetGid\000\377", (void*)primitiveGetGid},
	{(void*)_m, "primitiveGetPGid\000\000", (void*)primitiveGetPGid},
	{(void*)_m, "primitiveGetPGrp\000\377", (void*)primitiveGetPGrp},
	{(void*)_m, "primitiveGetPid\000\377", (void*)primitiveGetPid},
	{(void*)_m, "primitiveGetPPid\000\377", (void*)primitiveGetPPid},
	{(void*)_m, "primitiveGetSession\000\377", (void*)primitiveGetSession},
	{(void*)_m, "primitiveGetStdErrHandle\000\377", (void*)primitiveGetStdErrHandle},
	{(void*)_m, "primitiveGetStdErrHandleWithSessionIdentifier\000\001", (void*)primitiveGetStdErrHandleWithSessionIdentifier},
	{(void*)_m, "primitiveGetStdInHandle\000\377", (void*)primitiveGetStdInHandle},
	{(void*)_m, "primitiveGetStdInHandleWithSessionIdentifier\000\001", (void*)primitiveGetStdInHandleWithSessionIdentifier},
	{(void*)_m, "primitiveGetStdOutHandle\000\377", (void*)primitiveGetStdOutHandle},
	{(void*)_m, "primitiveGetStdOutHandleWithSessionIdentifier\000\001", (void*)primitiveGetStdOutHandleWithSessionIdentifier},
	{(void*)_m, "primitiveGetThreadID\000\377", (void*)primitiveGetThreadID},
	{(void*)_m, "primitiveGetUid\000\377", (void*)primitiveGetUid},
	{(void*)_m, "primitiveIsAtEndOfFile\000\001", (void*)primitiveIsAtEndOfFile},
	{(void*)_m, "primitiveKillOnExit\000\001", (void*)primitiveKillOnExit},
	{(void*)_m, "primitiveLockFileRegion\000\001", (void*)primitiveLockFileRegion},
	{(void*)_m, "primitiveMakePipe\000\377", (void*)primitiveMakePipe},
	{(void*)_m, "primitiveMakePipeWithSessionIdentifier\000\001", (void*)primitiveMakePipeWithSessionIdentifier},
	{(void*)_m, "primitiveModuleName\000\377", (void*)primitiveModuleName},
	{(void*)_m, "primitiveNice\000\000", (void*)primitiveNice},
	{(void*)_m, "primitivePutEnv\000\002", (void*)primitivePutEnv},
	{(void*)_m, "primitiveRealpath\000\000", (void*)primitiveRealpath},
	{(void*)_m, "primitiveRealpathAsBytes\000\000", (void*)primitiveRealpathAsBytes},
	{(void*)_m, "primitiveReapChildProcess\000\000", (void*)primitiveReapChildProcess},
	{(void*)_m, "primitiveSemaIndexFor\000\001", (void*)primitiveSemaIndexFor},
	{(void*)_m, "primitiveSendSigabrtTo\000\000", (void*)primitiveSendSigabrtTo},
	{(void*)_m, "primitiveSendSigalrmTo\000\000", (void*)primitiveSendSigalrmTo},
	{(void*)_m, "primitiveSendSigchldTo\000\000", (void*)primitiveSendSigchldTo},
	{(void*)_m, "primitiveSendSigcontTo\000\000", (void*)primitiveSendSigcontTo},
	{(void*)_m, "primitiveSendSighupTo\000\000", (void*)primitiveSendSighupTo},
	{(void*)_m, "primitiveSendSigintTo\000\000", (void*)primitiveSendSigintTo},
	{(void*)_m, "primitiveSendSigkillTo\000\000", (void*)primitiveSendSigkillTo},
	{(void*)_m, "primitiveSendSigpipeTo\000\000", (void*)primitiveSendSigpipeTo},
	{(void*)_m, "primitiveSendSigquitTo\000\000", (void*)primitiveSendSigquitTo},
	{(void*)_m, "primitiveSendSigstopTo\000\000", (void*)primitiveSendSigstopTo},
	{(void*)_m, "primitiveSendSigtermTo\000\000", (void*)primitiveSendSigtermTo},
	{(void*)_m, "primitiveSendSigusr1To\000\000", (void*)primitiveSendSigusr1To},
	{(void*)_m, "primitiveSendSigusr2To\000\000", (void*)primitiveSendSigusr2To},
	{(void*)_m, "primitiveSetPGid\000\000", (void*)primitiveSetPGid},
	{(void*)_m, "primitiveSetPGrp\000\377", (void*)primitiveSetPGrp},
	{(void*)_m, "primitiveSetSemaIndex\000\000", (void*)primitiveSetSemaIndex},
	{(void*)_m, "primitiveSetSid\000\377", (void*)primitiveSetSid},
	{(void*)_m, "primitiveSigChldNumber\000\377", (void*)primitiveSigChldNumber},
	{(void*)_m, "primitiveSigHupNumber\000\377", (void*)primitiveSigHupNumber},
	{(void*)_m, "primitiveSigIntNumber\000\377", (void*)primitiveSigIntNumber},
	{(void*)_m, "primitiveSigKillNumber\000\377", (void*)primitiveSigKillNumber},
	{(void*)_m, "primitiveSigPipeNumber\000\377", (void*)primitiveSigPipeNumber},
	{(void*)_m, "primitiveSigQuitNumber\000\377", (void*)primitiveSigQuitNumber},
	{(void*)_m, "primitiveSigTermNumber\000\377", (void*)primitiveSigTermNumber},
	{(void*)_m, "primitiveSigUsr1Number\000\377", (void*)primitiveSigUsr1Number},
	{(void*)_m, "primitiveSigUsr2Number\000\377", (void*)primitiveSigUsr2Number},
	{(void*)_m, "primitiveSizeOfInt\000\377", (void*)primitiveSizeOfInt},
	{(void*)_m, "primitiveSizeOfPointer\000\377", (void*)primitiveSizeOfPointer},
	{(void*)_m, "primitiveSQFileFlush\000\001", (void*)primitiveSQFileFlush},
	{(void*)_m, "primitiveSQFileFlushWithSessionIdentifier\000\001", (void*)primitiveSQFileFlushWithSessionIdentifier},
	{(void*)_m, "primitiveSQFileSetBlocking\000\001", (void*)primitiveSQFileSetBlocking},
	{(void*)_m, "primitiveSQFileSetBlockingWithSessionIdentifier\000\001", (void*)primitiveSQFileSetBlockingWithSessionIdentifier},
	{(void*)_m, "primitiveSQFileSetNonBlocking\000\001", (void*)primitiveSQFileSetNonBlocking},
	{(void*)_m, "primitiveSQFileSetNonBlockingWithSessionIdentifier\000\001", (void*)primitiveSQFileSetNonBlockingWithSessionIdentifier},
	{(void*)_m, "primitiveSQFileSetUnbuffered\000\001", (void*)primitiveSQFileSetUnbuffered},
	{(void*)_m, "primitiveSQFileSetUnbufferedWithSessionIdentifier\000\001", (void*)primitiveSQFileSetUnbufferedWithSessionIdentifier},
	{(void*)_m, "primitiveTestEndOfFileFlag\000\001", (void*)primitiveTestEndOfFileFlag},
	{(void*)_m, "primitiveTestLockableFileRegion\000\001", (void*)primitiveTestLockableFileRegion},
	{(void*)_m, "primitiveUnixFileClose", (void*)primitiveUnixFileClose},
	{(void*)_m, "primitiveUnixFileNumber\000\001", (void*)primitiveUnixFileNumber},
	{(void*)_m, "primitiveUnlockFileRegion\000\001", (void*)primitiveUnlockFileRegion},
	{(void*)_m, "primitiveUnsetEnv\000\000", (void*)primitiveUnsetEnv},
	{(void*)_m, "primitiveVersionString\000\377", (void*)primitiveVersionString},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{(void*)_m, "shutdownModule\000\377", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primitiveArgumentAtAccessorDepth = 0;
EXPORT(signed char) primitiveArgumentAtAsBytesAccessorDepth = 0;
EXPORT(signed char) primitiveCanReceiveSignalsAccessorDepth = 0;
EXPORT(signed char) primitiveChdirAccessorDepth = 0;
EXPORT(signed char) primitiveCreatePipeWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveEnvironmentAtAccessorDepth = 0;
EXPORT(signed char) primitiveEnvironmentAtAsBytesAccessorDepth = 0;
EXPORT(signed char) primitiveEnvironmentAtSymbolAccessorDepth = 0;
EXPORT(signed char) primitiveEnvironmentAtSymbolAsBytesAccessorDepth = 0;
EXPORT(signed char) primitiveErrorMessageAtAccessorDepth = 0;
EXPORT(signed char) primitiveFileProtectionMaskAccessorDepth = 0;
EXPORT(signed char) primitiveFileStatAccessorDepth = 0;
EXPORT(signed char) primitiveFixPointersInArrayOfStringsAccessorDepth = 1;
EXPORT(signed char) primitiveForkAndExecInDirectoryAccessorDepth = 1;
EXPORT(signed char) primitiveForkExecAccessorDepth = 1;
EXPORT(signed char) primitiveForwardSignalToSemaphoreAccessorDepth = 2;
EXPORT(signed char) primitiveGetPGidAccessorDepth = 0;
EXPORT(signed char) primitiveGetStdErrHandleWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveGetStdInHandleWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveGetStdOutHandleWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveIsAtEndOfFileAccessorDepth = 1;
EXPORT(signed char) primitiveKillOnExitAccessorDepth = 1;
EXPORT(signed char) primitiveLockFileRegionAccessorDepth = 1;
EXPORT(signed char) primitiveMakePipeWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveNiceAccessorDepth = 0;
EXPORT(signed char) primitivePutEnvAccessorDepth = 2;
EXPORT(signed char) primitiveRealpathAccessorDepth = 0;
EXPORT(signed char) primitiveRealpathAsBytesAccessorDepth = 0;
EXPORT(signed char) primitiveReapChildProcessAccessorDepth = 0;
EXPORT(signed char) primitiveSemaIndexForAccessorDepth = 1;
EXPORT(signed char) primitiveSendSigabrtToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigalrmToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigchldToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigcontToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSighupToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigintToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigkillToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigpipeToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigquitToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigstopToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigtermToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigusr1ToAccessorDepth = 0;
EXPORT(signed char) primitiveSendSigusr2ToAccessorDepth = 0;
EXPORT(signed char) primitiveSetPGidAccessorDepth = 0;
EXPORT(signed char) primitiveSetSemaIndexAccessorDepth = 0;
EXPORT(signed char) primitiveSQFileFlushAccessorDepth = 1;
EXPORT(signed char) primitiveSQFileFlushWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveSQFileSetBlockingAccessorDepth = 1;
EXPORT(signed char) primitiveSQFileSetBlockingWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveSQFileSetNonBlockingAccessorDepth = 1;
EXPORT(signed char) primitiveSQFileSetNonBlockingWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveSQFileSetUnbufferedAccessorDepth = 1;
EXPORT(signed char) primitiveSQFileSetUnbufferedWithSessionIdentifierAccessorDepth = 1;
EXPORT(signed char) primitiveTestEndOfFileFlagAccessorDepth = 1;
EXPORT(signed char) primitiveTestLockableFileRegionAccessorDepth = 1;
EXPORT(signed char) primitiveUnixFileNumberAccessorDepth = 1;
EXPORT(signed char) primitiveUnlockFileRegionAccessorDepth = 1;
EXPORT(signed char) primitiveUnsetEnvAccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
