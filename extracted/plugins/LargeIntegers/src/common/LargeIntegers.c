/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-eem.2495 uuid: fcbf4c90-4c50-4ff3-8690-0edfded4f9c4
   from
	LargeIntegersPlugin VMMaker.oscog-eem.2495 uuid: fcbf4c90-4c50-4ff3-8690-0edfded4f9c4
 */
static char __buildInfo[] = "LargeIntegersPlugin VMMaker.oscog-eem.2495 uuid: fcbf4c90-4c50-4ff3-8690-0edfded4f9c4 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrNoMemory 9


/*** Function Prototypes ***/
static sqInt anyBitOfLargeIntfromto(sqInt anOop, sqInt start, sqInt stopArg, struct foo * self);
static sqInt byteSizeOfCSI(sqInt csi, struct foo * self);
static unsigned int cDigitAddlenwithleninto(unsigned int *pWordShort, sqInt shortLen, unsigned int *pWordLong, sqInt longLen, unsigned int *pWordRes, struct foo * self);
static sqInt cDigitComparewithlen(unsigned int *pFirst, unsigned int *pSecond, sqInt len, struct foo * self);
static sqInt cDigitCopyFromtolen(unsigned int *pFrom, unsigned int *pTo, sqInt len, struct foo * self);
static sqInt cDigitDivlenremlenquolen(unsigned int *pDiv, sqInt divLen, unsigned int *pRem, sqInt remLen, unsigned int *pQuo, sqInt quoLen, struct foo * self);
static sqInt cDigitHighBitlen(unsigned int *pUint32, sqInt len, struct foo * self);
static sqInt cDigitLshiftfromlentolen(sqInt shiftCount, unsigned int *pFrom, sqInt lenFrom, unsigned int *pTo, sqInt lenTo, struct foo * self);
static sqInt cDigitMontgomerylentimeslenmodulolenmInvModBinto(unsigned int *pFirst, sqInt firstLen, unsigned int *pSecond, sqInt secondLen, unsigned int *pThird, sqInt thirdLen, unsigned int mInv, unsigned int *pRes, struct foo * self);
static unsigned int cDigitMultiplylenwithlenintolen(unsigned int *pWordShort, sqInt shortLen, unsigned int *pWordLong, sqInt longLen, unsigned int *pWordRes, sqInt resLen, struct foo * self);
static unsigned int cDigitOfat(unsigned int *cPointer, sqInt zeroBasedDigitIndex, struct foo * self);
static unsigned int cDigitOfatput(unsigned int *cPointer, sqInt zeroBasedDigitIndex, unsigned int aValue, struct foo * self);
static sqInt cDigitOpshortlenlongleninto(sqInt opIndex, unsigned int *pWordShort, sqInt shortLen, unsigned int *pWordLong, sqInt longLen, unsigned int *pWordRes, struct foo * self);
static sqInt cDigitReplacefromtowithstartingAt(unsigned int *pTo, sqInt start, sqInt stop, unsigned int *pFrom, sqInt repStart, struct foo * self);
static sqInt cDigitRshiftfromlentolen(sqInt shiftCount, unsigned int *pFrom, sqInt lenFrom, unsigned int *pTo, sqInt lenTo, struct foo * self);
static sqInt cDigitSublenwithleninto(unsigned int *pWordSmall, sqInt smallLen, unsigned int *pWordLarge, sqInt largeLen, unsigned int *pWordRes, struct foo * self);
static sqInt cHighBit32(unsigned int anUnsignedInt32, struct foo * self);
static sqInt createLargeFromSmallInteger(sqInt anOop, struct foo * self);
static sqInt digitAddLargewith(sqInt firstInteger, sqInt secondInteger, struct foo * self);
static sqInt digitBitLogicwithopIndex(sqInt firstInteger, sqInt secondInteger, sqInt opIx, struct foo * self);
static sqInt digitCompareLargewith(sqInt firstInteger, sqInt secondInteger, struct foo * self);
static sqInt digitDivLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg, struct foo * self);
static sqInt digitMontgomerytimesmodulomInvModB(sqInt firstLarge, sqInt secondLarge, sqInt thirdLarge, unsigned int mInv, struct foo * self);
static sqInt digitMultiplyLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg, struct foo * self);
static sqInt digitOfCSIat(sqInt csi, sqInt ix, struct foo * self);
static sqInt digitOfLargeIntat(sqInt aBytesOop, sqInt ix, struct foo * self);
static sqInt digitSizeOfCSI(sqInt csi, struct foo * self);
static sqInt digitSizeOfLargeInt(sqInt anOop, struct foo * self);
static sqInt digitSubLargewith(sqInt firstInteger, sqInt secondInteger, struct foo * self);
static sqInt digitLshift(sqInt anOop, sqInt shiftCount, struct foo * self);
static sqInt digitRshiftlookfirst(sqInt anOop, sqInt shiftCount, sqInt a, struct foo * self);
EXPORT(const char*) getModuleName(void);
static sqInt highBitOfLargeInt(sqInt anOop, struct foo * self);
static sqInt isNormalized(sqInt aLargeInteger, struct foo * self);
static sqInt largeIntgrowTo(sqInt aBytesObject, sqInt newByteLen, struct foo * self);
static sqInt msg(char *s, struct foo * self);
static sqInt normalizeNegative(sqInt aLargeNegativeInteger, struct foo * self);
static sqInt normalizePositive(sqInt aLargePositiveInteger, struct foo * self);
static sqInt normalize(sqInt aLargeInteger, struct foo * self);
EXPORT(sqInt) primAnyBitFromTo(struct foo * self);
EXPORT(sqInt) primDigitAdd(struct foo * self);
EXPORT(sqInt) primDigitBitAnd(struct foo * self);
EXPORT(sqInt) primDigitBitOr(struct foo * self);
EXPORT(sqInt) primDigitBitShiftMagnitude(struct foo * self);
EXPORT(sqInt) primDigitBitXor(struct foo * self);
EXPORT(sqInt) primDigitCompare(struct foo * self);
EXPORT(sqInt) primDigitDivNegative(struct foo * self);
EXPORT(sqInt) primDigitMultiplyNegative(struct foo * self);
EXPORT(sqInt) primDigitSubtract(struct foo * self);
EXPORT(sqInt) primGetModuleName(struct foo * self);
EXPORT(sqInt) primMontgomeryDigitLength(struct foo * self);
EXPORT(sqInt) primMontgomeryTimesModulo(struct foo * self);
EXPORT(sqInt) primNormalizeNegative(struct foo * self);
EXPORT(sqInt) primNormalizePositive(struct foo * self);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt sqAssert(sqInt aBool, struct foo * self);
static unsigned char unsafeByteOfLargeIntat(sqInt bytesObj, sqInt ix, struct foo * self);


/*** Variables ***/
static const int  andOpIndex = 0;

#if defined(SQUEAK_BUILTIN_PLUGIN)

# define isIntegerObject(oop, self) ((oop) & 1)

# if SPURVM
extern sqInt classIndexOf(sqInt, struct foo *);
#	define LargeNegativeIntegerClassIndex 32
#	define LargePositiveIntegerClassIndex 33
#	if BytesPerOop == 4
#	  define isImmediate(oop, self) ((oop) & 3)
#	else
#	  define isImmediate(oop, self) ((oop) & 7)
#	endif
#	define isKindOfInteger(oop, self) (isImmediate(oop, self) ? isIntegerObject(oop, self) : (unsigned)(classIndexOf(oop, self) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeIntegerObject(oop, self) (!isImmediate(oop, self) && (unsigned)(classIndexOf(oop, self) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeNegativeIntegerObject(oop, self) (!isImmediate(oop, self) && classIndexOf(oop, self) == LargeNegativeIntegerClassIndex)
#	define isLargePositiveIntegerObject(oop, self) (!isImmediate(oop, self) && classIndexOf(oop, self) == LargePositiveIntegerClassIndex)
# endif /* SPURVM */
#endif /* defined(SQUEAK_BUILTIN_PLUGIN) */

#if !defined(isKindOfInteger)
# define isLargeNegativeIntegerObject(oop, self) (fetchClassOf(oop, self) == classLargeNegativeInteger(self))
# define isLargePositiveIntegerObject(oop, self) (fetchClassOf(oop, self) == classLargePositiveInteger(self))
# define isLargeIntegerObject(oop, self) (isLargeNegativeIntegerObject(oop, self) || isLargePositiveIntegerObject(oop, self))
# define isKindOfInteger(oop , self) (isIntegerObject(oop, self) || isLargeNegativeIntegerObject(oop, self) || isLargePositiveIntegerObject(oop, self))
#endif

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj, struct foo * self);
static sqInt (*classArray)(struct foo * self);
static sqInt (*classLargeNegativeInteger)(struct foo * self);
static sqInt (*classLargePositiveInteger)(struct foo * self);
static sqInt (*classString)(struct foo * self);
static sqInt (*failed)(struct foo * self);
static sqInt (*falseObject)(struct foo * self);
static sqInt (*fetchClassOf)(sqInt oop, struct foo * self);
static void * (*firstIndexableField)(sqInt oop, struct foo * self);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size, struct foo * self);
static sqInt (*integerObjectOf)(sqInt value, struct foo * self);
static sqInt (*integerValueOf)(sqInt oop, struct foo * self);
static sqInt (*isBooleanObject)(sqInt oop, struct foo * self);
static sqInt (*isIntegerObject)(sqInt objectPointer, struct foo * self);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop, struct foo * self);
static sqInt (*popRemappableOop)(struct foo * self);
static usqInt (*positive32BitValueOf)(sqInt oop, struct foo * self);
static sqInt (*primitiveFail)(struct foo * self);
static sqInt (*primitiveFailFor)(sqInt reasonCode, struct foo * self);
static sqInt (*pushRemappableOop)(sqInt oop, struct foo * self);
static sqInt (*slotSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stObjectatput)(sqInt array, sqInt index, sqInt value, struct foo * self);
static sqInt (*stackIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackValue)(sqInt offset, struct foo * self);
static sqInt (*success)(sqInt aBoolean, struct foo * self);
static sqInt (*trueObject)(struct foo * self);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj, struct foo * self);
extern sqInt classArray(struct foo * self);
extern sqInt classLargeNegativeInteger(struct foo * self);
extern sqInt classLargePositiveInteger(struct foo * self);
extern sqInt classString(struct foo * self);
extern sqInt failed(struct foo * self);
extern sqInt falseObject(struct foo * self);
extern sqInt fetchClassOf(sqInt oop, struct foo * self);
extern void * firstIndexableField(sqInt oop, struct foo * self);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern sqInt integerValueOf(sqInt oop, struct foo * self);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
extern sqInt isBooleanObject(sqInt oop, struct foo * self);
#else
# define isBooleanObject(oop) 0
#endif
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer, struct foo * self);
#endif
extern sqInt popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt popRemappableOop(struct foo * self);
extern usqInt positive32BitValueOf(sqInt oop, struct foo * self);
extern sqInt primitiveFail(struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
extern sqInt pushRemappableOop(sqInt oop, struct foo * self);
extern sqInt slotSizeOf(sqInt oop, struct foo * self);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt success(sqInt aBoolean, struct foo * self);
extern sqInt trueObject(struct foo * self);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"LargeIntegers v2.0 VMMaker.oscog-eem.2495 (i)"
#else
	"LargeIntegers v2.0 VMMaker.oscog-eem.2495 (e)"
#endif
;
static const int  orOpIndex = 1;
static const int  xorOpIndex = 2;



/*	Argument has to be a Large Integer! */
/*	Tests for any magnitude bits in the interval from start to stopArg. */

	/* LargeIntegersPlugin>>#anyBitOfLargeInt:from:to: */
static sqInt
anyBitOfLargeIntfromto(sqInt anOop, sqInt start, sqInt stopArg, struct foo * self)
{
	unsigned int *cPointer;
	unsigned int digit;
	usqInt firstDigitIx;
	unsigned int firstMask;
	usqInt ix;
	usqInt lastDigitIx;
	unsigned int lastMask;
	sqInt magnitude;
	sqInt stop;
	sqInt zeroBasedDigitIndex;

	/* missing DebugCode */;
	if ((start < 1) || (stopArg < 1)) {
		return primitiveFail(self);
	}
	magnitude = anOop;
	stop = ((stopArg < (cDigitHighBitlen(((unsigned int *) (firstIndexableField(magnitude, self))), ((slotSizeOf(magnitude, self)) + 3) / 4, self))) ? stopArg : (cDigitHighBitlen(((unsigned int *) (firstIndexableField(magnitude, self))), ((slotSizeOf(magnitude, self)) + 3) / 4, self)));
	if (start > stop) {
		return 0;
	}
	firstDigitIx = ((start - 1) / 32) + 1;
	lastDigitIx = ((stop - 1) / 32) + 1;

	/* Note asUnsignedLong required to avoid ULLL suffix bug */
	firstMask = (((unsigned long)0xFFFFFFFFU)) << ((start - 1) & 0x1F);
	lastMask = ((usqInt) 0xFFFFFFFFU) >> (0x1F - ((stop - 1) & 0x1F));
	if (firstDigitIx == lastDigitIx) {
		/* begin cDigitOf:at: */
		cPointer = ((unsigned int *) (firstIndexableField(magnitude, self)));
		zeroBasedDigitIndex = firstDigitIx - 1;
		digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((cPointer[zeroBasedDigitIndex]));
		return (digit & (firstMask & lastMask)) != 0;
	}
	if (((cDigitOfat(((unsigned int *) (firstIndexableField(magnitude, self))), firstDigitIx - 1, self)) & firstMask) != 0) {
		return 1;
	}
	for (ix = (firstDigitIx + 1); ix < lastDigitIx; ix += 1) {
		if ((cDigitOfat(((unsigned int *) (firstIndexableField(magnitude, self))), ix - 1, self)) != 0) {
			return 1;
		}
	}
	if (((cDigitOfat(((unsigned int *) (firstIndexableField(magnitude, self))), lastDigitIx - 1, self)) & lastMask) != 0) {
		return 1;
	}
	return 0;
}


/*	Answer the number of bytes required to represent the value of a
	C-SmallInteger. 
 */

	/* LargeIntegersPlugin>>#byteSizeOfCSI: */
static sqInt
byteSizeOfCSI(sqInt csi, struct foo * self)
{
	if (csi >= 0) {
		if (csi < 256) {
			return 1;
		}
		if (csi < 65536) {
			return 2;
		}
		if (csi < 0x1000000) {
			return 3;
		}
		
#    if BytesPerOop == 4
		return 4;
#    else /* BytesPerOop == 4 */
		if (csi < 0x100000000LL) {
			return 4;
		}
		if (csi < 0x10000000000LL) {
			return 5;
		}
		if (csi < 0x1000000000000LL) {
			return 6;
		}
		if (csi < 0x100000000000000LL) {
			return 7;
		}
		return 8;
#    endif /* BytesPerOop == 4 */
	}
	if (csi > -256) {
		return 1;
	}
	if (csi > -65536) {
		return 2;
	}
	if (csi > -16777216) {
		return 3;
	}
	
#  if BytesPerOop == 4
	return 4;
#  else /* BytesPerOop == 4 */
	if (csi > -4294967296LL) {
		return 4;
	}
	if (csi > -1099511627776LL) {
		return 5;
	}
	if (csi > -281474976710656LL) {
		return 6;
	}
	if (csi > -72057594037927936LL) {
		return 7;
	}
	return 8;
#  endif /* BytesPerOop == 4 */
	return 0;
}


/*	pWordRes len = longLen; returns over.. */

	/* LargeIntegersPlugin>>#cDigitAdd:len:with:len:into: */
static unsigned int
cDigitAddlenwithleninto(unsigned int *pWordShort, sqInt shortLen, unsigned int *pWordLong, sqInt longLen, unsigned int *pWordRes, struct foo * self)
{
	unsigned long long accum;
	sqInt i;

	accum = 0;
	for (i = 0; i < shortLen; i += 1) {
		accum = ((accum >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordShort[i])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[i])));
		pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
	}
	for (i = shortLen; i < longLen; i += 1) {
		accum = (accum >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[i])));
		pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
	}
	return accum >> 32;
}


/*	Precondition: pFirst len = pSecond len. */

	/* LargeIntegersPlugin>>#cDigitCompare:with:len: */
static sqInt
cDigitComparewithlen(unsigned int *pFirst, unsigned int *pSecond, sqInt len, struct foo * self)
{
	unsigned int firstDigit;
	sqInt ix;
	unsigned int secondDigit;

	ix = len - 1;
	while (ix >= 0) {
		if (((secondDigit = pSecond[ix])) != ((firstDigit = pFirst[ix]))) {
			if ((SQ_SWAP_4_BYTES_IF_BIGENDIAN(secondDigit)) < (SQ_SWAP_4_BYTES_IF_BIGENDIAN(firstDigit))) {
				return 1;
			}
			else {
				return -1;
			}
		}
		ix -= 1;
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitCopyFrom:to:len: */
static sqInt
cDigitCopyFromtolen(unsigned int *pFrom, unsigned int *pTo, sqInt len, struct foo * self)
{
	sqInt i;

	for (i = 0; i < len; i += 1) {
		pTo[i] = (pFrom[i]);
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitDiv:len:rem:len:quo:len: */
static sqInt
cDigitDivlenremlenquolen(unsigned int *pDiv, sqInt divLen, unsigned int *pRem, sqInt remLen, unsigned int *pQuo, sqInt quoLen, struct foo * self)
{
	unsigned long long a;
	unsigned long long b;
	sqInt cond;
	unsigned int dh;
	sqInt dl;
	unsigned int dnh;
	unsigned long long hi;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt l;
	unsigned long long lo;
	unsigned long long mul;
	unsigned long long q;
	sqInt ql;
	unsigned long long r1r2;
	unsigned int r3;
	unsigned long long t;


	/* Last actual byte of data (ST ix) */
	dl = divLen - 1;
	ql = quoLen;
	dh = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[dl - 1]));
	if (dl == 1) {
		dnh = 0;
	}
	else {
		dnh = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[dl - 2]));
	}
	for (k = 1; k <= ql; k += 1) {

		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two unint32 of rem by dh. */
		/* The estimate is q = qhi*16r100000000+qlo, where qhi and qlo are uint32. */

		/* r1 := rem digitAt: j. */
		j = (remLen + 1) - k;
		if ((SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 1]))) == dh) {
			q = 0xFFFFFFFFU;
		}
		else {

			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.
			   Note that r1,r2 are uint64, not uint32. */
			/* r2 := (rem digitAt: j - 2). */
			r1r2 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 1]));
			r1r2 = (r1r2 << 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 2])));
			t = r1r2 % dh;

			/* Next compute (hi,lo) := q*dnh */
			q = r1r2 / dh;
			mul = q * dnh;
			hi = mul >> 32;

			/* Correct overestimate of q.
			   Max of 2 iterations through loop -- see Knuth vol. 2 */
			lo = mul & 0xFFFFFFFFU;
			if (j < 3) {
				r3 = 0;
			}
			else {
				r3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 3]));
			}
			while (1) {
				if ((t < hi)
				 || ((t == hi)
				 && (r3 < lo))) {

					/* i.e. (t,r3) < (hi,lo) */
					q -= 1;
					if (hi == 0) {

						/* since hi is unsigned we must have this guard */
						cond = 0;
					}
					else {
						if (lo < dnh) {
							hi -= 1;
							lo = (lo + 0x100000000LL) - dnh;
						}
						else {
							lo -= dnh;
						}
						cond = hi >= dh;
					}
				}
				else {
					cond = 0;
				}
				if (!(cond)) break;
				hi -= dh;
			}
		}
		l = j - dl;
		a = 0;
		for (i = 1; i <= divLen; i += 1) {
			hi = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1]))) * (q >> 32);
			lo = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1]))) * (q & 0xFFFFFFFFU);
			b = ((SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[l - 1]))) - a) - (lo & 0xFFFFFFFFU);
			pRem[l - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((b & 0xFFFFFFFFU)));
			b = (b >> 32) | ((0 - (b >> 0x3F)) & 0xFFFFFFFF00000000ULL);
			a = (hi + (lo >> 32)) - b;
			l += 1;
		}
		if (a > 0) {

			/* Add div back into rem, decrease q by 1 */
			q -= 1;
			l = j - dl;
			a = 0;
			for (i = 1; i <= divLen; i += 1) {
				a = ((a >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[l - 1])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1])));
				pRem[l - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((a & 0xFFFFFFFFU)));
				l += 1;
			}
		}
		pQuo[quoLen - k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) q))));
	}
	return 0;
}


/*	Answer the index (in bits) of the high order bit of the receiver, or zero
	if the 
	receiver is zero. This method is allowed (and needed) for 
	LargeNegativeIntegers as well, since Squeak's LargeIntegers are
	sign/magnitude. Work with 32 bits digits. */

	/* LargeIntegersPlugin>>#cDigitHighBit:len: */
static sqInt
cDigitHighBitlen(unsigned int *pUint32, sqInt len, struct foo * self)
{
	unsigned int lastDigit;
	sqInt realLength;

	realLength = len;
	do {
		if (realLength == 0) {
			return 0;
		}
	} while(((lastDigit = cDigitOfat(pUint32, (realLength -= 1), self))) == 0);
	return (cHighBit32(lastDigit, self)) + (32 * realLength);
}


/*	C indexed! */

	/* LargeIntegersPlugin>>#cDigitLshift:from:len:to:len: */
static sqInt
cDigitLshiftfromlentolen(sqInt shiftCount, unsigned int *pFrom, sqInt lenFrom, unsigned int *pTo, sqInt lenTo, struct foo * self)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt i;
	sqInt i1;
	sqInt limit;
	sqInt rshift;

	digitShift = shiftCount / 32;
	bitShift = shiftCount % 32;

	/* Note: 0 is endian neutral, use direct access */
	limit = digitShift - 1;
	for (i = 0; i <= limit; i += 1) {
		pTo[i] = 0;
	}
	if (bitShift == 0) {

		/* Fast version for digit-aligned shifts */
		/* C indexed! */
		/* begin cDigitCopyFrom:to:len: */
		for (i1 = 0; i1 < (((lenTo - 1) - digitShift) + 1); i1 += 1) {
			(pTo + digitShift)[i1] = ((pFrom)[i1]);
		}
		return 0;
	}
	rshift = 32 - bitShift;
	carry = 0;
	limit = lenFrom - 1;
	for (i = 0; i <= limit; i += 1) {
		digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFrom[i]));
		pTo[i + digitShift] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(((carry | (((usqInt)(digit) << bitShift))) & 0xFFFFFFFFU)));
		carry = ((usqInt) digit) >> rshift;
	}
	if (!(carry == 0)) {
		pTo[lenTo - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(carry));
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
static sqInt
cDigitMontgomerylentimeslenmodulolenmInvModBinto(unsigned int *pFirst, sqInt firstLen, unsigned int *pSecond, sqInt secondLen, unsigned int *pThird, sqInt thirdLen, unsigned int mInv, unsigned int *pRes, struct foo * self)
{
	unsigned long long accum;
	unsigned long long accum2;
	unsigned long long accum3;
	sqInt i;
	sqInt k;
	unsigned int lastDigit;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned long long u;

	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastDigit = 0;
	for (i = 0; i <= limit1; i += 1) {
		accum3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFirst[i]));
		accum3 = (accum3 * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pSecond[0])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[0])));
		u = (accum3 * mInv) & 0xFFFFFFFFU;
		accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[0])));
		accum = (accum2 & 0xFFFFFFFFU) + (accum3 & 0xFFFFFFFFU);
		accum = ((accum >> 32) + (accum2 >> 32)) + (accum3 >> 32);
		for (k = 1; k <= limit2; k += 1) {
			accum3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFirst[i]));
			accum3 = (accum3 * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pSecond[k])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])));
			accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
			accum = (accum + (accum2 & 0xFFFFFFFFU)) + (accum3 & 0xFFFFFFFFU);
			pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = ((accum >> 32) + (accum2 >> 32)) + (accum3 >> 32);
		}
		for (k = secondLen; k <= limit3; k += 1) {
			accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
			accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])))) + (accum2 & 0xFFFFFFFFU);
			pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = (accum >> 32) + (accum2 >> 32);
		}
		accum += lastDigit;
		pRes[limit3] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
		lastDigit = accum >> 32;
	}
	for (i = firstLen; i <= limit3; i += 1) {
		accum = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[0]));
		u = (accum * mInv) & 0xFFFFFFFFU;
		accum += u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[0])));
		accum = accum >> 32;
		for (k = 1; k <= limit3; k += 1) {
			accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
			accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])))) + (accum2 & 0xFFFFFFFFU);
			pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = (accum >> 32) + (accum2 >> 32);
		}
		accum += lastDigit;
		pRes[limit3] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
		lastDigit = accum >> 32;
	}
	if (!((lastDigit == 0)
		 && ((cDigitComparewithlen(pThird, pRes, thirdLen, self)) == 1))) {

		/* self cDigitSub: pThird len: thirdLen with: pRes len: thirdLen into: pRes */
		accum = 0;
		for (i = 0; i <= limit3; i += 1) {
			accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[i])))) - (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[i])));
			pRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = 0 - (accum >> 0x3F);
		}
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitMultiply:len:with:len:into:len: */
static unsigned int
cDigitMultiplylenwithlenintolen(unsigned int *pWordShort, sqInt shortLen, unsigned int *pWordLong, sqInt longLen, unsigned int *pWordRes, sqInt resLen, struct foo * self)
{
	unsigned long long ab;
	unsigned int carry;
	unsigned int digit;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt limitLong;
	sqInt limitShort;

	if ((shortLen == 1)
	 && ((pWordShort[0]) == 0)) {
		return 0;
	}
	if ((longLen == 1)
	 && ((pWordLong[0]) == 0)) {
		return 0;
	}
	limitShort = shortLen - 1;
	limitLong = longLen - 1;
	for (i = 0; i <= limitShort; i += 1) {
		if (((digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordShort[i])))) != 0) {
			k = i;

			/* Loop invariant: 0<=carry<=16rFFFFFFFF, k=i+j-1 (ST) */
			/* -> Loop invariant: 0<=carry<=16rFFFFFFFF, k=i+j (C) (?) */
			carry = 0;
			for (j = 0; j <= limitLong; j += 1) {
				ab = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[j]));
				ab = ((ab * digit) + carry) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordRes[k])));
				carry = ab >> 32;
				pWordRes[k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((ab & 0xFFFFFFFFU)));
				k += 1;
			}
			if (k < resLen) {
				pWordRes[k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(carry));
			}
		}
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitOf:at: */
static unsigned int
cDigitOfat(unsigned int *cPointer, sqInt zeroBasedDigitIndex, struct foo * self)
{
	return SQ_SWAP_4_BYTES_IF_BIGENDIAN((cPointer[zeroBasedDigitIndex]));
}

	/* LargeIntegersPlugin>>#cDigitOf:at:put: */
static unsigned int
cDigitOfatput(unsigned int *cPointer, sqInt zeroBasedDigitIndex, unsigned int aValue, struct foo * self)
{
	return cPointer[zeroBasedDigitIndex] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(aValue));
}


/*	pWordRes len = longLen.
	NOTE: we don't bother with endianness here, those bit opes are
	endian-neutral 
 */

	/* LargeIntegersPlugin>>#cDigitOp:short:len:long:len:into: */
static sqInt
cDigitOpshortlenlongleninto(sqInt opIndex, unsigned int *pWordShort, sqInt shortLen, unsigned int *pWordLong, sqInt longLen, unsigned int *pWordRes, struct foo * self)
{
	sqInt i;
	sqInt limit;

	limit = shortLen - 1;
	if (opIndex == andOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pWordRes[i] = ((pWordShort[i]) & (pWordLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pWordRes[i] = 0;
		}
		return 0;
	}
	if (opIndex == orOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pWordRes[i] = ((pWordShort[i]) | (pWordLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pWordRes[i] = (pWordLong[i]);
		}
		return 0;
	}
	if (opIndex == xorOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pWordRes[i] = ((pWordShort[i]) ^ (pWordLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
			pWordRes[i] = (pWordLong[i]);
		}
		return 0;
	}
	return primitiveFail(self);
}


/*	C indexed! */

	/* LargeIntegersPlugin>>#cDigitReplace:from:to:with:startingAt: */
static sqInt
cDigitReplacefromtowithstartingAt(unsigned int *pTo, sqInt start, sqInt stop, unsigned int *pFrom, sqInt repStart, struct foo * self)
{
	sqInt i;

	/* begin cDigitCopyFrom:to:len: */
	for (i = 0; i < ((stop - start) + 1); i += 1) {
		(pTo + start)[i] = ((pFrom + repStart)[i]);
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitRshift:from:len:to:len: */
static sqInt
cDigitRshiftfromlentolen(sqInt shiftCount, unsigned int *pFrom, sqInt lenFrom, unsigned int *pTo, sqInt lenTo, struct foo * self)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt i;
	sqInt j;
	sqInt leftShift;
	sqInt limit;
	sqInt start;

	digitShift = shiftCount / 32;
	bitShift = shiftCount % 32;
	if (bitShift == 0) {

		/* Fast version for digit-aligned shifts */
		/* C indexed! */
		/* begin cDigitReplace:from:to:with:startingAt: */
		for (i = 0; i < (((lenTo - 1)) + 1); i += 1) {
			(pTo)[i] = ((pFrom + digitShift)[i]);
		}
		return 0;
	}
	leftShift = 32 - bitShift;
	carry = ((usqInt) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFrom[digitShift])))) >> bitShift;
	start = digitShift + 1;
	limit = lenFrom - 1;
	for (j = start; j <= limit; j += 1) {
		/* begin cDigitOf:at: */
		digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFrom[j]));
		/* begin cDigitOf:at:put: */
		pTo[j - start] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(((carry | (((usqInt)(digit) << leftShift))) & 0xFFFFFFFFU)));
		carry = ((usqInt) digit) >> bitShift;
	}
	if (!(carry == 0)) {
		/* begin cDigitOf:at:put: */
		pTo[lenTo - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(carry));
	}
	return 0;
}

	/* LargeIntegersPlugin>>#cDigitSub:len:with:len:into: */
static sqInt
cDigitSublenwithleninto(unsigned int *pWordSmall, sqInt smallLen, unsigned int *pWordLarge, sqInt largeLen, unsigned int *pWordRes, struct foo * self)
{
	sqInt i;
	unsigned long long z;

	z = 0;
	for (i = 0; i < smallLen; i += 1) {
		z = (z + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLarge[i])))) - (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordSmall[i])));
		/* begin cDigitOf:at:put: */
		pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) (z & 0xFFFFFFFFU)))));
		z = 0 - (z >> 0x3F);
	}
	for (i = smallLen; i < largeLen; i += 1) {
		z += SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLarge[i]));
		/* begin cDigitOf:at:put: */
		pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) (z & 0xFFFFFFFFU)))));
		z = 0 - (z >> 0x3F);
	}
	return 0;
}


/*	Answer the index of the high order bit of the argument, or zero if the 
	argument is zero. */

	/* LargeIntegersPlugin>>#cHighBit32: */
static sqInt
cHighBit32(unsigned int anUnsignedInt32, struct foo * self)
{
	sqInt bitNo;
	unsigned int shifted;

	shifted = anUnsignedInt32;
	bitNo = 0;
	if (!(shifted < (1U << 16))) {
		shifted = ((usqInt) shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (1U << 8))) {
		shifted = ((usqInt) shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (1U << 4))) {
		shifted = ((usqInt) shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (1U << 2))) {
		shifted = ((usqInt) shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (1U << 1))) {
		shifted = ((usqInt) shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	anOop has to be a SmallInteger! */

	/* LargeIntegersPlugin>>#createLargeFromSmallInteger: */
static sqInt
createLargeFromSmallInteger(sqInt anOop, struct foo * self)
{
	unsigned int aValue;
	sqInt byteSize;
	sqInt digitSize;
	sqInt ix;
	unsigned int *pDigit;
	sqInt res;
	sqInt val;

	val = integerValueOf(anOop, self);
	/* begin byteSizeOfCSI: */
	if (val >= 0) {
		if (val < 256) {
			byteSize = 1;
			goto l2;
		}
		if (val < 65536) {
			byteSize = 2;
			goto l2;
		}
		if (val < 0x1000000) {
			byteSize = 3;
			goto l2;
		}
		
#    if BytesPerOop == 4
		byteSize = 4;
		goto l2;
#    else /* BytesPerOop == 4 */
		if (val < 0x100000000LL) {
			byteSize = 4;
			goto l2;
		}
		if (val < 0x10000000000LL) {
			byteSize = 5;
			goto l2;
		}
		if (val < 0x1000000000000LL) {
			byteSize = 6;
			goto l2;
		}
		if (val < 0x100000000000000LL) {
			byteSize = 7;
			goto l2;
		}
		byteSize = 8;
		goto l2;
#    endif /* BytesPerOop == 4 */
	}
	if (val > -256) {
		byteSize = 1;
		goto l2;
	}
	if (val > -65536) {
		byteSize = 2;
		goto l2;
	}
	if (val > -16777216) {
		byteSize = 3;
		goto l2;
	}
	
#  if BytesPerOop == 4
	byteSize = 4;
	goto l2;
#  else /* BytesPerOop == 4 */
	if (val > -4294967296LL) {
		byteSize = 4;
		goto l2;
	}
	if (val > -1099511627776LL) {
		byteSize = 5;
		goto l2;
	}
	if (val > -281474976710656LL) {
		byteSize = 6;
		goto l2;
	}
	if (val > -72057594037927936LL) {
		byteSize = 7;
		goto l2;
	}
	byteSize = 8;
	goto l2;
#  endif /* BytesPerOop == 4 */
	l2:	/* end byteSizeOfCSI: */;
	res = instantiateClassindexableSize((val < 0
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), byteSize, self);
	pDigit = ((unsigned int *) (firstIndexableField(res, self)));
	digitSize = (byteSize + 3) / 4;
	for (ix = 1; ix <= digitSize; ix += 1) {
		/* begin cDigitOf:at:put: */
		aValue = ((unsigned int) (((usqInt) ((val < 0
	? 0 - val
	: val))) >> ((ix - 1) * 32)));
		pDigit[ix - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(aValue));
	}
	return res;
}


/*	Does not need to normalize! */

	/* LargeIntegersPlugin>>#digitAddLarge:with: */
static sqInt
digitAddLargewith(sqInt firstInteger, sqInt secondInteger, struct foo * self)
{
	unsigned long long accum;
	unsigned int *cPointer;
	sqInt firstDigitLen;
	sqInt i;
	sqInt i1;
	sqInt longDigitLen;
	sqInt longInt;
	sqInt neg;
	sqInt newSum;
	unsigned int over;
	unsigned int *pFrom;
	unsigned int *pTo;
	unsigned int *pWordLong;
	unsigned int *pWordRes;
	unsigned int *pWordShort;
	sqInt secondDigitLen;
	sqInt shortDigitLen;
	sqInt shortInt;
	sqInt sum;

	firstDigitLen = ((slotSizeOf(firstInteger, self)) + 3) / 4;
	secondDigitLen = ((slotSizeOf(secondInteger, self)) + 3) / 4;
	neg = isLargeNegativeIntegerObject(firstInteger, self);
	if (firstDigitLen <= secondDigitLen) {
		shortInt = firstInteger;
		shortDigitLen = firstDigitLen;
		longInt = secondInteger;
		longDigitLen = secondDigitLen;
	}
	else {
		shortInt = secondInteger;
		shortDigitLen = secondDigitLen;
		longInt = firstInteger;
		longDigitLen = firstDigitLen;
	}
	
#if SPURVM
	/* begin createLargeIntegerNeg:digitLength: */
	sum = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), longDigitLen * 4, self);

#else /* SPURVM */
	pushRemappableOop(shortInt, self);
	pushRemappableOop(longInt, self);
	/* begin createLargeIntegerNeg:digitLength: */
	sum = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), longDigitLen * 4, self);
	longInt = popRemappableOop(self);
	shortInt = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(sum)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	/* begin cDigitAdd:len:with:len:into: */
	pWordShort = ((unsigned int *) (firstIndexableField(shortInt, self)));
	pWordLong = ((unsigned int *) (firstIndexableField(longInt, self)));
	pWordRes = ((unsigned int *) (firstIndexableField(sum, self)));
	accum = 0;
	for (i1 = 0; i1 < shortDigitLen; i1 += 1) {
		accum = ((accum >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordShort[i1])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[i1])));
		pWordRes[i1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
	}
	for (i1 = shortDigitLen; i1 < longDigitLen; i1 += 1) {
		accum = (accum >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[i1])));
		pWordRes[i1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
	}
	over = accum >> 32;
	if (over > 0) {

		/* sum := sum growby: 1. */
		
#if SPURVM
		/* begin createLargeIntegerNeg:byteLength: */
		newSum = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), (longDigitLen * 4) + 1, self);

#else /* SPURVM */
		pushRemappableOop(sum, self);
		/* begin createLargeIntegerNeg:byteLength: */
		newSum = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), (longDigitLen * 4) + 1, self);
		sum = popRemappableOop(self)
#endif /* SPURVM */
;
		if (!(newSum)) {
			return primitiveFailFor(PrimErrNoMemory, self);
		}
		/* begin cDigitCopyFrom:to:len: */
		pFrom = ((unsigned int *) (firstIndexableField(sum, self)));
		pTo = ((unsigned int *) (firstIndexableField(newSum, self)));
		for (i = 0; i < longDigitLen; i += 1) {
			pTo[i] = (pFrom[i]);
		}

		/* C index! */
		sum = newSum;
		/* begin cDigitOf:at:put: */
		cPointer = ((unsigned int *) (firstIndexableField(sum, self)));
		cPointer[longDigitLen] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(over));
	}
	else {
		sum = (neg
			? normalizeNegative(sum, self)
			: normalizePositive(sum, self));
	}
	return sum;
}


/*	Bit logic here is only implemented for positive integers or Zero;
	if rec or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#digitBitLogic:with:opIndex: */
static sqInt
digitBitLogicwithopIndex(sqInt firstInteger, sqInt secondInteger, sqInt opIx, struct foo * self)
{
	sqInt firstLarge;
	sqInt firstLen;
	sqInt i;
	sqInt limit;
	sqInt longLarge;
	sqInt longLen;
	unsigned int *pWordLong;
	unsigned int *pWordRes;
	unsigned int *pWordShort;
	sqInt result;
	sqInt secondLarge;
	sqInt secondLen;
	sqInt shortLarge;
	sqInt shortLen;

	if (isIntegerObject(firstInteger, self)) {
		if ((integerValueOf(firstInteger, self)) < 0) {
			return primitiveFail(self);
		}
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger, self);

#else /* SPURVM */
		pushRemappableOop(secondInteger, self);
		firstLarge = createLargeFromSmallInteger(firstInteger, self);
		secondInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		if (!(isLargePositiveIntegerObject(firstInteger, self))) {
			return primitiveFail(self);
		}
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger, self)) {
		if ((integerValueOf(secondInteger, self)) < 0) {
			return primitiveFail(self);
		}
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger, self);

#else /* SPURVM */
		pushRemappableOop(firstLarge, self);
		secondLarge = createLargeFromSmallInteger(secondInteger, self);
		firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		if (!(isLargePositiveIntegerObject(secondInteger, self))) {
			return primitiveFail(self);
		}
		secondLarge = secondInteger;
	}
	/* begin byteSizeOfLargeInt: */
	firstLen = slotSizeOf(firstLarge, self);
	/* begin byteSizeOfLargeInt: */
	secondLen = slotSizeOf(secondLarge, self);
	if (firstLen < secondLen) {
		shortLen = firstLen;
		shortLarge = firstLarge;
		longLen = secondLen;
		longLarge = secondLarge;
	}
	else {
		shortLen = secondLen;
		shortLarge = secondLarge;
		longLen = firstLen;
		longLarge = firstLarge;
	}
	
#if SPURVM
	result = instantiateClassindexableSize(classLargePositiveInteger(self), longLen, self);

#else /* SPURVM */
	pushRemappableOop(shortLarge, self);
	pushRemappableOop(longLarge, self);
	result = instantiateClassindexableSize(classLargePositiveInteger(self), longLen, self);
	longLarge = popRemappableOop(self);
	shortLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(result)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	/* begin cDigitOp:short:len:long:len:into: */
	pWordShort = ((unsigned int *) (firstIndexableField(shortLarge, self)));
	pWordLong = ((unsigned int *) (firstIndexableField(longLarge, self)));
	pWordRes = ((unsigned int *) (firstIndexableField(result, self)));
	limit = ((shortLen + 3) / 4) - 1;
	if (opIx == andOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pWordRes[i] = ((pWordShort[i]) & (pWordLong[i]));
		}
		limit = ((longLen + 3) / 4) - 1;
		for (i = ((shortLen + 3) / 4); i <= limit; i += 1) {
			pWordRes[i] = 0;
		}
		goto l3;
	}
	if (opIx == orOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pWordRes[i] = ((pWordShort[i]) | (pWordLong[i]));
		}
		limit = ((longLen + 3) / 4) - 1;
		for (i = ((shortLen + 3) / 4); i <= limit; i += 1) {
			pWordRes[i] = (pWordLong[i]);
		}
		goto l3;
	}
	if (opIx == xorOpIndex) {
		for (i = 0; i <= limit; i += 1) {
			pWordRes[i] = ((pWordShort[i]) ^ (pWordLong[i]));
		}
		limit = ((longLen + 3) / 4) - 1;
		for (i = ((shortLen + 3) / 4); i <= limit; i += 1) {
			pWordRes[i] = (pWordLong[i]);
		}
		goto l3;
	}
	primitiveFail(self);
	l3:	/* end cDigitOp:short:len:long:len:into: */;
	if (failed(self)) {
		return 0;
	}
	return normalizePositive(result, self);
}


/*	Compare the magnitude of firstInteger with that of secondInteger. 
	Return a code of 1, 0, -1 for firstInteger >, = , < secondInteger */

	/* LargeIntegersPlugin>>#digitCompareLarge:with: */
static sqInt
digitCompareLargewith(sqInt firstInteger, sqInt secondInteger, struct foo * self)
{
	sqInt firstDigitLen;
	sqInt secondDigitLen;

	firstDigitLen = ((slotSizeOf(firstInteger, self)) + 3) / 4;
	secondDigitLen = ((slotSizeOf(secondInteger, self)) + 3) / 4;
	if (secondDigitLen != firstDigitLen) {
		if (secondDigitLen > firstDigitLen) {
			return integerObjectOf(-1, self);
		}
		else {
			return integerObjectOf(1, self);
		}
	}
	return integerObjectOf((cDigitComparewithlen(((unsigned int *) (firstIndexableField(firstInteger, self))), ((unsigned int *) (firstIndexableField(secondInteger, self))), firstDigitLen, self)), self);
}


/*	Does not normalize. */
/*	Division by zero has to be checked in caller. */

	/* LargeIntegersPlugin>>#digitDivLarge:with:negative: */
static sqInt
digitDivLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg, struct foo * self)
{
	unsigned long long a;
	unsigned long long b;
	sqInt cond;
	sqInt d;
	unsigned int dh;
	sqInt div;
	sqInt divLen;
	sqInt dl;
	unsigned int dnh;
	sqInt firstDigitLen;
	unsigned long long hi;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt l;
	unsigned long long lo;
	unsigned long long mul;
	unsigned int *pDiv;
	unsigned int *pQuo;
	unsigned int *pRem;
	unsigned long long q;
	sqInt ql;
	sqInt quo;
	sqInt quoDigitLen;
	sqInt quoLen;
	unsigned long long r1r2;
	unsigned int r3;
	sqInt rem;
	sqInt remLen;
	sqInt result;
	sqInt secondDigitLen;
	unsigned long long t;

	firstDigitLen = ((slotSizeOf(firstInteger, self)) + 3) / 4;
	secondDigitLen = ((slotSizeOf(secondInteger, self)) + 3) / 4;
	quoDigitLen = (firstDigitLen - secondDigitLen) + 1;
	if (quoDigitLen <= 0) {
		
#if SPURVM
		result = instantiateClassindexableSize(classArray(self), 2, self);

#else /* SPURVM */
		pushRemappableOop(firstInteger, self);
		result = instantiateClassindexableSize(classArray(self), 2, self);
		firstInteger = popRemappableOop(self)
#endif /* SPURVM */
;
		if (!(result == null)) {
			stObjectatput(result, 1, integerObjectOf(0, self), self);
			stObjectatput(result, 2, firstInteger, self);
		}
		return result;
	}
	d = 32 - (cHighBit32(cDigitOfat(((unsigned int *) (firstIndexableField(secondInteger, self))), secondDigitLen - 1, self), self));
	
#if SPURVM
	div = digitLshift(secondInteger, d, self);
	if (!(div == null)) {
		div = largeIntgrowTo(div, ((((slotSizeOf(div, self)) + 3) / 4) + 1) * 4, self);
	}
	if (!(div)) {
		return div;
	}

#else /* SPURVM */
	pushRemappableOop(firstInteger, self);
	div = digitLshift(secondInteger, d, self);
	if (!(div == null)) {
		div = largeIntgrowTo(div, ((((slotSizeOf(div, self)) + 3) / 4) + 1) * 4, self);
	}
	if (!(div)) {
		return div;
	}
	firstInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	
#if SPURVM
	rem = digitLshift(firstInteger, d, self);
	if (!(rem == null)) {
		if ((((slotSizeOf(rem, self)) + 3) / 4) == firstDigitLen) {
			rem = largeIntgrowTo(rem, (firstDigitLen + 1) * 4, self);
		}
	}
	if (!(rem)) {
		return rem;
	}

#else /* SPURVM */
	pushRemappableOop(div, self);
	rem = digitLshift(firstInteger, d, self);
	if (!(rem == null)) {
		if ((((slotSizeOf(rem, self)) + 3) / 4) == firstDigitLen) {
			rem = largeIntgrowTo(rem, (firstDigitLen + 1) * 4, self);
		}
	}
	if (!(rem)) {
		return rem;
	}
	div = popRemappableOop(self)
#endif /* SPURVM */
;
	
#if SPURVM
	/* begin createLargeIntegerNeg:digitLength: */
	quo = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), quoDigitLen * 4, self);

#else /* SPURVM */
	pushRemappableOop(div, self);
	pushRemappableOop(rem, self);
	/* begin createLargeIntegerNeg:digitLength: */
	quo = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), quoDigitLen * 4, self);
	rem = popRemappableOop(self);
	div = popRemappableOop(self)
#endif /* SPURVM */
;
	/* begin cDigitDiv:len:rem:len:quo:len: */
	pDiv = ((unsigned int *) (firstIndexableField(div, self)));
	divLen = ((slotSizeOf(div, self)) + 3) / 4;
	pRem = ((unsigned int *) (firstIndexableField(rem, self)));
	remLen = ((slotSizeOf(rem, self)) + 3) / 4;
	pQuo = ((unsigned int *) (firstIndexableField(quo, self)));
	quoLen = ((slotSizeOf(quo, self)) + 3) / 4;

	/* Last actual byte of data (ST ix) */
	dl = divLen - 1;
	ql = quoLen;
	dh = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[dl - 1]));
	if (dl == 1) {
		dnh = 0;
	}
	else {
		dnh = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[dl - 2]));
	}
	for (k = 1; k <= ql; k += 1) {

		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two unint32 of rem by dh. */
		/* The estimate is q = qhi*16r100000000+qlo, where qhi and qlo are uint32. */

		/* r1 := rem digitAt: j. */
		j = (remLen + 1) - k;
		if ((SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 1]))) == dh) {
			q = 0xFFFFFFFFU;
		}
		else {

			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.
			   Note that r1,r2 are uint64, not uint32. */
			/* r2 := (rem digitAt: j - 2). */
			r1r2 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 1]));
			r1r2 = (r1r2 << 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 2])));
			t = r1r2 % dh;

			/* Next compute (hi,lo) := q*dnh */
			q = r1r2 / dh;
			mul = q * dnh;
			hi = mul >> 32;

			/* Correct overestimate of q.
			   Max of 2 iterations through loop -- see Knuth vol. 2 */
			lo = mul & 0xFFFFFFFFU;
			if (j < 3) {
				r3 = 0;
			}
			else {
				r3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 3]));
			}
			while (1) {
				if ((t < hi)
				 || ((t == hi)
				 && (r3 < lo))) {

					/* i.e. (t,r3) < (hi,lo) */
					q -= 1;
					if (hi == 0) {

						/* since hi is unsigned we must have this guard */
						cond = 0;
					}
					else {
						if (lo < dnh) {
							hi -= 1;
							lo = (lo + 0x100000000LL) - dnh;
						}
						else {
							lo -= dnh;
						}
						cond = hi >= dh;
					}
				}
				else {
					cond = 0;
				}
				if (!(cond)) break;
				hi -= dh;
			}
		}
		l = j - dl;
		a = 0;
		for (i = 1; i <= divLen; i += 1) {
			hi = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1]))) * (q >> 32);
			lo = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1]))) * (q & 0xFFFFFFFFU);
			b = ((SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[l - 1]))) - a) - (lo & 0xFFFFFFFFU);
			pRem[l - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((b & 0xFFFFFFFFU)));
			b = (b >> 32) | ((0 - (b >> 0x3F)) & 0xFFFFFFFF00000000ULL);
			a = (hi + (lo >> 32)) - b;
			l += 1;
		}
		if (a > 0) {

			/* Add div back into rem, decrease q by 1 */
			q -= 1;
			l = j - dl;
			a = 0;
			for (i = 1; i <= divLen; i += 1) {
				a = ((a >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[l - 1])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1])));
				pRem[l - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((a & 0xFFFFFFFFU)));
				l += 1;
			}
		}
		pQuo[quoLen - k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) q))));
	}
	
#if SPURVM
	rem = digitRshiftlookfirst(rem, d, (((slotSizeOf(div, self)) + 3) / 4) - 1, self);

#else /* SPURVM */
	pushRemappableOop(quo, self);
	rem = digitRshiftlookfirst(rem, d, (((slotSizeOf(div, self)) + 3) / 4) - 1, self);
	quo = popRemappableOop(self)
#endif /* SPURVM */
;
	
#if SPURVM
	result = instantiateClassindexableSize(classArray(self), 2, self);

#else /* SPURVM */
	pushRemappableOop(quo, self);
	pushRemappableOop(rem, self);
	result = instantiateClassindexableSize(classArray(self), 2, self);
	rem = popRemappableOop(self);
	quo = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(result == null)) {
		stObjectatput(result, 1, quo, self);
		stObjectatput(result, 2, rem, self);
	}
	return result;
}

	/* LargeIntegersPlugin>>#digitMontgomery:times:modulo:mInvModB: */
static sqInt
digitMontgomerytimesmodulomInvModB(sqInt firstLarge, sqInt secondLarge, sqInt thirdLarge, unsigned int mInv, struct foo * self)
{
	unsigned long long accum;
	unsigned long long accum2;
	unsigned long long accum3;
	sqInt firstLen;
	sqInt i;
	sqInt k;
	unsigned int lastDigit;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned int *pFirst;
	unsigned int *pRes;
	sqInt prod;
	unsigned int *pSecond;
	unsigned int *pThird;
	sqInt secondLen;
	sqInt thirdLen;
	unsigned long long u;

	firstLen = ((slotSizeOf(firstLarge, self)) + 3) / 4;
	secondLen = ((slotSizeOf(secondLarge, self)) + 3) / 4;
	thirdLen = ((slotSizeOf(thirdLarge, self)) + 3) / 4;
	if (!((firstLen <= thirdLen)
		 && (secondLen <= thirdLen))) {
		return primitiveFail(self);
	}
	
#if SPURVM
	prod = instantiateClassindexableSize(classLargePositiveInteger(self), thirdLen * 4, self);

#else /* SPURVM */
	pushRemappableOop(firstLarge, self);
	pushRemappableOop(secondLarge, self);
	pushRemappableOop(thirdLarge, self);
	prod = instantiateClassindexableSize(classLargePositiveInteger(self), thirdLen * 4, self);
	thirdLarge = popRemappableOop(self);
	secondLarge = popRemappableOop(self);
	firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(prod)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	/* begin cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
	pFirst = ((unsigned int *) (firstIndexableField(firstLarge, self)));
	pSecond = ((unsigned int *) (firstIndexableField(secondLarge, self)));
	pThird = ((unsigned int *) (firstIndexableField(thirdLarge, self)));
	pRes = ((unsigned int *) (firstIndexableField(prod, self)));
	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastDigit = 0;
	for (i = 0; i <= limit1; i += 1) {
		accum3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFirst[i]));
		accum3 = (accum3 * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pSecond[0])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[0])));
		u = (accum3 * mInv) & 0xFFFFFFFFU;
		accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[0])));
		accum = (accum2 & 0xFFFFFFFFU) + (accum3 & 0xFFFFFFFFU);
		accum = ((accum >> 32) + (accum2 >> 32)) + (accum3 >> 32);
		for (k = 1; k <= limit2; k += 1) {
			accum3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFirst[i]));
			accum3 = (accum3 * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pSecond[k])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])));
			accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
			accum = (accum + (accum2 & 0xFFFFFFFFU)) + (accum3 & 0xFFFFFFFFU);
			pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = ((accum >> 32) + (accum2 >> 32)) + (accum3 >> 32);
		}
		for (k = secondLen; k <= limit3; k += 1) {
			accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
			accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])))) + (accum2 & 0xFFFFFFFFU);
			pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = (accum >> 32) + (accum2 >> 32);
		}
		accum += lastDigit;
		pRes[limit3] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
		lastDigit = accum >> 32;
	}
	for (i = firstLen; i <= limit3; i += 1) {
		accum = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[0]));
		u = (accum * mInv) & 0xFFFFFFFFU;
		accum += u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[0])));
		accum = accum >> 32;
		for (k = 1; k <= limit3; k += 1) {
			accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
			accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])))) + (accum2 & 0xFFFFFFFFU);
			pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = (accum >> 32) + (accum2 >> 32);
		}
		accum += lastDigit;
		pRes[limit3] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
		lastDigit = accum >> 32;
	}
	if (!((lastDigit == 0)
		 && ((cDigitComparewithlen(pThird, pRes, thirdLen, self)) == 1))) {

		/* self cDigitSub: pThird len: thirdLen with: pRes len: thirdLen into: pRes */
		accum = 0;
		for (i = 0; i <= limit3; i += 1) {
			accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[i])))) - (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[i])));
			pRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			accum = 0 - (accum >> 0x3F);
		}
	}
	return normalizePositive(prod, self);
}


/*	Normalizes. */

	/* LargeIntegersPlugin>>#digitMultiplyLarge:with:negative: */
static sqInt
digitMultiplyLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg, struct foo * self)
{
	unsigned long long ab;
	unsigned int carry;
	unsigned int digit;
	sqInt firstLen;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt limitLong;
	sqInt limitShort;
	sqInt longInt;
	sqInt longLen;
	sqInt prod;
	unsigned int *pWordLong;
	unsigned int *pWordRes;
	unsigned int *pWordShort;
	sqInt secondLen;
	sqInt shortInt;
	sqInt shortLen;

	/* begin byteSizeOfLargeInt: */
	firstLen = slotSizeOf(firstInteger, self);
	/* begin byteSizeOfLargeInt: */
	secondLen = slotSizeOf(secondInteger, self);
	if (firstLen <= secondLen) {
		shortInt = firstInteger;
		shortLen = firstLen;
		longInt = secondInteger;
		longLen = secondLen;
	}
	else {
		shortInt = secondInteger;
		shortLen = secondLen;
		longInt = firstInteger;
		longLen = firstLen;
	}
	
#if SPURVM
	/* begin createLargeIntegerNeg:byteLength: */
	prod = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), longLen + shortLen, self);

#else /* SPURVM */
	pushRemappableOop(shortInt, self);
	pushRemappableOop(longInt, self);
	/* begin createLargeIntegerNeg:byteLength: */
	prod = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), longLen + shortLen, self);
	longInt = popRemappableOop(self);
	shortInt = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(prod)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	/* begin cDigitMultiply:len:with:len:into:len: */
	pWordShort = ((unsigned int *) (firstIndexableField(shortInt, self)));
	pWordLong = ((unsigned int *) (firstIndexableField(longInt, self)));
	pWordRes = ((unsigned int *) (firstIndexableField(prod, self)));
	if ((((shortLen + 3) / 4) == 1)
	 && ((pWordShort[0]) == 0)) {
		goto l4;
	}
	if ((((longLen + 3) / 4) == 1)
	 && ((pWordLong[0]) == 0)) {
		goto l4;
	}
	limitShort = ((shortLen + 3) / 4) - 1;
	limitLong = ((longLen + 3) / 4) - 1;
	for (i = 0; i <= limitShort; i += 1) {
		if (((digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordShort[i])))) != 0) {
			k = i;

			/* Loop invariant: 0<=carry<=16rFFFFFFFF, k=i+j-1 (ST) */
			/* -> Loop invariant: 0<=carry<=16rFFFFFFFF, k=i+j (C) (?) */
			carry = 0;
			for (j = 0; j <= limitLong; j += 1) {
				ab = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[j]));
				ab = ((ab * digit) + carry) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordRes[k])));
				carry = ab >> 32;
				pWordRes[k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((ab & 0xFFFFFFFFU)));
				k += 1;
			}
			if (k < (((longLen + shortLen) + 3) / 4)) {
				pWordRes[k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(carry));
			}
		}
	}
	l4:	/* end cDigitMultiply:len:with:len:into:len: */;
	return (neg
		? normalizeNegative(prod, self)
		: normalizePositive(prod, self));
}


/*	Answer the value of a 32 bits digit in a C-SmallInteger. */
/*	ST indexed! */

	/* LargeIntegersPlugin>>#digitOfCSI:at: */
static sqInt
digitOfCSIat(sqInt csi, sqInt ix, struct foo * self)
{
	return ((usqInt) ((csi < 0
		? 0 - csi
		: csi))) >> ((ix - 1) * 32);
}


/*	Argument has to be aLargeInteger! */

	/* LargeIntegersPlugin>>#digitOfLargeInt:at: */
static sqInt
digitOfLargeIntat(sqInt aBytesOop, sqInt ix, struct foo * self)
{
	unsigned int *cPointer;

	if (ix > (((slotSizeOf(aBytesOop, self)) + 3) / 4)) {
		return 0;
	}
	else {
		/* begin cDigitOf:at: */
		cPointer = ((unsigned int *) (firstIndexableField(aBytesOop, self)));
		return SQ_SWAP_4_BYTES_IF_BIGENDIAN((cPointer[ix - 1]));
	}
}


/*	Answer the number of 32-bits fields of a C-SmallInteger. This value is 
	the same as the largest legal subscript. */

	/* LargeIntegersPlugin>>#digitSizeOfCSI: */
static sqInt
digitSizeOfCSI(sqInt csi, struct foo * self)
{
	return ((MaxSmallInteger) <= 0x3FFFFFFF
		? 1
		: (csi > (((sqIntptr_t)0xFFFFFFFFU))
				? 2
				: (csi < -4294967295LL
						? 2
						: 1)));
}


/*	answer number of 32 bits digits of a Large Integer */

	/* LargeIntegersPlugin>>#digitSizeOfLargeInt: */
static sqInt
digitSizeOfLargeInt(sqInt anOop, struct foo * self)
{
	return ((slotSizeOf(anOop, self)) + 3) / 4;
}


/*	Normalizes. */

	/* LargeIntegersPlugin>>#digitSubLarge:with: */
static sqInt
digitSubLargewith(sqInt firstInteger, sqInt secondInteger, struct foo * self)
{
	sqInt firstDigitLen;
	sqInt firstNeg;
	sqInt i;
	sqInt largeDigitLen;
	sqInt larger;
	int neg;
	unsigned int *pWordLarge;
	unsigned int *pWordRes;
	unsigned int *pWordSmall;
	sqInt res;
	sqInt resDigitLen;
	sqInt secondDigitLen;
	sqInt smaller;
	sqInt smallerDigitLen;
	unsigned long long z;

	firstNeg = isLargeNegativeIntegerObject(firstInteger, self);
	/* begin digitSizeOfLargeInt: */
	firstDigitLen = ((slotSizeOf(firstInteger, self)) + 3) / 4;
	/* begin digitSizeOfLargeInt: */
	secondDigitLen = ((slotSizeOf(secondInteger, self)) + 3) / 4;
	if (firstDigitLen == secondDigitLen) {
		while ((firstDigitLen > 1)
		 && ((cDigitOfat(((unsigned int *) (firstIndexableField(firstInteger, self))), firstDigitLen - 1, self)) == (cDigitOfat(((unsigned int *) (firstIndexableField(secondInteger, self))), firstDigitLen - 1, self)))) {
			firstDigitLen -= 1;
		}
		secondDigitLen = firstDigitLen;
	}
	if ((firstDigitLen < secondDigitLen)
	 || ((firstDigitLen == secondDigitLen)
	 && ((cDigitOfat(((unsigned int *) (firstIndexableField(firstInteger, self))), firstDigitLen - 1, self)) < (cDigitOfat(((unsigned int *) (firstIndexableField(secondInteger, self))), firstDigitLen - 1, self))))) {
		larger = secondInteger;
		largeDigitLen = secondDigitLen;
		smaller = firstInteger;
		smallerDigitLen = firstDigitLen;
		neg = firstNeg == 0;
	}
	else {
		larger = firstInteger;
		largeDigitLen = firstDigitLen;
		smaller = secondInteger;
		smallerDigitLen = secondDigitLen;
		neg = firstNeg;
	}
	resDigitLen = largeDigitLen;
	
#if SPURVM
	/* begin createLargeIntegerNeg:digitLength: */
	res = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), resDigitLen * 4, self);

#else /* SPURVM */
	pushRemappableOop(smaller, self);
	pushRemappableOop(larger, self);
	/* begin createLargeIntegerNeg:digitLength: */
	res = instantiateClassindexableSize((neg
		? classLargeNegativeInteger(self)
		: classLargePositiveInteger(self)), resDigitLen * 4, self);
	larger = popRemappableOop(self);
	smaller = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(res)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	/* begin cDigitSub:len:with:len:into: */
	pWordSmall = ((unsigned int *) (firstIndexableField(smaller, self)));
	pWordLarge = ((unsigned int *) (firstIndexableField(larger, self)));
	pWordRes = ((unsigned int *) (firstIndexableField(res, self)));
	z = 0;
	for (i = 0; i < smallerDigitLen; i += 1) {
		z = (z + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLarge[i])))) - (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordSmall[i])));
		/* begin cDigitOf:at:put: */
		pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) (z & 0xFFFFFFFFU)))));
		z = 0 - (z >> 0x3F);
	}
	for (i = smallerDigitLen; i < largeDigitLen; i += 1) {
		z += SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLarge[i]));
		/* begin cDigitOf:at:put: */
		pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) (z & 0xFFFFFFFFU)))));
		z = 0 - (z >> 0x3F);
	}
	return (neg
		? normalizeNegative(res, self)
		: normalizePositive(res, self));
}


/*	Attention: this method invalidates all oop's! Only newOop is valid at
	return. 
 */
/*	Does not normalize. */

	/* LargeIntegersPlugin>>#digit:Lshift: */
static sqInt
digitLshift(sqInt anOop, sqInt shiftCount, struct foo * self)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt highBit;
	sqInt i;
	sqInt i1;
	sqInt limit;
	sqInt newByteLen;
	sqInt newDigitLen;
	sqInt newOop;
	sqInt oldDigitLen;
	unsigned int *pFrom;
	unsigned int *pTo;
	sqInt rshift;

	/* begin digitSizeOfLargeInt: */
	oldDigitLen = ((slotSizeOf(anOop, self)) + 3) / 4;
	if (((highBit = cDigitHighBitlen(((unsigned int *) (firstIndexableField(anOop, self))), oldDigitLen, self))) == 0) {
		return instantiateClassindexableSize(fetchClassOf(anOop, self), 1, self);
	}
	newByteLen = ((highBit + shiftCount) + 7) / 8;
	
#if SPURVM
	newOop = instantiateClassindexableSize(fetchClassOf(anOop, self), newByteLen, self);

#else /* SPURVM */
	pushRemappableOop(anOop, self);
	newOop = instantiateClassindexableSize(fetchClassOf(anOop, self), newByteLen, self);
	anOop = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(newOop)) {
		primitiveFailFor(PrimErrNoMemory, self);
		return null;
	}
	newDigitLen = (newByteLen + 3) / 4;
	/* begin cDigitLshift:from:len:to:len: */
	pFrom = ((unsigned int *) (firstIndexableField(anOop, self)));
	pTo = ((unsigned int *) (firstIndexableField(newOop, self)));
	digitShift = shiftCount / 32;
	bitShift = shiftCount % 32;

	/* Note: 0 is endian neutral, use direct access */
	limit = digitShift - 1;
	for (i = 0; i <= limit; i += 1) {
		pTo[i] = 0;
	}
	if (bitShift == 0) {

		/* Fast version for digit-aligned shifts */
		/* C indexed! */
		/* begin cDigitCopyFrom:to:len: */
		for (i1 = 0; i1 < (((newDigitLen - 1) - digitShift) + 1); i1 += 1) {
			(pTo + digitShift)[i1] = ((pFrom)[i1]);
		}
		goto l2;
	}
	rshift = 32 - bitShift;
	carry = 0;
	limit = oldDigitLen - 1;
	for (i = 0; i <= limit; i += 1) {
		digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFrom[i]));
		pTo[i + digitShift] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(((carry | (((usqInt)(digit) << bitShift))) & 0xFFFFFFFFU)));
		carry = ((usqInt) digit) >> rshift;
	}
	if (!(carry == 0)) {
		pTo[newDigitLen - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(carry));
	}
	l2:	/* end cDigitLshift:from:len:to:len: */;
	return newOop;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Shift right 32*digitShift+bitShift bits, 0<=bitShift<32. 
	Discard all digits beyond a, and all zeroes at or below a. */
/*	Does not normalize. */

	/* LargeIntegersPlugin>>#digit:Rshift:lookfirst: */
static sqInt
digitRshiftlookfirst(sqInt anOop, sqInt shiftCount, sqInt a, struct foo * self)
{
	sqInt bitShift;
	unsigned int carry;
	unsigned int digit;
	sqInt digitShift;
	sqInt i;
	sqInt j;
	unsigned int lastDigit;
	sqInt leftShift;
	sqInt limit;
	sqInt newBitLen;
	sqInt newByteLen;
	sqInt newDigitLen;
	sqInt newOop;
	sqInt oldBitLen;
	sqInt oldDigitLen;
	unsigned int *pFrom;
	unsigned int *pTo;
	unsigned int *pUint32;
	sqInt realLength;
	sqInt start;

	/* begin cDigitHighBit:len: */
	pUint32 = ((unsigned int *) (firstIndexableField(anOop, self)));
	realLength = a;
	do {
		if (realLength == 0) {
			oldBitLen = 0;
			goto l5;
		}
	} while(((lastDigit = cDigitOfat(pUint32, (realLength -= 1), self))) == 0);
	oldBitLen = (cHighBit32(lastDigit, self)) + (32 * realLength);
	l5:	/* end cDigitHighBit:len: */;
	oldDigitLen = (oldBitLen + 0x1F) / 32;
	newBitLen = oldBitLen - shiftCount;
	if (newBitLen <= 0) {

		/* All bits lost */
		return instantiateClassindexableSize(fetchClassOf(anOop, self), 0, self);
	}
	newByteLen = (newBitLen + 7) / 8;
	newDigitLen = (newByteLen + 3) / 4;
	
#if SPURVM
	newOop = instantiateClassindexableSize(fetchClassOf(anOop, self), newByteLen, self);

#else /* SPURVM */
	pushRemappableOop(anOop, self);
	newOop = instantiateClassindexableSize(fetchClassOf(anOop, self), newByteLen, self);
	anOop = popRemappableOop(self)
#endif /* SPURVM */
;
	if (!(newOop)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	/* begin cDigitRshift:from:len:to:len: */
	pFrom = ((unsigned int *) (firstIndexableField(anOop, self)));
	pTo = ((unsigned int *) (firstIndexableField(newOop, self)));
	digitShift = shiftCount / 32;
	bitShift = shiftCount % 32;
	if (bitShift == 0) {

		/* Fast version for digit-aligned shifts */
		/* C indexed! */
		/* begin cDigitReplace:from:to:with:startingAt: */
		for (i = 0; i < (((newDigitLen - 1)) + 1); i += 1) {
			(pTo)[i] = ((pFrom + digitShift)[i]);
		}
		goto l4;
	}
	leftShift = 32 - bitShift;
	carry = ((usqInt) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFrom[digitShift])))) >> bitShift;
	start = digitShift + 1;
	limit = oldDigitLen - 1;
	for (j = start; j <= limit; j += 1) {
		/* begin cDigitOf:at: */
		digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFrom[j]));
		/* begin cDigitOf:at:put: */
		pTo[j - start] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(((carry | (((usqInt)(digit) << leftShift))) & 0xFFFFFFFFU)));
		carry = ((usqInt) digit) >> bitShift;
	}
	if (!(carry == 0)) {
		/* begin cDigitOf:at:put: */
		pTo[newDigitLen - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(carry));
	}
	l4:	/* end cDigitRshift:from:len:to:len: */;
	return newOop;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* LargeIntegersPlugin>>#highBitOfLargeInt: */
static sqInt
highBitOfLargeInt(sqInt anOop, struct foo * self)
{
	unsigned int lastDigit;
	sqInt len;
	unsigned int *pUint32;
	sqInt realLength;

	/* begin cDigitHighBit:len: */
	pUint32 = ((unsigned int *) (firstIndexableField(anOop, self)));
	len = ((slotSizeOf(anOop, self)) + 3) / 4;
	realLength = len;
	do {
		if (realLength == 0) {
			return 0;
		}
	} while(((lastDigit = cDigitOfat(pUint32, (realLength -= 1), self))) == 0);
	return (cHighBit32(lastDigit, self)) + (32 * realLength);
}


/*	Check for leading zero of LargeInteger */

	/* LargeIntegersPlugin>>#isNormalized: */
static sqInt
isNormalized(sqInt aLargeInteger, struct foo * self)
{
	sqInt len;

	/* begin byteSizeOfLargeInt: */
	len = slotSizeOf(aLargeInteger, self);
	if (len == 0) {
		return 0;
	}
	if ((unsafeByteOfLargeIntat(aLargeInteger, len, self)) == 0) {
		return 0;
	}
	return 1;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Does not normalize. */

	/* LargeIntegersPlugin>>#largeInt:growTo: */
static sqInt
largeIntgrowTo(sqInt aBytesObject, sqInt newByteLen, struct foo * self)
{
	sqInt copyLen;
	sqInt i;
	sqInt newBytes;
	sqInt newDigitLen;
	sqInt oldDigitLen;
	unsigned int *pFrom;
	unsigned int *pTo;

	
#if SPURVM
	newBytes = instantiateClassindexableSize(fetchClassOf(aBytesObject, self), newByteLen, self);
	if (!(newBytes)) {
		primitiveFailFor(PrimErrNoMemory, self);
		return null;
	}

#else /* SPURVM */
	pushRemappableOop(aBytesObject, self);
	newBytes = instantiateClassindexableSize(fetchClassOf(aBytesObject, self), newByteLen, self);
	if (!(newBytes)) {
		primitiveFailFor(PrimErrNoMemory, self);
		return null;
	}
	aBytesObject = popRemappableOop(self)
#endif /* SPURVM */
;
	newDigitLen = (newByteLen + 3) / 4;
	/* begin digitSizeOfLargeInt: */
	oldDigitLen = ((slotSizeOf(aBytesObject, self)) + 3) / 4;
	copyLen = (oldDigitLen < newDigitLen
		? oldDigitLen
		: newDigitLen);
	/* begin cDigitCopyFrom:to:len: */
	pFrom = ((unsigned int *) (firstIndexableField(aBytesObject, self)));
	pTo = ((unsigned int *) (firstIndexableField(newBytes, self)));
	for (i = 0; i < copyLen; i += 1) {
		pTo[i] = (pFrom[i]);
	}
	return newBytes;
}

	/* InterpreterPlugin>>#msg: */
static sqInt
msg(char *s, struct foo * self)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Check for leading zeroes and return shortened copy if so. */
/*	First establish len = significant length. */

	/* LargeIntegersPlugin>>#normalizeNegative: */
static sqInt
normalizeNegative(sqInt aLargeNegativeInteger, struct foo * self)
{
	sqInt byteLen;
	unsigned int *cPointer;
	sqInt digitLen;
	usqInt minVal;
	sqInt oldByteLen;
	int sLen;
	usqInt val;
	usqInt val2;

	/* begin digitSizeOfLargeInt: */
	digitLen = ((slotSizeOf(aLargeNegativeInteger, self)) + 3) / 4;
	while ((digitLen != 0)
	 && ((cDigitOfat(((unsigned int *) (firstIndexableField(aLargeNegativeInteger, self))), digitLen - 1, self)) == 0)) {
		digitLen -= 1;
	}
	if (digitLen == 0) {
		return integerObjectOf(0, self);
	}
	/* begin cDigitOf:at: */
	cPointer = ((unsigned int *) (firstIndexableField(aLargeNegativeInteger, self)));
	val = SQ_SWAP_4_BYTES_IF_BIGENDIAN((cPointer[digitLen - 1]));

	/* SmallInteger minVal digitLength */
	sLen = ((MinSmallInteger) < -1073741824LL
		? 2
		: 1);
	if (digitLen <= sLen) {
		minVal = 0 - (MinSmallInteger);
		val2 = val;
		if (digitLen > 1) {
			val2 = (val2 << 32) + (cDigitOfat(((unsigned int *) (firstIndexableField(aLargeNegativeInteger, self))), 1 - 1, self));
		}
		if (val2 <= minVal) {
			return integerObjectOf((0 - val2), self);
		}
	}
	byteLen = digitLen * 4;
	if (val <= 0xFFFF) {
		byteLen -= 2;
	}
	else {
		val = ((usqInt) val) >> 16;
	}
	if (val <= 0xFF) {
		byteLen -= 1;
	}
	/* begin byteSizeOfLargeInt: */
	oldByteLen = slotSizeOf(aLargeNegativeInteger, self);
	if (byteLen < oldByteLen) {
		return largeIntgrowTo(aLargeNegativeInteger, byteLen, self);
	}
	else {
		return aLargeNegativeInteger;
	}
}


/*	Check for leading zeroes and return shortened copy if so. */
/*	First establish len = significant length. */

	/* LargeIntegersPlugin>>#normalizePositive: */
static sqInt
normalizePositive(sqInt aLargePositiveInteger, struct foo * self)
{
	sqInt byteLen;
	unsigned int *cPointer;
	sqInt digitLen;
	usqInt maxVal;
	sqInt oldByteLen;
	int sLen;
	usqInt val;
	usqInt val2;

	/* begin digitSizeOfLargeInt: */
	digitLen = ((slotSizeOf(aLargePositiveInteger, self)) + 3) / 4;
	while ((digitLen != 0)
	 && ((cDigitOfat(((unsigned int *) (firstIndexableField(aLargePositiveInteger, self))), digitLen - 1, self)) == 0)) {
		digitLen -= 1;
	}
	if (digitLen == 0) {
		return integerObjectOf(0, self);
	}
	/* begin cDigitOf:at: */
	cPointer = ((unsigned int *) (firstIndexableField(aLargePositiveInteger, self)));
	val = SQ_SWAP_4_BYTES_IF_BIGENDIAN((cPointer[digitLen - 1]));

	/* SmallInteger maxVal digitLength */
	sLen = ((MaxSmallInteger) > 0x3FFFFFFF
		? 2
		: 1);
	if (digitLen <= sLen) {
		maxVal = MaxSmallInteger;
		val2 = val;
		if (digitLen > 1) {

			/* Note: asUnsignedLongLong is not necessary because this branch is for 64 bits only.
			   but we want to avoid a C Compiler warning on 32 bits */
			val2 = ((((unsigned long long)val2)) << 32) + (cDigitOfat(((unsigned int *) (firstIndexableField(aLargePositiveInteger, self))), 1 - 1, self));
		}
		if (val2 <= maxVal) {
			return integerObjectOf(val2, self);
		}
	}
	byteLen = digitLen * 4;
	if (val <= 0xFFFF) {
		byteLen -= 2;
	}
	else {
		val = ((usqInt) val) >> 16;
	}
	if (val <= 0xFF) {
		byteLen -= 1;
	}
	/* begin byteSizeOfLargeInt: */
	oldByteLen = slotSizeOf(aLargePositiveInteger, self);
	if (byteLen < oldByteLen) {
		return largeIntgrowTo(aLargePositiveInteger, byteLen, self);
	}
	else {
		return aLargePositiveInteger;
	}
}


/*	Check for leading zeroes and return shortened copy if so. */

	/* LargeIntegersPlugin>>#normalize: */
static sqInt
normalize(sqInt aLargeInteger, struct foo * self)
{
	/* missing DebugCode */;
	if (isLargePositiveIntegerObject(aLargeInteger, self)) {
		return normalizePositive(aLargeInteger, self);
	}
	else {
		return normalizeNegative(aLargeInteger, self);
	}
}

	/* LargeIntegersPlugin>>#primAnyBitFrom:to: */
EXPORT(sqInt)
primAnyBitFromTo(struct foo * self)
{
	sqInt from;
	sqInt integer;
	sqInt large;
	sqInt to;
	sqInt _return_value;

	if (!((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	from = stackIntegerValue(1, self);
	to = stackIntegerValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(2, self), self), self);
	integer = stackValue(2, self);
	if (failed(self)) {
		return null;
	}
	if (isIntegerObject(integer, self)) {

		/* convert it to a not normalized LargeInteger */
		large = createLargeFromSmallInteger(integer, self);
	}
	else {
		large = integer;
	}
	if (!(failed(self))) {
		_return_value = (((anyBitOfLargeIntfromto(large, from, to, self))) ? trueObject(self) : falseObject(self));
		if (!(failed(self))) {
			popthenPush(3, _return_value, self);
		}
	}
	return null;
}

	/* LargeIntegersPlugin>>#primDigitAdd: */
EXPORT(sqInt)
primDigitAdd(struct foo * self)
{
	unsigned long long accum;
	unsigned int *cPointer;
	sqInt firstDigitLen;
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt i;
	sqInt i1;
	sqInt longDigitLen;
	sqInt longInt;
	sqInt neg;
	sqInt newSum;
	unsigned int over;
	unsigned int *pFrom;
	unsigned int *pTo;
	unsigned int *pWordLong;
	unsigned int *pWordRes;
	unsigned int *pWordShort;
	sqInt secondDigitLen;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt shortDigitLen;
	sqInt shortInt;
	sqInt sum;
	sqInt _return_value;

	if (!(isKindOfInteger(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(1, self), self), self);
	firstInteger = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	if (isIntegerObject(firstInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger, self);

#else /* SPURVM */
		pushRemappableOop(secondInteger, self);
		firstLarge = createLargeFromSmallInteger(firstInteger, self);
		secondInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger, self);

#else /* SPURVM */
		pushRemappableOop(firstLarge, self);
		secondLarge = createLargeFromSmallInteger(secondInteger, self);
		firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (!(failed(self))) {
		/* begin digitAddLarge:with: */
		firstDigitLen = ((slotSizeOf(firstLarge, self)) + 3) / 4;
		secondDigitLen = ((slotSizeOf(secondLarge, self)) + 3) / 4;
		neg = isLargeNegativeIntegerObject(firstLarge, self);
		if (firstDigitLen <= secondDigitLen) {
			shortInt = firstLarge;
			shortDigitLen = firstDigitLen;
			longInt = secondLarge;
			longDigitLen = secondDigitLen;
		}
		else {
			shortInt = secondLarge;
			shortDigitLen = secondDigitLen;
			longInt = firstLarge;
			longDigitLen = firstDigitLen;
		}
		
#if SPURVM
		/* begin createLargeIntegerNeg:digitLength: */
		sum = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), longDigitLen * 4, self);

#else /* SPURVM */
		pushRemappableOop(shortInt, self);
		pushRemappableOop(longInt, self);
		/* begin createLargeIntegerNeg:digitLength: */
		sum = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), longDigitLen * 4, self);
		longInt = popRemappableOop(self);
		shortInt = popRemappableOop(self)
#endif /* SPURVM */
;
		if (!(sum)) {
			_return_value = primitiveFailFor(PrimErrNoMemory, self);
			goto l6;
		}
		/* begin cDigitAdd:len:with:len:into: */
		pWordShort = ((unsigned int *) (firstIndexableField(shortInt, self)));
		pWordLong = ((unsigned int *) (firstIndexableField(longInt, self)));
		pWordRes = ((unsigned int *) (firstIndexableField(sum, self)));
		accum = 0;
		for (i1 = 0; i1 < shortDigitLen; i1 += 1) {
			accum = ((accum >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordShort[i1])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[i1])));
			pWordRes[i1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
		}
		for (i1 = shortDigitLen; i1 < longDigitLen; i1 += 1) {
			accum = (accum >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[i1])));
			pWordRes[i1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
		}
		over = accum >> 32;
		if (over > 0) {

			/* sum := sum growby: 1. */
			
#if SPURVM
			/* begin createLargeIntegerNeg:byteLength: */
			newSum = instantiateClassindexableSize((neg
				? classLargeNegativeInteger(self)
				: classLargePositiveInteger(self)), (longDigitLen * 4) + 1, self);

#else /* SPURVM */
			pushRemappableOop(sum, self);
			/* begin createLargeIntegerNeg:byteLength: */
			newSum = instantiateClassindexableSize((neg
				? classLargeNegativeInteger(self)
				: classLargePositiveInteger(self)), (longDigitLen * 4) + 1, self);
			sum = popRemappableOop(self)
#endif /* SPURVM */
;
			if (!(newSum)) {
				_return_value = primitiveFailFor(PrimErrNoMemory, self);
				goto l6;
			}
			/* begin cDigitCopyFrom:to:len: */
			pFrom = ((unsigned int *) (firstIndexableField(sum, self)));
			pTo = ((unsigned int *) (firstIndexableField(newSum, self)));
			for (i = 0; i < longDigitLen; i += 1) {
				pTo[i] = (pFrom[i]);
			}

			/* C index! */
			sum = newSum;
			/* begin cDigitOf:at:put: */
			cPointer = ((unsigned int *) (firstIndexableField(sum, self)));
			cPointer[longDigitLen] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(over));
		}
		else {
			sum = (neg
				? normalizeNegative(sum, self)
				: normalizePositive(sum, self));
		}
		_return_value = sum;
	l6:	/* end digitAddLarge:with: */;
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#primDigitBitAnd: */
EXPORT(sqInt)
primDigitBitAnd(struct foo * self)
{
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	if (!(isKindOfInteger(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(1, self), self), self);
	firstInteger = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, andOpIndex, self);
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#primDigitBitOr: */
EXPORT(sqInt)
primDigitBitOr(struct foo * self)
{
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	if (!(isKindOfInteger(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(1, self), self), self);
	firstInteger = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, orOpIndex, self);
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}

	/* LargeIntegersPlugin>>#primDigitBitShiftMagnitude: */
EXPORT(sqInt)
primDigitBitShiftMagnitude(struct foo * self)
{
	sqInt aLarge;
	sqInt aLargeInteger;
	sqInt anInteger;
	sqInt rShift;
	sqInt shiftCount;
	sqInt _return_value;

	if (!(isIntegerObject(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	shiftCount = stackIntegerValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(1, self), self), self);
	anInteger = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	if (isIntegerObject(anInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		aLarge = createLargeFromSmallInteger(anInteger, self);
	}
	else {
		aLarge = anInteger;
	}
	if (shiftCount >= 0) {
		_return_value = digitLshift(aLarge, shiftCount, self);
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
		return null;
	}
	else {
		rShift = 0 - shiftCount;
		if (!(failed(self))) {
			/* begin normalize: */
			aLargeInteger = digitRshiftlookfirst(aLarge, rShift, ((slotSizeOf(aLarge, self)) + 3) / 4, self);
			/* missing DebugCode */;
			if (isLargePositiveIntegerObject(aLargeInteger, self)) {
				_return_value = normalizePositive(aLargeInteger, self);
				goto l1;
			}
			else {
				_return_value = normalizeNegative(aLargeInteger, self);
				goto l1;
			}
	l1:	/* end normalize: */;
			if (!(failed(self))) {
				popthenPush(2, _return_value, self);
			}
		}
		return null;
	}
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

	/* LargeIntegersPlugin>>#primDigitBitXor: */
EXPORT(sqInt)
primDigitBitXor(struct foo * self)
{
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	if (!(isKindOfInteger(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(1, self), self), self);
	firstInteger = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, xorOpIndex, self);
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}


/*	Compare the magnitude of self with that of arg. 
	Answer a code of 1, 0, -1 for self >, = , < arg */

	/* LargeIntegersPlugin>>#primDigitCompare: */
EXPORT(sqInt)
primDigitCompare(struct foo * self)
{
	sqInt firstDigitLen;
	sqInt firstInteger;
	sqInt firstVal;
	sqInt secondDigitLen;
	sqInt secondInteger;
	sqInt secondVal;
	sqInt _return_value;

	if (!(isKindOfInteger(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(1, self), self), self);
	firstInteger = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	if (isIntegerObject(firstInteger, self)) {
		if (isIntegerObject(secondInteger, self)) {
			firstVal = integerValueOf(firstInteger, self);

			/* Compute their magnitudes.  Since SmallIntegers are tagged they have
			   fewer bits than an integer on the platform; therefore in computing their
			   magnitude they cannot overflow. */
			secondVal = integerValueOf(secondInteger, self);
			if (firstVal < 0) {
				firstVal = 0 - firstVal;
			}
			if (secondVal < 0) {
				secondVal = 0 - secondVal;
			}
			if (!(failed(self))) {
				_return_value = (firstVal == secondVal
					? integerObjectOf(0, self)
					: (firstVal < secondVal
							? integerObjectOf(-1, self)
							: integerObjectOf(1, self)));
				if (!(failed(self))) {
					popthenPush(2, _return_value, self);
				}
			}
			return null;
		}
		if (!(failed(self))) {
			_return_value = integerObjectOf(-1, self);
			if (!(failed(self))) {
				popthenPush(2, _return_value, self);
			}
		}
		return null;
	}
	if (isIntegerObject(secondInteger, self)) {
		_return_value = integerObjectOf(1, self);
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
		return null;
	}
	if (!(failed(self))) {
		/* begin digitCompareLarge:with: */
		firstDigitLen = ((slotSizeOf(firstInteger, self)) + 3) / 4;
		secondDigitLen = ((slotSizeOf(secondInteger, self)) + 3) / 4;
		if (secondDigitLen != firstDigitLen) {
			if (secondDigitLen > firstDigitLen) {
				_return_value = integerObjectOf(-1, self);
				goto l1;
			}
			else {
				_return_value = integerObjectOf(1, self);
				goto l1;
			}
		}
		_return_value = integerObjectOf((cDigitComparewithlen(((unsigned int *) (firstIndexableField(firstInteger, self))), ((unsigned int *) (firstIndexableField(secondInteger, self))), firstDigitLen, self)), self);
	l1:	/* end digitCompareLarge:with: */;
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}


/*	Answer the result of dividing firstInteger by secondInteger. 
	Fail if parameters are not integers, not normalized or secondInteger is 
	zero. */

	/* LargeIntegersPlugin>>#primDigitDiv:negative: */
EXPORT(sqInt)
primDigitDivNegative(struct foo * self)
{
	unsigned long long a;
	unsigned long long b;
	sqInt cond;
	sqInt d;
	unsigned int dh;
	sqInt div;
	sqInt divLen;
	sqInt dl;
	unsigned int dnh;
	sqInt firstAsLargeInteger;
	sqInt firstDigitLen;
	sqInt firstInteger;
	unsigned long long hi;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt l;
	unsigned long long lo;
	unsigned long long mul;
	sqInt neg;
	unsigned int *pDiv;
	unsigned int *pQuo;
	unsigned int *pRem;
	unsigned long long q;
	sqInt ql;
	sqInt quo;
	sqInt quoDigitLen;
	sqInt quoLen;
	unsigned long long r1r2;
	unsigned int r3;
	sqInt rem;
	sqInt remLen;
	sqInt result;
	sqInt secondAsLargeInteger;
	sqInt secondDigitLen;
	sqInt secondInteger;
	unsigned long long t;
	sqInt _return_value;

	if (!((isKindOfInteger(stackValue(1, self), self))
		 && (isBooleanObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(1, self);
	neg = booleanValueOf(stackValue(0, self), self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(2, self), self), self);
	firstInteger = stackValue(2, self);
	if (failed(self)) {
		return null;
	}
	if (isIntegerObject(firstInteger, self)) {

		/* convert to LargeInteger */
		
#if SPURVM
		firstAsLargeInteger = createLargeFromSmallInteger(firstInteger, self);

#else /* SPURVM */
		pushRemappableOop(secondInteger, self);
		firstAsLargeInteger = createLargeFromSmallInteger(firstInteger, self);
		secondInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {

		/* Avoid crashes in case of getting unnormalized args. */
		if (!(isNormalized(firstInteger, self))) {
			/* missing DebugCode */;
			primitiveFail(self);
			return null;
		}
		firstAsLargeInteger = firstInteger;
	}
	if (isIntegerObject(secondInteger, self)) {

		/* check for zerodivide and convert to LargeInteger */
		if ((integerValueOf(secondInteger, self)) == 0) {
			primitiveFail(self);
			return null;
		}
		
#if SPURVM
		secondAsLargeInteger = createLargeFromSmallInteger(secondInteger, self);

#else /* SPURVM */
		pushRemappableOop(firstAsLargeInteger, self);
		secondAsLargeInteger = createLargeFromSmallInteger(secondInteger, self);
		firstAsLargeInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {

		/* Avoid crashes in case of getting unnormalized args. */
		if (!(isNormalized(secondInteger, self))) {
			/* missing DebugCode */;
			primitiveFail(self);
			return null;
		}
		secondAsLargeInteger = secondInteger;
	}
	if (!(failed(self))) {
		/* begin digitDivLarge:with:negative: */
		firstDigitLen = ((slotSizeOf(firstAsLargeInteger, self)) + 3) / 4;
		secondDigitLen = ((slotSizeOf(secondAsLargeInteger, self)) + 3) / 4;
		quoDigitLen = (firstDigitLen - secondDigitLen) + 1;
		if (quoDigitLen <= 0) {
			
#if SPURVM
			result = instantiateClassindexableSize(classArray(self), 2, self);

#else /* SPURVM */
			pushRemappableOop(firstAsLargeInteger, self);
			result = instantiateClassindexableSize(classArray(self), 2, self);
			firstAsLargeInteger = popRemappableOop(self)
#endif /* SPURVM */
;
			if (!(result == null)) {
				stObjectatput(result, 1, integerObjectOf(0, self), self);
				stObjectatput(result, 2, firstAsLargeInteger, self);
			}
			_return_value = result;
			goto l3;
		}
		d = 32 - (cHighBit32(cDigitOfat(((unsigned int *) (firstIndexableField(secondAsLargeInteger, self))), secondDigitLen - 1, self), self));
		
#if SPURVM
		div = digitLshift(secondAsLargeInteger, d, self);
		if (!(div == null)) {
			div = largeIntgrowTo(div, ((((slotSizeOf(div, self)) + 3) / 4) + 1) * 4, self);
		}
		if (!(div)) {
			_return_value = div;
			goto l3;
		}

#else /* SPURVM */
		pushRemappableOop(firstAsLargeInteger, self);
		div = digitLshift(secondAsLargeInteger, d, self);
		if (!(div == null)) {
			div = largeIntgrowTo(div, ((((slotSizeOf(div, self)) + 3) / 4) + 1) * 4, self);
		}
		if (!(div)) {
			_return_value = div;
			goto l3;
		}
		firstAsLargeInteger = popRemappableOop(self)
#endif /* SPURVM */
;
		
#if SPURVM
		rem = digitLshift(firstAsLargeInteger, d, self);
		if (!(rem == null)) {
			if ((((slotSizeOf(rem, self)) + 3) / 4) == firstDigitLen) {
				rem = largeIntgrowTo(rem, (firstDigitLen + 1) * 4, self);
			}
		}
		if (!(rem)) {
			_return_value = rem;
			goto l3;
		}

#else /* SPURVM */
		pushRemappableOop(div, self);
		rem = digitLshift(firstAsLargeInteger, d, self);
		if (!(rem == null)) {
			if ((((slotSizeOf(rem, self)) + 3) / 4) == firstDigitLen) {
				rem = largeIntgrowTo(rem, (firstDigitLen + 1) * 4, self);
			}
		}
		if (!(rem)) {
			_return_value = rem;
			goto l3;
		}
		div = popRemappableOop(self)
#endif /* SPURVM */
;
		
#if SPURVM
		/* begin createLargeIntegerNeg:digitLength: */
		quo = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), quoDigitLen * 4, self);

#else /* SPURVM */
		pushRemappableOop(div, self);
		pushRemappableOop(rem, self);
		/* begin createLargeIntegerNeg:digitLength: */
		quo = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), quoDigitLen * 4, self);
		rem = popRemappableOop(self);
		div = popRemappableOop(self)
#endif /* SPURVM */
;
		/* begin cDigitDiv:len:rem:len:quo:len: */
		pDiv = ((unsigned int *) (firstIndexableField(div, self)));
		divLen = ((slotSizeOf(div, self)) + 3) / 4;
		pRem = ((unsigned int *) (firstIndexableField(rem, self)));
		remLen = ((slotSizeOf(rem, self)) + 3) / 4;
		pQuo = ((unsigned int *) (firstIndexableField(quo, self)));
		quoLen = ((slotSizeOf(quo, self)) + 3) / 4;

		/* Last actual byte of data (ST ix) */
		dl = divLen - 1;
		ql = quoLen;
		dh = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[dl - 1]));
		if (dl == 1) {
			dnh = 0;
		}
		else {
			dnh = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[dl - 2]));
		}
		for (k = 1; k <= ql; k += 1) {

			/* maintain quo*arg+rem=self */
			/* Estimate rem/div by dividing the leading two unint32 of rem by dh. */
			/* The estimate is q = qhi*16r100000000+qlo, where qhi and qlo are uint32. */

			/* r1 := rem digitAt: j. */
			j = (remLen + 1) - k;
			if ((SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 1]))) == dh) {
				q = 0xFFFFFFFFU;
			}
			else {

				/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.
				   Note that r1,r2 are uint64, not uint32. */
				/* r2 := (rem digitAt: j - 2). */
				r1r2 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 1]));
				r1r2 = (r1r2 << 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 2])));
				t = r1r2 % dh;

				/* Next compute (hi,lo) := q*dnh */
				q = r1r2 / dh;
				mul = q * dnh;
				hi = mul >> 32;

				/* Correct overestimate of q.
				   Max of 2 iterations through loop -- see Knuth vol. 2 */
				lo = mul & 0xFFFFFFFFU;
				if (j < 3) {
					r3 = 0;
				}
				else {
					r3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[j - 3]));
				}
				while (1) {
					if ((t < hi)
					 || ((t == hi)
					 && (r3 < lo))) {

						/* i.e. (t,r3) < (hi,lo) */
						q -= 1;
						if (hi == 0) {

							/* since hi is unsigned we must have this guard */
							cond = 0;
						}
						else {
							if (lo < dnh) {
								hi -= 1;
								lo = (lo + 0x100000000LL) - dnh;
							}
							else {
								lo -= dnh;
							}
							cond = hi >= dh;
						}
					}
					else {
						cond = 0;
					}
					if (!(cond)) break;
					hi -= dh;
				}
			}
			l = j - dl;
			a = 0;
			for (i = 1; i <= divLen; i += 1) {
				hi = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1]))) * (q >> 32);
				lo = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1]))) * (q & 0xFFFFFFFFU);
				b = ((SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[l - 1]))) - a) - (lo & 0xFFFFFFFFU);
				pRem[l - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((b & 0xFFFFFFFFU)));
				b = (b >> 32) | ((0 - (b >> 0x3F)) & 0xFFFFFFFF00000000ULL);
				a = (hi + (lo >> 32)) - b;
				l += 1;
			}
			if (a > 0) {

				/* Add div back into rem, decrease q by 1 */
				q -= 1;
				l = j - dl;
				a = 0;
				for (i = 1; i <= divLen; i += 1) {
					a = ((a >> 32) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRem[l - 1])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pDiv[i - 1])));
					pRem[l - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((a & 0xFFFFFFFFU)));
					l += 1;
				}
			}
			pQuo[quoLen - k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) q))));
		}
		
#if SPURVM
		rem = digitRshiftlookfirst(rem, d, (((slotSizeOf(div, self)) + 3) / 4) - 1, self);

#else /* SPURVM */
		pushRemappableOop(quo, self);
		rem = digitRshiftlookfirst(rem, d, (((slotSizeOf(div, self)) + 3) / 4) - 1, self);
		quo = popRemappableOop(self)
#endif /* SPURVM */
;
		
#if SPURVM
		result = instantiateClassindexableSize(classArray(self), 2, self);

#else /* SPURVM */
		pushRemappableOop(quo, self);
		pushRemappableOop(rem, self);
		result = instantiateClassindexableSize(classArray(self), 2, self);
		rem = popRemappableOop(self);
		quo = popRemappableOop(self)
#endif /* SPURVM */
;
		if (!(result == null)) {
			stObjectatput(result, 1, quo, self);
			stObjectatput(result, 2, rem, self);
		}
		_return_value = result;
	l3:	/* end digitDivLarge:with:negative: */;
		if (!(failed(self))) {
			popthenPush(3, _return_value, self);
		}
	}
	return null;
}

	/* LargeIntegersPlugin>>#primDigitMultiply:negative: */
EXPORT(sqInt)
primDigitMultiplyNegative(struct foo * self)
{
	unsigned long long ab;
	unsigned int carry;
	unsigned int digit;
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt firstLen;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt limitLong;
	sqInt limitShort;
	sqInt longInt;
	sqInt longLen;
	sqInt neg;
	sqInt prod;
	unsigned int *pWordLong;
	unsigned int *pWordRes;
	unsigned int *pWordShort;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt secondLen;
	sqInt shortInt;
	sqInt shortLen;
	sqInt _return_value;

	if (!((isKindOfInteger(stackValue(1, self), self))
		 && (isBooleanObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(1, self);
	neg = booleanValueOf(stackValue(0, self), self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(2, self), self), self);
	firstInteger = stackValue(2, self);
	if (failed(self)) {
		return null;
	}
	if (isIntegerObject(firstInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger, self);

#else /* SPURVM */
		pushRemappableOop(secondInteger, self);
		firstLarge = createLargeFromSmallInteger(firstInteger, self);
		secondInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger, self);

#else /* SPURVM */
		pushRemappableOop(firstLarge, self);
		secondLarge = createLargeFromSmallInteger(secondInteger, self);
		firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (!(failed(self))) {
		/* begin digitMultiplyLarge:with:negative: */
		firstLen = slotSizeOf(firstLarge, self);
		/* begin byteSizeOfLargeInt: */
		secondLen = slotSizeOf(secondLarge, self);
		if (firstLen <= secondLen) {
			shortInt = firstLarge;
			shortLen = firstLen;
			longInt = secondLarge;
			longLen = secondLen;
		}
		else {
			shortInt = secondLarge;
			shortLen = secondLen;
			longInt = firstLarge;
			longLen = firstLen;
		}
		
#if SPURVM
		/* begin createLargeIntegerNeg:byteLength: */
		prod = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), longLen + shortLen, self);

#else /* SPURVM */
		pushRemappableOop(shortInt, self);
		pushRemappableOop(longInt, self);
		/* begin createLargeIntegerNeg:byteLength: */
		prod = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), longLen + shortLen, self);
		longInt = popRemappableOop(self);
		shortInt = popRemappableOop(self)
#endif /* SPURVM */
;
		if (!(prod)) {
			_return_value = primitiveFailFor(PrimErrNoMemory, self);
			goto l5;
		}
		/* begin cDigitMultiply:len:with:len:into:len: */
		pWordShort = ((unsigned int *) (firstIndexableField(shortInt, self)));
		pWordLong = ((unsigned int *) (firstIndexableField(longInt, self)));
		pWordRes = ((unsigned int *) (firstIndexableField(prod, self)));
		if ((((shortLen + 3) / 4) == 1)
		 && ((pWordShort[0]) == 0)) {
			goto l4;
		}
		if ((((longLen + 3) / 4) == 1)
		 && ((pWordLong[0]) == 0)) {
			goto l4;
		}
		limitShort = ((shortLen + 3) / 4) - 1;
		limitLong = ((longLen + 3) / 4) - 1;
		for (i = 0; i <= limitShort; i += 1) {
			if (((digit = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordShort[i])))) != 0) {
				k = i;

				/* Loop invariant: 0<=carry<=16rFFFFFFFF, k=i+j-1 (ST) */
				/* -> Loop invariant: 0<=carry<=16rFFFFFFFF, k=i+j (C) (?) */
				carry = 0;
				for (j = 0; j <= limitLong; j += 1) {
					ab = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLong[j]));
					ab = ((ab * digit) + carry) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordRes[k])));
					carry = ab >> 32;
					pWordRes[k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((ab & 0xFFFFFFFFU)));
					k += 1;
				}
				if (k < (((longLen + shortLen) + 3) / 4)) {
					pWordRes[k] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN(carry));
				}
			}
		}
	l4:	/* end cDigitMultiply:len:with:len:into:len: */;
		_return_value = (neg
			? normalizeNegative(prod, self)
			: normalizePositive(prod, self));
	l5:	/* end digitMultiplyLarge:with:negative: */;
		if (!(failed(self))) {
			popthenPush(3, _return_value, self);
		}
	}
	return null;
}

	/* LargeIntegersPlugin>>#primDigitSubtract: */
EXPORT(sqInt)
primDigitSubtract(struct foo * self)
{
	sqInt firstDigitLen;
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt firstNeg;
	sqInt i;
	sqInt largeDigitLen;
	sqInt larger;
	int neg;
	unsigned int *pWordLarge;
	unsigned int *pWordRes;
	unsigned int *pWordSmall;
	sqInt res;
	sqInt resDigitLen;
	sqInt secondDigitLen;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt smaller;
	sqInt smallerDigitLen;
	unsigned long long z;
	sqInt _return_value;

	if (!(isKindOfInteger(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondInteger = stackValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(1, self), self), self);
	firstInteger = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	if (isIntegerObject(firstInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger, self);

#else /* SPURVM */
		pushRemappableOop(secondInteger, self);
		firstLarge = createLargeFromSmallInteger(firstInteger, self);
		secondInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondInteger, self);

#else /* SPURVM */
		pushRemappableOop(firstLarge, self);
		secondLarge = createLargeFromSmallInteger(secondInteger, self);
		firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondInteger;
	}
	if (!(failed(self))) {
		/* begin digitSubLarge:with: */
		firstNeg = isLargeNegativeIntegerObject(firstLarge, self);
		/* begin digitSizeOfLargeInt: */
		firstDigitLen = ((slotSizeOf(firstLarge, self)) + 3) / 4;
		/* begin digitSizeOfLargeInt: */
		secondDigitLen = ((slotSizeOf(secondLarge, self)) + 3) / 4;
		if (firstDigitLen == secondDigitLen) {
			while ((firstDigitLen > 1)
			 && ((cDigitOfat(((unsigned int *) (firstIndexableField(firstLarge, self))), firstDigitLen - 1, self)) == (cDigitOfat(((unsigned int *) (firstIndexableField(secondLarge, self))), firstDigitLen - 1, self)))) {
				firstDigitLen -= 1;
			}
			secondDigitLen = firstDigitLen;
		}
		if ((firstDigitLen < secondDigitLen)
		 || ((firstDigitLen == secondDigitLen)
		 && ((cDigitOfat(((unsigned int *) (firstIndexableField(firstLarge, self))), firstDigitLen - 1, self)) < (cDigitOfat(((unsigned int *) (firstIndexableField(secondLarge, self))), firstDigitLen - 1, self))))) {
			larger = secondLarge;
			largeDigitLen = secondDigitLen;
			smaller = firstLarge;
			smallerDigitLen = firstDigitLen;
			neg = firstNeg == 0;
		}
		else {
			larger = firstLarge;
			largeDigitLen = firstDigitLen;
			smaller = secondLarge;
			smallerDigitLen = secondDigitLen;
			neg = firstNeg;
		}
		resDigitLen = largeDigitLen;
		
#if SPURVM
		/* begin createLargeIntegerNeg:digitLength: */
		res = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), resDigitLen * 4, self);

#else /* SPURVM */
		pushRemappableOop(smaller, self);
		pushRemappableOop(larger, self);
		/* begin createLargeIntegerNeg:digitLength: */
		res = instantiateClassindexableSize((neg
			? classLargeNegativeInteger(self)
			: classLargePositiveInteger(self)), resDigitLen * 4, self);
		larger = popRemappableOop(self);
		smaller = popRemappableOop(self)
#endif /* SPURVM */
;
		if (!(res)) {
			_return_value = primitiveFailFor(PrimErrNoMemory, self);
			goto l7;
		}
		/* begin cDigitSub:len:with:len:into: */
		pWordSmall = ((unsigned int *) (firstIndexableField(smaller, self)));
		pWordLarge = ((unsigned int *) (firstIndexableField(larger, self)));
		pWordRes = ((unsigned int *) (firstIndexableField(res, self)));
		z = 0;
		for (i = 0; i < smallerDigitLen; i += 1) {
			z = (z + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLarge[i])))) - (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordSmall[i])));
			/* begin cDigitOf:at:put: */
			pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) (z & 0xFFFFFFFFU)))));
			z = 0 - (z >> 0x3F);
		}
		for (i = smallerDigitLen; i < largeDigitLen; i += 1) {
			z += SQ_SWAP_4_BYTES_IF_BIGENDIAN((pWordLarge[i]));
			/* begin cDigitOf:at:put: */
			pWordRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) (z & 0xFFFFFFFFU)))));
			z = 0 - (z >> 0x3F);
		}
		_return_value = (neg
			? normalizeNegative(res, self)
			: normalizePositive(res, self));
	l7:	/* end digitSubLarge:with: */;
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}


/*	If calling this primitive fails, then C module does not exist. */

	/* LargeIntegersPlugin>>#primGetModuleName */
EXPORT(sqInt)
primGetModuleName(struct foo * self)
{
	sqInt strLen;
	sqInt strOop;

	/* missing DebugCode */;
	strLen = strlen(getModuleName());
	strOop = instantiateClassindexableSize(classString(self), strLen, self);
	strncpy(firstIndexableField(strOop, self), getModuleName(), strLen);
	if (!(failed(self))) {
		popthenPush(1, strOop, self);
	}
	return null;
}

	/* LargeIntegersPlugin>>#primMontgomeryDigitLength */
EXPORT(sqInt)
primMontgomeryDigitLength(struct foo * self)
{
	sqInt _return_value;

	/* missing DebugCode */;
	if (!(failed(self))) {
		_return_value = integerObjectOf(32, self);
		if (!(failed(self))) {
			popthenPush(1, _return_value, self);
		}
	}
	return null;
}

	/* LargeIntegersPlugin>>#primMontgomeryTimes:modulo:mInvModB: */
EXPORT(sqInt)
primMontgomeryTimesModulo(struct foo * self)
{
	unsigned long long accum;
	unsigned long long accum2;
	unsigned long long accum3;
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt firstLen;
	sqInt i;
	sqInt k;
	unsigned int lastDigit;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned int mInv;
	sqInt mInverseInteger;
	unsigned int *pFirst;
	unsigned int *pRes;
	sqInt prod;
	unsigned int *pSecond;
	unsigned int *pThird;
	sqInt secondLarge;
	sqInt secondLen;
	sqInt secondOperandInteger;
	sqInt thirdLarge;
	sqInt thirdLen;
	sqInt thirdModuloInteger;
	unsigned long long u;
	sqInt _return_value;

	if (!((isKindOfInteger(stackValue(2, self), self))
		 && ((isKindOfInteger(stackValue(1, self), self))
		 && (isKindOfInteger(stackValue(0, self), self))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	secondOperandInteger = stackValue(2, self);
	thirdModuloInteger = stackValue(1, self);
	mInverseInteger = stackValue(0, self);
	/* missing DebugCode */;
	success(isKindOfInteger(stackValue(3, self), self), self);
	firstInteger = stackValue(3, self);
	if (failed(self)) {
		return null;
	}
	mInv = positive32BitValueOf(mInverseInteger, self);
	if (isIntegerObject(firstInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		firstLarge = createLargeFromSmallInteger(firstInteger, self);

#else /* SPURVM */
		pushRemappableOop(secondOperandInteger, self);
		pushRemappableOop(thirdModuloInteger, self);
		firstLarge = createLargeFromSmallInteger(firstInteger, self);
		thirdModuloInteger = popRemappableOop(self);
		secondOperandInteger = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondOperandInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		secondLarge = createLargeFromSmallInteger(secondOperandInteger, self);

#else /* SPURVM */
		pushRemappableOop(firstLarge, self);
		pushRemappableOop(thirdModuloInteger, self);
		secondLarge = createLargeFromSmallInteger(secondOperandInteger, self);
		thirdModuloInteger = popRemappableOop(self);
		firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		secondLarge = secondOperandInteger;
	}
	if (isIntegerObject(thirdModuloInteger, self)) {

		/* convert it to a not normalized LargeInteger */
		
#if SPURVM
		thirdLarge = createLargeFromSmallInteger(thirdModuloInteger, self);

#else /* SPURVM */
		pushRemappableOop(firstLarge, self);
		pushRemappableOop(secondLarge, self);
		thirdLarge = createLargeFromSmallInteger(thirdModuloInteger, self);
		secondLarge = popRemappableOop(self);
		firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
	}
	else {
		thirdLarge = thirdModuloInteger;
	}
	if (!(failed(self))) {
		/* begin digitMontgomery:times:modulo:mInvModB: */
		firstLen = ((slotSizeOf(firstLarge, self)) + 3) / 4;
		secondLen = ((slotSizeOf(secondLarge, self)) + 3) / 4;
		thirdLen = ((slotSizeOf(thirdLarge, self)) + 3) / 4;
		if (!((firstLen <= thirdLen)
			 && (secondLen <= thirdLen))) {
			_return_value = primitiveFail(self);
			goto l2;
		}
		
#if SPURVM
		prod = instantiateClassindexableSize(classLargePositiveInteger(self), thirdLen * 4, self);

#else /* SPURVM */
		pushRemappableOop(firstLarge, self);
		pushRemappableOop(secondLarge, self);
		pushRemappableOop(thirdLarge, self);
		prod = instantiateClassindexableSize(classLargePositiveInteger(self), thirdLen * 4, self);
		thirdLarge = popRemappableOop(self);
		secondLarge = popRemappableOop(self);
		firstLarge = popRemappableOop(self)
#endif /* SPURVM */
;
		if (!(prod)) {
			_return_value = primitiveFailFor(PrimErrNoMemory, self);
			goto l2;
		}
		/* begin cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
		pFirst = ((unsigned int *) (firstIndexableField(firstLarge, self)));
		pSecond = ((unsigned int *) (firstIndexableField(secondLarge, self)));
		pThird = ((unsigned int *) (firstIndexableField(thirdLarge, self)));
		pRes = ((unsigned int *) (firstIndexableField(prod, self)));
		limit1 = firstLen - 1;
		limit2 = secondLen - 1;
		limit3 = thirdLen - 1;
		lastDigit = 0;
		for (i = 0; i <= limit1; i += 1) {
			accum3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFirst[i]));
			accum3 = (accum3 * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pSecond[0])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[0])));
			u = (accum3 * mInv) & 0xFFFFFFFFU;
			accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[0])));
			accum = (accum2 & 0xFFFFFFFFU) + (accum3 & 0xFFFFFFFFU);
			accum = ((accum >> 32) + (accum2 >> 32)) + (accum3 >> 32);
			for (k = 1; k <= limit2; k += 1) {
				accum3 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pFirst[i]));
				accum3 = (accum3 * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pSecond[k])))) + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])));
				accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
				accum = (accum + (accum2 & 0xFFFFFFFFU)) + (accum3 & 0xFFFFFFFFU);
				pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
				accum = ((accum >> 32) + (accum2 >> 32)) + (accum3 >> 32);
			}
			for (k = secondLen; k <= limit3; k += 1) {
				accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
				accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])))) + (accum2 & 0xFFFFFFFFU);
				pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
				accum = (accum >> 32) + (accum2 >> 32);
			}
			accum += lastDigit;
			pRes[limit3] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			lastDigit = accum >> 32;
		}
		for (i = firstLen; i <= limit3; i += 1) {
			accum = SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[0]));
			u = (accum * mInv) & 0xFFFFFFFFU;
			accum += u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[0])));
			accum = accum >> 32;
			for (k = 1; k <= limit3; k += 1) {
				accum2 = u * (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[k])));
				accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[k])))) + (accum2 & 0xFFFFFFFFU);
				pRes[k - 1] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
				accum = (accum >> 32) + (accum2 >> 32);
			}
			accum += lastDigit;
			pRes[limit3] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
			lastDigit = accum >> 32;
		}
		if (!((lastDigit == 0)
			 && ((cDigitComparewithlen(pThird, pRes, thirdLen, self)) == 1))) {

			/* self cDigitSub: pThird len: thirdLen with: pRes len: thirdLen into: pRes */
			accum = 0;
			for (i = 0; i <= limit3; i += 1) {
				accum = (accum + (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pRes[i])))) - (SQ_SWAP_4_BYTES_IF_BIGENDIAN((pThird[i])));
				pRes[i] = (SQ_SWAP_4_BYTES_IF_BIGENDIAN((accum & 0xFFFFFFFFU)));
				accum = 0 - (accum >> 0x3F);
			}
		}
		_return_value = normalizePositive(prod, self);
	l2:	/* end digitMontgomery:times:modulo:mInvModB: */;
		if (!(failed(self))) {
			popthenPush(4, _return_value, self);
		}
	}
	return null;
}

	/* LargeIntegersPlugin>>#primNormalizeNegative */
EXPORT(sqInt)
primNormalizeNegative(struct foo * self)
{
	sqInt rcvr;
	sqInt _return_value;

	/* missing DebugCode */;
	success(isLargeNegativeIntegerObject(stackValue(0, self), self), self);
	rcvr = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		_return_value = normalizeNegative(rcvr, self);
		if (!(failed(self))) {
			popthenPush(1, _return_value, self);
		}
	}
	return null;
}

	/* LargeIntegersPlugin>>#primNormalizePositive */
EXPORT(sqInt)
primNormalizePositive(struct foo * self)
{
	sqInt rcvr;
	sqInt _return_value;

	/* missing DebugCode */;
	success(isLargePositiveIntegerObject(stackValue(0, self), self), self);
	rcvr = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		_return_value = normalizePositive(rcvr, self);
		if (!(failed(self))) {
			popthenPush(1, _return_value, self);
		}
	}
	return null;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		classArray = interpreterProxy->classArray;
		classLargeNegativeInteger = interpreterProxy->classLargeNegativeInteger;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		firstIndexableField = interpreterProxy->firstIndexableField;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
		isBooleanObject = interpreterProxy->isBooleanObject;
#else
#if !defined(isBooleanObject)
		isBooleanObject = 0;
#endif
#endif
		isIntegerObject = interpreterProxy->isIntegerObject;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stObjectatput = interpreterProxy->stObjectatput;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		success = interpreterProxy->success;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* SmartSyntaxInterpreterPlugin>>#sqAssert: */
static sqInt
sqAssert(sqInt aBool, struct foo * self)
{
	/* missing DebugCode */;
	return aBool;
}


/*	Argument bytesObj must not be aSmallInteger! */

	/* LargeIntegersPlugin>>#unsafeByteOfLargeInt:at: */
static unsigned char
unsafeByteOfLargeIntat(sqInt bytesObj, sqInt ix, struct foo * self)
{
	return (((unsigned char *) (firstIndexableField(bytesObj, self))))[ix - 1];
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "LargeIntegers";
void* LargeIntegers_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primAnyBitFromTo\000\001", (void*)primAnyBitFromTo},
	{(void*)_m, "primDigitAdd\000\001", (void*)primDigitAdd},
	{(void*)_m, "primDigitBitAnd\000\001", (void*)primDigitBitAnd},
	{(void*)_m, "primDigitBitOr\000\001", (void*)primDigitBitOr},
	{(void*)_m, "primDigitBitShiftMagnitude\000\003", (void*)primDigitBitShiftMagnitude},
	{(void*)_m, "primDigitBitXor\000\001", (void*)primDigitBitXor},
	{(void*)_m, "primDigitCompare\000\000", (void*)primDigitCompare},
	{(void*)_m, "primDigitDivNegative\000\002", (void*)primDigitDivNegative},
	{(void*)_m, "primDigitMultiplyNegative\000\001", (void*)primDigitMultiplyNegative},
	{(void*)_m, "primDigitSubtract\000\001", (void*)primDigitSubtract},
	{(void*)_m, "primGetModuleName\000\377", (void*)primGetModuleName},
	{(void*)_m, "primMontgomeryDigitLength\000\377", (void*)primMontgomeryDigitLength},
	{(void*)_m, "primMontgomeryTimesModulo\000\001", (void*)primMontgomeryTimesModulo},
	{(void*)_m, "primNormalizeNegative\000\001", (void*)primNormalizeNegative},
	{(void*)_m, "primNormalizePositive\000\001", (void*)primNormalizePositive},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primAnyBitFromToAccessorDepth = 1;
EXPORT(signed char) primDigitAddAccessorDepth = 1;
EXPORT(signed char) primDigitBitAndAccessorDepth = 1;
EXPORT(signed char) primDigitBitOrAccessorDepth = 1;
EXPORT(signed char) primDigitBitShiftMagnitudeAccessorDepth = 3;
EXPORT(signed char) primDigitBitXorAccessorDepth = 1;
EXPORT(signed char) primDigitCompareAccessorDepth = 0;
EXPORT(signed char) primDigitDivNegativeAccessorDepth = 2;
EXPORT(signed char) primDigitMultiplyNegativeAccessorDepth = 1;
EXPORT(signed char) primDigitSubtractAccessorDepth = 1;
EXPORT(signed char) primMontgomeryTimesModuloAccessorDepth = 1;
EXPORT(signed char) primNormalizeNegativeAccessorDepth = 1;
EXPORT(signed char) primNormalizePositiveAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
