/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2498 uuid: f4233232-2c6b-452e-bdab-b814d48cc4a8
   from
	FilePlugin VMMaker.oscog-eem.2498 uuid: f4233232-2c6b-452e-bdab-b814d48cc4a8
 */
static char __buildInfo[] = "FilePlugin VMMaker.oscog-eem.2498 uuid: f4233232-2c6b-452e-bdab-b814d48cc4a8 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "FilePlugin.h"
#include "sqMemoryAccess.h"


/*** Constants ***/
#if !defined(COGMTVM) /* Allow this to be overridden on the compiler command line */
# define COGMTVM 0
#endif
#define DirBadPath 2
#define DirNoMoreEntries 1
#if !defined(PharoVM) /* Allow this to be overridden on the compiler command line */
# define PharoVM 0
#endif
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrInappropriate 6
#define PrimErrNoMemory 9
#define PrimErrObjectMayMove 14
#define PrimErrUnsupported 7
#define PrimNoErr 0
#if !defined(SPURVM) /* Allow this to be overridden on the compiler command line */
# define SPURVM 1
#endif


/*** Function Prototypes ***/
static sqInt connectToFdwrite(int fd, sqInt writeFlag);
static sqInt connectToFilewrite(void *cfile, sqInt writeFlag);
EXPORT(sqInt) fileOpenNamesizewritesecure(char *nameIndex, sqInt nameSize, sqInt writeFlag, sqInt secureFlag);
EXPORT(sqInt) fileOpenNewNamesizesecure(char *nameIndex, sqInt nameSize, sqInt secureFlag);
extern usqIntptr_t fileRecordSize(void);
extern SQFile * fileValueOf(sqInt objectPointer);
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt makeDirEntryNamesizecreateDatemodDateisDirfileSize(char *entryName, sqInt entryNameSize, sqInt createDate, sqInt modifiedDate, sqInt dirFlag, squeakFileOffsetType fileSize);
#if PharoVM
static sqInt makeDirEntryNamesizecreateDatemodDateisDirfileSizeposixPermissionsisSymlink(char *entryName, sqInt entryNameSize, sqInt createDate, sqInt modifiedDate, sqInt dirFlag, squeakFileOffsetType fileSize, sqInt posixPermissions, sqInt symlinkFlag);
#endif /* PharoVM */
EXPORT(sqInt) moduleUnloaded(char *aModuleName, struct foo * self);
static void * pointerFrom(sqInt pointerByteArray);
EXPORT(sqInt) primitiveConnectToFile(void);
EXPORT(sqInt) primitiveConnectToFileDescriptor(void);
EXPORT(sqInt) primitiveDirectoryCreate(void);
EXPORT(sqInt) primitiveDirectoryDelete(void);
EXPORT(sqInt) primitiveDirectoryDelimitor(void);
EXPORT(sqInt) primitiveDirectoryEntry(void);
EXPORT(sqInt) primitiveDirectoryGetMacTypeAndCreator(void);
EXPORT(sqInt) primitiveDirectoryLookup(void);
EXPORT(sqInt) primitiveDirectorySetMacTypeAndCreator(void);
EXPORT(sqInt) primitiveDisableFileAccess(void);
EXPORT(sqInt) primitiveFileAtEnd(void);
EXPORT(sqInt) primitiveFileClose(void);
EXPORT(sqInt) primitiveFileDelete(void);
EXPORT(sqInt) primitiveFileDescriptorType(void);
EXPORT(sqInt) primitiveFileFlush(void);
EXPORT(sqInt) primitiveFileGetPosition(void);
EXPORT(sqInt) primitiveFileOpen(void);
EXPORT(sqInt) primitiveFileOpenNew(void);
EXPORT(sqInt) primitiveFileRead(void);
static sqInt primitiveFileReadWithoutPinning(void);
static sqInt primitiveFileReadWithPinning(void);
EXPORT(sqInt) primitiveFileRename(void);
EXPORT(sqInt) primitiveFileSetPosition(void);
EXPORT(sqInt) primitiveFileSize(void);
EXPORT(sqInt) primitiveFileStdioHandles(void);
EXPORT(sqInt) primitiveFileSync(void);
EXPORT(sqInt) primitiveFileTruncate(void);
EXPORT(sqInt) primitiveFileWrite(void);
EXPORT(sqInt) primitiveHasFileAccess(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
EXPORT(sqInt) setMacFileTypeAndCreator(char *fileName, char *typeString, char *creatorString);
EXPORT(sqInt) shutdownModule(void);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop, struct foo * self);
static sqInt (*booleanValueOf)(sqInt obj, struct foo * self);
static sqInt (*byteSizeOf)(sqInt oop, struct foo * self);
static sqInt (*characterObjectOf)(sqInt characterCode, struct foo * self);
static sqInt (*characterTable)(struct foo * self);
static sqInt (*classArray)(struct foo * self);
static sqInt (*classByteArray)(struct foo * self);
static sqInt (*classString)(struct foo * self);
static sqInt (*failed)(struct foo * self);
static sqInt (*falseObject)(struct foo * self);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop, struct foo * self);
static void * (*firstIndexableField)(sqInt oop, struct foo * self);
static sqInt (*fullGC)(struct foo * self);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size, struct foo * self);
static sqInt (*integerObjectOf)(sqInt value, struct foo * self);
static sqInt (*integerValueOf)(sqInt oop, struct foo * self);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName, struct foo * self);
static sqInt (*isKindOf)(sqInt oop, char *aString, struct foo * self);
static sqInt (*isBytes)(sqInt oop, struct foo * self);
static sqInt (*isIntegerObject)(sqInt objectPointer, struct foo * self);
static sqInt (*isWords)(sqInt oop, struct foo * self);
static sqInt (*isWordsOrBytes)(sqInt oop, struct foo * self);
static sqInt (*methodReturnBool)(sqInt boolean, struct foo * self);
static sqInt (*methodReturnInteger)(sqInt integer, struct foo * self);
static sqInt (*methodReturnValue)(sqInt oop, struct foo * self);
static sqInt (*nilObject)(struct foo * self);
static sqInt (*pop)(sqInt nItems, struct foo * self);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop, struct foo * self);
static sqInt (*popRemappableOop)(struct foo * self);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue, struct foo * self);
static usqInt (*positive32BitValueOf)(sqInt oop, struct foo * self);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue, struct foo * self);
static usqLong (*positive64BitValueOf)(sqInt oop, struct foo * self);
static usqIntptr_t (*positiveMachineIntegerValueOf)(sqInt oop, struct foo * self);
static sqInt (*primitiveFail)(struct foo * self);
static sqInt (*primitiveFailFor)(sqInt reasonCode, struct foo * self);
static sqInt (*primitiveFailForOSError)(sqLong osError, struct foo * self);
static sqInt (*primitiveFailureCode)(struct foo * self);
static sqInt (*pushRemappableOop)(sqInt oop, struct foo * self);
static sqInt (*slotSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stackIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackValue)(sqInt offset, struct foo * self);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer, struct foo * self);
static void (*tenuringIncrementalGC)(struct foo * self);
static sqInt (*topRemappableOop)(struct foo * self);
static sqInt (*trueObject)(struct foo * self);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop, struct foo * self);
extern sqInt booleanValueOf(sqInt obj, struct foo * self);
extern sqInt byteSizeOf(sqInt oop, struct foo * self);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt characterObjectOf(sqInt characterCode, struct foo * self);
#else
# define characterObjectOf(characterCode) 0
#endif
extern sqInt characterTable(struct foo * self);
extern sqInt classArray(struct foo * self);
extern sqInt classByteArray(struct foo * self);
extern sqInt classString(struct foo * self);
extern sqInt failed(struct foo * self);
extern sqInt falseObject(struct foo * self);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop, struct foo * self);
extern void * firstIndexableField(sqInt oop, struct foo * self);
extern sqInt fullGC(struct foo * self);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern sqInt integerValueOf(sqInt oop, struct foo * self);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern sqInt isKindOf(sqInt oop, char *aString, struct foo * self);
extern sqInt isBytes(sqInt oop, struct foo * self);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer, struct foo * self);
#endif
extern sqInt isWords(sqInt oop, struct foo * self);
extern sqInt isWordsOrBytes(sqInt oop, struct foo * self);
extern sqInt methodReturnBool(sqInt boolean, struct foo * self);
extern sqInt methodReturnInteger(sqInt integer, struct foo * self);
extern sqInt methodReturnValue(sqInt oop, struct foo * self);
extern sqInt nilObject(struct foo * self);
extern sqInt pop(sqInt nItems, struct foo * self);
extern sqInt popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt popRemappableOop(struct foo * self);
extern sqInt positive32BitIntegerFor(unsigned int integerValue, struct foo * self);
extern usqInt positive32BitValueOf(sqInt oop, struct foo * self);
extern sqInt positive64BitIntegerFor(usqLong integerValue, struct foo * self);
extern usqLong positive64BitValueOf(sqInt oop, struct foo * self);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop, struct foo * self);
extern sqInt primitiveFail(struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 14)
extern sqInt primitiveFailForOSError(sqLong osError, struct foo * self);
#else
# define primitiveFailForOSError(osError) 0
#endif
extern sqInt primitiveFailureCode(struct foo * self);
extern sqInt pushRemappableOop(sqInt oop, struct foo * self);
extern sqInt slotSizeOf(sqInt oop, struct foo * self);
extern sqInt stSizeOf(sqInt oop, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer, struct foo * self);
extern void tenuringIncrementalGC(struct foo * self);
extern sqInt topRemappableOop(struct foo * self);
extern sqInt trueObject(struct foo * self);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"FilePlugin VMMaker.oscog-eem.2498 (i)"
#else
	"FilePlugin VMMaker.oscog-eem.2498 (e)"
#endif
;
static void * sCCPfn;
static void * sCDFfn;
static void * sCDPfn;
static void * sCGFTfn;
static void * sCLPfn;
static void * sCOFfn;
static void * sCRFfn;
static void * sCSFTfn;
static void * sDFAfn;
static void * sHFAfn;



/*	Connect to the supplied file descriptor. Answer the file oop.
	On POSIX platforms this translates to fdopen().
	writeFlag must be compatible with the existing file access. */

	/* FilePlugin>>#connectToFd:write: */
static sqInt
connectToFdwrite(int fd, sqInt writeFlag)
{
    SQFile *file;
    sqInt fileOop;

	fileOop = instantiateClassindexableSize(classByteArray(interpreterProxy->interpreterState), sizeof(SQFile), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	if (!((isBytes(fileOop, interpreterProxy->interpreterState))
		 && ((byteSizeOf(fileOop, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(fileOop, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqConnectToFileDescriptor(file, fd, writeFlag);
	}
	return fileOop;
}


/*	Open the FILE* as file. Answer the file oop.
	writeFlag must be compatible with the existing file access. */

	/* FilePlugin>>#connectToFile:write: */
static sqInt
connectToFilewrite(void *cfile, sqInt writeFlag)
{
    SQFile *file;
    sqInt fileOop;

	fileOop = instantiateClassindexableSize(classByteArray(interpreterProxy->interpreterState), sizeof(SQFile), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	if (!((isBytes(fileOop, interpreterProxy->interpreterState))
		 && ((byteSizeOf(fileOop, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(fileOop, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqConnectToFile(file, cfile, writeFlag);
	}
	return fileOop;
}


/*	Open the named file, possibly checking security. Answer the file oop. */

	/* FilePlugin>>#fileOpenName:size:write:secure: */
EXPORT(sqInt)
fileOpenNamesizewritesecure(char *nameIndex, sqInt nameSize, sqInt writeFlag, sqInt secureFlag)
{
    SQFile *file;
    sqInt fileOop;
    sqInt okToOpen;

	fileOop = instantiateClassindexableSize(classByteArray(interpreterProxy->interpreterState), sizeof(SQFile), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	if (!((isBytes(fileOop, interpreterProxy->interpreterState))
		 && ((byteSizeOf(fileOop, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(fileOop, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		if (secureFlag) {

			/* If the security plugin can be loaded, use it to check for permission.
			   If not, assume it's ok */
			if (sCOFfn != 0) {
				okToOpen = ((sqInt (*) (char *, sqInt, sqInt)) sCOFfn)(nameIndex, nameSize, writeFlag);
				if (!okToOpen) {
					primitiveFail(interpreterProxy->interpreterState);
				}
			}
		}
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		sqFileOpen(file, nameIndex, nameSize, writeFlag);
	}
	return fileOop;
}


/*	Open the new named file, possibly checking security. Answer the file oop. */

	/* FilePlugin>>#fileOpenNewName:size:secure: */
EXPORT(sqInt)
fileOpenNewNamesizesecure(char *nameIndex, sqInt nameSize, sqInt secureFlag)
{
    sqInt exists;
    SQFile *file;
    sqInt fileOop;
    sqInt okToOpen;

	fileOop = instantiateClassindexableSize(classByteArray(interpreterProxy->interpreterState), sizeof(SQFile), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	if (!((isBytes(fileOop, interpreterProxy->interpreterState))
		 && ((byteSizeOf(fileOop, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(fileOop, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		if (secureFlag) {

			/* If the security plugin can be loaded, use it to check for permission.
			   If not, assume it's ok */
			if (sCOFfn != 0) {
				okToOpen = ((sqInt (*) (char *, sqInt, sqInt)) sCOFfn)(nameIndex, nameSize, true);
				if (!okToOpen) {
					primitiveFail(interpreterProxy->interpreterState);
				}
			}
		}
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		exists = 0;
		sqFileOpenNew(file, nameIndex, nameSize, &exists);
		if ((failed(interpreterProxy->interpreterState))
		 && (exists)) {
			primitiveFailFor(PrimErrInappropriate, interpreterProxy->interpreterState);
		}
	}
	return fileOop;
}


/*	Return the size of a Smalltalk file record in bytes. */

	/* FilePlugin>>#fileRecordSize */
usqIntptr_t
fileRecordSize(void)
{
	return sizeof(SQFile);
}


/*	Return a pointer to the first byte of of the file record within the given
	Smalltalk object, or nil if objectPointer is not a file record.
 */

	/* FilePlugin>>#fileValueOf: */
SQFile *
fileValueOf(sqInt objectPointer)
{
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		return null;
	}
	return firstIndexableField(objectPointer, interpreterProxy->interpreterState);
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* FilePlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{
	sCCPfn = ioLoadFunctionFrom("secCanCreatePathOfSize", "SecurityPlugin", interpreterProxy->interpreterState);
	sCDPfn = ioLoadFunctionFrom("secCanDeletePathOfSize", "SecurityPlugin", interpreterProxy->interpreterState);
	sCGFTfn = ioLoadFunctionFrom("secCanGetFileTypeOfSize", "SecurityPlugin", interpreterProxy->interpreterState);
	sCLPfn = ioLoadFunctionFrom("secCanListPathOfSize", "SecurityPlugin", interpreterProxy->interpreterState);
	sCSFTfn = ioLoadFunctionFrom("secCanSetFileTypeOfSize", "SecurityPlugin", interpreterProxy->interpreterState);
	sDFAfn = ioLoadFunctionFrom("secDisableFileAccess", "SecurityPlugin", interpreterProxy->interpreterState);
	sCDFfn = ioLoadFunctionFrom("secCanDeleteFileOfSize", "SecurityPlugin", interpreterProxy->interpreterState);
	sCOFfn = ioLoadFunctionFrom("secCanOpenFileOfSizeWritable", "SecurityPlugin", interpreterProxy->interpreterState);
	sCRFfn = ioLoadFunctionFrom("secCanRenameFileOfSize", "SecurityPlugin", interpreterProxy->interpreterState);
	sHFAfn = ioLoadFunctionFrom("secHasFileAccess", "SecurityPlugin", interpreterProxy->interpreterState);
	return sqFileInit();
}

	/* FilePlugin>>#makeDirEntryName:size:createDate:modDate:isDir:fileSize: */
static sqInt
makeDirEntryNamesizecreateDatemodDateisDirfileSize(char *entryName, sqInt entryNameSize, sqInt createDate, sqInt modifiedDate, sqInt dirFlag, squeakFileOffsetType fileSize)
{
    sqInt createDateOop;
    sqInt fileSizeOop;
    sqInt i;
    sqInt modDateOop;
    sqInt nameString;
    sqInt results;
    char *stringPtr;


	/* allocate storage for results, remapping newly allocated
	   oops if required in case GC happens during allocation */
	results = instantiateClassindexableSize(classArray(interpreterProxy->interpreterState), 5, interpreterProxy->interpreterState);
	
#if SPURVM
	nameString = instantiateClassindexableSize(classString(interpreterProxy->interpreterState), entryNameSize, interpreterProxy->interpreterState);
	createDateOop = positive32BitIntegerFor(createDate, interpreterProxy->interpreterState);
	modDateOop = positive32BitIntegerFor(modifiedDate, interpreterProxy->interpreterState);
	fileSizeOop = positive64BitIntegerFor(fileSize, interpreterProxy->interpreterState);

#else /* SPURVM */
	pushRemappableOop(results, interpreterProxy->interpreterState);
	nameString = instantiateClassindexableSize(classString(interpreterProxy->interpreterState), entryNameSize, interpreterProxy->interpreterState);
		pushRemappableOop(nameString, interpreterProxy->interpreterState);
	createDateOop = positive32BitIntegerFor(createDate, interpreterProxy->interpreterState);
		pushRemappableOop(createDateOop, interpreterProxy->interpreterState);
	modDateOop = positive32BitIntegerFor(modifiedDate, interpreterProxy->interpreterState);
		pushRemappableOop(modDateOop, interpreterProxy->interpreterState);
	fileSizeOop = positive64BitIntegerFor(fileSize, interpreterProxy->interpreterState);
	modDateOop = popRemappableOop(interpreterProxy->interpreterState);
	createDateOop = popRemappableOop(interpreterProxy->interpreterState);
	nameString = popRemappableOop(interpreterProxy->interpreterState);
	results = popRemappableOop(interpreterProxy->interpreterState)
#endif /* SPURVM */
;
	stringPtr = firstIndexableField(nameString, interpreterProxy->interpreterState);
	for (i = 0; i < entryNameSize; i += 1) {
		stringPtr[i] = (entryName[i]);
	}
	storePointerofObjectwithValue(0, results, nameString, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(1, results, createDateOop, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(2, results, modDateOop, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(3, results, (dirFlag
		? trueObject(interpreterProxy->interpreterState)
		: falseObject(interpreterProxy->interpreterState)), interpreterProxy->interpreterState);
	storePointerofObjectwithValue(4, results, fileSizeOop, interpreterProxy->interpreterState);
	return results;
}

	/* FilePlugin>>#makeDirEntryName:size:createDate:modDate:isDir:fileSize:posixPermissions:isSymlink: */
#if PharoVM
static sqInt
makeDirEntryNamesizecreateDatemodDateisDirfileSizeposixPermissionsisSymlink(char *entryName, sqInt entryNameSize, sqInt createDate, sqInt modifiedDate, sqInt dirFlag, squeakFileOffsetType fileSize, sqInt posixPermissions, sqInt symlinkFlag)
{
    sqInt createDateOop;
    sqInt fileSizeOop;
    sqInt i;
    sqInt modDateOop;
    sqInt nameString;
    sqInt posixPermissionsOop;
    sqInt results;
    char *stringPtr;


	/* allocate storage for results, remapping newly allocated
	   oops if required in case GC happens during allocation */
	results = instantiateClassindexableSize(classArray(interpreterProxy->interpreterState), 7, interpreterProxy->interpreterState);
	
#if SPURVM
	nameString = instantiateClassindexableSize(classString(interpreterProxy->interpreterState), entryNameSize, interpreterProxy->interpreterState);
	createDateOop = positive32BitIntegerFor(createDate, interpreterProxy->interpreterState);
	modDateOop = positive32BitIntegerFor(modifiedDate, interpreterProxy->interpreterState);
	fileSizeOop = positive64BitIntegerFor(fileSize, interpreterProxy->interpreterState);
	posixPermissionsOop = positive32BitIntegerFor(posixPermissions, interpreterProxy->interpreterState);

#else /* SPURVM */
	pushRemappableOop(results, interpreterProxy->interpreterState);
	nameString = instantiateClassindexableSize(classString(interpreterProxy->interpreterState), entryNameSize, interpreterProxy->interpreterState);
		pushRemappableOop(nameString, interpreterProxy->interpreterState);
	createDateOop = positive32BitIntegerFor(createDate, interpreterProxy->interpreterState);
		pushRemappableOop(createDateOop, interpreterProxy->interpreterState);
	modDateOop = positive32BitIntegerFor(modifiedDate, interpreterProxy->interpreterState);
		pushRemappableOop(modDateOop, interpreterProxy->interpreterState);
	fileSizeOop = positive64BitIntegerFor(fileSize, interpreterProxy->interpreterState);
		pushRemappableOop(fileSizeOop, interpreterProxy->interpreterState);
	posixPermissionsOop = positive32BitIntegerFor(posixPermissions, interpreterProxy->interpreterState);
	fileSizeOop = popRemappableOop(interpreterProxy->interpreterState);
	modDateOop = popRemappableOop(interpreterProxy->interpreterState);
	createDateOop = popRemappableOop(interpreterProxy->interpreterState);
	nameString = popRemappableOop(interpreterProxy->interpreterState);
	results = popRemappableOop(interpreterProxy->interpreterState)
#endif /* SPURVM */
;
	stringPtr = firstIndexableField(nameString, interpreterProxy->interpreterState);
	for (i = 0; i < entryNameSize; i += 1) {
		stringPtr[i] = (entryName[i]);
	}
	storePointerofObjectwithValue(0, results, nameString, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(1, results, createDateOop, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(2, results, modDateOop, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(3, results, (dirFlag
		? trueObject(interpreterProxy->interpreterState)
		: falseObject(interpreterProxy->interpreterState)), interpreterProxy->interpreterState);
	storePointerofObjectwithValue(4, results, fileSizeOop, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(5, results, posixPermissionsOop, interpreterProxy->interpreterState);
	storePointerofObjectwithValue(6, results, (symlinkFlag
		? trueObject(interpreterProxy->interpreterState)
		: falseObject(interpreterProxy->interpreterState)), interpreterProxy->interpreterState);
	return results;
}
#endif /* PharoVM */


/*	The module with the given name was just unloaded.
	Make sure we have no dangling references. */

	/* FilePlugin>>#moduleUnloaded: */
EXPORT(sqInt)
moduleUnloaded(char *aModuleName, struct foo * self)
{
	if ((strcmp(aModuleName, "SecurityPlugin")) == 0) {

		/* The security plugin just shut down. How odd. */
		sCCPfn = (sCDPfn = (sCGFTfn = (sCLPfn = (sCSFTfn = (sDFAfn = (sCDFfn = (sCOFfn = (sCRFfn = (sHFAfn = 0)))))))));
	}
	return 0;
}


/*	Answer the machine address contained in anExternalAddressOop. */

	/* FilePlugin>>#pointerFrom: */
static void *
pointerFrom(sqInt pointerByteArray)
{
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;
    unsigned char *ptr;

	if (!((isKindOf(pointerByteArray, "ByteArray", interpreterProxy->interpreterState))
		 && ((stSizeOf(pointerByteArray, interpreterProxy->interpreterState)) == (sizeof(void *))))) {
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	ptr = arrayValueOf(pointerByteArray, interpreterProxy->interpreterState);
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	idx = 0;
	while (idx < (sizeof(void *))) {
		addressUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return addressUnion.address;
}


/*	Connect to the file with the supplied FILE* and writeFlag.
	FILE* must be supplied in a byte object (ByteArray) with the platform
	address size.
	writeFlag must be a boolean and compatible with the existing file access.
 */

	/* FilePlugin>>#primitiveConnectToFile */
EXPORT(sqInt)
primitiveConnectToFile(void)
{
    void *cfile;
    sqInt cfileOop;
    SQFile *file;
    sqInt fileOop;
    sqInt filePointer;
    sqInt writeFlag;

	writeFlag = booleanValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	cfileOop = stackValue(1, interpreterProxy->interpreterState);
	cfile = pointerFrom(cfileOop);
	if (failed(interpreterProxy->interpreterState)) {

		/* Ensure that the appropriate failure code has been set */
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	/* begin connectToFile:write: */
	fileOop = instantiateClassindexableSize(classByteArray(interpreterProxy->interpreterState), sizeof(SQFile), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	if (!((isBytes(fileOop, interpreterProxy->interpreterState))
		 && ((byteSizeOf(fileOop, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(fileOop, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqConnectToFile(file, cfile, writeFlag);
	}
	filePointer = fileOop;
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(filePointer, interpreterProxy->interpreterState);
	}
	return 0;
}


/*	Connect to the existing file identified by fileDescriptor.
	fileDescriptor must be an integer.
	writeFlag is aboolean indicating whether to open in read or write mode and
	must be compatible with the existing file access.
 */

	/* FilePlugin>>#primitiveConnectToFileDescriptor */
EXPORT(sqInt)
primitiveConnectToFileDescriptor(void)
{
    int fd;
    sqInt fdPointer;
    SQFile *file;
    sqInt fileOop;
    sqInt filePointer;
    sqInt writeFlag;

	writeFlag = booleanValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	fdPointer = stackValue(1, interpreterProxy->interpreterState);
	if (!(isIntegerObject(fdPointer, interpreterProxy->interpreterState))) {
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	fd = integerValueOf(fdPointer, interpreterProxy->interpreterState);
	if (failed(interpreterProxy->interpreterState)) {

		/* Ensure that the appropriate failure code has been set */
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	/* begin connectToFd:write: */
	fileOop = instantiateClassindexableSize(classByteArray(interpreterProxy->interpreterState), sizeof(SQFile), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	if (!((isBytes(fileOop, interpreterProxy->interpreterState))
		 && ((byteSizeOf(fileOop, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(fileOop, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqConnectToFileDescriptor(file, fd, writeFlag);
	}
	filePointer = fileOop;
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(filePointer, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveDirectoryCreate */
EXPORT(sqInt)
primitiveDirectoryCreate(void)
{
    sqInt dirName;
    char *dirNameIndex;
    sqInt dirNameSize;
    sqInt okToCreate;

	dirName = stackValue(0, interpreterProxy->interpreterState);
	if (!(isBytes(dirName, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	dirNameIndex = firstIndexableField(dirName, interpreterProxy->interpreterState);

	/* If the security plugin can be loaded, use it to check for permission.
	   If not, assume it's ok */
	dirNameSize = byteSizeOf(dirName, interpreterProxy->interpreterState);
	if (sCCPfn != 0) {
		okToCreate =  ((sqInt (*)(char *, sqInt))sCCPfn)(dirNameIndex, dirNameSize);
		if (!okToCreate) {
			return primitiveFail(interpreterProxy->interpreterState);
		}
	}
	if (!(dir_Create(dirNameIndex, dirNameSize))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	pop(1, interpreterProxy->interpreterState);
	return 0;
}

	/* FilePlugin>>#primitiveDirectoryDelete */
EXPORT(sqInt)
primitiveDirectoryDelete(void)
{
    sqInt dirName;
    char *dirNameIndex;
    sqInt dirNameSize;
    sqInt okToDelete;

	dirName = stackValue(0, interpreterProxy->interpreterState);
	if (!(isBytes(dirName, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	dirNameIndex = firstIndexableField(dirName, interpreterProxy->interpreterState);

	/* If the security plugin can be loaded, use it to check for permission.
	   If not, assume it's ok */
	dirNameSize = byteSizeOf(dirName, interpreterProxy->interpreterState);
	if (sCDPfn != 0) {
		okToDelete =  ((sqInt (*)(char *, sqInt))sCDPfn)(dirNameIndex, dirNameSize);
		if (!okToDelete) {
			return primitiveFail(interpreterProxy->interpreterState);
		}
	}
	if (!(dir_Delete(dirNameIndex, dirNameSize))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	pop(1, interpreterProxy->interpreterState);
	return 0;
}

	/* FilePlugin>>#primitiveDirectoryDelimitor */
EXPORT(sqInt)
primitiveDirectoryDelimitor(void)
{
    sqInt ascii;

	if ((interpreterProxy->minorVersion()) >= 13) {
		popthenPush(1, characterObjectOf(dir_Delimitor(), interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	else {
		ascii = dir_Delimitor();
		if ((ascii >= 0)
		 && (ascii <= 0xFF)) {
			popthenPush(1, fetchPointerofObject(ascii, characterTable(interpreterProxy->interpreterState), interpreterProxy->interpreterState), interpreterProxy->interpreterState);
		}
		else {
			primitiveFail(interpreterProxy->interpreterState);
		}
	}
	return 0;
}


/*	Two arguments - directory path, and simple file name;
	returns an array (see primitiveDirectoryLookup) describing the file or
	directory, or nil if it does not exist. 
	Primitive fails if the outer path does not identify a readable directory.
	(This is a lookup-by-name variant of primitiveDirectoryLookup.) */

	/* FilePlugin>>#primitiveDirectoryEntry */
EXPORT(sqInt)
primitiveDirectoryEntry(void)
{
    sqInt createDate;
    sqInt dirFlag;
    char entryName[256];
    sqInt entryNameSize;
    squeakFileOffsetType fileSize;
    sqInt modifiedDate;
    sqInt okToList;
    sqInt pathName;
    char *pathNameIndex;
    sqInt pathNameSize;
    sqInt posixPermissions;
    char *reqNameIndex;
    sqInt reqNameSize;
    sqInt requestedName;
    sqInt status;
    sqInt symlinkFlag;
    sqInt v;

	createDate = 0;
	dirFlag = 0;
	entryNameSize = 0;
	modifiedDate = 0;
	posixPermissions = 0;
	symlinkFlag = 0;
	v = 0;
	requestedName = stackValue(0, interpreterProxy->interpreterState);
	pathName = stackValue(1, interpreterProxy->interpreterState);
	if (!(isBytes(pathName, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	pathNameIndex = firstIndexableField(pathName, interpreterProxy->interpreterState);
	pathNameSize = byteSizeOf(pathName, interpreterProxy->interpreterState);
	reqNameIndex = firstIndexableField(requestedName, interpreterProxy->interpreterState);
	reqNameSize = byteSizeOf(requestedName, interpreterProxy->interpreterState);
	okToList = (sCLPfn != 0
		? ((sqInt (*)(char *, sqInt))sCLPfn)(pathNameIndex, pathNameSize)
		: 1);
	status = (okToList
		? dir_EntryLookup(pathNameIndex, pathNameSize, reqNameIndex, reqNameSize, entryName, (&entryNameSize), (&createDate), (&modifiedDate), (&dirFlag), (&fileSize), (&posixPermissions), (&symlinkFlag))
		: DirNoMoreEntries);
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	if (status == DirNoMoreEntries) {

		/* no entry; return nil */
		/* pop pathName, index, rcvr */
		popthenPush(3, nilObject(interpreterProxy->interpreterState), interpreterProxy->interpreterState);
		return null;
	}
	if (status == DirBadPath) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	popthenPush(3, 
#  if PharoVM
		makeDirEntryNamesizecreateDatemodDateisDirfileSizeposixPermissionsisSymlink(entryName, entryNameSize, createDate, modifiedDate, dirFlag, fileSize, posixPermissions, symlinkFlag)
#  else /* PharoVM */
		makeDirEntryNamesizecreateDatemodDateisDirfileSize(entryName, entryNameSize, createDate, modifiedDate, dirFlag, fileSize)
#  endif /* PharoVM */
		, interpreterProxy->interpreterState);
	return 0;
}

	/* FilePlugin>>#primitiveDirectoryGetMacTypeAndCreator */
EXPORT(sqInt)
primitiveDirectoryGetMacTypeAndCreator(void)
{
    sqInt creatorString;
    char *creatorStringIndex;
    sqInt fileName;
    char *fileNameIndex;
    sqInt fileNameSize;
    sqInt okToGet;
    sqInt typeString;
    char *typeStringIndex;

	creatorString = stackValue(0, interpreterProxy->interpreterState);
	typeString = stackValue(1, interpreterProxy->interpreterState);
	fileName = stackValue(2, interpreterProxy->interpreterState);
	if (!((isBytes(creatorString, interpreterProxy->interpreterState))
		 && ((byteSizeOf(creatorString, interpreterProxy->interpreterState)) == 4))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	if (!((isBytes(typeString, interpreterProxy->interpreterState))
		 && ((byteSizeOf(typeString, interpreterProxy->interpreterState)) == 4))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	if (!(isBytes(fileName, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	creatorStringIndex = firstIndexableField(creatorString, interpreterProxy->interpreterState);
	typeStringIndex = firstIndexableField(typeString, interpreterProxy->interpreterState);
	fileNameIndex = firstIndexableField(fileName, interpreterProxy->interpreterState);

	/* If the security plugin can be loaded, use it to check for permission.
	   If not, assume it's ok */
	fileNameSize = byteSizeOf(fileName, interpreterProxy->interpreterState);
	if (sCGFTfn != 0) {
		okToGet =  ((sqInt (*)(char *, sqInt))sCGFTfn)(fileNameIndex, fileNameSize);
		if (!okToGet) {
			return primitiveFail(interpreterProxy->interpreterState);
		}
	}
	if (!(dir_GetMacFileTypeAndCreator(fileNameIndex, fileNameSize, typeStringIndex, creatorStringIndex))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	pop(3, interpreterProxy->interpreterState);
	return 0;
}

	/* FilePlugin>>#primitiveDirectoryLookup */
EXPORT(sqInt)
primitiveDirectoryLookup(void)
{
    sqInt createDate;
    sqInt dirFlag;
    char entryName[256];
    sqInt entryNameSize;
    squeakFileOffsetType fileSize;
    sqInt index;
    sqInt modifiedDate;
    sqInt okToList;
    sqInt pathName;
    char *pathNameIndex;
    sqInt pathNameSize;
    sqInt posixPermissions;
    sqInt status;
    sqInt symlinkFlag;
    sqInt v;

	createDate = 0;
	dirFlag = 0;
	entryNameSize = 0;
	modifiedDate = 0;
	posixPermissions = 0;
	symlinkFlag = 0;
	v = 0;
	index = stackIntegerValue(0, interpreterProxy->interpreterState);
	pathName = stackValue(1, interpreterProxy->interpreterState);
	if (!(isBytes(pathName, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	pathNameIndex = firstIndexableField(pathName, interpreterProxy->interpreterState);
	pathNameSize = byteSizeOf(pathName, interpreterProxy->interpreterState);
	okToList = (sCLPfn != 0
		? ((sqInt (*)(char *, sqInt))sCLPfn)(pathNameIndex, pathNameSize)
		: 1);
	status = (okToList
		? dir_Lookup(pathNameIndex, pathNameSize, index, entryName, (&entryNameSize), (&createDate), (&modifiedDate), (&dirFlag), (&fileSize), (&posixPermissions), (&symlinkFlag))
		: DirNoMoreEntries);
	if (failed(interpreterProxy->interpreterState)) {
		return null;
	}
	if (status == DirNoMoreEntries) {

		/* no more entries; return nil */
		/* pop pathName, index, rcvr */
		popthenPush(3, nilObject(interpreterProxy->interpreterState), interpreterProxy->interpreterState);
		return null;
	}
	if (status == DirBadPath) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	popthenPush(3, 
#  if PharoVM
		makeDirEntryNamesizecreateDatemodDateisDirfileSizeposixPermissionsisSymlink(entryName, entryNameSize, createDate, modifiedDate, dirFlag, fileSize, posixPermissions, symlinkFlag)
#  else /* PharoVM */
		makeDirEntryNamesizecreateDatemodDateisDirfileSize(entryName, entryNameSize, createDate, modifiedDate, dirFlag, fileSize)
#  endif /* PharoVM */
		, interpreterProxy->interpreterState);
	return 0;
}

	/* FilePlugin>>#primitiveDirectorySetMacTypeAndCreator */
EXPORT(sqInt)
primitiveDirectorySetMacTypeAndCreator(void)
{
    sqInt creatorString;
    char *creatorStringIndex;
    sqInt fileName;
    char *fileNameIndex;
    sqInt fileNameSize;
    sqInt okToSet;
    sqInt typeString;
    char *typeStringIndex;

	creatorString = stackValue(0, interpreterProxy->interpreterState);
	typeString = stackValue(1, interpreterProxy->interpreterState);
	fileName = stackValue(2, interpreterProxy->interpreterState);
	if (!((isBytes(creatorString, interpreterProxy->interpreterState))
		 && ((isBytes(typeString, interpreterProxy->interpreterState))
		 && ((isBytes(fileName, interpreterProxy->interpreterState))
		 && (((byteSizeOf(creatorString, interpreterProxy->interpreterState)) == 4)
		 && ((byteSizeOf(typeString, interpreterProxy->interpreterState)) == 4)))))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	creatorStringIndex = firstIndexableField(creatorString, interpreterProxy->interpreterState);
	typeStringIndex = firstIndexableField(typeString, interpreterProxy->interpreterState);
	fileNameIndex = firstIndexableField(fileName, interpreterProxy->interpreterState);

	/* If the security plugin can be loaded, use it to check for permission.
	   If not, assume it's ok */
	fileNameSize = byteSizeOf(fileName, interpreterProxy->interpreterState);
	if (sCSFTfn != 0) {
		okToSet = ((sqInt (*)(char *, sqInt))sCSFTfn)(fileNameIndex, fileNameSize);
		if (!okToSet) {
			return primitiveFail(interpreterProxy->interpreterState);
		}
	}
	if (!(dir_SetMacFileTypeAndCreator(fileNameIndex, fileNameSize, typeStringIndex, creatorStringIndex))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	pop(3, interpreterProxy->interpreterState);
	return 0;
}


/*	If the security plugin can be loaded, use it to turn off file access
	If not, assume it's ok */

	/* FilePlugin>>#primitiveDisableFileAccess */
EXPORT(sqInt)
primitiveDisableFileAccess(void)
{
	if (sDFAfn != 0) {
		((sqInt (*)(void))sDFAfn)();
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileAtEnd */
EXPORT(sqInt)
primitiveFileAtEnd(void)
{
    sqInt atEnd;
    SQFile *file;
    sqInt objectPointer;

	atEnd = 0;
	/* begin fileValueOf: */
	objectPointer = stackValue(0, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		atEnd = sqFileAtEnd(file);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnBool(atEnd, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileClose */
EXPORT(sqInt)
primitiveFileClose(void)
{
    SQFile *file;
    sqInt objectPointer;

	/* begin fileValueOf: */
	objectPointer = stackValue(0, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqFileClose(file);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(1, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileDelete */
EXPORT(sqInt)
primitiveFileDelete(void)
{
    char *nameIndex;
    sqInt namePointer;
    sqInt nameSize;
    sqInt okToDelete;

	namePointer = stackValue(0, interpreterProxy->interpreterState);
	if (!(isBytes(namePointer, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	nameIndex = firstIndexableField(namePointer, interpreterProxy->interpreterState);

	/* If the security plugin can be loaded, use it to check for permission.
	   If not, assume it's ok */
	nameSize = byteSizeOf(namePointer, interpreterProxy->interpreterState);
	if (sCDFfn != 0) {
		okToDelete =  ((sqInt (*)(char *, sqInt))sCDFfn)(nameIndex, nameSize);
		if (!okToDelete) {
			return primitiveFail(interpreterProxy->interpreterState);
		}
	}
	sqFileDeleteNameSize(nameIndex, nameSize);
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(1, interpreterProxy->interpreterState);
	}
	return 0;
}


/*	Allow to test if the standard input/output files are from a console or not
	Return values:
	* -1 - Error
	* 0 - no console (windows only)
	* 1 - normal terminal (unix terminal / windows console)
	* 2 - pipe
	* 3 - file
	* 4 - cygwin terminal (windows only) */

	/* FilePlugin>>#primitiveFileDescriptorType */
EXPORT(sqInt)
primitiveFileDescriptorType(void)
{
    int fd;
    sqInt fdPointer;
    sqInt fileType;

	fdPointer = stackValue(0, interpreterProxy->interpreterState);
	if (!(isIntegerObject(fdPointer, interpreterProxy->interpreterState))) {
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	fd = integerValueOf(fdPointer, interpreterProxy->interpreterState);
	if (failed(interpreterProxy->interpreterState)) {

		/* Ensure that the appropriate failure code has been set */
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	fileType = sqFileDescriptorType(fd);
	methodReturnInteger(fileType, interpreterProxy->interpreterState);
	return 0;
}

	/* FilePlugin>>#primitiveFileFlush */
EXPORT(sqInt)
primitiveFileFlush(void)
{
    SQFile *file;
    sqInt objectPointer;

	/* begin fileValueOf: */
	objectPointer = stackValue(0, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqFileFlush(file);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(1, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileGetPosition */
EXPORT(sqInt)
primitiveFileGetPosition(void)
{
    SQFile *file;
    sqInt objectPointer;
    squeakFileOffsetType position;

	/* begin fileValueOf: */
	objectPointer = stackValue(0, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		position = sqFileGetPosition(file);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(positive64BitIntegerFor(position, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileOpen */
EXPORT(sqInt)
primitiveFileOpen(void)
{
    sqInt filePointer;
    char *nameIndex;
    sqInt namePointer;
    sqInt nameSize;
    sqInt writeFlag;

	writeFlag = booleanValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	namePointer = stackValue(1, interpreterProxy->interpreterState);
	if (!(isBytes(namePointer, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	nameIndex = firstIndexableField(namePointer, interpreterProxy->interpreterState);
	nameSize = byteSizeOf(namePointer, interpreterProxy->interpreterState);
	filePointer = fileOpenNamesizewritesecure(nameIndex, nameSize, writeFlag, 1);
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(filePointer, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileOpenNew */
EXPORT(sqInt)
primitiveFileOpenNew(void)
{
    sqInt filePointer;
    char *nameIndex;
    sqInt namePointer;
    sqInt nameSize;

	namePointer = stackValue(0, interpreterProxy->interpreterState);
	if (!(isBytes(namePointer, interpreterProxy->interpreterState))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	nameIndex = firstIndexableField(namePointer, interpreterProxy->interpreterState);
	nameSize = byteSizeOf(namePointer, interpreterProxy->interpreterState);
	filePointer = fileOpenNewNamesizesecure(nameIndex, nameSize, 1);
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(filePointer, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileRead */
EXPORT(sqInt)
primitiveFileRead(void)
{
    sqInt array;
    sqInt array1;
    sqInt bytesRead;
    sqInt bytesRead1;
    size_t count;
    size_t count1;
    size_t elementSize;
    size_t elementSize1;
    SQFile *file;
    SQFile *file1;
    sqInt objectPointer;
    sqInt objectPointer1;
    sqInt retryCount;
    size_t slotSize;
    size_t startIndex;
    size_t startIndex1;

	
#  if SPURVM
	/* begin primitiveFileReadWithPinning */
	count = positiveMachineIntegerValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	startIndex = positiveMachineIntegerValueOf(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	array = stackValue(2, interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	objectPointer = stackValue(3, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if ((failed(interpreterProxy->interpreterState))
	 || (!(isWordsOrBytes(array, interpreterProxy->interpreterState)))) {
		primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		goto l2;
	}
	slotSize = slotSizeOf(array, interpreterProxy->interpreterState);
	if (!((startIndex >= 1)
		 && (((startIndex + count) - 1) <= slotSize))) {
		primitiveFailFor(PrimErrBadIndex, interpreterProxy->interpreterState);
		goto l2;
	}
	elementSize = (slotSize == 0
		? 1
		: (byteSizeOf(array, interpreterProxy->interpreterState)) / slotSize);
	bytesRead = sqFileReadIntoAt(file, count * elementSize, ((char *) (firstIndexableField(array, interpreterProxy->interpreterState))), (startIndex - 1) * elementSize);
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(integerObjectOf(bytesRead / elementSize, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	l2:	/* end primitiveFileReadWithPinning */;
#  else /* SPURVM */
	/* begin primitiveFileReadWithoutPinning */
	retryCount = 0;
	count1 = positive32BitValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	startIndex1 = positive32BitValueOf(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	while (1) {
		array1 = stackValue(2, interpreterProxy->interpreterState);
		/* begin fileValueOf: */
		objectPointer1 = stackValue(3, interpreterProxy->interpreterState);
		if (!((isBytes(objectPointer1, interpreterProxy->interpreterState))
			 && ((byteSizeOf(objectPointer1, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
			primitiveFail(interpreterProxy->interpreterState);
			file1 = null;
			goto l3;
		}
		file1 = firstIndexableField(objectPointer1, interpreterProxy->interpreterState);
	l3:	/* end fileValueOf: */;
		if ((failed(interpreterProxy->interpreterState))
		 || (!(isWordsOrBytes(array1, interpreterProxy->interpreterState)))) {
			primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
			goto l4;
		}
		elementSize1 = (isWords(array1, interpreterProxy->interpreterState)
			? 4
			: 1);
		if (!((startIndex1 >= 1)
			 && (((startIndex1 + count1) - 1) <= (slotSizeOf(array1, interpreterProxy->interpreterState))))) {
			primitiveFailFor(PrimErrBadIndex, interpreterProxy->interpreterState);
			goto l4;
		}
		bytesRead1 = sqFileReadIntoAt(file1, count1 * elementSize1, ((char *) (firstIndexableField(array1, interpreterProxy->interpreterState))), (startIndex1 - 1) * elementSize1);
		if (!(((primitiveFailureCode(interpreterProxy->interpreterState)) == PrimErrObjectMayMove)
		 && (((retryCount += 1)) <= 2))) break;
		tenuringIncrementalGC(interpreterProxy->interpreterState);
		primitiveFailFor(PrimNoErr, interpreterProxy->interpreterState);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(integerObjectOf(bytesRead1 / elementSize1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	l4:	/* end primitiveFileReadWithoutPinning */;
#  endif /* SPURVM */
	return 0;
}


/*	This version of primitiveFileRead is for garbage collectors without
	support for pinning.
 */

	/* FilePlugin>>#primitiveFileReadWithoutPinning */
static sqInt
primitiveFileReadWithoutPinning(void)
{
    sqInt array;
    sqInt bytesRead;
    size_t count;
    size_t elementSize;
    SQFile *file;
    sqInt objectPointer;
    sqInt retryCount;
    size_t startIndex;

	retryCount = 0;
	count = positive32BitValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	startIndex = positive32BitValueOf(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	while (1) {
		array = stackValue(2, interpreterProxy->interpreterState);
		/* begin fileValueOf: */
		objectPointer = stackValue(3, interpreterProxy->interpreterState);
		if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
			 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
			primitiveFail(interpreterProxy->interpreterState);
			file = null;
			goto l1;
		}
		file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
		if ((failed(interpreterProxy->interpreterState))
		 || (!(isWordsOrBytes(array, interpreterProxy->interpreterState)))) {
			return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
		}
		elementSize = (isWords(array, interpreterProxy->interpreterState)
			? 4
			: 1);
		if (!((startIndex >= 1)
			 && (((startIndex + count) - 1) <= (slotSizeOf(array, interpreterProxy->interpreterState))))) {
			return primitiveFailFor(PrimErrBadIndex, interpreterProxy->interpreterState);
		}
		bytesRead = sqFileReadIntoAt(file, count * elementSize, ((char *) (firstIndexableField(array, interpreterProxy->interpreterState))), (startIndex - 1) * elementSize);
		if (!(((primitiveFailureCode(interpreterProxy->interpreterState)) == PrimErrObjectMayMove)
		 && (((retryCount += 1)) <= 2))) break;
		tenuringIncrementalGC(interpreterProxy->interpreterState);
		primitiveFailFor(PrimNoErr, interpreterProxy->interpreterState);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(integerObjectOf(bytesRead / elementSize, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	return 0;
}


/*	This version of primitiveFileRead is for garbage collectors that support
	pinning. 
 */

	/* FilePlugin>>#primitiveFileReadWithPinning */
static sqInt
primitiveFileReadWithPinning(void)
{
    sqInt array;
    sqInt bytesRead;
    size_t count;
    size_t elementSize;
    SQFile *file;
    sqInt objectPointer;
    size_t slotSize;
    size_t startIndex;

	count = positiveMachineIntegerValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	startIndex = positiveMachineIntegerValueOf(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	array = stackValue(2, interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	objectPointer = stackValue(3, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if ((failed(interpreterProxy->interpreterState))
	 || (!(isWordsOrBytes(array, interpreterProxy->interpreterState)))) {
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	slotSize = slotSizeOf(array, interpreterProxy->interpreterState);
	if (!((startIndex >= 1)
		 && (((startIndex + count) - 1) <= slotSize))) {
		return primitiveFailFor(PrimErrBadIndex, interpreterProxy->interpreterState);
	}
	elementSize = (slotSize == 0
		? 1
		: (byteSizeOf(array, interpreterProxy->interpreterState)) / slotSize);
	bytesRead = sqFileReadIntoAt(file, count * elementSize, ((char *) (firstIndexableField(array, interpreterProxy->interpreterState))), (startIndex - 1) * elementSize);
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(integerObjectOf(bytesRead / elementSize, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileRename */
EXPORT(sqInt)
primitiveFileRename(void)
{
    char *newNameIndex;
    sqInt newNamePointer;
    sqInt newNameSize;
    sqInt okToRename;
    char *oldNameIndex;
    sqInt oldNamePointer;
    sqInt oldNameSize;

	newNamePointer = stackValue(0, interpreterProxy->interpreterState);
	oldNamePointer = stackValue(1, interpreterProxy->interpreterState);
	if (!((isBytes(newNamePointer, interpreterProxy->interpreterState))
		 && (isBytes(oldNamePointer, interpreterProxy->interpreterState)))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	newNameIndex = firstIndexableField(newNamePointer, interpreterProxy->interpreterState);
	newNameSize = byteSizeOf(newNamePointer, interpreterProxy->interpreterState);
	oldNameIndex = firstIndexableField(oldNamePointer, interpreterProxy->interpreterState);

	/* If the security plugin can be loaded, use it to check for rename permission.
	   If not, assume it's ok */
	oldNameSize = byteSizeOf(oldNamePointer, interpreterProxy->interpreterState);
	if (sCRFfn != 0) {
		okToRename =  ((sqInt (*)(char *, sqInt))sCRFfn)(oldNameIndex, oldNameSize);
		if (!okToRename) {
			return primitiveFail(interpreterProxy->interpreterState);
		}
	}
	sqFileRenameOldSizeNewSize(oldNameIndex, oldNameSize, newNameIndex, newNameSize);
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(2, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileSetPosition */
EXPORT(sqInt)
primitiveFileSetPosition(void)
{
    SQFile *file;
    squeakFileOffsetType newPosition;
    sqInt objectPointer;

	if ((byteSizeOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)) > (sizeof(squeakFileOffsetType))) {
		return primitiveFail(interpreterProxy->interpreterState);
	}
	newPosition = positive64BitValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	objectPointer = stackValue(1, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqFileSetPosition(file, newPosition);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(2, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileSize */
EXPORT(sqInt)
primitiveFileSize(void)
{
    SQFile *file;
    sqInt objectPointer;
    squeakFileOffsetType size;

	/* begin fileValueOf: */
	objectPointer = stackValue(0, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		size = sqFileSize(file);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(positive64BitIntegerFor(size, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	return 0;
}


/*	Answer an Array of file handles for standard in, standard out and standard
	error, with nil in entries that are unvailable, e.g. because the platform
	does not provide
	standard error, etc. Fail if an error occurs determining the stdio
	handles, if the security plugin denies access or if memory runs out. */

	/* FilePlugin>>#primitiveFileStdioHandles */
EXPORT(sqInt)
primitiveFileStdioHandles(void)
{
    SQFile fileRecords[3];
    sqInt index;
    sqInt result;
    sqInt validMask;

	if (sHFAfn != 0) {
		if (!( ((sqInt (*)(void))sHFAfn)())) {
			return primitiveFailFor(PrimErrUnsupported, interpreterProxy->interpreterState);
		}
	}
	validMask = sqFileStdioHandlesInto(fileRecords);
	if (validMask < 0) {
		return primitiveFailForOSError(validMask, interpreterProxy->interpreterState);
	}
	result = instantiateClassindexableSize(classArray(interpreterProxy->interpreterState), 3, interpreterProxy->interpreterState);
	if (result == null) {
		return primitiveFailFor(PrimErrNoMemory, interpreterProxy->interpreterState);
	}
	pushRemappableOop(result, interpreterProxy->interpreterState);
	for (index = 0; index <= 2; index += 1) {
		if ((validMask & (1U << index)) != 0) {
			result = instantiateClassindexableSize(classByteArray(interpreterProxy->interpreterState), sizeof(SQFile), interpreterProxy->interpreterState);
			if (result == null) {
				popRemappableOop(interpreterProxy->interpreterState);
				return primitiveFailFor(PrimErrNoMemory, interpreterProxy->interpreterState);
			}
			storePointerofObjectwithValue(index, topRemappableOop(interpreterProxy->interpreterState), result, interpreterProxy->interpreterState);
			memcpy(firstIndexableField(result, interpreterProxy->interpreterState), (&(fileRecords[index])), sizeof(SQFile));
		}
	}
	
#  if COGMTVM
	
#  if SPURVM
#  else /* SPURVM */
	fullGC(interpreterProxy->interpreterState);
#  endif /* SPURVM */
#  endif /* COGMTVM */
	result = popRemappableOop(interpreterProxy->interpreterState);
	methodReturnValue(result, interpreterProxy->interpreterState);
	return 0;
}

	/* FilePlugin>>#primitiveFileSync */
EXPORT(sqInt)
primitiveFileSync(void)
{
    SQFile *file;
    sqInt objectPointer;

	/* begin fileValueOf: */
	objectPointer = stackValue(0, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqFileSync(file);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(1, interpreterProxy->interpreterState);
	}
	return 0;
}


/*	ftruncate is not an ansi function so we have a macro to point to a
	suitable platform implementation
 */

	/* FilePlugin>>#primitiveFileTruncate */
EXPORT(sqInt)
primitiveFileTruncate(void)
{
    SQFile *file;
    sqInt objectPointer;
    squeakFileOffsetType truncatePosition;

	if (!(isIntegerObject(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState))) {
		if ((byteSizeOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState)) > (sizeof(squeakFileOffsetType))) {
			return primitiveFail(interpreterProxy->interpreterState);
		}
	}
	truncatePosition = positive64BitValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	objectPointer = stackValue(1, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if (!(failed(interpreterProxy->interpreterState))) {
		sqFileTruncate(file, truncatePosition);
	}
	if (!(failed(interpreterProxy->interpreterState))) {
		pop(2, interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveFileWrite */
EXPORT(sqInt)
primitiveFileWrite(void)
{
    sqInt array;
    sqInt bytesWritten;
    size_t count;
    size_t elementSize;
    SQFile *file;
    sqInt objectPointer;
    size_t slotSize;
    size_t startIndex;

	count = positiveMachineIntegerValueOf(stackValue(0, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	startIndex = positiveMachineIntegerValueOf(stackValue(1, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	array = stackValue(2, interpreterProxy->interpreterState);
	/* begin fileValueOf: */
	objectPointer = stackValue(3, interpreterProxy->interpreterState);
	if (!((isBytes(objectPointer, interpreterProxy->interpreterState))
		 && ((byteSizeOf(objectPointer, interpreterProxy->interpreterState)) == (sizeof(SQFile))))) {
		primitiveFail(interpreterProxy->interpreterState);
		file = null;
		goto l1;
	}
	file = firstIndexableField(objectPointer, interpreterProxy->interpreterState);
	l1:	/* end fileValueOf: */;
	if ((failed(interpreterProxy->interpreterState))
	 || (!(isWordsOrBytes(array, interpreterProxy->interpreterState)))) {
		return primitiveFailFor(PrimErrBadArgument, interpreterProxy->interpreterState);
	}
	slotSize = slotSizeOf(array, interpreterProxy->interpreterState);
	if (!((startIndex >= 1)
		 && (((startIndex + count) - 1) <= slotSize))) {
		return primitiveFailFor(PrimErrBadIndex, interpreterProxy->interpreterState);
	}
	elementSize = (slotSize == 0
		? 1
		: (byteSizeOf(array, interpreterProxy->interpreterState)) / slotSize);
	bytesWritten = sqFileWriteFromAt(file, count * elementSize, ((char *) (firstIndexableField(array, interpreterProxy->interpreterState))), (startIndex - 1) * elementSize);
	if (!(failed(interpreterProxy->interpreterState))) {
		methodReturnValue(integerObjectOf(bytesWritten / elementSize, interpreterProxy->interpreterState), interpreterProxy->interpreterState);
	}
	return 0;
}

	/* FilePlugin>>#primitiveHasFileAccess */
EXPORT(sqInt)
primitiveHasFileAccess(void)
{
    sqInt hasAccess;


	/* If the security plugin can be loaded, use it to check .
	   If not, assume it's ok */
	if (sHFAfn != 0) {
		hasAccess =  ((sqInt (*)(void))sHFAfn)();
	}
	else {
		hasAccess = 1;
	}
	methodReturnBool(hasAccess, interpreterProxy->interpreterState);
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		booleanValueOf = interpreterProxy->booleanValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		characterObjectOf = interpreterProxy->characterObjectOf;
#else
#if !defined(characterObjectOf)
		characterObjectOf = 0;
#endif
#endif
		characterTable = interpreterProxy->characterTable;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		fullGC = interpreterProxy->fullGC;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isKindOf = interpreterProxy->isKindOf;
		isBytes = interpreterProxy->isBytes;
		isIntegerObject = interpreterProxy->isIntegerObject;
		isWords = interpreterProxy->isWords;
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		methodReturnBool = interpreterProxy->methodReturnBool;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnValue = interpreterProxy->methodReturnValue;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		positive64BitValueOf = interpreterProxy->positive64BitValueOf;
		positiveMachineIntegerValueOf = interpreterProxy->positiveMachineIntegerValueOf;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 14)
		primitiveFailForOSError = interpreterProxy->primitiveFailForOSError;
#else
#if !defined(primitiveFailForOSError)
		primitiveFailForOSError = 0;
#endif
#endif
		primitiveFailureCode = interpreterProxy->primitiveFailureCode;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		tenuringIncrementalGC = interpreterProxy->tenuringIncrementalGC;
		topRemappableOop = interpreterProxy->topRemappableOop;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Exported entry point for the VM. Needed for image saving only and no-op on
	anything but Macs.
 */

	/* FilePlugin>>#setMacFile:Type:AndCreator: */
EXPORT(sqInt)
setMacFileTypeAndCreator(char *fileName, char *typeString, char *creatorString)
{
	return dir_SetMacFileTypeAndCreator(fileName, strlen(fileName), typeString, creatorString);
}

	/* FilePlugin>>#shutdownModule */
EXPORT(sqInt)
shutdownModule(void)
{
	return sqFileShutdown();
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "FilePlugin";
void* FilePlugin_exports[][3] = {
	{(void*)_m, "fileOpenNamesizewritesecure", (void*)fileOpenNamesizewritesecure},
	{(void*)_m, "fileOpenNewNamesizesecure", (void*)fileOpenNewNamesizesecure},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveConnectToFile\000\001", (void*)primitiveConnectToFile},
	{(void*)_m, "primitiveConnectToFileDescriptor\000\000", (void*)primitiveConnectToFileDescriptor},
	{(void*)_m, "primitiveDirectoryCreate\000\001", (void*)primitiveDirectoryCreate},
	{(void*)_m, "primitiveDirectoryDelete\000\001", (void*)primitiveDirectoryDelete},
	{(void*)_m, "primitiveDirectoryDelimitor\000\377", (void*)primitiveDirectoryDelimitor},
	{(void*)_m, "primitiveDirectoryEntry\000\001", (void*)primitiveDirectoryEntry},
	{(void*)_m, "primitiveDirectoryGetMacTypeAndCreator\000\001", (void*)primitiveDirectoryGetMacTypeAndCreator},
	{(void*)_m, "primitiveDirectoryLookup\000\001", (void*)primitiveDirectoryLookup},
	{(void*)_m, "primitiveDirectorySetMacTypeAndCreator\000\001", (void*)primitiveDirectorySetMacTypeAndCreator},
	{(void*)_m, "primitiveDisableFileAccess\000\377", (void*)primitiveDisableFileAccess},
	{(void*)_m, "primitiveFileAtEnd\000\001", (void*)primitiveFileAtEnd},
	{(void*)_m, "primitiveFileClose\000\001", (void*)primitiveFileClose},
	{(void*)_m, "primitiveFileDelete\000\001", (void*)primitiveFileDelete},
	{(void*)_m, "primitiveFileDescriptorType\000\000", (void*)primitiveFileDescriptorType},
	{(void*)_m, "primitiveFileFlush\000\001", (void*)primitiveFileFlush},
	{(void*)_m, "primitiveFileGetPosition\000\001", (void*)primitiveFileGetPosition},
	{(void*)_m, "primitiveFileOpen\000\002", (void*)primitiveFileOpen},
	{(void*)_m, "primitiveFileOpenNew\000\002", (void*)primitiveFileOpenNew},
	{(void*)_m, "primitiveFileRead\000\001", (void*)primitiveFileRead},
	{(void*)_m, "primitiveFileRename\000\001", (void*)primitiveFileRename},
	{(void*)_m, "primitiveFileSetPosition\000\001", (void*)primitiveFileSetPosition},
	{(void*)_m, "primitiveFileSize\000\001", (void*)primitiveFileSize},
	{(void*)_m, "primitiveFileStdioHandles\000\377", (void*)primitiveFileStdioHandles},
	{(void*)_m, "primitiveFileSync\000\001", (void*)primitiveFileSync},
	{(void*)_m, "primitiveFileTruncate\000\001", (void*)primitiveFileTruncate},
	{(void*)_m, "primitiveFileWrite\000\001", (void*)primitiveFileWrite},
	{(void*)_m, "primitiveHasFileAccess\000\377", (void*)primitiveHasFileAccess},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{(void*)_m, "setMacFileTypeAndCreator", (void*)setMacFileTypeAndCreator},
	{(void*)_m, "shutdownModule\000\377", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primitiveConnectToFileAccessorDepth = 1;
EXPORT(signed char) primitiveConnectToFileDescriptorAccessorDepth = 0;
EXPORT(signed char) primitiveDirectoryCreateAccessorDepth = 1;
EXPORT(signed char) primitiveDirectoryDeleteAccessorDepth = 1;
EXPORT(signed char) primitiveDirectoryEntryAccessorDepth = 1;
EXPORT(signed char) primitiveDirectoryGetMacTypeAndCreatorAccessorDepth = 1;
EXPORT(signed char) primitiveDirectoryLookupAccessorDepth = 1;
EXPORT(signed char) primitiveDirectorySetMacTypeAndCreatorAccessorDepth = 1;
EXPORT(signed char) primitiveFileAtEndAccessorDepth = 1;
EXPORT(signed char) primitiveFileCloseAccessorDepth = 1;
EXPORT(signed char) primitiveFileDeleteAccessorDepth = 1;
EXPORT(signed char) primitiveFileDescriptorTypeAccessorDepth = 0;
EXPORT(signed char) primitiveFileFlushAccessorDepth = 1;
EXPORT(signed char) primitiveFileGetPositionAccessorDepth = 1;
EXPORT(signed char) primitiveFileOpenAccessorDepth = 2;
EXPORT(signed char) primitiveFileOpenNewAccessorDepth = 2;
EXPORT(signed char) primitiveFileReadAccessorDepth = 1;
EXPORT(signed char) primitiveFileRenameAccessorDepth = 1;
EXPORT(signed char) primitiveFileSetPositionAccessorDepth = 1;
EXPORT(signed char) primitiveFileSizeAccessorDepth = 1;
EXPORT(signed char) primitiveFileSyncAccessorDepth = 1;
EXPORT(signed char) primitiveFileTruncateAccessorDepth = 1;
EXPORT(signed char) primitiveFileWriteAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
