/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2481 uuid: 43e5789a-92ab-47cd-9c5b-ffe711bbfa4e
   from
	ThreadedX64SysVFFIPlugin VMMaker.oscog-eem.2481 uuid: 43e5789a-92ab-47cd-9c5b-ffe711bbfa4e
 */
static char __buildInfo[] = "ThreadedX64SysVFFIPlugin VMMaker.oscog-eem.2481 uuid: 43e5789a-92ab-47cd-9c5b-ffe711bbfa4e " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/* ThreadedFFIPlugin class>>preambleCCode */

#include "sqAssert.h" /* for assert */
#define ThreadedFFIPlugin 1 /* to filter-out unwanted declarations from sqFFI.h */
#include "sqFFI.h" /* for logging and surface functions */
#include "sqCogStackAlignment.h" /* for STACK_ALIGN_BYTES and getsp() */

#ifdef _MSC_VER
# define alloca _alloca
#endif
#if defined(__GNUC__) && (defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__))
# define setsp(sp) asm volatile ("movl %0,%%esp" : : "m"(sp))
# elif defined(__GNUC__) && (defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64))
# define setsp(sp) asm volatile ("movq %0,%%rsp" : : "m"(sp))
# elif defined(__GNUC__) && (defined(__arm__))
# define setsp(sp) asm volatile ("ldr %%sp, %0" : : "m"(sp))
#endif
#if !defined(getsp)
# define getsp() 0
#endif 
#if !defined(setsp)
# define setsp(ignored) 0
#endif 

#if !defined(STACK_ALIGN_BYTES)
#  define STACK_ALIGN_BYTES 0
#endif /* !defined(STACK_ALIGN_BYTES) */

/* For ABI that require stack alignment greater than natural word size */
#define MUST_ALIGN_STACK (STACK_ALIGN_BYTES > sizeof(void*))

#if defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__)
/* Both Mac OS X x86 and Win32 x86 return structs of a power of two in size
 * less than or equal to eight bytes in length in registers. Linux never does so.
 */
# if __linux__
#	define WIN32_X86_STRUCT_RETURN 0
# else
#	define WIN32_X86_STRUCT_RETURN 1
# endif
# if _WIN32
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# endif
# elif defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64)
# if _WIN32 | _WIN64
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# endif
#endif /* defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__) */

#if !defined(ALLOCA_LIES_SO_SETSP_BEFORE_CALL)
# if defined(__MINGW32__) && !defined(__clang__) && (__GNUC__ >= 3) && (defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__))
    /*
     * cygwin -mno-cygwin (MinGW) gcc 3.4.x's alloca is a library routine that answers
     * %esp + xx, so the outgoing stack is offset by one or more word if uncorrected.
     * Grab the actual stack pointer to correct.
     */
#	define ALLOCA_LIES_SO_SETSP_BEFORE_CALL 1
# else
#	define ALLOCA_LIES_SO_SETSP_BEFORE_CALL 0
# endif
#endif /* !defined(ALLOCA_LIES_SO_SETSP_BEFORE_CALL) */

#if !defined(PLATFORM_API_USES_CALLEE_POPS_CONVENTION)
# define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 0
#endif

/* This alignment stuff is a hack for integerAt:put:size:signed:/primitiveFFIIntegerAt[Put].
 * The assumption right now is that all processors support unaligned access.  That only
 * holds true for x86, x86-64 & ARMv6 & later.  But this keeps us going until we can address
 * it properly.
 */
#define unalignedShortAt(a) shortAt(a)
#define unalignedShortAtput(a,v) shortAtput(a,v)
#define unalignedLong32At(a) long32At(a)
#define unalignedLong32Atput(a,v) long32Atput(a,v)
#define unalignedLong64At(a) long64At(a)
#define unalignedLong64Atput(a,v) long64Atput(a,v)

/* The dispatchOn:in:with:with: generates an unwanted call on error.  Just squash it. */
#define error(foo) 0
#ifndef SQUEAK_BUILTIN_PLUGIN
/* but print assert failures. */
void
warning(char *s, struct foo * self) { /* Print an error message but don't exit. */
	printf("\n%s\n", s);
}
#endif

/* sanitize */
#ifdef SQUEAK_BUILTIN_PLUGIN
# define EXTERN 
#else
# define EXTERN extern
#endif

/* end ThreadedFFIPlugin class>>preambleCCode */


/*** Constants ***/
#define DefaultMaxStackSize 16384
#define DisownVMForFFICall 16
#define DisownVMForThreading 32
#define ExternalFunctionArgTypesIndex 2
#define ExternalFunctionFlagsIndex 1
#define ExternalFunctionStackSizeIndex 3
#define FFIAtomicTypeMask 0xF000000
#define FFIAtomicTypeShift 24
#define FFICallFlagThreaded 0x100
#define FFICallTypeApi 1
#define FFICallTypeCDecl 0
#define FFICallTypesMask 0xFF
#define FFIErrorAddressNotFound 13
#define FFIErrorAttemptToPassVoid 14
#define FFIErrorBadAddress 11
#define FFIErrorBadArg 3
#define FFIErrorBadArgs 2
#define FFIErrorBadAtomicType 5
#define FFIErrorBadExternalFunction 17
#define FFIErrorBadExternalLibrary 16
#define FFIErrorBadReturn 10
#define FFIErrorCallFrameTooBig 19
#define FFIErrorCallType 9
#define FFIErrorCoercionFailed 6
#define FFIErrorIntAsPointer 4
#define FFIErrorInvalidPointer 18
#define FFIErrorModuleNotFound 15
#define FFIErrorNoModule 12
#define FFIErrorNotFunction 1
#define FFIErrorStructSize 8
#define FFIErrorWrongType 7
#define FFIFlagAtomic 0x40000
#define FFIFlagPointer 0x20000
#define FFIFlagStructure 0x10000
#define FFINoCalloutAvailable -1
#define FFIStructSizeMask 0xFFFF
#define FFITypeBool 1
#define FFITypeDoubleFloat 13
#define FFITypeSignedByte 3
#define FFITypeSignedChar 11
#define FFITypeSignedInt 7
#define FFITypeSignedLongLong 9
#define FFITypeSignedShort 5
#define FFITypeSingleFloat 12
#define FFITypeUnsignedByte 2
#define FFITypeUnsignedInt 6
#define FFITypeVoid 0
#define MaxNumArgs 15
#define NumFloatRegArgs 8
#define NumIntRegArgs 6
#define PrimErrBadArgument 3
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrFFIException 22
#define PrimErrNoCMemory 10
#define PrimErrNotFound 11
#define PrimErrObjectMayMove 14
#if !defined(SPURVM) /* Allow this to be overridden on the compiler command line */
# define SPURVM 1
#endif
#define WordSize 8

typedef struct {
	char *argVector;
	char *currentArg;
	char *limit;
	sqInt	structReturnSize;
	sqInt	callFlags;
	void *ffiArgSpec;
	sqInt	ffiArgSpecSize;
	sqInt	ffiArgHeader;
	sqInt	ffiRetHeader;
	sqInt	stringArgIndex;
	char *stringArgs [MaxNumArgs];
	char	integerRegisterIndex;
	char	floatRegisterIndex;
	sqInt		integerRegisters [NumIntRegArgs];
	double		floatRegisters [NumFloatRegArgs];
 } CalloutState;

#define ThreadedFFICalloutStateForX64SysV CalloutState
#define ThreadedFFICalloutStateForX64 CalloutState
#define ThreadedFFICalloutState CalloutState


typedef struct {
	sqInt	a;
	sqInt	b;
 } SixteenByteReturn;

#define ThreadedFFIX64SixteenByteReturn SixteenByteReturn



/*** Function Prototypes ***/
static sqInt atomicTypeOf(sqInt typeSpec, struct foo * self);
static void cleanupCalloutState(CalloutState *calloutState, struct foo * self);
static sqInt externalFunctionHasStackSizeSlot(struct foo * self);
static void * ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize, struct foo * self);
static sqInt ffiArgByValuein(sqInt oop, CalloutState *calloutState, struct foo * self);
static sqInt ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState, struct foo * self);
static sqInt ffiAtomicArgByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState, struct foo * self);
static sqInt ffiAtomicStructByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState, struct foo * self);
static sqInt ffiCalloutToSpecOnStackin(void *procAddr, sqInt specOnStack, CalloutState *calloutState, struct foo * self);
static sqInt ffiCallArgArrayOrNilNumArgs(sqInt externalFunction, sqInt argArrayOrNil, sqInt nArgs, struct foo * self);
static sqInt ffiCheckReturnWithin(sqInt retSpec, sqInt retClass, CalloutState *calloutState, struct foo * self);
static sqInt ffiContentsOfHandleerrCode(sqInt oop, sqInt errCode, struct foo * self);
static sqInt ffiCreateIntegralResultOopofAtomicTypein(usqLong retVal, sqInt atomicType, CalloutState *calloutState, struct foo * self);
static sqInt ffiFail(sqInt reason, struct foo * self);
static double ffiFloatValueOf(sqInt oop, struct foo * self);
static sqInt ffiIntegerValueOf(sqInt oop, struct foo * self);
static sqInt ffiLoadCalloutAddressFrom(sqInt oop, struct foo * self);
static sqInt ffiLoadCalloutAddress(sqInt lit, struct foo * self);
static sqInt ffiLoadCalloutModule(sqInt module, struct foo * self);
static void ffiLogCallout(sqInt lit, struct foo * self);
EXPORT(sqInt) ffiLogCallsTo(char *fileName, struct foo * self);
static sqInt ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushPointerin(void *pointer, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushSignedBytein(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushSignedCharin(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushSignedIntin(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushSignedLongLongOopin(sqInt oop, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushSignedLongLongin(sqLong value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushSignedShortin(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushStringOfLengthin(char *pointer, sqInt length, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushStructureofSizetypeSpecofLengthin(void *pointer, sqInt structSize, sqInt *argSpec, sqInt argSpecSize, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushUnsignedBytein(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushUnsignedCharin(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushUnsignedIntin(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushUnsignedLongLongOopin(sqInt oop, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushUnsignedLongLongin(usqLong value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushUnsignedShortin(sqInt value, CalloutState *calloutState, struct foo * self);
static sqInt ffiPushVoidin(sqInt ignored, CalloutState *calloutState, struct foo * self);
static sqInt ffiReturnCStringFrom(sqInt cPointer, struct foo * self);
static sqInt ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState, struct foo * self);
static sqInt ffiReturnStructofTypein(SixteenByteReturn sixteenByteRet, sqInt ffiRetType, CalloutState *calloutState, struct foo * self);
static sqInt ffiReturnType(sqInt specOnStack, struct foo * self);
static sqInt ffiSupportsCallingConvention(sqInt aCallingConvention, struct foo * self);
static sqInt ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType, struct foo * self);
EXPORT(const char *) getModuleName(void);
static sqInt incrementFloatRegisterIndex(CalloutState * self_in_incrementFloatRegisterIndex);
static sqInt incrementIntegerRegisterIndex(CalloutState * self_in_incrementIntegerRegisterIndex);
EXPORT(sqInt) initialiseModule(struct foo * self);
static sqInt isAlien(sqInt anOop, struct foo * self);
static sqInt isAtomicType(sqInt typeSpec, struct foo * self);
static sqInt isDirectAlien(sqInt oop, struct foo * self);
static sqInt msg(char *s, struct foo * self);
static sqInt nonRegisterStructReturnIsViaImplicitFirstArgument(struct foo * self);
EXPORT(void) primitiveCallout(struct foo * self);
EXPORT(void) primitiveCalloutWithArgs(struct foo * self);
EXPORT(sqInt) primitiveCreateManualSurface(struct foo * self);
EXPORT(sqInt) primitiveDestroyManualSurface(struct foo * self);
EXPORT(sqInt) primitiveFFIAllocate(struct foo * self);
EXPORT(sqInt) primitiveFFIDoubleAt(struct foo * self);
EXPORT(sqInt) primitiveFFIDoubleAtPut(struct foo * self);
EXPORT(sqInt) primitiveFFIFloatAt(struct foo * self);
EXPORT(sqInt) primitiveFFIFloatAtPut(struct foo * self);
EXPORT(sqInt) primitiveFFIFree(struct foo * self);
EXPORT(sqInt) primitiveFFIGetLastError(struct foo * self);
EXPORT(sqInt) primitiveFFIIntegerAt(struct foo * self);
EXPORT(sqInt) primitiveFFIIntegerAtPut(struct foo * self);
EXPORT(sqInt) primitiveForceLoad(struct foo * self);
EXPORT(sqInt) primitiveLoadSymbolFromModule(struct foo * self);
EXPORT(sqInt) primitiveLogCallsTo(struct foo * self);
EXPORT(sqInt) primitiveSetManualSurfacePointer(struct foo * self);
static sqInt returnStructInRegisters(sqInt returnStructSize);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt sizeField(sqInt oop);
static sqInt startOfData(sqInt oop);


/*** Variables ***/
static sqInt externalFunctionInstSize;
static sqInt ffiLastError;
static sqInt ffiLogEnabled;

#if defined(SQUEAK_BUILTIN_PLUGIN)

# define isIntegerObject(oop, self) ((oop) & 1)

# if SPURVM
extern sqInt classIndexOf(sqInt, struct foo *);
#	define LargeNegativeIntegerClassIndex 32
#	define LargePositiveIntegerClassIndex 33
#	if BytesPerOop == 4
#	  define isImmediate(oop, self) ((oop) & 3)
#	else
#	  define isImmediate(oop, self) ((oop) & 7)
#	endif
#	define isKindOfInteger(oop, self) (isImmediate(oop, self) ? isIntegerObject(oop, self) : (unsigned)(classIndexOf(oop, self) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeIntegerObject(oop, self) (!isImmediate(oop, self) && (unsigned)(classIndexOf(oop, self) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeNegativeIntegerObject(oop, self) (!isImmediate(oop, self) && classIndexOf(oop, self) == LargeNegativeIntegerClassIndex)
#	define isLargePositiveIntegerObject(oop, self) (!isImmediate(oop, self) && classIndexOf(oop, self) == LargePositiveIntegerClassIndex)
# endif /* SPURVM */
#endif /* defined(SQUEAK_BUILTIN_PLUGIN) */

#if !defined(isKindOfInteger)
# define isLargeNegativeIntegerObject(oop, self) (fetchClassOf(oop, self) == classLargeNegativeInteger(self))
# define isLargePositiveIntegerObject(oop, self) (fetchClassOf(oop, self) == classLargePositiveInteger(self))
# define isLargeIntegerObject(oop, self) (isLargeNegativeIntegerObject(oop, self) || isLargePositiveIntegerObject(oop, self))
# define isKindOfInteger(oop , self) (isIntegerObject(oop, self) || isLargeNegativeIntegerObject(oop, self) || isLargePositiveIntegerObject(oop, self))
#endif

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj, struct foo * self);
static sqInt (*byteSizeOf)(sqInt oop, struct foo * self);
static sqInt (*characterObjectOf)(sqInt characterCode, struct foo * self);
static sqInt (*characterValueOf)(sqInt aCharacter, struct foo * self);
static sqInt (*classAlien)(struct foo * self);
static sqInt (*classByteArray)(struct foo * self);
static sqInt (*classExternalAddress)(struct foo * self);
static sqInt (*classExternalData)(struct foo * self);
static sqInt (*classExternalFunction)(struct foo * self);
static sqInt (*classExternalLibrary)(struct foo * self);
static sqInt (*classExternalStructure)(struct foo * self);
static sqInt (*classLargePositiveInteger)(struct foo * self);
static sqInt (*classString)(struct foo * self);
static sqInt (*disownVM)(sqInt flags, struct foo * self);
static sqInt (*failed)(struct foo * self);
static sqInt (*falseObject)(struct foo * self);
static sqInt (*fetchClassOf)(sqInt oop, struct foo * self);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
static sqInt (*fetchLong32ofObject)(sqInt fieldIndex, sqInt oop, struct foo * self);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop, struct foo * self);
static void * (*firstIndexableField)(sqInt oop, struct foo * self);
static sqInt (*floatObjectOf)(double aFloat, struct foo * self);
static double (*floatValueOf)(sqInt oop, struct foo * self);
static sqInt (*includesBehaviorThatOf)(sqInt aClass, sqInt aSuperclass, struct foo * self);
static sqInt (*instanceSizeOf)(sqInt classObj, struct foo * self);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size, struct foo * self);
static sqInt (*integerObjectOf)(sqInt value, struct foo * self);
static sqInt (*integerValueOf)(sqInt oop, struct foo * self);
static void * (*ioLoadModuleOfLength)(sqInt moduleNameIndex, sqInt moduleLength, struct foo * self);
static void * (*ioLoadSymbolOfLengthFromModule)(sqInt functionNameIndex, sqInt functionLength, sqInt moduleHandle);
static sqInt (*isKindOfClass)(sqInt oop, sqInt aClass, struct foo * self);
static sqInt (*isArray)(sqInt oop, struct foo * self);
static sqInt (*isBytes)(sqInt oop, struct foo * self);
static sqInt (*isCharacterObject)(sqInt oop, struct foo * self);
static sqInt (*isFloatObject)(sqInt oop, struct foo * self);
static sqInt (*isImmediate)(sqInt anObject, struct foo * self);
static sqInt (*isInMemory)(sqInt address, struct foo * self);
static sqInt (*isIntegerObject)(sqInt objectPointer, struct foo * self);
static sqInt (*isPointers)(sqInt oop, struct foo * self);
static sqInt (*isWords)(sqInt oop, struct foo * self);
static sqInt (*isYoung)(sqInt anOop, struct foo * self);
static sqInt (*literalofMethod)(sqInt offset, sqInt methodPointer, struct foo * self);
static sqInt (*literalCountOf)(sqInt methodPointer, struct foo * self);
static sqInt (*methodArgumentCount)(struct foo * self);
static sqInt (*methodReturnInteger)(sqInt integer, struct foo * self);
static sqInt (*methodReturnValue)(sqInt oop, struct foo * self);
static sqInt (*nilObject)(struct foo * self);
static sqInt (*ownVM)(sqInt flags, struct foo * self);
static sqInt (*pop)(sqInt nItems, struct foo * self);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop, struct foo * self);
static sqInt (*popRemappableOop)(struct foo * self);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue, struct foo * self);
static usqInt (*positive32BitValueOf)(sqInt oop, struct foo * self);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue, struct foo * self);
static usqLong (*positive64BitValueOf)(sqInt oop, struct foo * self);
static usqIntptr_t (*positiveMachineIntegerValueOf)(sqInt oop, struct foo * self);
static sqInt (*primitiveErrorTable)(struct foo * self);
static sqInt (*primitiveFail)(struct foo * self);
static sqInt (*primitiveFailFor)(sqInt reasonCode, struct foo * self);
static sqInt (*primitiveMethod)(struct foo * self);
static sqInt (*pushFloat)(double f, struct foo * self);
static sqInt (*pushRemappableOop)(sqInt oop, struct foo * self);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue, struct foo * self);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue, struct foo * self);
static sqLong (*signed64BitValueOf)(sqInt oop, struct foo * self);
static sqIntptr_t (*signedMachineIntegerValueOf)(sqInt oop, struct foo * self);
static sqInt (*slotSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stackIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackObjectValue)(sqInt offset, struct foo * self);
static sqInt (*stackValue)(sqInt offset, struct foo * self);
static sqInt (*storeIntegerofObjectwithValue)(sqInt index, sqInt oop, sqInt integer, struct foo * self);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer, struct foo * self);
static void (*tenuringIncrementalGC)(struct foo * self);
static sqInt (*trueObject)(struct foo * self);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj, struct foo * self);
extern sqInt byteSizeOf(sqInt oop, struct foo * self);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt characterObjectOf(sqInt characterCode, struct foo * self);
#else
# define characterObjectOf(characterCode) 0
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt characterValueOf(sqInt aCharacter, struct foo * self);
#else
# define characterValueOf(aCharacter) 0
#endif
extern sqInt classAlien(struct foo * self);
extern sqInt classByteArray(struct foo * self);
extern sqInt classExternalAddress(struct foo * self);
extern sqInt classExternalData(struct foo * self);
extern sqInt classExternalFunction(struct foo * self);
extern sqInt classExternalLibrary(struct foo * self);
extern sqInt classExternalStructure(struct foo * self);
extern sqInt classLargePositiveInteger(struct foo * self);
extern sqInt classString(struct foo * self);
extern sqInt disownVM(sqInt flags, struct foo * self);
extern sqInt failed(struct foo * self);
extern sqInt falseObject(struct foo * self);
extern sqInt fetchClassOf(sqInt oop, struct foo * self);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer, struct foo * self);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop, struct foo * self);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop, struct foo * self);
extern void * firstIndexableField(sqInt oop, struct foo * self);
extern sqInt floatObjectOf(double aFloat, struct foo * self);
extern double floatValueOf(sqInt oop, struct foo * self);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass, struct foo * self);
extern sqInt instanceSizeOf(sqInt classObj, struct foo * self);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern sqInt integerValueOf(sqInt oop, struct foo * self);
extern void * ioLoadModuleOfLength(sqInt moduleNameIndex, sqInt moduleLength, struct foo * self);
extern void * ioLoadSymbolOfLengthFromModule(sqInt functionNameIndex, sqInt functionLength, sqInt moduleHandle);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass, struct foo * self);
extern sqInt isArray(sqInt oop, struct foo * self);
extern sqInt isBytes(sqInt oop, struct foo * self);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isCharacterObject(sqInt oop, struct foo * self);
#else
# define isCharacterObject(oop) 0
#endif
extern sqInt isFloatObject(sqInt oop, struct foo * self);
#if !defined(isImmediate)
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isImmediate(sqInt anObject, struct foo * self);
#else
# define isImmediate(anObject) 0
#endif
#endif /* !defined(isImmediate) */
extern sqInt isInMemory(sqInt address, struct foo * self);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer, struct foo * self);
#endif
extern sqInt isPointers(sqInt oop, struct foo * self);
extern sqInt isWords(sqInt oop, struct foo * self);
extern sqInt isYoung(sqInt anOop, struct foo * self);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer, struct foo * self);
extern sqInt literalCountOf(sqInt methodPointer, struct foo * self);
extern sqInt methodArgumentCount(struct foo * self);
extern sqInt methodReturnInteger(sqInt integer, struct foo * self);
extern sqInt methodReturnValue(sqInt oop, struct foo * self);
extern sqInt nilObject(struct foo * self);
extern sqInt ownVM(sqInt flags, struct foo * self);
extern sqInt pop(sqInt nItems, struct foo * self);
extern sqInt popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt popRemappableOop(struct foo * self);
extern sqInt positive32BitIntegerFor(unsigned int integerValue, struct foo * self);
extern usqInt positive32BitValueOf(sqInt oop, struct foo * self);
extern sqInt positive64BitIntegerFor(usqLong integerValue, struct foo * self);
extern usqLong positive64BitValueOf(sqInt oop, struct foo * self);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop, struct foo * self);
extern sqInt primitiveErrorTable(struct foo * self);
extern sqInt primitiveFail(struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
extern sqInt primitiveMethod(struct foo * self);
extern sqInt pushFloat(double f, struct foo * self);
extern sqInt pushRemappableOop(sqInt oop, struct foo * self);
extern sqInt signed32BitIntegerFor(sqInt integerValue, struct foo * self);
extern sqInt signed64BitIntegerFor(sqLong integerValue, struct foo * self);
extern sqLong signed64BitValueOf(sqInt oop, struct foo * self);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop, struct foo * self);
extern sqInt slotSizeOf(sqInt oop, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackObjectValue(sqInt offset, struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt storeIntegerofObjectwithValue(sqInt index, sqInt oop, sqInt integer, struct foo * self);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer, struct foo * self);
extern void tenuringIncrementalGC(struct foo * self);
extern sqInt trueObject(struct foo * self);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"X64SysVFFIPlugin VMMaker.oscog-eem.2481 (i)"
#else
	"X64SysVFFIPlugin VMMaker.oscog-eem.2481 (e)"
#endif
;


/*** Macros ***/
#define allocaLiesSoSetSpBeforeCall() ALLOCA_LIES_SO_SETSP_BEFORE_CALL
#define cStackAlignment() STACK_ALIGN_BYTES
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define dispatchFunctionPointerwithwithwithwith(aFunctionPointer, int1, int2, int3, int4) (aFunctionPointer)(int1, int2, int3, int4)
#define dispatchFunctionPointerwithwithwithwithwithwith(aFunctionPointer, int1, int2, int3, int4, int5, int6) (aFunctionPointer)(int1, int2, int3, int4, int5, int6)
#define ffiAlloc(bytes) (usqInt)malloc(bytes)
#define ffiFree(pointer) free((void *)(pointer))
#define isCalleePopsConvention(callType) (PLATFORM_API_USES_CALLEE_POPS_CONVENTION && (callType) == FFICallTypeApi)
#define mustAlignStack() MUST_ALIGN_STACK


	/* ThreadedFFIPlugin>>#atomicTypeOf: */
static sqInt
atomicTypeOf(sqInt typeSpec, struct foo * self)
{
	return ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
}


/*	Free any temporary arg strings. */

	/* ThreadedFFIPlugin>>#cleanupCalloutState: */
static void
cleanupCalloutState(CalloutState *calloutState, struct foo * self)
{
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
}

	/* ThreadedFFIPlugin>>#externalFunctionHasStackSizeSlot */
static sqInt
externalFunctionHasStackSizeSlot(struct foo * self)
{
	return externalFunctionInstSize > ExternalFunctionStackSizeIndex;
}


/*	Answer a long of the address of the byteSize slot (byte, short, int,
	whatever) at byteOffset in rcvr.
	Nominally intended for use with ExternalAddress objects, this code will
	work (for obscure historical
	reasons) with plain Byte or Word Arrays as well. Answer 0 on error. */

	/* ThreadedFFIPlugin>>#ffiAddressOf:startingAt:size: */
static void *
ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize, struct foo * self)
{
    sqInt addr;
    sqInt rcvrClass;
    sqInt rcvrSize;

	if (!(isBytes(rcvr, self))) {
		return 0;
	}
	if (!(byteOffset > 0)) {
		return 0;
	}
	rcvrClass = fetchClassOf(rcvr, self);
	rcvrSize = byteSizeOf(rcvr, self);
	if (rcvrClass == (classExternalAddress(self))) {
		if (!(rcvrSize == BytesPerWord)) {
			return 0;
		}

		/* Hack!! */
		/* don't you dare to read from object memory (unless is pinned)! */
		addr = fetchPointerofObject(0, rcvr, self);
		if (addr == 0) {

			/* or: [(interpreterProxy isInMemory: addr) or: [(interpreterProxy isPinned: rcvr) not]] */
			return 0;
		}
	}
	else {
		if (!(((byteOffset + byteSize) - 1) <= rcvrSize)) {
			return 0;
		}
		addr = ((sqIntptr_t) (firstIndexableField(rcvr, self)));
	}
	addr = (addr + byteOffset) - 1;
	return ((void *)addr);
}


/*	Support for generic callout. Prepare an argument by value for a callout. */

	/* ThreadedFFIPlugin>>#ffiArgByValue:in: */
static sqInt
ffiArgByValuein(sqInt oop, CalloutState *calloutState, struct foo * self)
{
    sqInt atomicType;
    double floatValue;
    sqInt intValue;
    sqInt typeSpec;

	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((atomicType < 0)
	 || (atomicType > FFITypeDoubleFloat)) {
		return FFIErrorBadAtomicType;
	}
	if (atomicType < FFITypeSingleFloat) {

		/* integer types */
		if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)) {

			/* ffi support code must coerce longlong */
			intValue = oop;
		}
		else {
			/* begin ffiIntegerValueOf: */
			if (oop & (BytesPerWord - 1)) {
				if (isIntegerObject(oop, self)) {
					intValue = integerValueOf(oop, self);
					goto l2;
				}
				
#        if SPURVM
				if (isCharacterObject(oop, self)) {

					/* Immediate in Spur */
					intValue = characterValueOf(oop, self);
					goto l2;
				}
				if (isFloatObject(oop, self)) {

					/* Immediate in 64-bit Spur */
					intValue = floatValueOf(oop, self);
					goto l2;
				}
#        endif /* SPURVM */
			}
			else {
				
#        if SPURVM

				/* No non-immediate characters in Spur */
#        else /* SPURVM */
				if (isCharacterObject(oop, self)) {
					intValue = characterValueOf(oop, self);
					goto l2;
				}
#        endif /* SPURVM */
				if (isFloatObject(oop, self)) {
					intValue = floatValueOf(oop, self);
					goto l2;
				}
				if (oop == (nilObject(self))) {
					intValue = 0;
					goto l2;
				}
				if (oop == (falseObject(self))) {
					intValue = 0;
					goto l2;
				}
				if (oop == (trueObject(self))) {
					intValue = 1;
					goto l2;
				}
				if (isLargePositiveIntegerObject(oop, self)) {
					
#          if BytesPerWord == 8

					/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
					intValue = positive64BitValueOf(oop, self);
					goto l2;
#          else /* BytesPerWord == 8 */
					intValue = positive32BitValueOf(oop, self);
					goto l2;
#          endif /* BytesPerWord == 8 */
				}
			}
			intValue = signedMachineIntegerValueOf(oop, self);
	l2:	/* end ffiIntegerValueOf: */;
		}
		if (failed(self)) {
			return FFIErrorCoercionFailed;
		}
		
		switch (atomicType) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			return ffiPushUnsignedIntin(intValue, calloutState, self);
		case 2:
			return ffiPushUnsignedBytein(intValue, calloutState, self);
		case 3:
			return ffiPushSignedBytein(intValue, calloutState, self);
		case 4:
			return ffiPushUnsignedShortin(intValue, calloutState, self);
		case 5:
			return ffiPushSignedShortin(intValue, calloutState, self);
		case 6:
			return ffiPushUnsignedIntin(intValue, calloutState, self);
		case 7:
			return ffiPushSignedIntin(intValue, calloutState, self);
		case 8:
			return ffiPushUnsignedLongLongOopin(intValue, calloutState, self);
		case 9:
			return ffiPushSignedLongLongOopin(intValue, calloutState, self);
		case 10:
			return ffiPushUnsignedCharin(intValue, calloutState, self);
		case 11:
			return ffiPushSignedCharin(intValue, calloutState, self);

		default:
			error("Case not found");
			return -1;
		}
	}
	/* begin ffiFloatValueOf: */
	if (isFloatObject(oop, self)) {
		floatValue = floatValueOf(oop, self);
		goto l3;
	}
	floatValue = ((double) (ffiIntegerValueOf(oop, self)) );
	l3:	/* end ffiFloatValueOf: */;
	if (failed(self)) {
		return FFIErrorCoercionFailed;
	}
	if (atomicType == FFITypeSingleFloat) {
		/* begin ffiPushSingleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
			(((float *) (((calloutState->floatRegisters)) + ((calloutState->floatRegisterIndex)))))[0] = floatValue;
			(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			long64AtPointerput((calloutState->currentArg), 0);
			storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
			(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
		}
		return 0;
	}
	else {
		/* begin ffiPushDoubleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
			((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
			(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
			(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
		}
		return 0;
	}
}


/*	Callout support. Prepare the given oop as argument.
	argSpec defines the compiled spec for the argument.
	argClass (if non-nil) defines the required (super)class for the argument. */

	/* ThreadedFFIPlugin>>#ffiArgument:Spec:Class:in: */
static sqInt
ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState, struct foo * self)
{
    sqInt *argSpec1;
    sqInt *argSpec2;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType2;
    char *copy;
    int doubleType;
    int doubleType1;
    sqInt err;
    int floatType;
    int floatType1;
    double floatValue;
    sqInt intValue;
    sqInt isAlien;
    sqInt isString;
    sqInt isStruct;
    sqInt length;
    sqInt nilOop;
    int numDoubleRegisters;
    int numDoubleRegisters1;
    int numIntegerRegisters;
    int numIntegerRegisters1;
    sqInt oopClass;
    sqInt passField0InXmmReg;
    sqInt passField0InXmmReg1;
    sqInt passField1InXmmReg;
    sqInt passField1InXmmReg1;
    char *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    void *pointer4;
    void *pointer5;
    void *pointer6;
    void * ptrAddress;
    sqInt ptrClass;
    sqInt ptrType;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt spec;
    sqInt specOop;
    sqInt specType;
    sqInt structSize;
    sqInt structSize1;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec2;
    sqInt valueOop;
    sqInt valueOop1;

	passField1InXmmReg = 0;
	passField1InXmmReg1 = 0;

	/* Prefetch class (we'll need it) */
	oopClass = fetchClassOf(oop, self);

	/* Do the necessary type checks */
	nilOop = nilObject(self);
	if (!(argClass == nilOop)) {

		/* Type check 1:
		   Is the required class of the argument a subclass of ExternalStructure? */
		if (!(includesBehaviorThatOf(argClass, classExternalStructure(self), self))) {
			return FFIErrorWrongType;
		}
		if (!((nilOop == oop)
			 || (includesBehaviorThatOf(oopClass, argClass, self)))) {
			return FFIErrorCoercionFailed;
		}
	}
	isStruct = 0;
	if ((oop != nilOop)
	 && (isPointers(oop, self))) {

		/* #isPointers: will fail if oop is immediate so don't even attempt to use it */
		isStruct = includesBehaviorThatOf(oopClass, classExternalStructure(self), self);
		if (!((argClass == nilOop)
			 || (isStruct))) {
			return FFIErrorCoercionFailed;
		}
	}
	if (isStruct) {
		valueOop = fetchPointerofObject(0, oop, self);
	}
	else {
		valueOop = oop;
	}
	if (!(isWords(argSpec, self))) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpecSize = slotSizeOf(argSpec, self));
	if (((calloutState->ffiArgSpecSize)) == 0) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpec = firstIndexableField(argSpec, self));
	(calloutState->ffiArgHeader = longAt((calloutState->ffiArgSpec)));
	if (((calloutState->ffiArgHeader)) & FFIFlagStructure) {

		/* argument must be ExternalStructure */
		if (!isStruct) {
			return FFIErrorCoercionFailed;
		}
		if (((calloutState->ffiArgHeader)) & FFIFlagAtomic) {
			return FFIErrorWrongType;
		}
		/* begin ffiPushStructureContentsOf:in: */
		ptrClass = fetchClassOf(valueOop, self);
		if (ptrClass == (classExternalAddress(self))) {

			/* ExternalAddress is bytes */

			/* There is no way we can make sure the structure is valid.
			   But we can at least check for attempts to pass pointers to ST memory. */
			ptrAddress = ((void *)(fetchPointerofObject(0, valueOop, self)));
			if (isInMemory(ptrAddress, self)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec2 = (calloutState->ffiArgSpec);
			argSpecSize = (calloutState->ffiArgSpecSize);
			if (structSize <= 16) {

				/* See sec 3.2.3 of http://people.freebsd.org/~obrien/amd64-elf-abi.pdf. (dravft version 0.90).
				   All of the folowing are passed in registers:
				   typedef struct { long a; } s0;
				   typedef struct { double a; } s1;
				   typedef struct { long a; double b; } s2;
				   typedef struct { int a; int b; double c; } s2a;
				   typedef struct { short a; short b; short c; short d; double e; } s2b;
				   typedef struct { long a; float b; } s2f;
				   typedef struct { long a; float b; float c; } s2g;
				   but not ones like this:
				   typedef struct { int a; float b; int c; float d; } s2h; */
				doubleType = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeDoubleFloat;
				floatType = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeSingleFloat;
				passField0InXmmReg = (doubleType == ((((int *) argSpec2))[1]))
				 || ((floatType == ((((int *) argSpec2))[1]))
				 && (floatType == ((((int *) argSpec2))[2])));
				if (structSize <= 8) {
					numDoubleRegisters = (passField0InXmmReg
						? 1
						: 0);
					numIntegerRegisters = 1 - numDoubleRegisters;
				}
				else {
					passField1InXmmReg = (doubleType == ((((int *) argSpec2))[argSpecSize - 1]))
					 || ((floatType == ((((int *) argSpec2))[argSpecSize - 2]))
					 && (floatType == ((((int *) argSpec2))[argSpecSize - 1])));
					numDoubleRegisters = ((passField0InXmmReg
	? 1
	: 0)) + ((passField1InXmmReg
	? 1
	: 0));
					numIntegerRegisters = 2 - numDoubleRegisters;
				}
				if (((((calloutState->floatRegisterIndex)) + numDoubleRegisters) <= NumFloatRegArgs)
				 && ((((calloutState->integerRegisterIndex)) + numIntegerRegisters) <= NumIntRegArgs)) {
					if (passField0InXmmReg) {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[0]);
							(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								goto l10;
							}
							storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[0]);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
	l10:	/* end ffiPushDoubleFloat:in: */;
					}
					else {
						/* begin ffiPushSignedLongLong:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[0])));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								goto l11;
							}
							longAtput((calloutState->currentArg), (((long long *) ptrAddress))[0]);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
	l11:	/* end ffiPushSignedLongLong:in: */;
					}
					if (structSize > 8) {
						if (passField1InXmmReg) {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[1]);
								(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
							}
							else {
								if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
									goto l9;
								}
								storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[1]);
								(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
							}
	l9:	/* end ffiPushDoubleFloat:in: */;
						}
						else {
							/* begin ffiPushSignedLongLong:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[1])));
								(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
							}
							else {
								if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
									goto l4;
								}
								longAtput((calloutState->currentArg), (((long long *) ptrAddress))[1]);
								(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
							}
	l4:	/* end ffiPushSignedLongLong:in: */;
						}
					}
					return 0;
				}
			}
			roundedSize = (((structSize + 7) | 7) - 7);
			if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			memcpy((calloutState->currentArg), ((char *) ptrAddress), structSize);
			(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
			return 0;
		}
		if (ptrClass == (classByteArray(self))) {

			/* The following is a somewhat pessimistic test but I like being sure... */
			if (!((byteSizeOf(valueOop, self)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
				return FFIErrorStructSize;
			}
			ptrAddress = firstIndexableField(valueOop, self);
			if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

				/* Since this involves passing the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
				
#        if COGMTVM
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (isYoung(valueOop, self))) {
					return -PrimErrObjectMayMove;
				}
#        endif /* COGMTVM */
				/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
				structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
				argSpec1 = (calloutState->ffiArgSpec);
				argSpecSize1 = (calloutState->ffiArgSpecSize);
				if (structSize1 <= 16) {

					/* See sec 3.2.3 of http://people.freebsd.org/~obrien/amd64-elf-abi.pdf. (dravft version 0.90).
					   All of the folowing are passed in registers:
					   typedef struct { long a; } s0;
					   typedef struct { double a; } s1;
					   typedef struct { long a; double b; } s2;
					   typedef struct { int a; int b; double c; } s2a;
					   typedef struct { short a; short b; short c; short d; double e; } s2b;
					   typedef struct { long a; float b; } s2f;
					   typedef struct { long a; float b; float c; } s2g;
					   but not ones like this:
					   typedef struct { int a; float b; int c; float d; } s2h; */
					doubleType1 = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeDoubleFloat;
					floatType1 = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeSingleFloat;
					passField0InXmmReg1 = (doubleType1 == ((((int *) argSpec1))[1]))
					 || ((floatType1 == ((((int *) argSpec1))[1]))
					 && (floatType1 == ((((int *) argSpec1))[2])));
					if (structSize1 <= 8) {
						numDoubleRegisters1 = (passField0InXmmReg1
							? 1
							: 0);
						numIntegerRegisters1 = 1 - numDoubleRegisters1;
					}
					else {
						passField1InXmmReg1 = (doubleType1 == ((((int *) argSpec1))[argSpecSize1 - 1]))
						 || ((floatType1 == ((((int *) argSpec1))[argSpecSize1 - 2]))
						 && (floatType1 == ((((int *) argSpec1))[argSpecSize1 - 1])));
						numDoubleRegisters1 = ((passField0InXmmReg1
	? 1
	: 0)) + ((passField1InXmmReg1
	? 1
	: 0));
						numIntegerRegisters1 = 2 - numDoubleRegisters1;
					}
					if (((((calloutState->floatRegisterIndex)) + numDoubleRegisters1) <= NumFloatRegArgs)
					 && ((((calloutState->integerRegisterIndex)) + numIntegerRegisters1) <= NumIntRegArgs)) {
						if (passField0InXmmReg1) {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[0]);
								(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
							}
							else {
								if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
									goto l6;
								}
								storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[0]);
								(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
							}
	l6:	/* end ffiPushDoubleFloat:in: */;
						}
						else {
							/* begin ffiPushSignedLongLong:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[0])));
								(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
							}
							else {
								if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
									goto l8;
								}
								longAtput((calloutState->currentArg), (((long long *) ptrAddress))[0]);
								(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
							}
	l8:	/* end ffiPushSignedLongLong:in: */;
						}
						if (structSize1 > 8) {
							if (passField1InXmmReg1) {
								/* begin ffiPushDoubleFloat:in: */
								if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
									((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[1]);
									(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
								}
								else {
									if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
										goto l5;
									}
									storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[1]);
									(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
								}
	l5:	/* end ffiPushDoubleFloat:in: */;
							}
							else {
								/* begin ffiPushSignedLongLong:in: */
								if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
									((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[1])));
									(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
								}
								else {
									if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
										goto l7;
									}
									longAtput((calloutState->currentArg), (((long long *) ptrAddress))[1]);
									(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
								}
	l7:	/* end ffiPushSignedLongLong:in: */;
							}
						}
						return 0;
					}
				}
				roundedSize1 = (((structSize1 + 7) | 7) - 7);
				if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				memcpy((calloutState->currentArg), ((char *) ptrAddress), structSize1);
				(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
				return 0;
			}
			if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
				return FFIErrorStructSize;
			}
			ptrAddress = ((void *)(fetchPointerofObject(0, valueOop, self)));
			if (isInMemory(ptrAddress, self)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ptrAddress);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		return FFIErrorBadArg;
	}
	if (((calloutState->ffiArgHeader)) & FFIFlagPointer) {

		/* no integers (or characters) for pointers please */
		if (isImmediate(oop, self)) {
			return FFIErrorIntAsPointer;
		}
		if (oop == nilOop) {
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), null);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		if (((calloutState->ffiArgHeader)) & FFIFlagAtomic) {

			/* e.g., ExternalData */
			if (isStruct) {
				/* begin ffiAtomicStructByReference:Class:in: */
				if (!(oopClass == (classExternalData(self)))) {
					return FFIErrorCoercionFailed;
				}
				/* begin atomicTypeOf: */
				typeSpec = (calloutState->ffiArgHeader);
				atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if (atomicType != FFITypeVoid) {
					/* begin ffiValidateExternalData:AtomicType: */
					ptrType = fetchPointerofObject(1, oop, self);
					if (!((isPointers(ptrType, self))
						 && ((slotSizeOf(ptrType, self)) >= 2))) {
						err = FFIErrorWrongType;
						goto l3;
					}
					specOop = fetchPointerofObject(0, ptrType, self);
					if (!((isWords(specOop, self))
						 && ((slotSizeOf(specOop, self)) > 0))) {
						err = FFIErrorWrongType;
						goto l3;
					}
					spec = fetchPointerofObject(0, specOop, self);
					if (!(spec & FFIFlagAtomic)) {
						err = FFIErrorWrongType;
						goto l3;
					}
					/* begin atomicTypeOf: */
					specType = ((usqInt) (spec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
					if (specType != atomicType) {

						/* Allow for signed/unsigned conversion but nothing else.
						   See FFIConstants class>>#initializeTypeConstants */
						if (!((atomicType >= FFITypeUnsignedByte)
							 && ((atomicType <= FFITypeSignedChar)
							 && ((((usqInt) atomicType) >> 1) == (((usqInt) specType) >> 1))))) {
							err = FFIErrorCoercionFailed;
							goto l3;
						}
					}
					err = 0;
	l3:	/* end ffiValidateExternalData:AtomicType: */;
					if (err != 0) {
						return err;
					}
				}
				valueOop1 = fetchPointerofObject(0, oop, self);
				return ffiPushPointerContentsOfin(valueOop1, calloutState, self);
			}
			else {
				/* begin ffiAtomicArgByReference:Class:in: */
				typeSpec1 = (calloutState->ffiArgHeader);
				atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if (atomicType1 == FFITypeBool) {

					/* No bools on input */
					return FFIErrorCoercionFailed;
				}
				isAlien = ((isString = includesBehaviorThatOf(oopClass, classString(self), self))
					? 0
					: includesBehaviorThatOf(oopClass, classAlien(self), self));
				if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

					/* string value (char*) */
					/* note: the only types allowed for passing into char* types are
					   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
					   (e.g., CompiledMethod, LargeInteger). We only check for strings
					   here and fall through to the byte* check otherwise. */
					if (isString) {

						/* String/Symbol */
						/* Strings must be allocated by the ffi support code */
						/* begin ffiPushString:OfLength:in: */
						pointer = ((char *) (firstIndexableField(oop, self)));
						length = byteSizeOf(oop, self);
						if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
							return -PrimErrBadNumArgs;
						}
						copy = malloc(length + 1);
						if (copy == null) {
							return -PrimErrNoCMemory;
						}
						memcpy(copy, pointer, length);
						copy[length] = 0;
						((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
						(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							longAtput((calloutState->currentArg), copy);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
						return 0;
					}
					atomicType1 = FFITypeUnsignedByte;
				}
				
#        if COGMTVM

				/* Since all the following pass the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (((!isAlien)
				 || ((assert(isAlien(oop, self)),
				(longAt(oop + BaseHeaderSize)) > 0)))
				 && (isYoung(oop, self)))) {
					return -PrimErrObjectMayMove;
				}
#        endif /* COGMTVM */
				if ((atomicType1 == FFITypeVoid)
				 || ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedByte) >> 1))) {

					/* byte* -- see comment on string above */
					if (isString
					 || (oopClass == (classByteArray(self)))) {

						/* String/Symbol/ByteArray */
						/* begin ffiPushPointer:in: */
						pointer1 = ((void *) (firstIndexableField(oop, self)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							longAtput((calloutState->currentArg), pointer1);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
						return 0;
					}
					if (oopClass == (classExternalAddress(self))) {
						/* begin ffiPushPointer:in: */
						pointer2 = ((void *) (longAt(oop + BaseHeaderSize)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							longAtput((calloutState->currentArg), pointer2);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
						return 0;
					}
					if (isAlien) {
						/* begin ffiPushPointer:in: */
						pointer3 = pointerForOop(((longAt(oop + BaseHeaderSize)) > 0
							? (oop + BaseHeaderSize) + BytesPerOop
							: longAt((oop + BaseHeaderSize) + BytesPerOop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							longAtput((calloutState->currentArg), pointer3);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
						return 0;
					}
					if (!(atomicType1 == FFITypeVoid)) {
						return FFIErrorCoercionFailed;
					}
				}
				if (atomicType1 <= FFITypeDoubleFloat) {
					if ((isWords(oop, self))
					 || (oopClass == (classByteArray(self)))) {
						/* begin ffiPushPointer:in: */
						pointer4 = ((void *) (firstIndexableField(oop, self)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							longAtput((calloutState->currentArg), pointer4);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
						return 0;
					}
					if (oopClass == (classExternalAddress(self))) {
						/* begin ffiPushPointer:in: */
						pointer5 = ((void *) (longAt(oop + BaseHeaderSize)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer5));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							longAtput((calloutState->currentArg), pointer5);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
						return 0;
					}
					if (isAlien) {
						/* begin ffiPushPointer:in: */
						pointer6 = pointerForOop(((longAt(oop + BaseHeaderSize)) > 0
							? (oop + BaseHeaderSize) + BytesPerOop
							: longAt((oop + BaseHeaderSize) + BytesPerOop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer6));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							longAtput((calloutState->currentArg), pointer6);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
						return 0;
					}
				}
				return FFIErrorCoercionFailed;
			}
		}
		if (!isStruct) {
			return FFIErrorCoercionFailed;
		}
		return ffiPushPointerContentsOfin(valueOop, calloutState, self);
	}
	if (((calloutState->ffiArgHeader)) & FFIFlagAtomic) {

		/* argument is atomic value */
		/* begin ffiArgByValue:in: */
		typeSpec2 = (calloutState->ffiArgHeader);
		atomicType2 = ((usqInt) (typeSpec2 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if ((atomicType2 < 0)
		 || (atomicType2 > FFITypeDoubleFloat)) {
			return FFIErrorBadAtomicType;
		}
		if (atomicType2 < FFITypeSingleFloat) {

			/* integer types */
			if ((((usqInt) atomicType2) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)) {

				/* ffi support code must coerce longlong */
				intValue = valueOop;
			}
			else {
				/* begin ffiIntegerValueOf: */
				if (valueOop & (BytesPerWord - 1)) {
					if (isIntegerObject(valueOop, self)) {
						intValue = integerValueOf(valueOop, self);
						goto l15;
					}
					
#          if SPURVM
					if (isCharacterObject(valueOop, self)) {

						/* Immediate in Spur */
						intValue = characterValueOf(valueOop, self);
						goto l15;
					}
					if (isFloatObject(valueOop, self)) {

						/* Immediate in 64-bit Spur */
						intValue = floatValueOf(valueOop, self);
						goto l15;
					}
#          endif /* SPURVM */
				}
				else {
					
#          if SPURVM

					/* No non-immediate characters in Spur */
#          else /* SPURVM */
					if (isCharacterObject(valueOop, self)) {
						intValue = characterValueOf(valueOop, self);
						goto l15;
					}
#          endif /* SPURVM */
					if (isFloatObject(valueOop, self)) {
						intValue = floatValueOf(valueOop, self);
						goto l15;
					}
					if (valueOop == (nilObject(self))) {
						intValue = 0;
						goto l15;
					}
					if (valueOop == (falseObject(self))) {
						intValue = 0;
						goto l15;
					}
					if (valueOop == (trueObject(self))) {
						intValue = 1;
						goto l15;
					}
					if (isLargePositiveIntegerObject(valueOop, self)) {
						
#            if BytesPerWord == 8

						/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
						intValue = positive64BitValueOf(valueOop, self);
						goto l15;
#            else /* BytesPerWord == 8 */
						intValue = positive32BitValueOf(valueOop, self);
						goto l15;
#            endif /* BytesPerWord == 8 */
					}
				}
				intValue = signedMachineIntegerValueOf(valueOop, self);
	l15:	/* end ffiIntegerValueOf: */;
			}
			if (failed(self)) {
				return FFIErrorCoercionFailed;
			}
			
			switch (atomicType2) {
			case 0:
				return FFIErrorAttemptToPassVoid;
			case 1:
				return ffiPushUnsignedIntin(intValue, calloutState, self);
			case 2:
				return ffiPushUnsignedBytein(intValue, calloutState, self);
			case 3:
				return ffiPushSignedBytein(intValue, calloutState, self);
			case 4:
				return ffiPushUnsignedShortin(intValue, calloutState, self);
			case 5:
				return ffiPushSignedShortin(intValue, calloutState, self);
			case 6:
				return ffiPushUnsignedIntin(intValue, calloutState, self);
			case 7:
				return ffiPushSignedIntin(intValue, calloutState, self);
			case 8:
				return ffiPushUnsignedLongLongOopin(intValue, calloutState, self);
			case 9:
				return ffiPushSignedLongLongOopin(intValue, calloutState, self);
			case 10:
				return ffiPushUnsignedCharin(intValue, calloutState, self);
			case 11:
				return ffiPushSignedCharin(intValue, calloutState, self);

			default:
				error("Case not found");
				return -1;
			}
		}
		/* begin ffiFloatValueOf: */
		if (isFloatObject(valueOop, self)) {
			floatValue = floatValueOf(valueOop, self);
			goto l13;
		}
		floatValue = ((double) (ffiIntegerValueOf(valueOop, self)) );
	l13:	/* end ffiFloatValueOf: */;
		if (failed(self)) {
			return FFIErrorCoercionFailed;
		}
		if (atomicType2 == FFITypeSingleFloat) {
			/* begin ffiPushSingleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
				(((float *) (((calloutState->floatRegisters)) + ((calloutState->floatRegisterIndex)))))[0] = floatValue;
				(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				long64AtPointerput((calloutState->currentArg), 0);
				storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		else {
			/* begin ffiPushDoubleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
				((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
				(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
	}
	return FFIErrorWrongType;
}


/*	Support for generic callout. Prepare a pointer reference to an atomic type
	for callout.
	Note: 
	for type 'void*' we allow ByteArray/String/Symbol, wordVariableSubclass,
	Alien or ExternalAddress.
	for other types we allow ByteArray, wordVariableSubclass, Alien or
	ExternalAddress. 
 */

	/* ThreadedFFIPlugin>>#ffiAtomicArgByReference:Class:in: */
static sqInt
ffiAtomicArgByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState, struct foo * self)
{
    sqInt atomicType;
    char *copy;
    sqInt isAlien;
    sqInt isString;
    sqInt length;
    char *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    void *pointer4;
    void *pointer5;
    void *pointer6;
    sqInt typeSpec;

	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if (atomicType == FFITypeBool) {

		/* No bools on input */
		return FFIErrorCoercionFailed;
	}
	isAlien = ((isString = includesBehaviorThatOf(oopClass, classString(self), self))
		? 0
		: includesBehaviorThatOf(oopClass, classAlien(self), self));
	if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

		/* string value (char*) */
		/* note: the only types allowed for passing into char* types are
		   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
		   (e.g., CompiledMethod, LargeInteger). We only check for strings
		   here and fall through to the byte* check otherwise. */
		if (isString) {

			/* String/Symbol */
			/* Strings must be allocated by the ffi support code */
			/* begin ffiPushString:OfLength:in: */
			pointer = ((char *) (firstIndexableField(oop, self)));
			length = byteSizeOf(oop, self);
			if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
				return -PrimErrBadNumArgs;
			}
			copy = malloc(length + 1);
			if (copy == null) {
				return -PrimErrNoCMemory;
			}
			memcpy(copy, pointer, length);
			copy[length] = 0;
			((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
			(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), copy);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		atomicType = FFITypeUnsignedByte;
	}
	
#  if COGMTVM

	/* Since all the following pass the address of the first indexable field we need to fail
	   the call if it is threaded and the object is young, since it may move during the call. */
	if ((((calloutState->callFlags)) & FFICallFlagThreaded)
	 && (((!isAlien)
	 || ((assert(isAlien(oop, self)),
	(longAt(oop + BaseHeaderSize)) > 0)))
	 && (isYoung(oop, self)))) {
		return -PrimErrObjectMayMove;
	}
#  endif /* COGMTVM */
	if ((atomicType == FFITypeVoid)
	 || ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedByte) >> 1))) {

		/* byte* -- see comment on string above */
		if (isString
		 || (oopClass == (classByteArray(self)))) {

			/* String/Symbol/ByteArray */
			/* begin ffiPushPointer:in: */
			pointer1 = ((void *) (firstIndexableField(oop, self)));
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), pointer1);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		if (oopClass == (classExternalAddress(self))) {
			/* begin ffiPushPointer:in: */
			pointer2 = ((void *) (longAt(oop + BaseHeaderSize)));
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), pointer2);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		if (isAlien) {
			/* begin ffiPushPointer:in: */
			pointer3 = pointerForOop(((longAt(oop + BaseHeaderSize)) > 0
				? (oop + BaseHeaderSize) + BytesPerOop
				: longAt((oop + BaseHeaderSize) + BytesPerOop)));
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), pointer3);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		if (!(atomicType == FFITypeVoid)) {
			return FFIErrorCoercionFailed;
		}
	}
	if (atomicType <= FFITypeDoubleFloat) {
		if ((isWords(oop, self))
		 || (oopClass == (classByteArray(self)))) {
			/* begin ffiPushPointer:in: */
			pointer4 = ((void *) (firstIndexableField(oop, self)));
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), pointer4);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		if (oopClass == (classExternalAddress(self))) {
			/* begin ffiPushPointer:in: */
			pointer5 = ((void *) (longAt(oop + BaseHeaderSize)));
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer5));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), pointer5);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
		if (isAlien) {
			/* begin ffiPushPointer:in: */
			pointer6 = pointerForOop(((longAt(oop + BaseHeaderSize)) > 0
				? (oop + BaseHeaderSize) + BytesPerOop
				: longAt((oop + BaseHeaderSize) + BytesPerOop)));
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer6));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), pointer6);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			return 0;
		}
	}
	return FFIErrorCoercionFailed;
}


/*	Support for generic callout. Prepare an external pointer reference to an
	atomic type for callout.
 */

	/* ThreadedFFIPlugin>>#ffiAtomicStructByReference:Class:in: */
static sqInt
ffiAtomicStructByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState, struct foo * self)
{
    sqInt atomicType;
    sqInt err;
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;
    sqInt typeSpec;
    sqInt valueOop;


	/* must be external data to pass pointers to atomic type */
	if (!(oopClass == (classExternalData(self)))) {
		return FFIErrorCoercionFailed;
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if (atomicType != FFITypeVoid) {
		/* begin ffiValidateExternalData:AtomicType: */
		ptrType = fetchPointerofObject(1, oop, self);
		if (!((isPointers(ptrType, self))
			 && ((slotSizeOf(ptrType, self)) >= 2))) {
			err = FFIErrorWrongType;
			goto l3;
		}
		specOop = fetchPointerofObject(0, ptrType, self);
		if (!((isWords(specOop, self))
			 && ((slotSizeOf(specOop, self)) > 0))) {
			err = FFIErrorWrongType;
			goto l3;
		}
		spec = fetchPointerofObject(0, specOop, self);
		if (!(spec & FFIFlagAtomic)) {
			err = FFIErrorWrongType;
			goto l3;
		}
		/* begin atomicTypeOf: */
		specType = ((usqInt) (spec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if (specType != atomicType) {

			/* Allow for signed/unsigned conversion but nothing else.
			   See FFIConstants class>>#initializeTypeConstants */
			if (!((atomicType >= FFITypeUnsignedByte)
				 && ((atomicType <= FFITypeSignedChar)
				 && ((((usqInt) atomicType) >> 1) == (((usqInt) specType) >> 1))))) {
				err = FFIErrorCoercionFailed;
				goto l3;
			}
		}
		err = 0;
	l3:	/* end ffiValidateExternalData:AtomicType: */;
		if (err != 0) {
			return err;
		}
	}
	valueOop = fetchPointerofObject(0, oop, self);
	return ffiPushPointerContentsOfin(valueOop, calloutState, self);
}


/*	Go out, call this guy and create the return value. This *must* be inlined
	because of
	the alloca of the outgoing stack frame in
	ffiCall:WithFlags:NumArgs:Args:AndTypes: 
 */

	/* ThreadedX64SysVFFIPlugin>>#ffiCalloutTo:SpecOnStack:in: */
static sqInt
ffiCalloutToSpecOnStackin(void *procAddr, sqInt specOnStack, CalloutState *calloutState, struct foo * self)
{
    sqInt argTypes;
    sqInt argTypes1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt byteSize;
    sqInt classOop;
    sqInt cPointer;
    char *cString;
    sqInt ffiRetType;
    double floatRet;
    sqInt i;
    SixteenByteReturn intRet;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double, struct foo * self);
    usqLong mask;
    sqInt myThreadIndex;
    sqInt oop;
    sqInt oop1;
    sqInt *ptr;
    sqInt retClass;
    sqInt retClass1;
    sqInt retOop;
    sqInt retOop1;
    sqInt retType;
    usqLong retVal;
    usqLong retVal1;
    sqInt shift;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt typeSpec;
    sqInt typeSpec1;
    usqLong value;

	myThreadIndex = disownVM(
#  if COGMTVM
		(((calloutState->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		, self);
	if (((calloutState->floatRegisterIndex)) > 0) {
		loadFloatRegs(((calloutState->floatRegisters))[0], ((calloutState->floatRegisters))[1], ((calloutState->floatRegisters))[2], ((calloutState->floatRegisters))[3], ((calloutState->floatRegisters))[4], ((calloutState->floatRegisters))[5], ((calloutState->floatRegisters))[6], ((calloutState->floatRegisters))[7], self);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiRetHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSingleFloat) >> 1)) {
		if (atomicType == FFITypeSingleFloat) {
			floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) procAddr), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) procAddr), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
		}
		ownVM(myThreadIndex, self);
		return floatObjectOf(floatRet, self);
	}
	intRet = dispatchFunctionPointerwithwithwithwithwithwith(((SixteenByteReturn (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) procAddr), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
	ownVM(myThreadIndex, self);
	if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			retVal = (intRet.a);
			/* begin ffiReturnType: */
			specLiteral = (specOnStack
				? stackValue(1, self)
				: literalofMethod(0, primitiveMethod(self), self));
			argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral, self);
			retType = fetchPointerofObject(0, argTypes, self);
			retClass = fetchPointerofObject(1, retType, self);
			if (retClass == (nilObject(self))) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec1 = (calloutState->ffiRetHeader);
				atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer = ((usqInt) retVal);
					if (!(cPointer)) {
						retOop = nilObject(self);
						goto l3;
					}
					cString = ((char *) cPointer);
					strLen = 0;
					while (!((cString[strLen]) == 0)) {
						strLen += 1;
					}
					strOop = instantiateClassindexableSize(classString(self), strLen, self);
					strPtr = firstIndexableField(strOop, self);
					for (i = 0; i < strLen; i += 1) {
						strPtr[i] = (cString[i]);
					}
					retOop = strOop;
	l3:	/* end ffiReturnCStringFrom: */;
					return retOop;
				}
				
#if SPURVM
				oop = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr = firstIndexableField(oop, self);
				ptr[0] = (((sqInt) retVal));
				retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
				storePointerofObjectwithValue(0, retOop, oop, self);

#else /* SPURVM */
				pushRemappableOop(retType, self);
				oop = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr = firstIndexableField(oop, self);
				ptr[0] = (((sqInt) retVal));
								pushRemappableOop(oop, self);
				retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
				oop = popRemappableOop(self);
				storePointerofObjectwithValue(0, retOop, oop, self);
				retType = popRemappableOop(self)
#endif /* SPURVM */
;
				storePointerofObjectwithValue(1, retOop, retType, self);
				return retOop;
			}
			classOop = (((calloutState->ffiRetHeader)) & FFIFlagStructure
				? classByteArray(self)
				: classExternalAddress(self));
			
#if SPURVM
			oop = instantiateClassindexableSize(classOop, BytesPerWord, self);

#else /* SPURVM */
			pushRemappableOop(retClass, self);
			oop = instantiateClassindexableSize(classOop, BytesPerWord, self);
			retClass = popRemappableOop(self)
#endif /* SPURVM */
;
			ptr = firstIndexableField(oop, self);
			ptr[0] = (((sqInt) retVal));
			
#if SPURVM
			retOop = instantiateClassindexableSize(retClass, 0, self);

#else /* SPURVM */
			pushRemappableOop(oop, self);
			retOop = instantiateClassindexableSize(retClass, 0, self);
			oop = popRemappableOop(self)
#endif /* SPURVM */
;
			storePointerofObjectwithValue(0, retOop, oop, self);
			return retOop;
		}
		/* begin ffiReturnStruct:ofType:in: */
		specLiteral1 = (specOnStack
			? stackValue(1, self)
			: literalofMethod(0, primitiveMethod(self), self));
		argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1, self);
		ffiRetType = fetchPointerofObject(0, argTypes1, self);
		retClass1 = fetchPointerofObject(1, ffiRetType, self);
		retOop1 = instantiateClassindexableSize(retClass1, 0, self);
		
#if SPURVM
		oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);

#else /* SPURVM */
		pushRemappableOop(retOop1, self);
		oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);
		retOop1 = popRemappableOop(self)
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop1, self), (((calloutState->structReturnSize)) <= (WordSize * 2)
			? ((void *)((&intRet)))
			: (calloutState->limit)), (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop1, oop1, self);
		return retOop1;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	retVal1 = (intRet.a);
	assert(atomicType < FFITypeSingleFloat);
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(retVal1))
			? retVal1
			: retVal1 & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		return (value == 0
			? falseObject(self)
			: trueObject(self));
	}
	if (atomicType <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift = ((BytesPerWord == 8)
			 && (atomicType >= FFITypeUnsignedInt)
				? 32
				: (((usqInt) atomicType) >> 1) * 8);
			value = retVal1 & (((((unsigned long long)1)) << shift) - 1);
			if (atomicType & 1) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			return integerObjectOf(value, self);
		}
		return (atomicType & 1
			? (BytesPerWord == 8
					? signed64BitIntegerFor(retVal1, self)
					: signed32BitIntegerFor(retVal1, self))
			: (BytesPerWord == 8
					? positive64BitIntegerFor(retVal1, self)
					: positive32BitIntegerFor(retVal1, self)));
	}
	return ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)
		? (atomicType & 1
				? signed64BitIntegerFor(retVal1, self)
				: positive64BitIntegerFor(retVal1, self))
		: characterObjectOf(retVal1 & 0xFF, self));
}


/*	Generic callout. Does the actual work. If argArrayOrNil is nil it takes
	args from the stack
	and the spec from the method. If argArrayOrNil is not nil takes args from
	argArrayOrNil and the spec from the receiver. */

	/* ThreadedFFIPlugin>>#ffiCall:ArgArrayOrNil:NumArgs: */
static sqInt
ffiCallArgArrayOrNilNumArgs(sqInt externalFunction, sqInt argArrayOrNil, sqInt nArgs, struct foo * self)
{
    sqInt address;
    sqInt address1;
    sqInt addressPtr;
    char *allocation;
    sqInt argClass;
    sqInt argSpec;
    sqInt argType;
    sqInt argTypeArray;
    sqInt argTypes;
    sqInt argTypes1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt byteSize;
    CalloutState *calloutState;
    sqInt classOop;
    sqInt cPointer;
    char *cString;
    sqInt err;
    sqInt ffiRetType;
    sqInt flags;
    double floatRet;
    sqInt functionName;
    sqInt i;
    sqInt i1;
    SixteenByteReturn intRet;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double, struct foo * self);
    usqLong mask;
    sqInt myThreadIndex;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    void *pointer;
    sqInt primNumArgs;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    sqInt requiredStackSize;
    sqInt result;
    sqInt retClass;
    sqInt retClass1;
    sqInt retOop;
    sqInt retOop1;
    sqInt retType;
    usqLong retVal;
    usqLong retVal1;
    sqInt shift;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt stackSize;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    CalloutState theCalloutState;
    sqInt typeSpec;
    sqInt typeSpec1;
    usqLong value;

	primNumArgs = methodArgumentCount(self);
	if (!(isKindOfClass(externalFunction, classExternalFunction(self), self))) {
		return ffiFail(FFIErrorNotFunction, self);
	}
	flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction, self);
	if (failed(self)) {
		return ffiFail(FFIErrorBadArgs, self);
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr = fetchPointerofObject(0, externalFunction, self);
	if (!((isBytes(addressPtr, self))
		 && ((byteSizeOf(addressPtr, self)) == (sizeof(sqInt))))) {
		address1 = ffiFail(FFIErrorBadAddress, self);
		goto l1;
	}
	address1 = fetchPointerofObject(0, addressPtr, self);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed(self)) {
		address = 0;
		goto l2;
	}
	if (address1 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1, self), self);
		}
		if ((slotSizeOf(externalFunction, self)) < 5) {
			address = ffiFail(FFIErrorNoModule, self);
			goto l2;
		}
		address1 = ffiLoadCalloutAddressFrom(externalFunction, self);
		if (failed(self)) {
			address = 0;
			goto l2;
		}
		ptr = firstIndexableField(addressPtr, self);
		ptr[0] = address1;
	}
	address = address1;
	l2:	/* end ffiLoadCalloutAddress: */;
	if (failed(self)) {
		return 0;
	}

	/* must be array of arg types */
	argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction, self);
	if (!((isArray(argTypeArray, self))
		 && ((slotSizeOf(argTypeArray, self)) == (nArgs + 1)))) {
		return ffiFail(FFIErrorBadArgs, self);
	}
	
#  if COGMTVM
	if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
		return ffiFail(FFIErrorCallType, self);
	}
#  else /* COGMTVM */

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags == FFICallTypeCDecl)
		 || (flags == FFICallTypeApi))) {
		return ffiFail(FFIErrorCallType, self);
	}
#  endif /* COGMTVM */
	requiredStackSize = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
		? fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction, self)
		: -1);
	if (failed(self)) {
		return primitiveFailFor((argArrayOrNil == null
			? PrimErrBadMethod
			: PrimErrBadReceiver), self);
	}
	stackSize = (requiredStackSize < 0
		? DefaultMaxStackSize
		: requiredStackSize);
	calloutState = (&theCalloutState);
	memset(calloutState, 0, sizeof(CalloutState));
	(calloutState->callFlags = flags);
	argType = fetchPointerofObject(0, argTypeArray, self);
	argSpec = fetchPointerofObject(0, argType, self);
	argClass = fetchPointerofObject(1, argType, self);
	if (((err = ffiCheckReturnWithin(argSpec, argClass, calloutState, self))) != 0) {
		return ffiFail(err, self);
	}
	allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState->argVector = allocation);
	(calloutState->currentArg = allocation);
	(calloutState->limit = allocation + stackSize);
	if ((((calloutState->structReturnSize)) > 0)
	 && (1
	 && (!(((calloutState->structReturnSize)) <= (WordSize * 2))))) {
		/* begin ffiPushPointer:in: */
		pointer = (calloutState->limit);
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
			(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
				err = FFIErrorCallFrameTooBig;
				goto l4;
			}
			longAtput((calloutState->currentArg), pointer);
			(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
		}
		err = 0;
	l4:	/* end ffiPushPointer:in: */;
		if (err != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState->stringArgIndex)) > 0) {
				free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err == (-PrimErrObjectMayMove)) {
				return PrimErrObjectMayMove;
			}
#      endif /* COGMTVM */
			return ffiFail(err, self);
		}
	}
	for (i = 1; i <= nArgs; i += 1) {
		argType = fetchPointerofObject(i, argTypeArray, self);
		argSpec = fetchPointerofObject(0, argType, self);
		argClass = fetchPointerofObject(1, argType, self);
		oop = (argArrayOrNil == null
			? stackValue(nArgs - i, self)
			: fetchPointerofObject(i - 1, argArrayOrNil, self));
		err = ffiArgumentSpecClassin(oop, argSpec, argClass, calloutState, self);
		if (err != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState->stringArgIndex)) > 0) {
				free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err == (-PrimErrObjectMayMove)) {
				return PrimErrObjectMayMove;
			}
#      endif /* COGMTVM */
			return ffiFail(err, self);
		}
	}
	assert(!(failed(self)));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		functionName = fetchPointerofObject(externalFunctionInstSize, externalFunction, self);
		if (!(isBytes(functionName, self))) {
			goto l3;
		}
		ffiLogCallOfLength(firstIndexableField(functionName, self), byteSizeOf(functionName, self), self);
	}
	l3:	/* end ffiLogCallout: */;
	if ((requiredStackSize < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize, self);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	myThreadIndex = disownVM(
#  if COGMTVM
		(((calloutState->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		, self);
	if (((calloutState->floatRegisterIndex)) > 0) {
		loadFloatRegs(((calloutState->floatRegisters))[0], ((calloutState->floatRegisters))[1], ((calloutState->floatRegisters))[2], ((calloutState->floatRegisters))[3], ((calloutState->floatRegisters))[4], ((calloutState->floatRegisters))[5], ((calloutState->floatRegisters))[6], ((calloutState->floatRegisters))[7], self);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiRetHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSingleFloat) >> 1)) {
		if (atomicType == FFITypeSingleFloat) {
			floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
		}
		ownVM(myThreadIndex, self);
		result = floatObjectOf(floatRet, self);
		goto l9;
	}
	intRet = dispatchFunctionPointerwithwithwithwithwithwith(((SixteenByteReturn (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
	ownVM(myThreadIndex, self);
	if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			retVal = (intRet.a);
			/* begin ffiReturnType: */
			specLiteral = (argArrayOrNil != null
				? stackValue(1, self)
				: literalofMethod(0, primitiveMethod(self), self));
			argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral, self);
			retType = fetchPointerofObject(0, argTypes, self);
			retClass = fetchPointerofObject(1, retType, self);
			if (retClass == (nilObject(self))) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec1 = (calloutState->ffiRetHeader);
				atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer = ((usqInt) retVal);
					if (!(cPointer)) {
						retOop = nilObject(self);
						goto l5;
					}
					cString = ((char *) cPointer);
					strLen = 0;
					while (!((cString[strLen]) == 0)) {
						strLen += 1;
					}
					strOop = instantiateClassindexableSize(classString(self), strLen, self);
					strPtr = firstIndexableField(strOop, self);
					for (i1 = 0; i1 < strLen; i1 += 1) {
						strPtr[i1] = (cString[i1]);
					}
					retOop = strOop;
	l5:	/* end ffiReturnCStringFrom: */;
					result = retOop;
					goto l9;
				}
				
#if SPURVM
				oop2 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr1 = firstIndexableField(oop2, self);
				ptr1[0] = (((sqInt) retVal));
				retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
				storePointerofObjectwithValue(0, retOop, oop2, self);

#else /* SPURVM */
				pushRemappableOop(retType, self);
				oop2 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr1 = firstIndexableField(oop2, self);
				ptr1[0] = (((sqInt) retVal));
								pushRemappableOop(oop2, self);
				retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
				oop2 = popRemappableOop(self);
				storePointerofObjectwithValue(0, retOop, oop2, self);
				retType = popRemappableOop(self)
#endif /* SPURVM */
;
				storePointerofObjectwithValue(1, retOop, retType, self);
				result = retOop;
				goto l9;
			}
			classOop = (((calloutState->ffiRetHeader)) & FFIFlagStructure
				? classByteArray(self)
				: classExternalAddress(self));
			
#if SPURVM
			oop2 = instantiateClassindexableSize(classOop, BytesPerWord, self);

#else /* SPURVM */
			pushRemappableOop(retClass, self);
			oop2 = instantiateClassindexableSize(classOop, BytesPerWord, self);
			retClass = popRemappableOop(self)
#endif /* SPURVM */
;
			ptr1 = firstIndexableField(oop2, self);
			ptr1[0] = (((sqInt) retVal));
			
#if SPURVM
			retOop = instantiateClassindexableSize(retClass, 0, self);

#else /* SPURVM */
			pushRemappableOop(oop2, self);
			retOop = instantiateClassindexableSize(retClass, 0, self);
			oop2 = popRemappableOop(self)
#endif /* SPURVM */
;
			storePointerofObjectwithValue(0, retOop, oop2, self);
			result = retOop;
			goto l9;
		}
		/* begin ffiReturnStruct:ofType:in: */
		specLiteral1 = (argArrayOrNil != null
			? stackValue(1, self)
			: literalofMethod(0, primitiveMethod(self), self));
		argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1, self);
		ffiRetType = fetchPointerofObject(0, argTypes1, self);
		retClass1 = fetchPointerofObject(1, ffiRetType, self);
		retOop1 = instantiateClassindexableSize(retClass1, 0, self);
		
#if SPURVM
		oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);

#else /* SPURVM */
		pushRemappableOop(retOop1, self);
		oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);
		retOop1 = popRemappableOop(self)
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop1, self), (((calloutState->structReturnSize)) <= (WordSize * 2)
			? ((void *)((&intRet)))
			: (calloutState->limit)), (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop1, oop1, self);
		result = retOop1;
		goto l9;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	retVal1 = (intRet.a);
	assert(atomicType < FFITypeSingleFloat);
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(retVal1))
			? retVal1
			: retVal1 & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		result = (value == 0
			? falseObject(self)
			: trueObject(self));
		goto l9;
	}
	if (atomicType <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift = ((BytesPerWord == 8)
			 && (atomicType >= FFITypeUnsignedInt)
				? 32
				: (((usqInt) atomicType) >> 1) * 8);
			value = retVal1 & (((((unsigned long long)1)) << shift) - 1);
			if (atomicType & 1) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			result = integerObjectOf(value, self);
			goto l9;
		}
		result = (atomicType & 1
			? (BytesPerWord == 8
					? signed64BitIntegerFor(retVal1, self)
					: signed32BitIntegerFor(retVal1, self))
			: (BytesPerWord == 8
					? positive64BitIntegerFor(retVal1, self)
					: positive32BitIntegerFor(retVal1, self)));
		goto l9;
	}
	result = ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)
		? (atomicType & 1
				? signed64BitIntegerFor(retVal1, self)
				: positive64BitIntegerFor(retVal1, self))
		: characterObjectOf(retVal1 & 0xFF, self));
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
	/* begin cleanupCalloutState: */
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs + 1, result, self);
	return result;
}


/*	Make sure we can return an object of the given type */

	/* ThreadedFFIPlugin>>#ffiCheckReturn:With:in: */
static sqInt
ffiCheckReturnWithin(sqInt retSpec, sqInt retClass, CalloutState *calloutState, struct foo * self)
{
	if (!(retClass == (nilObject(self)))) {
		if (!(includesBehaviorThatOf(retClass, classExternalStructure(self), self))) {
			return FFIErrorBadReturn;
		}
	}
	if (!((isWords(retSpec, self))
		 && ((slotSizeOf(retSpec, self)) > 0))) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiRetHeader = fetchLong32ofObject(0, retSpec, self));
	if (!(((calloutState->ffiRetHeader)) & FFIFlagAtomic)) {
		if (retClass == (nilObject(self))) {
			return FFIErrorBadReturn;
		}
	}
	if ((((calloutState->ffiRetHeader)) & (FFIFlagPointer | FFIFlagStructure)) == FFIFlagStructure) {
		(calloutState->structReturnSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask);
	}
	return 0;
}


/*	Make sure that the given oop is a valid external handle */

	/* ThreadedFFIPlugin>>#ffiContentsOfHandle:errCode: */
static sqInt
ffiContentsOfHandleerrCode(sqInt oop, sqInt errCode, struct foo * self)
{
	if (!((isBytes(oop, self))
		 && ((byteSizeOf(oop, self)) == (sizeof(sqInt))))) {
		return ffiFail(errCode, self);
	}
	return fetchPointerofObject(0, oop, self);
}


/*	Callout support. Return the appropriate oop for the given atomic type */

	/* ThreadedFFIPlugin>>#ffiCreateIntegralResultOop:ofAtomicType:in: */
static sqInt
ffiCreateIntegralResultOopofAtomicTypein(usqLong retVal, sqInt atomicType, CalloutState *calloutState, struct foo * self)
{
    sqInt byteSize;
    usqLong mask;
    sqInt shift;
    usqLong value;

	assert(atomicType < FFITypeSingleFloat);
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(retVal))
			? retVal
			: retVal & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		return (value == 0
			? falseObject(self)
			: trueObject(self));
	}
	if (atomicType <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift = ((BytesPerWord == 8)
			 && (atomicType >= FFITypeUnsignedInt)
				? 32
				: (((usqInt) atomicType) >> 1) * 8);
			value = retVal & (((((unsigned long long)1)) << shift) - 1);
			if (atomicType & 1) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			return integerObjectOf(value, self);
		}
		return (atomicType & 1
			? (BytesPerWord == 8
					? signed64BitIntegerFor(retVal, self)
					: signed32BitIntegerFor(retVal, self))
			: (BytesPerWord == 8
					? positive64BitIntegerFor(retVal, self)
					: positive32BitIntegerFor(retVal, self)));
	}
	return ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)
		? (atomicType & 1
				? signed64BitIntegerFor(retVal, self)
				: positive64BitIntegerFor(retVal, self))
		: characterObjectOf(retVal & 0xFF, self));
}


/*	Map the FFI error code into a primitive error code. If reason is negative
	it encodes one of the
	standard PrimErr... codes, negated to distinguish it from the FFIError
	codes. If it is an FFIError...
	code then add the size of the primitive error table + 2 to disambiguate it
	from the PrimErr... codes.
	For historic reasons the FFIError codes range from -1 on up hence adding
	size + 2 maps them to
	size of table + 1 on up. This OFFSET IS undone by ExternalFunction
	class>>externalCallFailedWith:. Thus we can communicate back both
	PrimErr.. and FFIError codes. Complex but necessary. */

	/* ThreadedFFIPlugin>>#ffiFail: */
static sqInt
ffiFail(sqInt reason, struct foo * self)
{
	ffiLastError = reason;
	return primitiveFailFor((reason >= FFINoCalloutAvailable
		? (reason + 2) + (slotSizeOf(primitiveErrorTable(self), self))
		: -reason), self);
}


/*	Support for generic callout. Return a float value that is coerced as C
	would do.
 */

	/* ThreadedFFIPlugin>>#ffiFloatValueOf: */
static double
ffiFloatValueOf(sqInt oop, struct foo * self)
{
	if (isFloatObject(oop, self)) {
		return floatValueOf(oop, self);
	}
	return ((double) (ffiIntegerValueOf(oop, self)) );
}


/*	Support for generic callout. Answer an integer value that is coerced as C
	would do.
 */
/*	Cheat with a tag test */

	/* ThreadedFFIPlugin>>#ffiIntegerValueOf: */
static sqInt
ffiIntegerValueOf(sqInt oop, struct foo * self)
{
	if (oop & (BytesPerWord - 1)) {
		if (isIntegerObject(oop, self)) {
			return integerValueOf(oop, self);
		}
		
#    if SPURVM
		if (isCharacterObject(oop, self)) {

			/* Immediate in Spur */
			return characterValueOf(oop, self);
		}
		if (isFloatObject(oop, self)) {

			/* Immediate in 64-bit Spur */
			return floatValueOf(oop, self);
		}
#    endif /* SPURVM */
	}
	else {
		
#    if SPURVM

		/* No non-immediate characters in Spur */
#    else /* SPURVM */
		if (isCharacterObject(oop, self)) {
			return characterValueOf(oop, self);
		}
#    endif /* SPURVM */
		if (isFloatObject(oop, self)) {
			return floatValueOf(oop, self);
		}
		if (oop == (nilObject(self))) {
			return 0;
		}
		if (oop == (falseObject(self))) {
			return 0;
		}
		if (oop == (trueObject(self))) {
			return 1;
		}
		if (isLargePositiveIntegerObject(oop, self)) {
			
#      if BytesPerWord == 8

			/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
			return positive64BitValueOf(oop, self);
#      else /* BytesPerWord == 8 */
			return positive32BitValueOf(oop, self);
#      endif /* BytesPerWord == 8 */
		}
	}
	return signedMachineIntegerValueOf(oop, self);
}


/*	Load the function address for a call out to an external function */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutAddressFrom: */
static sqInt
ffiLoadCalloutAddressFrom(sqInt oop, struct foo * self)
{
    sqInt address;
    sqInt functionName;
    sqInt module;
    sqInt moduleHandle;


	/* First find and load the module */
	module = fetchPointerofObject(externalFunctionInstSize + 1, oop, self);
	moduleHandle = ffiLoadCalloutModule(module, self);
	if (failed(self)) {
		return 0;
	}
	functionName = fetchPointerofObject(externalFunctionInstSize, oop, self);
	if (!(isBytes(functionName, self))) {
		return ffiFail(FFIErrorBadExternalFunction, self);
	}
	address = ((sqInt)(ioLoadSymbolOfLengthFromModule(((sqInt)(firstIndexableField(functionName, self))), byteSizeOf(functionName, self), moduleHandle)));
	if ((failed(self))
	 || (address == 0)) {
		return ffiFail(FFIErrorAddressNotFound, self);
	}
	return address;
}


/*	Load the address of the foreign function from the given object */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutAddress: */
static sqInt
ffiLoadCalloutAddress(sqInt lit, struct foo * self)
{
    sqInt address;
    sqInt addressPtr;
    sqIntptr_t *ptr;


	/* Lookup the address */

	/* Make sure it's an external handle */
	addressPtr = fetchPointerofObject(0, lit, self);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(addressPtr, self))
		 && ((byteSizeOf(addressPtr, self)) == (sizeof(sqInt))))) {
		address = ffiFail(FFIErrorBadAddress, self);
		goto l1;
	}
	address = fetchPointerofObject(0, addressPtr, self);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed(self)) {
		return 0;
	}
	if (address == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, lit, integerObjectOf(-1, self), self);
		}
		if ((slotSizeOf(lit, self)) < 5) {
			return ffiFail(FFIErrorNoModule, self);
		}
		address = ffiLoadCalloutAddressFrom(lit, self);
		if (failed(self)) {
			return 0;
		}
		ptr = firstIndexableField(addressPtr, self);
		ptr[0] = address;
	}
	return address;
}


/*	Load the given module and return its handle */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutModule: */
static sqInt
ffiLoadCalloutModule(sqInt module, struct foo * self)
{
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    sqInt moduleLength;
    sqInt *ptr;
    sqInt rcvr;

	if (isBytes(module, self)) {

		/* plain module name */
		ffiModuleName = module;
		moduleLength = byteSizeOf(ffiModuleName, self);
		moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName, self))), moduleLength, self)));
		if ((failed(self))
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound, self);
		}
		return moduleHandle;
	}
	rcvr = stackValue(methodArgumentCount(self), self);
	if (!(isKindOfClass(rcvr, classExternalLibrary(self), self))) {
		return ffiFail(FFIErrorNoModule, self);
	}
	moduleHandlePtr = fetchPointerofObject(0, rcvr, self);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(moduleHandlePtr, self))
		 && ((byteSizeOf(moduleHandlePtr, self)) == (sizeof(sqInt))))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary, self);
		goto l1;
	}
	moduleHandle = fetchPointerofObject(0, moduleHandlePtr, self);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed(self)) {
		return 0;
	}
	if (moduleHandle == 0) {

		/* need to reload module */
		ffiModuleName = fetchPointerofObject(1, rcvr, self);
		if (!(isBytes(ffiModuleName, self))) {
			return ffiFail(FFIErrorBadExternalLibrary, self);
		}
		moduleLength = byteSizeOf(ffiModuleName, self);
		moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName, self))), moduleLength, self)));
		if ((failed(self))
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound, self);
		}
		ptr = firstIndexableField(moduleHandlePtr, self);
		ptr[0] = moduleHandle;
	}
	return moduleHandle;
}


/*	fetch the function name */

	/* ThreadedFFIPlugin>>#ffiLogCallout: */
static void
ffiLogCallout(sqInt lit, struct foo * self)
{
    sqInt functionName;

	if (ffiLogEnabled) {
		functionName = fetchPointerofObject(externalFunctionInstSize, lit, self);
		if (!(isBytes(functionName, self))) {
			return;
		}
		ffiLogCallOfLength(firstIndexableField(functionName, self), byteSizeOf(functionName, self), self);
	}
}


/*	This is a special entry point exposed such that client code can 
	enable and disable logging of FFI calls. */

	/* ThreadedFFIPlugin>>#ffiLogCallsTo: */
EXPORT(sqInt)
ffiLogCallsTo(char *fileName, struct foo * self)
{
    sqInt ok;

	if (fileName == null) {

		/* disable logging */
		ok = ffiLogFileNameOfLength(null, 0, self);
		if (!ok) {
			return 0;
		}
		ffiLogEnabled = 0;
	}
	else {

		/* enable logging */
		ok = ffiLogFileNameOfLength(fileName, strlen(fileName), self);
		if (!ok) {
			return 0;
		}
		ffiLogEnabled = 1;
	}
	return 1;
}


/*	Push the contents of the given external structure */

	/* ThreadedFFIPlugin>>#ffiPushPointerContentsOf:in: */
static sqInt
ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState, struct foo * self)
{
    void * ptrAddress;
    sqInt ptrClass;

	ptrClass = fetchClassOf(oop, self);
	if (ptrClass == (classExternalAddress(self))) {

		/* Don't you dare to pass pointers into object memory */
		ptrAddress = ((void *)(fetchPointerofObject(0, oop, self)));
		if (isInMemory(ptrAddress, self)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
		}
		return 0;
	}
	if (ptrClass == (classByteArray(self))) {

		/* Since this involves passing the address of the first indexable field we need to fail
		   the call if it is threaded and the object is young, since it may move during the call. */
		
#    if COGMTVM
		if ((((calloutState->callFlags)) & FFICallFlagThreaded)
		 && (isYoung(oop, self))) {
			return -PrimErrObjectMayMove;
		}
#    endif /* COGMTVM */
		ptrAddress = firstIndexableField(oop, self);
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
		}
		return 0;
	}
	if (includesBehaviorThatOf(ptrClass, classAlien(self), self)) {
		
#    if COGMTVM
		if ((((calloutState->callFlags)) & FFICallFlagThreaded)
		 && (((assert(isAlien(oop, self)),
		(longAt(oop + BaseHeaderSize)) > 0))
		 && (isYoung(oop, self)))) {
			return -PrimErrObjectMayMove;
		}
#    endif /* COGMTVM */
		ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
			? (oop + BaseHeaderSize) + BytesPerOop
			: longAt((oop + BaseHeaderSize) + BytesPerOop));
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
		}
		return 0;
	}
	return FFIErrorBadArg;
}

	/* ThreadedX64FFIPlugin>>#ffiPushPointer:in: */
static sqInt
ffiPushPointerin(void *pointer, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), pointer);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushSignedByte:in: */
static sqInt
ffiPushSignedBytein(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushSignedChar:in: */
static sqInt
ffiPushSignedCharin(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushSignedInt:in: */
static sqInt
ffiPushSignedIntin(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = value;
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}


/*	Push a longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported. */

	/* ThreadedFFIPlugin>>#ffiPushSignedLongLongOop:in: */
static sqInt
ffiPushSignedLongLongOopin(sqInt oop, CalloutState *calloutState, struct foo * self)
{
    sqLong value;

	if ((oop == (nilObject(self)))
	 || (oop == (falseObject(self)))) {
		value = 0;
	}
	else {
		if (oop == (trueObject(self))) {
			value = 1;
		}
		else {
			value = signed64BitValueOf(oop, self);
			if (failed(self)) {
				return FFIErrorCoercionFailed;
			}
		}
	}
	/* begin ffiPushSignedLongLong:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushSignedLongLong:in: */
static sqInt
ffiPushSignedLongLongin(sqLong value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushSignedShort:in: */
static sqInt
ffiPushSignedShortin(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed short) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed short) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushString:OfLength:in: */
static sqInt
ffiPushStringOfLengthin(char *pointer, sqInt length, CalloutState *calloutState, struct foo * self)
{
    char *copy;

	if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
		return -PrimErrBadNumArgs;
	}
	copy = malloc(length + 1);
	if (copy == null) {
		return -PrimErrNoCMemory;
	}
	memcpy(copy, pointer, length);
	copy[length] = 0;
	((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
	(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
	/* begin ffiPushPointer:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), copy);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}


/*	Push the contents of the given external structure */

	/* ThreadedFFIPlugin>>#ffiPushStructureContentsOf:in: */
static sqInt
ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState, struct foo * self)
{
    sqInt *argSpec;
    sqInt *argSpec1;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    int doubleType;
    int doubleType1;
    int floatType;
    int floatType1;
    int numDoubleRegisters;
    int numDoubleRegisters1;
    int numIntegerRegisters;
    int numIntegerRegisters1;
    sqInt passField0InXmmReg;
    sqInt passField0InXmmReg1;
    sqInt passField1InXmmReg;
    sqInt passField1InXmmReg1;
    void * ptrAddress;
    sqInt ptrClass;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt structSize;
    sqInt structSize1;

	passField1InXmmReg = 0;
	passField1InXmmReg1 = 0;
	ptrClass = fetchClassOf(oop, self);
	if (ptrClass == (classExternalAddress(self))) {

		/* ExternalAddress is bytes */

		/* There is no way we can make sure the structure is valid.
		   But we can at least check for attempts to pass pointers to ST memory. */
		ptrAddress = ((void *)(fetchPointerofObject(0, oop, self)));
		if (isInMemory(ptrAddress, self)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
		structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
		argSpec = (calloutState->ffiArgSpec);
		argSpecSize = (calloutState->ffiArgSpecSize);
		if (structSize <= 16) {

			/* See sec 3.2.3 of http://people.freebsd.org/~obrien/amd64-elf-abi.pdf. (dravft version 0.90).
			   All of the folowing are passed in registers:
			   typedef struct { long a; } s0;
			   typedef struct { double a; } s1;
			   typedef struct { long a; double b; } s2;
			   typedef struct { int a; int b; double c; } s2a;
			   typedef struct { short a; short b; short c; short d; double e; } s2b;
			   typedef struct { long a; float b; } s2f;
			   typedef struct { long a; float b; float c; } s2g;
			   but not ones like this:
			   typedef struct { int a; float b; int c; float d; } s2h; */
			doubleType = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeDoubleFloat;
			floatType = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeSingleFloat;
			passField0InXmmReg = (doubleType == ((((int *) argSpec))[1]))
			 || ((floatType == ((((int *) argSpec))[1]))
			 && (floatType == ((((int *) argSpec))[2])));
			if (structSize <= 8) {
				numDoubleRegisters = (passField0InXmmReg
					? 1
					: 0);
				numIntegerRegisters = 1 - numDoubleRegisters;
			}
			else {
				passField1InXmmReg = (doubleType == ((((int *) argSpec))[argSpecSize - 1]))
				 || ((floatType == ((((int *) argSpec))[argSpecSize - 2]))
				 && (floatType == ((((int *) argSpec))[argSpecSize - 1])));
				numDoubleRegisters = ((passField0InXmmReg
	? 1
	: 0)) + ((passField1InXmmReg
	? 1
	: 0));
				numIntegerRegisters = 2 - numDoubleRegisters;
			}
			if (((((calloutState->floatRegisterIndex)) + numDoubleRegisters) <= NumFloatRegArgs)
			 && ((((calloutState->integerRegisterIndex)) + numIntegerRegisters) <= NumIntRegArgs)) {
				if (passField0InXmmReg) {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
						((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[0]);
						(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
					}
					else {
						if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
							goto l1;
						}
						storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[0]);
						(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
					}
	l1:	/* end ffiPushDoubleFloat:in: */;
				}
				else {
					/* begin ffiPushSignedLongLong:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[0])));
						(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
					}
					else {
						if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
							goto l2;
						}
						longAtput((calloutState->currentArg), (((long long *) ptrAddress))[0]);
						(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
					}
	l2:	/* end ffiPushSignedLongLong:in: */;
				}
				if (structSize > 8) {
					if (passField1InXmmReg) {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[1]);
							(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								goto l3;
							}
							storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[1]);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
	l3:	/* end ffiPushDoubleFloat:in: */;
					}
					else {
						/* begin ffiPushSignedLongLong:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[1])));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								goto l4;
							}
							longAtput((calloutState->currentArg), (((long long *) ptrAddress))[1]);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
	l4:	/* end ffiPushSignedLongLong:in: */;
					}
				}
				return 0;
			}
		}
		roundedSize = (((structSize + 7) | 7) - 7);
		if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		memcpy((calloutState->currentArg), ((char *) ptrAddress), structSize);
		(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
		return 0;
	}
	if (ptrClass == (classByteArray(self))) {

		/* The following is a somewhat pessimistic test but I like being sure... */
		if (!((byteSizeOf(oop, self)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
			return FFIErrorStructSize;
		}
		ptrAddress = firstIndexableField(oop, self);
		if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

			/* Since this involves passing the address of the first indexable field we need to fail
			   the call if it is threaded and the object is young, since it may move during the call. */
			
#      if COGMTVM
			if ((((calloutState->callFlags)) & FFICallFlagThreaded)
			 && (isYoung(oop, self))) {
				return -PrimErrObjectMayMove;
			}
#      endif /* COGMTVM */
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec1 = (calloutState->ffiArgSpec);
			argSpecSize1 = (calloutState->ffiArgSpecSize);
			if (structSize1 <= 16) {

				/* See sec 3.2.3 of http://people.freebsd.org/~obrien/amd64-elf-abi.pdf. (dravft version 0.90).
				   All of the folowing are passed in registers:
				   typedef struct { long a; } s0;
				   typedef struct { double a; } s1;
				   typedef struct { long a; double b; } s2;
				   typedef struct { int a; int b; double c; } s2a;
				   typedef struct { short a; short b; short c; short d; double e; } s2b;
				   typedef struct { long a; float b; } s2f;
				   typedef struct { long a; float b; float c; } s2g;
				   but not ones like this:
				   typedef struct { int a; float b; int c; float d; } s2h; */
				doubleType1 = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeDoubleFloat;
				floatType1 = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeSingleFloat;
				passField0InXmmReg1 = (doubleType1 == ((((int *) argSpec1))[1]))
				 || ((floatType1 == ((((int *) argSpec1))[1]))
				 && (floatType1 == ((((int *) argSpec1))[2])));
				if (structSize1 <= 8) {
					numDoubleRegisters1 = (passField0InXmmReg1
						? 1
						: 0);
					numIntegerRegisters1 = 1 - numDoubleRegisters1;
				}
				else {
					passField1InXmmReg1 = (doubleType1 == ((((int *) argSpec1))[argSpecSize1 - 1]))
					 || ((floatType1 == ((((int *) argSpec1))[argSpecSize1 - 2]))
					 && (floatType1 == ((((int *) argSpec1))[argSpecSize1 - 1])));
					numDoubleRegisters1 = ((passField0InXmmReg1
	? 1
	: 0)) + ((passField1InXmmReg1
	? 1
	: 0));
					numIntegerRegisters1 = 2 - numDoubleRegisters1;
				}
				if (((((calloutState->floatRegisterIndex)) + numDoubleRegisters1) <= NumFloatRegArgs)
				 && ((((calloutState->integerRegisterIndex)) + numIntegerRegisters1) <= NumIntRegArgs)) {
					if (passField0InXmmReg1) {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[0]);
							(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								goto l6;
							}
							storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[0]);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
	l6:	/* end ffiPushDoubleFloat:in: */;
					}
					else {
						/* begin ffiPushSignedLongLong:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[0])));
							(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
						}
						else {
							if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
								goto l8;
							}
							longAtput((calloutState->currentArg), (((long long *) ptrAddress))[0]);
							(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
						}
	l8:	/* end ffiPushSignedLongLong:in: */;
					}
					if (structSize1 > 8) {
						if (passField1InXmmReg1) {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) ptrAddress))[1]);
								(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
							}
							else {
								if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
									goto l5;
								}
								storeFloatAtPointerfrom((calloutState->currentArg), (((double *) ptrAddress))[1]);
								(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
							}
	l5:	/* end ffiPushDoubleFloat:in: */;
						}
						else {
							/* begin ffiPushSignedLongLong:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) ptrAddress))[1])));
								(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
							}
							else {
								if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
									goto l7;
								}
								longAtput((calloutState->currentArg), (((long long *) ptrAddress))[1]);
								(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
							}
	l7:	/* end ffiPushSignedLongLong:in: */;
						}
					}
					return 0;
				}
			}
			roundedSize1 = (((structSize1 + 7) | 7) - 7);
			if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			memcpy((calloutState->currentArg), ((char *) ptrAddress), structSize1);
			(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
			return 0;
		}
		if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
			return FFIErrorStructSize;
		}
		ptrAddress = ((void *)(fetchPointerofObject(0, oop, self)));
		if (isInMemory(ptrAddress, self)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
		}
		return 0;
	}
	return FFIErrorBadArg;
}

	/* ThreadedX64SysVFFIPlugin>>#ffiPushStructure:ofSize:typeSpec:ofLength:in: */
static sqInt
ffiPushStructureofSizetypeSpecofLengthin(void *pointer, sqInt structSize, sqInt *argSpec, sqInt argSpecSize, CalloutState *calloutState, struct foo * self)
{
    int doubleType;
    int floatType;
    int numDoubleRegisters;
    int numIntegerRegisters;
    sqInt passField0InXmmReg;
    sqInt passField1InXmmReg;
    sqInt roundedSize;

	passField1InXmmReg = 0;
	if (structSize <= 16) {

		/* See sec 3.2.3 of http://people.freebsd.org/~obrien/amd64-elf-abi.pdf. (dravft version 0.90).
		   All of the folowing are passed in registers:
		   typedef struct { long a; } s0;
		   typedef struct { double a; } s1;
		   typedef struct { long a; double b; } s2;
		   typedef struct { int a; int b; double c; } s2a;
		   typedef struct { short a; short b; short c; short d; double e; } s2b;
		   typedef struct { long a; float b; } s2f;
		   typedef struct { long a; float b; float c; } s2g;
		   but not ones like this:
		   typedef struct { int a; float b; int c; float d; } s2h; */
		doubleType = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeDoubleFloat;
		floatType = (((sqInt)((usqInt)(FFITypeDoubleFloat) << FFIAtomicTypeShift))) + FFITypeSingleFloat;
		passField0InXmmReg = (doubleType == ((((int *) argSpec))[1]))
		 || ((floatType == ((((int *) argSpec))[1]))
		 && (floatType == ((((int *) argSpec))[2])));
		if (structSize <= 8) {
			numDoubleRegisters = (passField0InXmmReg
				? 1
				: 0);
			numIntegerRegisters = 1 - numDoubleRegisters;
		}
		else {
			passField1InXmmReg = (doubleType == ((((int *) argSpec))[argSpecSize - 1]))
			 || ((floatType == ((((int *) argSpec))[argSpecSize - 2]))
			 && (floatType == ((((int *) argSpec))[argSpecSize - 1])));
			numDoubleRegisters = ((passField0InXmmReg
	? 1
	: 0)) + ((passField1InXmmReg
	? 1
	: 0));
			numIntegerRegisters = 2 - numDoubleRegisters;
		}
		if (((((calloutState->floatRegisterIndex)) + numDoubleRegisters) <= NumFloatRegArgs)
		 && ((((calloutState->integerRegisterIndex)) + numIntegerRegisters) <= NumIntRegArgs)) {
			if (passField0InXmmReg) {
				/* begin ffiPushDoubleFloat:in: */
				if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
					((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) pointer))[0]);
					(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
				}
				else {
					if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
						goto l1;
					}
					storeFloatAtPointerfrom((calloutState->currentArg), (((double *) pointer))[0]);
					(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
				}
	l1:	/* end ffiPushDoubleFloat:in: */;
			}
			else {
				/* begin ffiPushSignedLongLong:in: */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) pointer))[0])));
					(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
				}
				else {
					if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
						goto l2;
					}
					longAtput((calloutState->currentArg), (((long long *) pointer))[0]);
					(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
				}
	l2:	/* end ffiPushSignedLongLong:in: */;
			}
			if (structSize > 8) {
				if (passField1InXmmReg) {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
						((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = ((((double *) pointer))[1]);
						(calloutState->floatRegisterIndex) = ((calloutState->floatRegisterIndex)) + 1;
					}
					else {
						if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
							goto l3;
						}
						storeFloatAtPointerfrom((calloutState->currentArg), (((double *) pointer))[1]);
						(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
					}
	l3:	/* end ffiPushDoubleFloat:in: */;
				}
				else {
					/* begin ffiPushSignedLongLong:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) ((((long long *) pointer))[1])));
						(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
					}
					else {
						if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
							goto l4;
						}
						longAtput((calloutState->currentArg), (((long long *) pointer))[1]);
						(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
					}
	l4:	/* end ffiPushSignedLongLong:in: */;
				}
			}
			return 0;
		}
	}
	roundedSize = (((structSize + 7) | 7) - 7);
	if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	memcpy((calloutState->currentArg), ((char *) pointer), structSize);
	(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushUnsignedByte:in: */
static sqInt
ffiPushUnsignedBytein(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushUnsignedChar:in: */
static sqInt
ffiPushUnsignedCharin(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushUnsignedInt:in: */
static sqInt
ffiPushUnsignedIntin(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = value;
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}


/*	Push an unsigned longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported. */

	/* ThreadedFFIPlugin>>#ffiPushUnsignedLongLongOop:in: */
static sqInt
ffiPushUnsignedLongLongOopin(sqInt oop, CalloutState *calloutState, struct foo * self)
{
    usqLong value;

	if ((oop == (nilObject(self)))
	 || (oop == (falseObject(self)))) {
		value = 0;
	}
	else {
		if (oop == (trueObject(self))) {
			value = 1;
		}
		else {
			value = positive64BitValueOf(oop, self);
			if (failed(self)) {
				return FFIErrorCoercionFailed;
			}
		}
	}
	/* begin ffiPushUnsignedLongLong:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = value;
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushUnsignedLongLong:in: */
static sqInt
ffiPushUnsignedLongLongin(usqLong value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = value;
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}

	/* ThreadedX64FFIPlugin>>#ffiPushUnsignedShort:in: */
static sqInt
ffiPushUnsignedShortin(sqInt value, CalloutState *calloutState, struct foo * self)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) value));
		(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
	}
	else {
		if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned short) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
	}
	return 0;
}


/*	This is a fallback in case somebody tries to pass a 'void' value.
	We could simply ignore the argument but I think it's better to let
	the caller know what he did */

	/* ThreadedFFIPlugin>>#ffiPushVoid:in: */
static sqInt
ffiPushVoidin(sqInt ignored, CalloutState *calloutState, struct foo * self)
{
	return FFIErrorAttemptToPassVoid;
}


/*	Create a Smalltalk string from a zero terminated C string */

	/* ThreadedFFIPlugin>>#ffiReturnCStringFrom: */
static sqInt
ffiReturnCStringFrom(sqInt cPointer, struct foo * self)
{
    char *cString;
    sqInt i;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;

	if (!(cPointer)) {
		return nilObject(self);
	}
	cString = ((char *) cPointer);
	strLen = 0;
	while (!((cString[strLen]) == 0)) {
		strLen += 1;
	}
	strOop = instantiateClassindexableSize(classString(self), strLen, self);
	strPtr = firstIndexableField(strOop, self);
	for (i = 0; i < strLen; i += 1) {
		strPtr[i] = (cString[i]);
	}
	return strOop;
}


/*	Generic callout support. Create a pointer return value from an external
	function call
 */

	/* ThreadedFFIPlugin>>#ffiReturnPointer:ofType:in: */
static sqInt
ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState, struct foo * self)
{
    sqInt atomicType;
    sqInt classOop;
    sqInt cPointer;
    char *cString;
    sqInt i;
    sqInt oop;
    sqInt *ptr;
    sqInt retClass;
    sqInt retOop;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt typeSpec;

	retClass = fetchPointerofObject(1, retType, self);
	if (retClass == (nilObject(self))) {

		/* Create ExternalData upon return */
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

			/* String return */
			/* begin ffiReturnCStringFrom: */
			cPointer = ((usqInt) retVal);
			if (!(cPointer)) {
				retOop = nilObject(self);
				goto l1;
			}
			cString = ((char *) cPointer);
			strLen = 0;
			while (!((cString[strLen]) == 0)) {
				strLen += 1;
			}
			strOop = instantiateClassindexableSize(classString(self), strLen, self);
			strPtr = firstIndexableField(strOop, self);
			for (i = 0; i < strLen; i += 1) {
				strPtr[i] = (cString[i]);
			}
			retOop = strOop;
	l1:	/* end ffiReturnCStringFrom: */;
			return retOop;
		}
		
#if SPURVM
		oop = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
		ptr = firstIndexableField(oop, self);
		ptr[0] = (((sqInt) retVal));
		retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
		storePointerofObjectwithValue(0, retOop, oop, self);

#else /* SPURVM */
		pushRemappableOop(retType, self);
		oop = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
		ptr = firstIndexableField(oop, self);
		ptr[0] = (((sqInt) retVal));
				pushRemappableOop(oop, self);
		retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
		oop = popRemappableOop(self);
		storePointerofObjectwithValue(0, retOop, oop, self);
		retType = popRemappableOop(self)
#endif /* SPURVM */
;
		storePointerofObjectwithValue(1, retOop, retType, self);
		return retOop;
	}
	classOop = (((calloutState->ffiRetHeader)) & FFIFlagStructure
		? classByteArray(self)
		: classExternalAddress(self));
	
#if SPURVM
	oop = instantiateClassindexableSize(classOop, BytesPerWord, self);

#else /* SPURVM */
	pushRemappableOop(retClass, self);
	oop = instantiateClassindexableSize(classOop, BytesPerWord, self);
	retClass = popRemappableOop(self)
#endif /* SPURVM */
;
	ptr = firstIndexableField(oop, self);
	ptr[0] = (((sqInt) retVal));
	
#if SPURVM
	retOop = instantiateClassindexableSize(retClass, 0, self);

#else /* SPURVM */
	pushRemappableOop(oop, self);
	retOop = instantiateClassindexableSize(retClass, 0, self);
	oop = popRemappableOop(self)
#endif /* SPURVM */
;
	storePointerofObjectwithValue(0, retOop, oop, self);
	return retOop;
}


/*	Create a structure return value from an external function call. The value
	has been stored in
	alloca'ed space pointed to by the calloutState or in the return value. */

	/* ThreadedX64SysVFFIPlugin>>#ffiReturnStruct:ofType:in: */
static sqInt
ffiReturnStructofTypein(SixteenByteReturn sixteenByteRet, sqInt ffiRetType, CalloutState *calloutState, struct foo * self)
{
    sqInt oop;
    sqInt retClass;
    sqInt retOop;

	retClass = fetchPointerofObject(1, ffiRetType, self);
	retOop = instantiateClassindexableSize(retClass, 0, self);
	
#if SPURVM
	oop = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);

#else /* SPURVM */
	pushRemappableOop(retOop, self);
	oop = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);
	retOop = popRemappableOop(self)
#endif /* SPURVM */
;
	memcpy(firstIndexableField(oop, self), (((calloutState->structReturnSize)) <= (WordSize * 2)
		? ((void *)((&sixteenByteRet)))
		: (calloutState->limit)), (calloutState->structReturnSize));
	storePointerofObjectwithValue(0, retOop, oop, self);
	return retOop;
}


/*	Answer the return type object for the current invocation */

	/* ThreadedFFIPlugin>>#ffiReturnType: */
static sqInt
ffiReturnType(sqInt specOnStack, struct foo * self)
{
    sqInt argTypes;
    sqInt specLiteral;

	specLiteral = (specOnStack
		? stackValue(1, self)
		: literalofMethod(0, primitiveMethod(self), self));
	argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral, self);
	return fetchPointerofObject(0, argTypes, self);
}


/*	Check that the calling convention is valid. This test also filters out
	attempts to do a threaded call in the non-threaded VM/plugin combinatioin. */

	/* ThreadedFFIPlugin>>#ffiSupportsCallingConvention: */
static sqInt
ffiSupportsCallingConvention(sqInt aCallingConvention, struct foo * self)
{
	return (aCallingConvention == FFICallTypeCDecl)
	 || (aCallingConvention == FFICallTypeApi);
}


/*	Validate if the given oop (an instance of ExternalData) can be passed as a
	pointer to the given atomic type.
 */

	/* ThreadedFFIPlugin>>#ffiValidateExternalData:AtomicType: */
static sqInt
ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType, struct foo * self)
{
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;

	ptrType = fetchPointerofObject(1, oop, self);
	if (!((isPointers(ptrType, self))
		 && ((slotSizeOf(ptrType, self)) >= 2))) {
		return FFIErrorWrongType;
	}
	specOop = fetchPointerofObject(0, ptrType, self);
	if (!((isWords(specOop, self))
		 && ((slotSizeOf(specOop, self)) > 0))) {
		return FFIErrorWrongType;
	}
	spec = fetchPointerofObject(0, specOop, self);
	if (!(spec & FFIFlagAtomic)) {
		return FFIErrorWrongType;
	}
	/* begin atomicTypeOf: */
	specType = ((usqInt) (spec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if (specType != atomicType) {

		/* Allow for signed/unsigned conversion but nothing else.
		   See FFIConstants class>>#initializeTypeConstants */
		if (!((atomicType >= FFITypeUnsignedByte)
			 && ((atomicType <= FFITypeSignedChar)
			 && ((((usqInt) atomicType) >> 1) == (((usqInt) specType) >> 1))))) {
			return FFIErrorCoercionFailed;
		}
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* ThreadedFFIPlugin>>#getModuleName */
EXPORT(const char *)
getModuleName(void)
{
	return "SqueakFFIPrims";
}

	/* ThreadedFFICalloutStateForX64>>#incrementFloatRegisterIndex */
static sqInt
incrementFloatRegisterIndex(CalloutState * self_in_incrementFloatRegisterIndex)
{
	return ((self_in_incrementFloatRegisterIndex->floatRegisterIndex) = ((self_in_incrementFloatRegisterIndex->floatRegisterIndex)) + 1);
}

	/* ThreadedFFICalloutStateForX64>>#incrementIntegerRegisterIndex */
static sqInt
incrementIntegerRegisterIndex(CalloutState * self_in_incrementIntegerRegisterIndex)
{
	return ((self_in_incrementIntegerRegisterIndex->integerRegisterIndex) = ((self_in_incrementIntegerRegisterIndex->integerRegisterIndex)) + 1);
}

	/* ThreadedFFIPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(struct foo * self)
{

	/* By default, disable logging */
	ffiLastError = 0;

	/* Get the instSize of ExternalFunction to know whether it contains a cache of the stackSize,
	   and what the offset of ExternalLibraryFunction's functionName and moduleName slots are. */
	ffiLogEnabled = 0;
	externalFunctionInstSize = instanceSizeOf(classExternalFunction(self), self);
	initSurfacePluginFunctionPointers(self);
	return 1;
}

	/* ThreadedFFIPlugin>>#isAlien: */
static sqInt
isAlien(sqInt anOop, struct foo * self)
{
	return includesBehaviorThatOf(fetchClassOf(anOop, self), classAlien(self), self);
}

	/* ThreadedFFIPlugin>>#isAtomicType: */
static sqInt
isAtomicType(sqInt typeSpec, struct foo * self)
{
	return typeSpec & FFIFlagAtomic;
}

	/* ThreadedFFIPlugin>>#isDirectAlien: */
static sqInt
isDirectAlien(sqInt oop, struct foo * self)
{
	assert(isAlien(oop, self));
	return (longAt(oop + BaseHeaderSize)) > 0;
}

	/* ThreadedFFIPlugin>>#msg: */
static sqInt
msg(char *s, struct foo * self)
{
	fprintf(stderr, "\n%s: %s", getModuleName(), s);
	return 0;
}


/*	Answer if a struct returned in memory is returned to the
	referent of a pointer passed as an implciit first argument.
	It almost always is. Subclasses can override if not. */

	/* ThreadedFFIPlugin>>#nonRegisterStructReturnIsViaImplicitFirstArgument */
static sqInt
nonRegisterStructReturnIsViaImplicitFirstArgument(struct foo * self)
{
	return 1;
}


/*	IMPORTANT: IF YOU CHANGE THE NAME OF THIS METHOD YOU MUST CHANGE
	Interpreter>>primitiveCalloutToFFI
	TO REFLECT THE CHANGE. */
/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec. */

	/* ThreadedFFIPlugin>>#primitiveCallout */
EXPORT(void)
primitiveCallout(struct foo * self)
{
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt addressPtr;
    sqInt addressPtr1;
    char *allocation;
    char *allocation1;
    sqInt argClass;
    sqInt argClass1;
    sqInt argSpec;
    sqInt argSpec1;
    sqInt argType;
    sqInt argType1;
    sqInt argTypeArray;
    sqInt argTypeArray1;
    sqInt argTypes;
    sqInt argTypes1;
    sqInt argTypes2;
    sqInt argTypes3;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType11;
    sqInt atomicType2;
    sqInt byteSize;
    sqInt byteSize1;
    CalloutState *calloutState;
    CalloutState *calloutState1;
    sqInt classOop;
    sqInt classOop1;
    sqInt cPointer;
    sqInt cPointer1;
    char *cString;
    char *cString1;
    sqInt err;
    sqInt err1;
    sqInt externalFunction;
    sqInt ffiRetType;
    sqInt ffiRetType1;
    sqInt flags;
    sqInt flags1;
    double floatRet;
    double floatRet1;
    sqInt functionName;
    sqInt functionName1;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    SixteenByteReturn intRet;
    SixteenByteReturn intRet1;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double, struct foo * self);
    usqLong mask;
    usqLong mask1;
    sqInt meth;
    sqInt myThreadIndex;
    sqInt myThreadIndex1;
    sqInt nArgs;
    sqInt nArgs1;
    sqInt oop;
    sqInt oop1;
    sqInt oop11;
    sqInt oop2;
    sqInt oop21;
    sqInt oop3;
    void *pointer;
    void *pointer1;
    sqInt primNumArgs;
    sqInt primNumArgs1;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    sqInt *ptr11;
    sqIntptr_t *ptr2;
    sqInt requiredStackSize;
    sqInt requiredStackSize1;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt retClass;
    sqInt retClass1;
    sqInt retClass11;
    sqInt retClass2;
    sqInt retOop;
    sqInt retOop1;
    sqInt retOop11;
    sqInt retOop2;
    sqInt retryCount;
    sqInt retType;
    sqInt retType1;
    usqLong retVal;
    usqLong retVal1;
    usqLong retVal11;
    usqLong retVal2;
    sqInt shift;
    sqInt shift1;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt specLiteral2;
    sqInt specLiteral3;
    sqInt stackSize;
    sqInt stackSize1;
    sqInt strLen;
    sqInt strLen1;
    sqInt strOop;
    sqInt strOop1;
    char *strPtr;
    char *strPtr1;
    CalloutState theCalloutState;
    CalloutState theCalloutState1;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec11;
    sqInt typeSpec2;
    usqLong value;
    usqLong value1;

	meth = primitiveMethod(self);
	if (!((literalCountOf(meth, self)) > 0)) {
		primitiveFailFor(PrimErrBadMethod, self);
		return;
	}
	externalFunction = literalofMethod(0, meth, self);
	
#  if COGMTVM
	nArgs = methodArgumentCount(self);
	retryCount = 0;
	while (1) {
		/* begin ffiCall:ArgArrayOrNil:NumArgs: */
		primNumArgs = methodArgumentCount(self);
		if (!(isKindOfClass(externalFunction, classExternalFunction(self), self))) {
			result = ffiFail(FFIErrorNotFunction, self);
			goto l10;
		}
		flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction, self);
		if (failed(self)) {
			result = ffiFail(FFIErrorBadArgs, self);
			goto l10;
		}
		/* begin ffiLoadCalloutAddress: */

		/* Make sure it's an external handle */
		addressPtr = fetchPointerofObject(0, externalFunction, self);
		if (!((isBytes(addressPtr, self))
			 && ((byteSizeOf(addressPtr, self)) == (sizeof(sqInt))))) {
			address1 = ffiFail(FFIErrorBadAddress, self);
			goto l1;
		}
		address1 = fetchPointerofObject(0, addressPtr, self);
	l1:	/* end ffiContentsOfHandle:errCode: */;
		if (failed(self)) {
			address = 0;
			goto l2;
		}
		if (address1 == 0) {

			/* Go look it up in the module */
			if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
				storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1, self), self);
			}
			if ((slotSizeOf(externalFunction, self)) < 5) {
				address = ffiFail(FFIErrorNoModule, self);
				goto l2;
			}
			address1 = ffiLoadCalloutAddressFrom(externalFunction, self);
			if (failed(self)) {
				address = 0;
				goto l2;
			}
			ptr = firstIndexableField(addressPtr, self);
			ptr[0] = address1;
		}
		address = address1;
	l2:	/* end ffiLoadCalloutAddress: */;
		if (failed(self)) {
			result = 0;
			goto l10;
		}

		/* must be array of arg types */
		argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction, self);
		if (!((isArray(argTypeArray, self))
			 && ((slotSizeOf(argTypeArray, self)) == (nArgs + 1)))) {
			result = ffiFail(FFIErrorBadArgs, self);
			goto l10;
		}
		
#    if COGMTVM
		if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
			 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType, self);
			goto l10;
		}
#    else /* COGMTVM */

		/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
		if (!((flags == FFICallTypeCDecl)
			 || (flags == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType, self);
			goto l10;
		}
#    endif /* COGMTVM */
		requiredStackSize = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
			? fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction, self)
			: -1);
		if (failed(self)) {
			result = primitiveFailFor((null == null
				? PrimErrBadMethod
				: PrimErrBadReceiver), self);
			goto l10;
		}
		stackSize = (requiredStackSize < 0
			? DefaultMaxStackSize
			: requiredStackSize);
		calloutState = (&theCalloutState);
		memset(calloutState, 0, sizeof(CalloutState));
		(calloutState->callFlags = flags);
		argType = fetchPointerofObject(0, argTypeArray, self);
		argSpec = fetchPointerofObject(0, argType, self);
		argClass = fetchPointerofObject(1, argType, self);
		if (((err = ffiCheckReturnWithin(argSpec, argClass, calloutState, self))) != 0) {
			result = ffiFail(err, self);
			goto l10;
		}
		allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
		if (mustAlignStack()) {
			allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
		}
		(calloutState->argVector = allocation);
		(calloutState->currentArg = allocation);
		(calloutState->limit = allocation + stackSize);
		if ((((calloutState->structReturnSize)) > 0)
		 && (1
		 && (!(((calloutState->structReturnSize)) <= (WordSize * 2))))) {
			/* begin ffiPushPointer:in: */
			pointer = (calloutState->limit);
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					err = FFIErrorCallFrameTooBig;
					goto l4;
				}
				longAtput((calloutState->currentArg), pointer);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			err = 0;
	l4:	/* end ffiPushPointer:in: */;
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l10;
				}
#        endif /* COGMTVM */
				result = ffiFail(err, self);
				goto l10;
			}
		}
		for (i = 1; i <= nArgs; i += 1) {
			argType = fetchPointerofObject(i, argTypeArray, self);
			argSpec = fetchPointerofObject(0, argType, self);
			argClass = fetchPointerofObject(1, argType, self);
			oop = (null == null
				? stackValue(nArgs - i, self)
				: fetchPointerofObject(i - 1, null, self));
			err = ffiArgumentSpecClassin(oop, argSpec, argClass, calloutState, self);
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l10;
				}
#        endif /* COGMTVM */
				result = ffiFail(err, self);
				goto l10;
			}
		}
		assert(!(failed(self)));
		/* begin ffiLogCallout: */
		if (ffiLogEnabled) {
			functionName = fetchPointerofObject(externalFunctionInstSize, externalFunction, self);
			if (!(isBytes(functionName, self))) {
				goto l3;
			}
			ffiLogCallOfLength(firstIndexableField(functionName, self), byteSizeOf(functionName, self), self);
		}
	l3:	/* end ffiLogCallout: */;
		if ((requiredStackSize < 0)
		 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
			stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
			storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize, self);
		}
		/* begin ffiCalloutTo:SpecOnStack:in: */
		myThreadIndex = disownVM(
#    if COGMTVM
			(((calloutState->callFlags)) & FFICallFlagThreaded
						? DisownVMForFFICall + DisownVMForThreading
						: DisownVMForFFICall)
#    else /* COGMTVM */
			DisownVMForFFICall
#    endif /* COGMTVM */
			, self);
		if (((calloutState->floatRegisterIndex)) > 0) {
			loadFloatRegs(((calloutState->floatRegisters))[0], ((calloutState->floatRegisters))[1], ((calloutState->floatRegisters))[2], ((calloutState->floatRegisters))[3], ((calloutState->floatRegisters))[4], ((calloutState->floatRegisters))[5], ((calloutState->floatRegisters))[6], ((calloutState->floatRegisters))[7], self);
		}
		if ((allocaLiesSoSetSpBeforeCall())
		 || (mustAlignStack())) {
			setsp((calloutState->argVector));
		}
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSingleFloat) >> 1)) {
			if (atomicType == FFITypeSingleFloat) {
				floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
			}
			else {

				/* atomicType = FFITypeDoubleFloat */
				floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
			}
			ownVM(myThreadIndex, self);
			result1 = floatObjectOf(floatRet, self);
			goto l9;
		}
		intRet = dispatchFunctionPointerwithwithwithwithwithwith(((SixteenByteReturn (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
		ownVM(myThreadIndex, self);
		if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

			/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
			   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
			if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
				/* begin ffiReturnPointer:ofType:in: */
				retVal = (intRet.a);
				/* begin ffiReturnType: */
				specLiteral = (null != null
					? stackValue(1, self)
					: literalofMethod(0, primitiveMethod(self), self));
				argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral, self);
				retType = fetchPointerofObject(0, argTypes, self);
				retClass = fetchPointerofObject(1, retType, self);
				if (retClass == (nilObject(self))) {

					/* Create ExternalData upon return */
					/* begin atomicTypeOf: */
					typeSpec1 = (calloutState->ffiRetHeader);
					atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
					if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

						/* String return */
						/* begin ffiReturnCStringFrom: */
						cPointer = ((usqInt) retVal);
						if (!(cPointer)) {
							retOop = nilObject(self);
							goto l5;
						}
						cString = ((char *) cPointer);
						strLen = 0;
						while (!((cString[strLen]) == 0)) {
							strLen += 1;
						}
						strOop = instantiateClassindexableSize(classString(self), strLen, self);
						strPtr = firstIndexableField(strOop, self);
						for (i1 = 0; i1 < strLen; i1 += 1) {
							strPtr[i1] = (cString[i1]);
						}
						retOop = strOop;
	l5:	/* end ffiReturnCStringFrom: */;
						result1 = retOop;
						goto l9;
					}
					
#if SPURVM
					oop2 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
					ptr1 = firstIndexableField(oop2, self);
					ptr1[0] = (((sqInt) retVal));
					retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
					storePointerofObjectwithValue(0, retOop, oop2, self);

#else /* SPURVM */
					pushRemappableOop(retType, self);
					oop2 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
					ptr1 = firstIndexableField(oop2, self);
					ptr1[0] = (((sqInt) retVal));
										pushRemappableOop(oop2, self);
					retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
					oop2 = popRemappableOop(self);
					storePointerofObjectwithValue(0, retOop, oop2, self);
					retType = popRemappableOop(self)
#endif /* SPURVM */
;
					storePointerofObjectwithValue(1, retOop, retType, self);
					result1 = retOop;
					goto l9;
				}
				classOop = (((calloutState->ffiRetHeader)) & FFIFlagStructure
					? classByteArray(self)
					: classExternalAddress(self));
				
#if SPURVM
				oop2 = instantiateClassindexableSize(classOop, BytesPerWord, self);

#else /* SPURVM */
				pushRemappableOop(retClass, self);
				oop2 = instantiateClassindexableSize(classOop, BytesPerWord, self);
				retClass = popRemappableOop(self)
#endif /* SPURVM */
;
				ptr1 = firstIndexableField(oop2, self);
				ptr1[0] = (((sqInt) retVal));
				
#if SPURVM
				retOop = instantiateClassindexableSize(retClass, 0, self);

#else /* SPURVM */
				pushRemappableOop(oop2, self);
				retOop = instantiateClassindexableSize(retClass, 0, self);
				oop2 = popRemappableOop(self)
#endif /* SPURVM */
;
				storePointerofObjectwithValue(0, retOop, oop2, self);
				result1 = retOop;
				goto l9;
			}
			/* begin ffiReturnStruct:ofType:in: */
			specLiteral2 = (null != null
				? stackValue(1, self)
				: literalofMethod(0, primitiveMethod(self), self));
			argTypes2 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral2, self);
			ffiRetType = fetchPointerofObject(0, argTypes2, self);
			retClass1 = fetchPointerofObject(1, ffiRetType, self);
			retOop1 = instantiateClassindexableSize(retClass1, 0, self);
			
#if SPURVM
			oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);

#else /* SPURVM */
			pushRemappableOop(retOop1, self);
			oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);
			retOop1 = popRemappableOop(self)
#endif /* SPURVM */
;
			memcpy(firstIndexableField(oop1, self), (((calloutState->structReturnSize)) <= (WordSize * 2)
				? ((void *)((&intRet)))
				: (calloutState->limit)), (calloutState->structReturnSize));
			storePointerofObjectwithValue(0, retOop1, oop1, self);
			result1 = retOop1;
			goto l9;
		}
		/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
		retVal1 = (intRet.a);
		assert(atomicType < FFITypeSingleFloat);
		if (atomicType == FFITypeBool) {

			/* Make sure bool honors the byte size requested */
			byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
			value = (byteSize == (sizeof(retVal1))
				? retVal1
				: retVal1 & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
			result1 = (value == 0
				? falseObject(self)
				: trueObject(self));
			goto l9;
		}
		if (atomicType <= FFITypeSignedInt) {

			/* these are all generall integer returns */
			if (atomicType <= ((BytesPerWord == 8
				? FFITypeSignedInt
				: FFITypeSignedShort))) {

				/* byte/short. first extract partial word, then sign extend */

				/* # of significant bits */
				shift = ((BytesPerWord == 8)
				 && (atomicType >= FFITypeUnsignedInt)
					? 32
					: (((usqInt) atomicType) >> 1) * 8);
				value = retVal1 & (((((unsigned long long)1)) << shift) - 1);
				if (atomicType & 1) {

					/* make the guy signed */
					mask = (((unsigned long long)1)) << (shift - 1);
					value = (value & (mask - 1)) - (value & mask);
				}
				result1 = integerObjectOf(value, self);
				goto l9;
			}
			result1 = (atomicType & 1
				? (BytesPerWord == 8
						? signed64BitIntegerFor(retVal1, self)
						: signed32BitIntegerFor(retVal1, self))
				: (BytesPerWord == 8
						? positive64BitIntegerFor(retVal1, self)
						: positive32BitIntegerFor(retVal1, self)));
			goto l9;
		}
		result1 = ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)
			? (atomicType & 1
					? signed64BitIntegerFor(retVal1, self)
					: positive64BitIntegerFor(retVal1, self))
			: characterObjectOf(retVal1 & 0xFF, self));
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
		/* begin cleanupCalloutState: */
		while (((calloutState->stringArgIndex)) > 0) {
			free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
		}
		popthenPush(primNumArgs + 1, result1, self);
		result = result1;
	l10:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
		if (!((result == PrimErrObjectMayMove)
		 && (((retryCount += 1)) <= (nArgs + 1)))) break;
		tenuringIncrementalGC(self);
	}
#  else /* COGMTVM */
	/* begin ffiCall:ArgArrayOrNil:NumArgs: */
	nArgs1 = methodArgumentCount(self);
	primNumArgs1 = methodArgumentCount(self);
	if (!(isKindOfClass(externalFunction, classExternalFunction(self), self))) {
		ffiFail(FFIErrorNotFunction, self);
		goto l20;
	}
	flags1 = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction, self);
	if (failed(self)) {
		ffiFail(FFIErrorBadArgs, self);
		goto l20;
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr1 = fetchPointerofObject(0, externalFunction, self);
	if (!((isBytes(addressPtr1, self))
		 && ((byteSizeOf(addressPtr1, self)) == (sizeof(sqInt))))) {
		address11 = ffiFail(FFIErrorBadAddress, self);
		goto l13;
	}
	address11 = fetchPointerofObject(0, addressPtr1, self);
	l13:	/* end ffiContentsOfHandle:errCode: */;
	if (failed(self)) {
		address2 = 0;
		goto l19;
	}
	if (address11 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1, self), self);
		}
		if ((slotSizeOf(externalFunction, self)) < 5) {
			address2 = ffiFail(FFIErrorNoModule, self);
			goto l19;
		}
		address11 = ffiLoadCalloutAddressFrom(externalFunction, self);
		if (failed(self)) {
			address2 = 0;
			goto l19;
		}
		ptr2 = firstIndexableField(addressPtr1, self);
		ptr2[0] = address11;
	}
	address2 = address11;
	l19:	/* end ffiLoadCalloutAddress: */;
	if (failed(self)) {
		goto l20;
	}

	/* must be array of arg types */
	argTypeArray1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction, self);
	if (!((isArray(argTypeArray1, self))
		 && ((slotSizeOf(argTypeArray1, self)) == (nArgs1 + 1)))) {
		ffiFail(FFIErrorBadArgs, self);
		goto l20;
	}
	
#  if COGMTVM
	if (!(((flags1 & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags1 & FFICallTypesMask) == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType, self);
		goto l20;
	}
#  else /* COGMTVM */

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags1 == FFICallTypeCDecl)
		 || (flags1 == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType, self);
		goto l20;
	}
#  endif /* COGMTVM */
	requiredStackSize1 = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
		? fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction, self)
		: -1);
	if (failed(self)) {
		primitiveFailFor((null == null
			? PrimErrBadMethod
			: PrimErrBadReceiver), self);
		goto l20;
	}
	stackSize1 = (requiredStackSize1 < 0
		? DefaultMaxStackSize
		: requiredStackSize1);
	calloutState1 = (&theCalloutState1);
	memset(calloutState1, 0, sizeof(CalloutState));
	(calloutState1->callFlags = flags1);
	argType1 = fetchPointerofObject(0, argTypeArray1, self);
	argSpec1 = fetchPointerofObject(0, argType1, self);
	argClass1 = fetchPointerofObject(1, argType1, self);
	if (((err1 = ffiCheckReturnWithin(argSpec1, argClass1, calloutState1, self))) != 0) {
		ffiFail(err1, self);
		goto l20;
	}
	allocation1 = alloca((stackSize1 + ((calloutState1->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation1 = ((char *) ((((((usqIntptr_t)allocation1)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState1->argVector = allocation1);
	(calloutState1->currentArg = allocation1);
	(calloutState1->limit = allocation1 + stackSize1);
	if ((((calloutState1->structReturnSize)) > 0)
	 && (1
	 && (!(((calloutState1->structReturnSize)) <= (WordSize * 2))))) {
		/* begin ffiPushPointer:in: */
		pointer1 = (calloutState1->limit);
		if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer1));
			(calloutState1->integerRegisterIndex) = ((calloutState1->integerRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState1->currentArg)) + WordSize) > ((calloutState1->limit))) {
				err1 = FFIErrorCallFrameTooBig;
				goto l12;
			}
			longAtput((calloutState1->currentArg), pointer1);
			(calloutState1->currentArg = ((calloutState1->currentArg)) + WordSize);
		}
		err1 = 0;
	l12:	/* end ffiPushPointer:in: */;
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l20;
			}
#      endif /* COGMTVM */
			ffiFail(err1, self);
			goto l20;
		}
	}
	for (i2 = 1; i2 <= nArgs1; i2 += 1) {
		argType1 = fetchPointerofObject(i2, argTypeArray1, self);
		argSpec1 = fetchPointerofObject(0, argType1, self);
		argClass1 = fetchPointerofObject(1, argType1, self);
		oop3 = (null == null
			? stackValue(nArgs1 - i2, self)
			: fetchPointerofObject(i2 - 1, null, self));
		err1 = ffiArgumentSpecClassin(oop3, argSpec1, argClass1, calloutState1, self);
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l20;
			}
#      endif /* COGMTVM */
			ffiFail(err1, self);
			goto l20;
		}
	}
	assert(!(failed(self)));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		functionName1 = fetchPointerofObject(externalFunctionInstSize, externalFunction, self);
		if (!(isBytes(functionName1, self))) {
			goto l16;
		}
		ffiLogCallOfLength(firstIndexableField(functionName1, self), byteSizeOf(functionName1, self), self);
	}
	l16:	/* end ffiLogCallout: */;
	if ((requiredStackSize1 < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize1 = ((calloutState1->currentArg)) - ((calloutState1->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize1, self);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	myThreadIndex1 = disownVM(
#  if COGMTVM
		(((calloutState1->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		, self);
	if (((calloutState1->floatRegisterIndex)) > 0) {
		loadFloatRegs(((calloutState1->floatRegisters))[0], ((calloutState1->floatRegisters))[1], ((calloutState1->floatRegisters))[2], ((calloutState1->floatRegisters))[3], ((calloutState1->floatRegisters))[4], ((calloutState1->floatRegisters))[5], ((calloutState1->floatRegisters))[6], ((calloutState1->floatRegisters))[7], self);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState1->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec2 = (calloutState1->ffiRetHeader);
	atomicType2 = ((usqInt) (typeSpec2 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((((usqInt) atomicType2) >> 1) == (((usqInt) FFITypeSingleFloat) >> 1)) {
		if (atomicType2 == FFITypeSingleFloat) {
			floatRet1 = dispatchFunctionPointerwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3], ((calloutState1->integerRegisters))[4], ((calloutState1->integerRegisters))[5]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet1 = dispatchFunctionPointerwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3], ((calloutState1->integerRegisters))[4], ((calloutState1->integerRegisters))[5]);
		}
		ownVM(myThreadIndex1, self);
		result2 = floatObjectOf(floatRet1, self);
		goto l14;
	}
	intRet1 = dispatchFunctionPointerwithwithwithwithwithwith(((SixteenByteReturn (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3], ((calloutState1->integerRegisters))[4], ((calloutState1->integerRegisters))[5]);
	ownVM(myThreadIndex1, self);
	if (((calloutState1->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState1->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			retVal2 = (intRet1.a);
			/* begin ffiReturnType: */
			specLiteral1 = (null != null
				? stackValue(1, self)
				: literalofMethod(0, primitiveMethod(self), self));
			argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1, self);
			retType1 = fetchPointerofObject(0, argTypes1, self);
			retClass2 = fetchPointerofObject(1, retType1, self);
			if (retClass2 == (nilObject(self))) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec11 = (calloutState1->ffiRetHeader);
				atomicType11 = ((usqInt) (typeSpec11 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if ((((usqInt) atomicType11) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer1 = ((usqInt) retVal2);
					if (!(cPointer1)) {
						retOop2 = nilObject(self);
						goto l18;
					}
					cString1 = ((char *) cPointer1);
					strLen1 = 0;
					while (!((cString1[strLen1]) == 0)) {
						strLen1 += 1;
					}
					strOop1 = instantiateClassindexableSize(classString(self), strLen1, self);
					strPtr1 = firstIndexableField(strOop1, self);
					for (i11 = 0; i11 < strLen1; i11 += 1) {
						strPtr1[i11] = (cString1[i11]);
					}
					retOop2 = strOop1;
	l18:	/* end ffiReturnCStringFrom: */;
					result2 = retOop2;
					goto l14;
				}
				
#if SPURVM
				oop21 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr11 = firstIndexableField(oop21, self);
				ptr11[0] = (((sqInt) retVal2));
				retOop2 = instantiateClassindexableSize(classExternalData(self), 0, self);
				storePointerofObjectwithValue(0, retOop2, oop21, self);

#else /* SPURVM */
				pushRemappableOop(retType1, self);
				oop21 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr11 = firstIndexableField(oop21, self);
				ptr11[0] = (((sqInt) retVal2));
								pushRemappableOop(oop21, self);
				retOop2 = instantiateClassindexableSize(classExternalData(self), 0, self);
				oop21 = popRemappableOop(self);
				storePointerofObjectwithValue(0, retOop2, oop21, self);
				retType1 = popRemappableOop(self)
#endif /* SPURVM */
;
				storePointerofObjectwithValue(1, retOop2, retType1, self);
				result2 = retOop2;
				goto l14;
			}
			classOop1 = (((calloutState1->ffiRetHeader)) & FFIFlagStructure
				? classByteArray(self)
				: classExternalAddress(self));
			
#if SPURVM
			oop21 = instantiateClassindexableSize(classOop1, BytesPerWord, self);

#else /* SPURVM */
			pushRemappableOop(retClass2, self);
			oop21 = instantiateClassindexableSize(classOop1, BytesPerWord, self);
			retClass2 = popRemappableOop(self)
#endif /* SPURVM */
;
			ptr11 = firstIndexableField(oop21, self);
			ptr11[0] = (((sqInt) retVal2));
			
#if SPURVM
			retOop2 = instantiateClassindexableSize(retClass2, 0, self);

#else /* SPURVM */
			pushRemappableOop(oop21, self);
			retOop2 = instantiateClassindexableSize(retClass2, 0, self);
			oop21 = popRemappableOop(self)
#endif /* SPURVM */
;
			storePointerofObjectwithValue(0, retOop2, oop21, self);
			result2 = retOop2;
			goto l14;
		}
		/* begin ffiReturnStruct:ofType:in: */
		specLiteral3 = (null != null
			? stackValue(1, self)
			: literalofMethod(0, primitiveMethod(self), self));
		argTypes3 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral3, self);
		ffiRetType1 = fetchPointerofObject(0, argTypes3, self);
		retClass11 = fetchPointerofObject(1, ffiRetType1, self);
		retOop11 = instantiateClassindexableSize(retClass11, 0, self);
		
#if SPURVM
		oop11 = instantiateClassindexableSize(classByteArray(self), (calloutState1->structReturnSize), self);

#else /* SPURVM */
		pushRemappableOop(retOop11, self);
		oop11 = instantiateClassindexableSize(classByteArray(self), (calloutState1->structReturnSize), self);
		retOop11 = popRemappableOop(self)
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop11, self), (((calloutState1->structReturnSize)) <= (WordSize * 2)
			? ((void *)((&intRet1)))
			: (calloutState1->limit)), (calloutState1->structReturnSize));
		storePointerofObjectwithValue(0, retOop11, oop11, self);
		result2 = retOop11;
		goto l14;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	retVal11 = (intRet1.a);
	assert(atomicType2 < FFITypeSingleFloat);
	if (atomicType2 == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize1 = ((calloutState1->ffiRetHeader)) & FFIStructSizeMask;
		value1 = (byteSize1 == (sizeof(retVal11))
			? retVal11
			: retVal11 & (((((unsigned long long)1)) << (byteSize1 * 8)) - 1));
		result2 = (value1 == 0
			? falseObject(self)
			: trueObject(self));
		goto l14;
	}
	if (atomicType2 <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType2 <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift1 = ((BytesPerWord == 8)
			 && (atomicType2 >= FFITypeUnsignedInt)
				? 32
				: (((usqInt) atomicType2) >> 1) * 8);
			value1 = retVal11 & (((((unsigned long long)1)) << shift1) - 1);
			if (atomicType2 & 1) {

				/* make the guy signed */
				mask1 = (((unsigned long long)1)) << (shift1 - 1);
				value1 = (value1 & (mask1 - 1)) - (value1 & mask1);
			}
			result2 = integerObjectOf(value1, self);
			goto l14;
		}
		result2 = (atomicType2 & 1
			? (BytesPerWord == 8
					? signed64BitIntegerFor(retVal11, self)
					: signed32BitIntegerFor(retVal11, self))
			: (BytesPerWord == 8
					? positive64BitIntegerFor(retVal11, self)
					: positive32BitIntegerFor(retVal11, self)));
		goto l14;
	}
	result2 = ((((usqInt) atomicType2) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)
		? (atomicType2 & 1
				? signed64BitIntegerFor(retVal11, self)
				: positive64BitIntegerFor(retVal11, self))
		: characterObjectOf(retVal11 & 0xFF, self));
	l14:	/* end ffiCalloutTo:SpecOnStack:in: */;
	/* begin cleanupCalloutState: */
	while (((calloutState1->stringArgIndex)) > 0) {
		free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs1 + 1, result2, self);
	l20:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
#  endif /* COGMTVM */
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from ExternalFunction>>invokeWithArguments: */

	/* ThreadedFFIPlugin>>#primitiveCalloutWithArgs */
EXPORT(void)
primitiveCalloutWithArgs(struct foo * self)
{
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt addressPtr;
    sqInt addressPtr1;
    char *allocation;
    char *allocation1;
    sqInt argArray;
    sqInt argClass;
    sqInt argClass1;
    sqInt argSpec;
    sqInt argSpec1;
    sqInt argType;
    sqInt argType1;
    sqInt argTypeArray;
    sqInt argTypeArray1;
    sqInt argTypes;
    sqInt argTypes1;
    sqInt argTypes2;
    sqInt argTypes3;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType11;
    sqInt atomicType2;
    sqInt byteSize;
    sqInt byteSize1;
    CalloutState *calloutState;
    CalloutState *calloutState1;
    sqInt classOop;
    sqInt classOop1;
    sqInt cPointer;
    sqInt cPointer1;
    char *cString;
    char *cString1;
    sqInt err;
    sqInt err1;
    sqInt externalFunction;
    sqInt ffiRetType;
    sqInt ffiRetType1;
    sqInt flags;
    sqInt flags1;
    double floatRet;
    double floatRet1;
    sqInt functionName;
    sqInt functionName1;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    SixteenByteReturn intRet;
    SixteenByteReturn intRet1;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double, struct foo * self);
    usqLong mask;
    usqLong mask1;
    sqInt myThreadIndex;
    sqInt myThreadIndex1;
    sqInt nArgs;
    sqInt oop;
    sqInt oop1;
    sqInt oop11;
    sqInt oop2;
    sqInt oop21;
    sqInt oop3;
    void *pointer;
    void *pointer1;
    sqInt primNumArgs;
    sqInt primNumArgs1;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    sqInt *ptr11;
    sqIntptr_t *ptr2;
    sqInt requiredStackSize;
    sqInt requiredStackSize1;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt retClass;
    sqInt retClass1;
    sqInt retClass11;
    sqInt retClass2;
    sqInt retOop;
    sqInt retOop1;
    sqInt retOop11;
    sqInt retOop2;
    sqInt retryCount;
    sqInt retType;
    sqInt retType1;
    usqLong retVal;
    usqLong retVal1;
    usqLong retVal11;
    usqLong retVal2;
    sqInt shift;
    sqInt shift1;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt specLiteral2;
    sqInt specLiteral3;
    sqInt stackSize;
    sqInt stackSize1;
    sqInt strLen;
    sqInt strLen1;
    sqInt strOop;
    sqInt strOop1;
    char *strPtr;
    char *strPtr1;
    CalloutState theCalloutState;
    CalloutState theCalloutState1;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec11;
    sqInt typeSpec2;
    usqLong value;
    usqLong value1;

	if (!((methodArgumentCount(self)) == 1)) {
		primitiveFailFor(PrimErrBadNumArgs, self);
		return;
	}
	
#  if COGMTVM
	retryCount = 0;
	while (1) {
		externalFunction = stackValue(1, self);
		argArray = stackValue(0, self);
		if (!(isArray(argArray, self))) {
			primitiveFailFor(PrimErrBadArgument, self);
			return;
		}
		nArgs = slotSizeOf(argArray, self);
		/* begin ffiCall:ArgArrayOrNil:NumArgs: */
		primNumArgs = methodArgumentCount(self);
		if (!(isKindOfClass(externalFunction, classExternalFunction(self), self))) {
			result = ffiFail(FFIErrorNotFunction, self);
			goto l10;
		}
		flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction, self);
		if (failed(self)) {
			result = ffiFail(FFIErrorBadArgs, self);
			goto l10;
		}
		/* begin ffiLoadCalloutAddress: */

		/* Make sure it's an external handle */
		addressPtr = fetchPointerofObject(0, externalFunction, self);
		if (!((isBytes(addressPtr, self))
			 && ((byteSizeOf(addressPtr, self)) == (sizeof(sqInt))))) {
			address1 = ffiFail(FFIErrorBadAddress, self);
			goto l1;
		}
		address1 = fetchPointerofObject(0, addressPtr, self);
	l1:	/* end ffiContentsOfHandle:errCode: */;
		if (failed(self)) {
			address = 0;
			goto l2;
		}
		if (address1 == 0) {

			/* Go look it up in the module */
			if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
				storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1, self), self);
			}
			if ((slotSizeOf(externalFunction, self)) < 5) {
				address = ffiFail(FFIErrorNoModule, self);
				goto l2;
			}
			address1 = ffiLoadCalloutAddressFrom(externalFunction, self);
			if (failed(self)) {
				address = 0;
				goto l2;
			}
			ptr = firstIndexableField(addressPtr, self);
			ptr[0] = address1;
		}
		address = address1;
	l2:	/* end ffiLoadCalloutAddress: */;
		if (failed(self)) {
			result = 0;
			goto l10;
		}

		/* must be array of arg types */
		argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction, self);
		if (!((isArray(argTypeArray, self))
			 && ((slotSizeOf(argTypeArray, self)) == (nArgs + 1)))) {
			result = ffiFail(FFIErrorBadArgs, self);
			goto l10;
		}
		
#    if COGMTVM
		if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
			 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType, self);
			goto l10;
		}
#    else /* COGMTVM */

		/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
		if (!((flags == FFICallTypeCDecl)
			 || (flags == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType, self);
			goto l10;
		}
#    endif /* COGMTVM */
		requiredStackSize = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
			? fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction, self)
			: -1);
		if (failed(self)) {
			result = primitiveFailFor((argArray == null
				? PrimErrBadMethod
				: PrimErrBadReceiver), self);
			goto l10;
		}
		stackSize = (requiredStackSize < 0
			? DefaultMaxStackSize
			: requiredStackSize);
		calloutState = (&theCalloutState);
		memset(calloutState, 0, sizeof(CalloutState));
		(calloutState->callFlags = flags);
		argType = fetchPointerofObject(0, argTypeArray, self);
		argSpec = fetchPointerofObject(0, argType, self);
		argClass = fetchPointerofObject(1, argType, self);
		if (((err = ffiCheckReturnWithin(argSpec, argClass, calloutState, self))) != 0) {
			result = ffiFail(err, self);
			goto l10;
		}
		allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
		if (mustAlignStack()) {
			allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
		}
		(calloutState->argVector = allocation);
		(calloutState->currentArg = allocation);
		(calloutState->limit = allocation + stackSize);
		if ((((calloutState->structReturnSize)) > 0)
		 && (1
		 && (!(((calloutState->structReturnSize)) <= (WordSize * 2))))) {
			/* begin ffiPushPointer:in: */
			pointer = (calloutState->limit);
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
				(calloutState->integerRegisterIndex) = ((calloutState->integerRegisterIndex)) + 1;
			}
			else {
				if ((((calloutState->currentArg)) + WordSize) > ((calloutState->limit))) {
					err = FFIErrorCallFrameTooBig;
					goto l4;
				}
				longAtput((calloutState->currentArg), pointer);
				(calloutState->currentArg = ((calloutState->currentArg)) + WordSize);
			}
			err = 0;
	l4:	/* end ffiPushPointer:in: */;
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l10;
				}
#        endif /* COGMTVM */
				result = ffiFail(err, self);
				goto l10;
			}
		}
		for (i = 1; i <= nArgs; i += 1) {
			argType = fetchPointerofObject(i, argTypeArray, self);
			argSpec = fetchPointerofObject(0, argType, self);
			argClass = fetchPointerofObject(1, argType, self);
			oop = (argArray == null
				? stackValue(nArgs - i, self)
				: fetchPointerofObject(i - 1, argArray, self));
			err = ffiArgumentSpecClassin(oop, argSpec, argClass, calloutState, self);
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l10;
				}
#        endif /* COGMTVM */
				result = ffiFail(err, self);
				goto l10;
			}
		}
		assert(!(failed(self)));
		/* begin ffiLogCallout: */
		if (ffiLogEnabled) {
			functionName = fetchPointerofObject(externalFunctionInstSize, externalFunction, self);
			if (!(isBytes(functionName, self))) {
				goto l3;
			}
			ffiLogCallOfLength(firstIndexableField(functionName, self), byteSizeOf(functionName, self), self);
		}
	l3:	/* end ffiLogCallout: */;
		if ((requiredStackSize < 0)
		 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
			stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
			storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize, self);
		}
		/* begin ffiCalloutTo:SpecOnStack:in: */
		myThreadIndex = disownVM(
#    if COGMTVM
			(((calloutState->callFlags)) & FFICallFlagThreaded
						? DisownVMForFFICall + DisownVMForThreading
						: DisownVMForFFICall)
#    else /* COGMTVM */
			DisownVMForFFICall
#    endif /* COGMTVM */
			, self);
		if (((calloutState->floatRegisterIndex)) > 0) {
			loadFloatRegs(((calloutState->floatRegisters))[0], ((calloutState->floatRegisters))[1], ((calloutState->floatRegisters))[2], ((calloutState->floatRegisters))[3], ((calloutState->floatRegisters))[4], ((calloutState->floatRegisters))[5], ((calloutState->floatRegisters))[6], ((calloutState->floatRegisters))[7], self);
		}
		if ((allocaLiesSoSetSpBeforeCall())
		 || (mustAlignStack())) {
			setsp((calloutState->argVector));
		}
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSingleFloat) >> 1)) {
			if (atomicType == FFITypeSingleFloat) {
				floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
			}
			else {

				/* atomicType = FFITypeDoubleFloat */
				floatRet = dispatchFunctionPointerwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
			}
			ownVM(myThreadIndex, self);
			result1 = floatObjectOf(floatRet, self);
			goto l9;
		}
		intRet = dispatchFunctionPointerwithwithwithwithwithwith(((SixteenByteReturn (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5]);
		ownVM(myThreadIndex, self);
		if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

			/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
			   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
			if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
				/* begin ffiReturnPointer:ofType:in: */
				retVal = (intRet.a);
				/* begin ffiReturnType: */
				specLiteral = (argArray != null
					? stackValue(1, self)
					: literalofMethod(0, primitiveMethod(self), self));
				argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral, self);
				retType = fetchPointerofObject(0, argTypes, self);
				retClass = fetchPointerofObject(1, retType, self);
				if (retClass == (nilObject(self))) {

					/* Create ExternalData upon return */
					/* begin atomicTypeOf: */
					typeSpec1 = (calloutState->ffiRetHeader);
					atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
					if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

						/* String return */
						/* begin ffiReturnCStringFrom: */
						cPointer = ((usqInt) retVal);
						if (!(cPointer)) {
							retOop = nilObject(self);
							goto l5;
						}
						cString = ((char *) cPointer);
						strLen = 0;
						while (!((cString[strLen]) == 0)) {
							strLen += 1;
						}
						strOop = instantiateClassindexableSize(classString(self), strLen, self);
						strPtr = firstIndexableField(strOop, self);
						for (i1 = 0; i1 < strLen; i1 += 1) {
							strPtr[i1] = (cString[i1]);
						}
						retOop = strOop;
	l5:	/* end ffiReturnCStringFrom: */;
						result1 = retOop;
						goto l9;
					}
					
#if SPURVM
					oop2 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
					ptr1 = firstIndexableField(oop2, self);
					ptr1[0] = (((sqInt) retVal));
					retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
					storePointerofObjectwithValue(0, retOop, oop2, self);

#else /* SPURVM */
					pushRemappableOop(retType, self);
					oop2 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
					ptr1 = firstIndexableField(oop2, self);
					ptr1[0] = (((sqInt) retVal));
										pushRemappableOop(oop2, self);
					retOop = instantiateClassindexableSize(classExternalData(self), 0, self);
					oop2 = popRemappableOop(self);
					storePointerofObjectwithValue(0, retOop, oop2, self);
					retType = popRemappableOop(self)
#endif /* SPURVM */
;
					storePointerofObjectwithValue(1, retOop, retType, self);
					result1 = retOop;
					goto l9;
				}
				classOop = (((calloutState->ffiRetHeader)) & FFIFlagStructure
					? classByteArray(self)
					: classExternalAddress(self));
				
#if SPURVM
				oop2 = instantiateClassindexableSize(classOop, BytesPerWord, self);

#else /* SPURVM */
				pushRemappableOop(retClass, self);
				oop2 = instantiateClassindexableSize(classOop, BytesPerWord, self);
				retClass = popRemappableOop(self)
#endif /* SPURVM */
;
				ptr1 = firstIndexableField(oop2, self);
				ptr1[0] = (((sqInt) retVal));
				
#if SPURVM
				retOop = instantiateClassindexableSize(retClass, 0, self);

#else /* SPURVM */
				pushRemappableOop(oop2, self);
				retOop = instantiateClassindexableSize(retClass, 0, self);
				oop2 = popRemappableOop(self)
#endif /* SPURVM */
;
				storePointerofObjectwithValue(0, retOop, oop2, self);
				result1 = retOop;
				goto l9;
			}
			/* begin ffiReturnStruct:ofType:in: */
			specLiteral2 = (argArray != null
				? stackValue(1, self)
				: literalofMethod(0, primitiveMethod(self), self));
			argTypes2 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral2, self);
			ffiRetType = fetchPointerofObject(0, argTypes2, self);
			retClass1 = fetchPointerofObject(1, ffiRetType, self);
			retOop1 = instantiateClassindexableSize(retClass1, 0, self);
			
#if SPURVM
			oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);

#else /* SPURVM */
			pushRemappableOop(retOop1, self);
			oop1 = instantiateClassindexableSize(classByteArray(self), (calloutState->structReturnSize), self);
			retOop1 = popRemappableOop(self)
#endif /* SPURVM */
;
			memcpy(firstIndexableField(oop1, self), (((calloutState->structReturnSize)) <= (WordSize * 2)
				? ((void *)((&intRet)))
				: (calloutState->limit)), (calloutState->structReturnSize));
			storePointerofObjectwithValue(0, retOop1, oop1, self);
			result1 = retOop1;
			goto l9;
		}
		/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
		retVal1 = (intRet.a);
		assert(atomicType < FFITypeSingleFloat);
		if (atomicType == FFITypeBool) {

			/* Make sure bool honors the byte size requested */
			byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
			value = (byteSize == (sizeof(retVal1))
				? retVal1
				: retVal1 & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
			result1 = (value == 0
				? falseObject(self)
				: trueObject(self));
			goto l9;
		}
		if (atomicType <= FFITypeSignedInt) {

			/* these are all generall integer returns */
			if (atomicType <= ((BytesPerWord == 8
				? FFITypeSignedInt
				: FFITypeSignedShort))) {

				/* byte/short. first extract partial word, then sign extend */

				/* # of significant bits */
				shift = ((BytesPerWord == 8)
				 && (atomicType >= FFITypeUnsignedInt)
					? 32
					: (((usqInt) atomicType) >> 1) * 8);
				value = retVal1 & (((((unsigned long long)1)) << shift) - 1);
				if (atomicType & 1) {

					/* make the guy signed */
					mask = (((unsigned long long)1)) << (shift - 1);
					value = (value & (mask - 1)) - (value & mask);
				}
				result1 = integerObjectOf(value, self);
				goto l9;
			}
			result1 = (atomicType & 1
				? (BytesPerWord == 8
						? signed64BitIntegerFor(retVal1, self)
						: signed32BitIntegerFor(retVal1, self))
				: (BytesPerWord == 8
						? positive64BitIntegerFor(retVal1, self)
						: positive32BitIntegerFor(retVal1, self)));
			goto l9;
		}
		result1 = ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)
			? (atomicType & 1
					? signed64BitIntegerFor(retVal1, self)
					: positive64BitIntegerFor(retVal1, self))
			: characterObjectOf(retVal1 & 0xFF, self));
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
		/* begin cleanupCalloutState: */
		while (((calloutState->stringArgIndex)) > 0) {
			free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
		}
		popthenPush(primNumArgs + 1, result1, self);
		result = result1;
	l10:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
		if (!((result == PrimErrObjectMayMove)
		 && (((retryCount += 1)) <= (nArgs + 1)))) break;
		tenuringIncrementalGC(self);
	}
#  else /* COGMTVM */
	externalFunction = stackValue(1, self);
	argArray = stackValue(0, self);
	if (!(isArray(argArray, self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return;
	}
	nArgs = slotSizeOf(argArray, self);
	/* begin ffiCall:ArgArrayOrNil:NumArgs: */
	primNumArgs1 = methodArgumentCount(self);
	if (!(isKindOfClass(externalFunction, classExternalFunction(self), self))) {
		ffiFail(FFIErrorNotFunction, self);
		goto l20;
	}
	flags1 = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction, self);
	if (failed(self)) {
		ffiFail(FFIErrorBadArgs, self);
		goto l20;
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr1 = fetchPointerofObject(0, externalFunction, self);
	if (!((isBytes(addressPtr1, self))
		 && ((byteSizeOf(addressPtr1, self)) == (sizeof(sqInt))))) {
		address11 = ffiFail(FFIErrorBadAddress, self);
		goto l13;
	}
	address11 = fetchPointerofObject(0, addressPtr1, self);
	l13:	/* end ffiContentsOfHandle:errCode: */;
	if (failed(self)) {
		address2 = 0;
		goto l19;
	}
	if (address11 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1, self), self);
		}
		if ((slotSizeOf(externalFunction, self)) < 5) {
			address2 = ffiFail(FFIErrorNoModule, self);
			goto l19;
		}
		address11 = ffiLoadCalloutAddressFrom(externalFunction, self);
		if (failed(self)) {
			address2 = 0;
			goto l19;
		}
		ptr2 = firstIndexableField(addressPtr1, self);
		ptr2[0] = address11;
	}
	address2 = address11;
	l19:	/* end ffiLoadCalloutAddress: */;
	if (failed(self)) {
		goto l20;
	}

	/* must be array of arg types */
	argTypeArray1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction, self);
	if (!((isArray(argTypeArray1, self))
		 && ((slotSizeOf(argTypeArray1, self)) == (nArgs + 1)))) {
		ffiFail(FFIErrorBadArgs, self);
		goto l20;
	}
	
#  if COGMTVM
	if (!(((flags1 & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags1 & FFICallTypesMask) == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType, self);
		goto l20;
	}
#  else /* COGMTVM */

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags1 == FFICallTypeCDecl)
		 || (flags1 == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType, self);
		goto l20;
	}
#  endif /* COGMTVM */
	requiredStackSize1 = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
		? fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction, self)
		: -1);
	if (failed(self)) {
		primitiveFailFor((argArray == null
			? PrimErrBadMethod
			: PrimErrBadReceiver), self);
		goto l20;
	}
	stackSize1 = (requiredStackSize1 < 0
		? DefaultMaxStackSize
		: requiredStackSize1);
	calloutState1 = (&theCalloutState1);
	memset(calloutState1, 0, sizeof(CalloutState));
	(calloutState1->callFlags = flags1);
	argType1 = fetchPointerofObject(0, argTypeArray1, self);
	argSpec1 = fetchPointerofObject(0, argType1, self);
	argClass1 = fetchPointerofObject(1, argType1, self);
	if (((err1 = ffiCheckReturnWithin(argSpec1, argClass1, calloutState1, self))) != 0) {
		ffiFail(err1, self);
		goto l20;
	}
	allocation1 = alloca((stackSize1 + ((calloutState1->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation1 = ((char *) ((((((usqIntptr_t)allocation1)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState1->argVector = allocation1);
	(calloutState1->currentArg = allocation1);
	(calloutState1->limit = allocation1 + stackSize1);
	if ((((calloutState1->structReturnSize)) > 0)
	 && (1
	 && (!(((calloutState1->structReturnSize)) <= (WordSize * 2))))) {
		/* begin ffiPushPointer:in: */
		pointer1 = (calloutState1->limit);
		if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer1));
			(calloutState1->integerRegisterIndex) = ((calloutState1->integerRegisterIndex)) + 1;
		}
		else {
			if ((((calloutState1->currentArg)) + WordSize) > ((calloutState1->limit))) {
				err1 = FFIErrorCallFrameTooBig;
				goto l12;
			}
			longAtput((calloutState1->currentArg), pointer1);
			(calloutState1->currentArg = ((calloutState1->currentArg)) + WordSize);
		}
		err1 = 0;
	l12:	/* end ffiPushPointer:in: */;
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l20;
			}
#      endif /* COGMTVM */
			ffiFail(err1, self);
			goto l20;
		}
	}
	for (i2 = 1; i2 <= nArgs; i2 += 1) {
		argType1 = fetchPointerofObject(i2, argTypeArray1, self);
		argSpec1 = fetchPointerofObject(0, argType1, self);
		argClass1 = fetchPointerofObject(1, argType1, self);
		oop3 = (argArray == null
			? stackValue(nArgs - i2, self)
			: fetchPointerofObject(i2 - 1, argArray, self));
		err1 = ffiArgumentSpecClassin(oop3, argSpec1, argClass1, calloutState1, self);
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l20;
			}
#      endif /* COGMTVM */
			ffiFail(err1, self);
			goto l20;
		}
	}
	assert(!(failed(self)));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		functionName1 = fetchPointerofObject(externalFunctionInstSize, externalFunction, self);
		if (!(isBytes(functionName1, self))) {
			goto l16;
		}
		ffiLogCallOfLength(firstIndexableField(functionName1, self), byteSizeOf(functionName1, self), self);
	}
	l16:	/* end ffiLogCallout: */;
	if ((requiredStackSize1 < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize1 = ((calloutState1->currentArg)) - ((calloutState1->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize1, self);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	myThreadIndex1 = disownVM(
#  if COGMTVM
		(((calloutState1->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		, self);
	if (((calloutState1->floatRegisterIndex)) > 0) {
		loadFloatRegs(((calloutState1->floatRegisters))[0], ((calloutState1->floatRegisters))[1], ((calloutState1->floatRegisters))[2], ((calloutState1->floatRegisters))[3], ((calloutState1->floatRegisters))[4], ((calloutState1->floatRegisters))[5], ((calloutState1->floatRegisters))[6], ((calloutState1->floatRegisters))[7], self);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState1->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec2 = (calloutState1->ffiRetHeader);
	atomicType2 = ((usqInt) (typeSpec2 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((((usqInt) atomicType2) >> 1) == (((usqInt) FFITypeSingleFloat) >> 1)) {
		if (atomicType2 == FFITypeSingleFloat) {
			floatRet1 = dispatchFunctionPointerwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3], ((calloutState1->integerRegisters))[4], ((calloutState1->integerRegisters))[5]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet1 = dispatchFunctionPointerwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3], ((calloutState1->integerRegisters))[4], ((calloutState1->integerRegisters))[5]);
		}
		ownVM(myThreadIndex1, self);
		result2 = floatObjectOf(floatRet1, self);
		goto l14;
	}
	intRet1 = dispatchFunctionPointerwithwithwithwithwithwith(((SixteenByteReturn (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3], ((calloutState1->integerRegisters))[4], ((calloutState1->integerRegisters))[5]);
	ownVM(myThreadIndex1, self);
	if (((calloutState1->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState1->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			retVal2 = (intRet1.a);
			/* begin ffiReturnType: */
			specLiteral1 = (argArray != null
				? stackValue(1, self)
				: literalofMethod(0, primitiveMethod(self), self));
			argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1, self);
			retType1 = fetchPointerofObject(0, argTypes1, self);
			retClass2 = fetchPointerofObject(1, retType1, self);
			if (retClass2 == (nilObject(self))) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec11 = (calloutState1->ffiRetHeader);
				atomicType11 = ((usqInt) (typeSpec11 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if ((((usqInt) atomicType11) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer1 = ((usqInt) retVal2);
					if (!(cPointer1)) {
						retOop2 = nilObject(self);
						goto l18;
					}
					cString1 = ((char *) cPointer1);
					strLen1 = 0;
					while (!((cString1[strLen1]) == 0)) {
						strLen1 += 1;
					}
					strOop1 = instantiateClassindexableSize(classString(self), strLen1, self);
					strPtr1 = firstIndexableField(strOop1, self);
					for (i11 = 0; i11 < strLen1; i11 += 1) {
						strPtr1[i11] = (cString1[i11]);
					}
					retOop2 = strOop1;
	l18:	/* end ffiReturnCStringFrom: */;
					result2 = retOop2;
					goto l14;
				}
				
#if SPURVM
				oop21 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr11 = firstIndexableField(oop21, self);
				ptr11[0] = (((sqInt) retVal2));
				retOop2 = instantiateClassindexableSize(classExternalData(self), 0, self);
				storePointerofObjectwithValue(0, retOop2, oop21, self);

#else /* SPURVM */
				pushRemappableOop(retType1, self);
				oop21 = instantiateClassindexableSize(classExternalAddress(self), BytesPerWord, self);
				ptr11 = firstIndexableField(oop21, self);
				ptr11[0] = (((sqInt) retVal2));
								pushRemappableOop(oop21, self);
				retOop2 = instantiateClassindexableSize(classExternalData(self), 0, self);
				oop21 = popRemappableOop(self);
				storePointerofObjectwithValue(0, retOop2, oop21, self);
				retType1 = popRemappableOop(self)
#endif /* SPURVM */
;
				storePointerofObjectwithValue(1, retOop2, retType1, self);
				result2 = retOop2;
				goto l14;
			}
			classOop1 = (((calloutState1->ffiRetHeader)) & FFIFlagStructure
				? classByteArray(self)
				: classExternalAddress(self));
			
#if SPURVM
			oop21 = instantiateClassindexableSize(classOop1, BytesPerWord, self);

#else /* SPURVM */
			pushRemappableOop(retClass2, self);
			oop21 = instantiateClassindexableSize(classOop1, BytesPerWord, self);
			retClass2 = popRemappableOop(self)
#endif /* SPURVM */
;
			ptr11 = firstIndexableField(oop21, self);
			ptr11[0] = (((sqInt) retVal2));
			
#if SPURVM
			retOop2 = instantiateClassindexableSize(retClass2, 0, self);

#else /* SPURVM */
			pushRemappableOop(oop21, self);
			retOop2 = instantiateClassindexableSize(retClass2, 0, self);
			oop21 = popRemappableOop(self)
#endif /* SPURVM */
;
			storePointerofObjectwithValue(0, retOop2, oop21, self);
			result2 = retOop2;
			goto l14;
		}
		/* begin ffiReturnStruct:ofType:in: */
		specLiteral3 = (argArray != null
			? stackValue(1, self)
			: literalofMethod(0, primitiveMethod(self), self));
		argTypes3 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral3, self);
		ffiRetType1 = fetchPointerofObject(0, argTypes3, self);
		retClass11 = fetchPointerofObject(1, ffiRetType1, self);
		retOop11 = instantiateClassindexableSize(retClass11, 0, self);
		
#if SPURVM
		oop11 = instantiateClassindexableSize(classByteArray(self), (calloutState1->structReturnSize), self);

#else /* SPURVM */
		pushRemappableOop(retOop11, self);
		oop11 = instantiateClassindexableSize(classByteArray(self), (calloutState1->structReturnSize), self);
		retOop11 = popRemappableOop(self)
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop11, self), (((calloutState1->structReturnSize)) <= (WordSize * 2)
			? ((void *)((&intRet1)))
			: (calloutState1->limit)), (calloutState1->structReturnSize));
		storePointerofObjectwithValue(0, retOop11, oop11, self);
		result2 = retOop11;
		goto l14;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	retVal11 = (intRet1.a);
	assert(atomicType2 < FFITypeSingleFloat);
	if (atomicType2 == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize1 = ((calloutState1->ffiRetHeader)) & FFIStructSizeMask;
		value1 = (byteSize1 == (sizeof(retVal11))
			? retVal11
			: retVal11 & (((((unsigned long long)1)) << (byteSize1 * 8)) - 1));
		result2 = (value1 == 0
			? falseObject(self)
			: trueObject(self));
		goto l14;
	}
	if (atomicType2 <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType2 <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift1 = ((BytesPerWord == 8)
			 && (atomicType2 >= FFITypeUnsignedInt)
				? 32
				: (((usqInt) atomicType2) >> 1) * 8);
			value1 = retVal11 & (((((unsigned long long)1)) << shift1) - 1);
			if (atomicType2 & 1) {

				/* make the guy signed */
				mask1 = (((unsigned long long)1)) << (shift1 - 1);
				value1 = (value1 & (mask1 - 1)) - (value1 & mask1);
			}
			result2 = integerObjectOf(value1, self);
			goto l14;
		}
		result2 = (atomicType2 & 1
			? (BytesPerWord == 8
					? signed64BitIntegerFor(retVal11, self)
					: signed32BitIntegerFor(retVal11, self))
			: (BytesPerWord == 8
					? positive64BitIntegerFor(retVal11, self)
					: positive32BitIntegerFor(retVal11, self)));
		goto l14;
	}
	result2 = ((((usqInt) atomicType2) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)
		? (atomicType2 & 1
				? signed64BitIntegerFor(retVal11, self)
				: positive64BitIntegerFor(retVal11, self))
		: characterObjectOf(retVal11 & 0xFF, self));
	l14:	/* end ffiCalloutTo:SpecOnStack:in: */;
	/* begin cleanupCalloutState: */
	while (((calloutState1->stringArgIndex)) > 0) {
		free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs1 + 1, result2, self);
	l20:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
#  endif /* COGMTVM */
	return;
}


/*	arguments: name(type, stack offset)
	width(Integer, 4)
	height(Integer, 3)
	rowPitch(Integer, 2)
	depth(Integer, 1)
	isMSB(Boolean, 0) */

	/* ThreadedFFIPlugin>>#primitiveCreateManualSurface */
EXPORT(sqInt)
primitiveCreateManualSurface(struct foo * self)
{
    sqInt depth;
    sqInt height;
    sqInt isMSB;
    sqInt result;
    sqInt rowPitch;
    sqInt width;

	if (!((methodArgumentCount(self)) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs, self);
	}
	width = stackIntegerValue(4, self);
	height = stackIntegerValue(3, self);
	rowPitch = stackIntegerValue(2, self);
	depth = stackIntegerValue(1, self);
	isMSB = stackObjectValue(0, self);
	isMSB = booleanValueOf(isMSB, self);
	if (failed(self)) {
		return null;
	}
	result = createManualSurface(width, height, rowPitch, depth, isMSB);
	if (result < 0) {
		return primitiveFail(self);
	}
	result = signed32BitIntegerFor(result, self);
	return popthenPush(6, result, self);
}

	/* ThreadedFFIPlugin>>#primitiveDestroyManualSurface */
EXPORT(sqInt)
primitiveDestroyManualSurface(struct foo * self)
{
    sqInt surfaceID;

	if (!((methodArgumentCount(self)) == 1)) {
		return primitiveFail(self);
	}
	surfaceID = stackIntegerValue(0, self);
	if (!(failed(self))) {
		if ((destroyManualSurface(surfaceID)) == 0) {
			primitiveFail(self);
		}
		else {
			pop(1, self);
		}
	}
	return 0;
}


/*	Primitive. Allocate an object on the external heap. */

	/* ThreadedFFIPlugin>>#primitiveFFIAllocate */
EXPORT(sqInt)
primitiveFFIAllocate(struct foo * self)
{
    sqInt addr;
    sqInt byteSize;
    sqInt oop;
    sqIntptr_t *ptr;

	byteSize = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	addr = ffiAlloc(byteSize);
	if (addr == 0) {
		return primitiveFail(self);
	}
	oop = instantiateClassindexableSize(classExternalAddress(self), sizeof(sqIntptr_t), self);
	ptr = firstIndexableField(oop, self);
	ptr[0] = addr;
	return popthenPush(2, oop, self);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIDoubleAt */
EXPORT(sqInt)
primitiveFFIDoubleAt(struct foo * self)
{
    void * addr;
    sqInt byteOffset;
    double floatValue;
    sqInt rcvr;

	byteOffset = stackIntegerValue(0, self);
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 8, self);
	if (addr == 0) {
		return primitiveFail(self);
	}
	memcpy((&floatValue), addr, sizeof(floatValue));
	pop(2, self);
	return pushFloat(floatValue, self);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIDoubleAtPut */
EXPORT(sqInt)
primitiveFFIDoubleAtPut(struct foo * self)
{
    void * addr;
    sqInt byteOffset;
    sqInt floatOop;
    double floatValue;
    sqInt rcvr;

	floatOop = stackValue(0, self);
	if (isIntegerObject(floatOop, self)) {
		floatValue = ((double) (integerValueOf(floatOop, self)));
	}
	else {
		floatValue = ((double) (floatValueOf(floatOop, self)));
	}
	byteOffset = stackIntegerValue(1, self);
	rcvr = stackObjectValue(2, self);
	if (failed(self)) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 8, self);
	if (addr == 0) {
		return primitiveFail(self);
	}
	memcpy(addr, (&floatValue), sizeof(floatValue));
	return popthenPush(3, floatOop, self);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIFloatAt */
EXPORT(sqInt)
primitiveFFIFloatAt(struct foo * self)
{
    void * addr;
    sqInt byteOffset;
    float floatValue;
    sqInt rcvr;

	byteOffset = stackIntegerValue(0, self);
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 4, self);
	if (addr == 0) {
		return primitiveFail(self);
	}
	memcpy((&floatValue), addr, sizeof(floatValue));
	pop(2, self);
	return pushFloat(floatValue, self);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIFloatAtPut */
EXPORT(sqInt)
primitiveFFIFloatAtPut(struct foo * self)
{
    void * addr;
    sqInt byteOffset;
    sqInt floatOop;
    float floatValue;
    sqInt rcvr;

	floatOop = stackValue(0, self);
	if (isIntegerObject(floatOop, self)) {
		floatValue = ((float) (integerValueOf(floatOop, self)));
	}
	else {
		floatValue = ((float) (floatValueOf(floatOop, self)));
	}
	byteOffset = stackIntegerValue(1, self);
	rcvr = stackObjectValue(2, self);
	if (failed(self)) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 4, self);
	if (addr == 0) {
		return primitiveFail(self);
	}
	memcpy(addr, (&floatValue), sizeof(floatValue));
	return popthenPush(3, floatOop, self);
}


/*	Primitive. Free the object pointed to on the external heap. */

	/* ThreadedFFIPlugin>>#primitiveFFIFree */
EXPORT(sqInt)
primitiveFFIFree(struct foo * self)
{
    sqIntptr_t addr;
    sqInt oop;
    sqIntptr_t *ptr;

	oop = stackObjectValue(0, self);
	if (!(((fetchClassOf(oop, self)) == (classExternalAddress(self)))
		 && ((byteSizeOf(oop, self)) == (sizeof(sqIntptr_t))))) {
		return primitiveFail(self);
	}
	ptr = firstIndexableField(oop, self);

	/* Don't you dare to free Squeak's memory! */
	addr = ptr[0];
	if ((addr == 0)
	 || ((((((usqIntptr_t)addr)) & ((sizeof(sqIntptr_t)) - 1)) != 0)
	 || (isInMemory(addr, self)))) {
		return primitiveFail(self);
	}
	ffiFree(addr);
	return ptr[0] = 0;
}


/*	Primitive. Return the error code from a failed call to the foreign
	function interface.
	This is for backwards-compatibility. Thread-safe access to the error code
	is via the
	primitive error code. */

	/* ThreadedFFIPlugin>>#primitiveFFIGetLastError */
EXPORT(sqInt)
primitiveFFIGetLastError(struct foo * self)
{
	methodReturnInteger(ffiLastError, self);
	return 0;
}


/*	Answer a (signed or unsigned) n byte integer from the given byte offset
	in the receiver, using the platform's endianness. */

	/* ThreadedFFIPlugin>>#primitiveFFIIntegerAt */
EXPORT(sqInt)
primitiveFFIIntegerAt(struct foo * self)
{
    void * addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    usqLong mask;
    sqInt rcvr;
    usqLong value;
    sqInt valueOop;

	isSigned = booleanValueOf(stackValue(0, self), self);
	byteSize = stackIntegerValue(1, self);
	byteOffset = stackIntegerValue(2, self);
	rcvr = stackObjectValue(3, self);
	if (failed(self)) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((((byteSize >= 1) && (byteSize <= 8)))
		 && ((byteSize & (byteSize - 1)) == 0)))) {
		return primitiveFail(self);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize, self);
	if (addr == 0) {
		return primitiveFail(self);
	}
	if (byteSize <= 2) {
		if (byteSize == 1) {
			value = ((unsigned char) (byteAt(addr)));
		}
		else {
			value = ((unsigned short) (unalignedShortAt(addr)));
		}
	}
	else {
		if (byteSize == 4) {
			value = ((unsigned int) (unalignedLong32At(addr)));
		}
		else {
			value = unalignedLong64At(addr);
		}
	}
	if (byteSize < BytesPerWord) {
		if (isSigned) {

			/* sign extend value */
			mask = (((unsigned long long)1)) << ((byteSize * 8) - 1);
			value = (value & (mask - 1)) - (value & mask);
		}
		valueOop = integerObjectOf(value, self);
	}
	else {

		/* general 64 bit integer; note these never fail */
		if (isSigned) {
			if (byteSize < 8) {

				/* sign extend value */
				mask = (((unsigned long long)1)) << ((byteSize * 8) - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			valueOop = signed64BitIntegerFor(value, self);
		}
		else {
			valueOop = positive64BitIntegerFor(value, self);
		}
	}
	return popthenPush(4, valueOop, self);
}


/*	Store a (signed or unsigned) n byte integer at the given byte offset
	in the receiver, using the platform's endianness. */

	/* ThreadedFFIPlugin>>#primitiveFFIIntegerAtPut */
EXPORT(sqInt)
primitiveFFIIntegerAtPut(struct foo * self)
{
    void * addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    sqLong max;
    sqInt rcvr;
    sqLong value;
    sqInt valueOop;

	isSigned = booleanValueOf(stackValue(0, self), self);
	byteSize = stackIntegerValue(1, self);
	valueOop = stackValue(2, self);
	byteOffset = stackIntegerValue(3, self);
	rcvr = stackObjectValue(4, self);
	if (failed(self)) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((((byteSize >= 1) && (byteSize <= 8)))
		 && ((byteSize & (byteSize - 1)) == 0)))) {
		return primitiveFail(self);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize, self);
	if (addr == 0) {
		return primitiveFail(self);
	}
	if (isSigned) {
		value = signed64BitValueOf(valueOop, self);
	}
	else {
		value = positive64BitValueOf(valueOop, self);
	}
	if (failed(self)) {
		return 0;
	}
	if (byteSize < 8) {
		if (isSigned) {
			max = (((unsigned long long)1)) << ((8 * byteSize) - 1);
			if (!((value >= (0 - max))
				 && (value < max))) {
				return primitiveFail(self);
			}
		}
		else {
			if (!((((unsigned long long)value)) < ((((unsigned long long)1)) << (8 * byteSize)))) {
				return primitiveFail(self);
			}
		}
	}
	if (byteSize <= 2) {
		if (byteSize == 1) {
			byteAtput(addr, value);
		}
		else {
			unalignedShortAtput(addr, value);
		}
	}
	else {
		if (byteSize == 4) {
			unalignedLong32Atput(addr, value);
		}
		else {
			unalignedLong64Atput(addr, value);
		}
	}
	return popthenPush(5, valueOop, self);
}


/*	Primitive. Force loading the receiver (an instance of ExternalLibrary). */

	/* ThreadedFFIPlugin>>#primitiveForceLoad */
EXPORT(sqInt)
primitiveForceLoad(struct foo * self)
{
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    sqInt *ptr;
    sqInt rcvr;

	if (!((methodArgumentCount(self)) == 0)) {
		return primitiveFail(self);
	}
	rcvr = stackValue(0, self);
	if (!(isKindOfClass(rcvr, classExternalLibrary(self), self))) {
		return ffiFail(FFIErrorBadExternalLibrary, self);
	}
	moduleHandlePtr = fetchPointerofObject(0, rcvr, self);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(moduleHandlePtr, self))
		 && ((byteSizeOf(moduleHandlePtr, self)) == (sizeof(sqInt))))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary, self);
		goto l1;
	}
	moduleHandle = fetchPointerofObject(0, moduleHandlePtr, self);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed(self)) {
		return 0;
	}
	ffiModuleName = fetchPointerofObject(1, rcvr, self);
	if (!(isBytes(ffiModuleName, self))) {
		return ffiFail(FFIErrorBadExternalLibrary, self);
	}
	moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName, self))), byteSizeOf(ffiModuleName, self), self)));
	if (failed(self)) {
		return ffiFail(FFIErrorModuleNotFound, self);
	}
	ptr = firstIndexableField(moduleHandlePtr, self);
	ptr[0] = moduleHandle;
	return 0;
}


/*	Attempt to find the address of a symbol in a loaded library.
	loadSymbol: aSymbol fromModule: moduleName
	<primitive: 'primitiveLoadSymbolFromModule' error: errorCode module:
	'SqueakFFIPrims'>  */

	/* ThreadedFFIPlugin>>#primitiveLoadSymbolFromModule */
EXPORT(sqInt)
primitiveLoadSymbolFromModule(struct foo * self)
{
    void *address;
    sqInt module;
    sqInt moduleHandle;
    sqInt oop;
    void **ptr;
    sqInt symbol;

	if (!((methodArgumentCount(self)) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs, self);
	}
	module = stackValue(0, self);
	symbol = stackValue(1, self);
	moduleHandle = (module != (nilObject(self))
		? ffiLoadCalloutModule(module, self)
		: 0);
	if (failed(self)) {
		return primitiveFailFor(PrimErrNotFound, self);
	}
	address = ioLoadSymbolOfLengthFromModule(((sqInt) (firstIndexableField(symbol, self))), byteSizeOf(symbol, self), moduleHandle);
	if ((failed(self))
	 || (address == 0)) {
		return primitiveFailFor(PrimErrNotFound, self);
	}
	oop = instantiateClassindexableSize(classExternalAddress(self), sizeof(void *), self);
	ptr = firstIndexableField(oop, self);
	ptr[0] = address;
	return methodReturnValue(oop, self);
}


/*	Enable logging of FFI calls by providing it with a log file name. */

	/* ThreadedFFIPlugin>>#primitiveLogCallsTo */
EXPORT(sqInt)
primitiveLogCallsTo(struct foo * self)
{
    sqInt logFile;
    sqInt ok;

	if (!((methodArgumentCount(self)) == 1)) {
		return primitiveFail(self);
	}
	logFile = stackValue(0, self);
	if (logFile == (nilObject(self))) {

		/* disable logging */
		ok = ffiLogFileNameOfLength(null, 0, self);
		if (!ok) {
			return primitiveFail(self);
		}
		ffiLogEnabled = 0;
	}
	else {

		/* enable logging */
		if (!(isBytes(logFile, self))) {
			return primitiveFail(self);
		}
		ok = ffiLogFileNameOfLength(firstIndexableField(logFile, self), byteSizeOf(logFile, self), self);
		if (!ok) {
			return primitiveFail(self);
		}
		ffiLogEnabled = 1;
	}
	return pop(1, self);
}


/*	Create a 'manual surface' data-structure. See the ExternalForm class in
	the FFI package for example usage. */
/*	arguments: name(type, stack offset)
	surfaceID(Integer, 1)
	ptr(uint32/uint64, 0) */

	/* ThreadedFFIPlugin>>#primitiveSetManualSurfacePointer */
EXPORT(sqInt)
primitiveSetManualSurfacePointer(struct foo * self)
{
    usqIntptr_t ptr;
    sqInt result;
    sqInt surfaceID;

	if (!((methodArgumentCount(self)) == 2)) {
		return primitiveFail(self);
	}
	surfaceID = stackIntegerValue(1, self);
	ptr = positiveMachineIntegerValueOf(stackValue(0, self), self);
	if (failed(self)) {
		return null;
	}
	result = setManualSurfacePointer(surfaceID, ((void *)ptr));
	if (result == 0) {
		return primitiveFail(self);
	}
	return pop(2, self);
}


/*	Answer if a struct result of a given size is returned in memory or not. */

	/* ThreadedX64SysVFFIPlugin>>#returnStructInRegisters: */
static sqInt
returnStructInRegisters(sqInt returnStructSize)
{
	return returnStructSize <= (WordSize * 2);
}


/*	Note: This is coded so that it can be run in Squeak. */
/*	Initialization of the plugin in the simulator.
	The real routine is in the superclass. */

	/* ThreadedFFIPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		characterObjectOf = interpreterProxy->characterObjectOf;
#else
#if !defined(characterObjectOf)
		characterObjectOf = 0;
#endif
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		characterValueOf = interpreterProxy->characterValueOf;
#else
#if !defined(characterValueOf)
		characterValueOf = 0;
#endif
#endif
		classAlien = interpreterProxy->classAlien;
		classByteArray = interpreterProxy->classByteArray;
		classExternalAddress = interpreterProxy->classExternalAddress;
		classExternalData = interpreterProxy->classExternalData;
		classExternalFunction = interpreterProxy->classExternalFunction;
		classExternalLibrary = interpreterProxy->classExternalLibrary;
		classExternalStructure = interpreterProxy->classExternalStructure;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classString = interpreterProxy->classString;
		disownVM = interpreterProxy->disownVM;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchLong32ofObject = interpreterProxy->fetchLong32ofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatObjectOf = interpreterProxy->floatObjectOf;
		floatValueOf = interpreterProxy->floatValueOf;
		includesBehaviorThatOf = interpreterProxy->includesBehaviorThatOf;
		instanceSizeOf = interpreterProxy->instanceSizeOf;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
		ioLoadModuleOfLength = interpreterProxy->ioLoadModuleOfLength;
		ioLoadSymbolOfLengthFromModule = interpreterProxy->ioLoadSymbolOfLengthFromModule;
		isKindOfClass = interpreterProxy->isKindOfClass;
		isArray = interpreterProxy->isArray;
		isBytes = interpreterProxy->isBytes;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isCharacterObject = interpreterProxy->isCharacterObject;
#else
#if !defined(isCharacterObject)
		isCharacterObject = 0;
#endif
#endif
		isFloatObject = interpreterProxy->isFloatObject;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isImmediate = interpreterProxy->isImmediate;
#else
#if !defined(isImmediate)
		isImmediate = 0;
#endif
#endif
		isInMemory = interpreterProxy->isInMemory;
		isIntegerObject = interpreterProxy->isIntegerObject;
		isPointers = interpreterProxy->isPointers;
		isWords = interpreterProxy->isWords;
		isYoung = interpreterProxy->isYoung;
		literalofMethod = interpreterProxy->literalofMethod;
		literalCountOf = interpreterProxy->literalCountOf;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnValue = interpreterProxy->methodReturnValue;
		nilObject = interpreterProxy->nilObject;
		ownVM = interpreterProxy->ownVM;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		positive64BitValueOf = interpreterProxy->positive64BitValueOf;
		positiveMachineIntegerValueOf = interpreterProxy->positiveMachineIntegerValueOf;
		primitiveErrorTable = interpreterProxy->primitiveErrorTable;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		primitiveMethod = interpreterProxy->primitiveMethod;
		pushFloat = interpreterProxy->pushFloat;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		signed64BitValueOf = interpreterProxy->signed64BitValueOf;
		signedMachineIntegerValueOf = interpreterProxy->signedMachineIntegerValueOf;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storeIntegerofObjectwithValue = interpreterProxy->storeIntegerofObjectwithValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		tenuringIncrementalGC = interpreterProxy->tenuringIncrementalGC;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Answer the first field of oop which is assumed to be an Alien of at least
	8 bytes
 */

	/* ThreadedFFIPlugin>>#sizeField: */
static sqInt
sizeField(sqInt oop)
{
	return longAt(oop + BaseHeaderSize);
}


/*	<Alien oop> ^<Integer> */
/*	Answer the start of oop's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

	/* ThreadedFFIPlugin>>#startOfData: */
static sqInt
startOfData(sqInt oop)
{
	return ((longAt(oop + BaseHeaderSize)) > 0
		? (oop + BaseHeaderSize) + BytesPerOop
		: longAt((oop + BaseHeaderSize) + BytesPerOop));
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "SqueakFFIPrims";
void* X64SysVFFIPlugin_exports[][3] = {
	{(void*)_m, "ffiLogCallsTo", (void*)ffiLogCallsTo},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primitiveCallout\000\002", (void*)primitiveCallout},
	{(void*)_m, "primitiveCalloutWithArgs\000\004", (void*)primitiveCalloutWithArgs},
	{(void*)_m, "primitiveCreateManualSurface\000\000", (void*)primitiveCreateManualSurface},
	{(void*)_m, "primitiveDestroyManualSurface\000\000", (void*)primitiveDestroyManualSurface},
	{(void*)_m, "primitiveFFIAllocate\000\001", (void*)primitiveFFIAllocate},
	{(void*)_m, "primitiveFFIDoubleAt\000\001", (void*)primitiveFFIDoubleAt},
	{(void*)_m, "primitiveFFIDoubleAtPut\000\001", (void*)primitiveFFIDoubleAtPut},
	{(void*)_m, "primitiveFFIFloatAt\000\001", (void*)primitiveFFIFloatAt},
	{(void*)_m, "primitiveFFIFloatAtPut\000\001", (void*)primitiveFFIFloatAtPut},
	{(void*)_m, "primitiveFFIFree\000\001", (void*)primitiveFFIFree},
	{(void*)_m, "primitiveFFIGetLastError\000\377", (void*)primitiveFFIGetLastError},
	{(void*)_m, "primitiveFFIIntegerAt\000\001", (void*)primitiveFFIIntegerAt},
	{(void*)_m, "primitiveFFIIntegerAtPut\000\001", (void*)primitiveFFIIntegerAtPut},
	{(void*)_m, "primitiveForceLoad\000\002", (void*)primitiveForceLoad},
	{(void*)_m, "primitiveLoadSymbolFromModule\000\002", (void*)primitiveLoadSymbolFromModule},
	{(void*)_m, "primitiveLogCallsTo\000\000", (void*)primitiveLogCallsTo},
	{(void*)_m, "primitiveSetManualSurfacePointer\000\000", (void*)primitiveSetManualSurfacePointer},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primitiveCalloutAccessorDepth = 2;
EXPORT(signed char) primitiveCalloutWithArgsAccessorDepth = 4;
EXPORT(signed char) primitiveCreateManualSurfaceAccessorDepth = 0;
EXPORT(signed char) primitiveDestroyManualSurfaceAccessorDepth = 0;
EXPORT(signed char) primitiveFFIAllocateAccessorDepth = 1;
EXPORT(signed char) primitiveFFIDoubleAtAccessorDepth = 1;
EXPORT(signed char) primitiveFFIDoubleAtPutAccessorDepth = 1;
EXPORT(signed char) primitiveFFIFloatAtAccessorDepth = 1;
EXPORT(signed char) primitiveFFIFloatAtPutAccessorDepth = 1;
EXPORT(signed char) primitiveFFIFreeAccessorDepth = 1;
EXPORT(signed char) primitiveFFIIntegerAtAccessorDepth = 1;
EXPORT(signed char) primitiveFFIIntegerAtPutAccessorDepth = 1;
EXPORT(signed char) primitiveForceLoadAccessorDepth = 2;
EXPORT(signed char) primitiveLoadSymbolFromModuleAccessorDepth = 2;
EXPORT(signed char) primitiveLogCallsToAccessorDepth = 0;
EXPORT(signed char) primitiveSetManualSurfacePointerAccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
