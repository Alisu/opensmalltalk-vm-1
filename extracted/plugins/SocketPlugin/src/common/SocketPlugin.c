/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-eem.2495 uuid: fcbf4c90-4c50-4ff3-8690-0edfded4f9c4
   from
	SocketPlugin VMMaker.oscog-eem.2495 uuid: fcbf4c90-4c50-4ff3-8690-0edfded4f9c4
 */
static char __buildInfo[] = "SocketPlugin VMMaker.oscog-eem.2495 uuid: fcbf4c90-4c50-4ff3-8690-0edfded4f9c4 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "SocketPlugin.h"
#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) initialiseModule(struct foo * self);
static sqInt intToNetAddress(sqInt addr, struct foo * self);
EXPORT(sqInt) moduleUnloaded(char *aModuleName, struct foo * self);
static sqInt netAddressToInt(unsigned char *ptrToByteArray, struct foo * self);
EXPORT(sqInt) primitiveDisableSocketAccess(struct foo * self);
EXPORT(sqInt) primitiveHasSocketAccess(struct foo * self);
EXPORT(sqInt) primitiveInitializeNetwork(struct foo * self);
EXPORT(sqInt) primitiveResolverAbortLookup(struct foo * self);
EXPORT(sqInt) primitiveResolverAddressLookupResult(struct foo * self);
EXPORT(sqInt) primitiveResolverError(struct foo * self);
EXPORT(sqInt) primitiveResolverGetAddressInfo(struct foo * self);
EXPORT(sqInt) primitiveResolverGetAddressInfoFamily(struct foo * self);
EXPORT(sqInt) primitiveResolverGetAddressInfoNext(struct foo * self);
EXPORT(sqInt) primitiveResolverGetAddressInfoProtocol(struct foo * self);
EXPORT(sqInt) primitiveResolverGetAddressInfoResult(struct foo * self);
EXPORT(sqInt) primitiveResolverGetAddressInfoSize(struct foo * self);
EXPORT(sqInt) primitiveResolverGetAddressInfoType(struct foo * self);
EXPORT(sqInt) primitiveResolverGetNameInfo(struct foo * self);
EXPORT(sqInt) primitiveResolverGetNameInfoHostResult(struct foo * self);
EXPORT(sqInt) primitiveResolverGetNameInfoHostSize(struct foo * self);
EXPORT(sqInt) primitiveResolverGetNameInfoServiceResult(struct foo * self);
EXPORT(sqInt) primitiveResolverGetNameInfoServiceSize(struct foo * self);
EXPORT(sqInt) primitiveResolverHostNameResult(struct foo * self);
EXPORT(sqInt) primitiveResolverHostNameSize(struct foo * self);
EXPORT(sqInt) primitiveResolverLocalAddress(struct foo * self);
EXPORT(sqInt) primitiveResolverNameLookupResult(struct foo * self);
EXPORT(sqInt) primitiveResolverStartAddressLookup(struct foo * self);
EXPORT(sqInt) primitiveResolverStartNameLookup(struct foo * self);
EXPORT(sqInt) primitiveResolverStatus(struct foo * self);
EXPORT(sqInt) primitiveSocketAbortConnection(struct foo * self);
EXPORT(sqInt) primitiveSocketAccept(struct foo * self);
EXPORT(sqInt) primitiveSocketAccept3Semaphores(struct foo * self);
EXPORT(sqInt) primitiveSocketAddressGetPort(struct foo * self);
EXPORT(sqInt) primitiveSocketAddressSetPort(struct foo * self);
EXPORT(sqInt) primitiveSocketBindTo(struct foo * self);
EXPORT(sqInt) primitiveSocketBindToPort(struct foo * self);
EXPORT(sqInt) primitiveSocketCloseConnection(struct foo * self);
EXPORT(sqInt) primitiveSocketConnectionStatus(struct foo * self);
EXPORT(sqInt) primitiveSocketConnectTo(struct foo * self);
EXPORT(sqInt) primitiveSocketConnectToPort(struct foo * self);
EXPORT(sqInt) primitiveSocketCreate(struct foo * self);
EXPORT(sqInt) primitiveSocketCreate3Semaphores(struct foo * self);
EXPORT(sqInt) primitiveSocketCreateRAW(struct foo * self);
EXPORT(sqInt) primitiveSocketDestroy(struct foo * self);
EXPORT(sqInt) primitiveSocketError(struct foo * self);
EXPORT(sqInt) primitiveSocketGetOptions(struct foo * self);
EXPORT(sqInt) primitiveSocketListenOnPort(struct foo * self);
EXPORT(sqInt) primitiveSocketListenOnPortBacklog(struct foo * self);
EXPORT(sqInt) primitiveSocketListenOnPortBacklogInterface(struct foo * self);
EXPORT(sqInt) primitiveSocketListenWithBacklog(struct foo * self);
EXPORT(sqInt) primitiveSocketListenWithOrWithoutBacklog(struct foo * self);
EXPORT(sqInt) primitiveSocketLocalAddress(struct foo * self);
EXPORT(sqInt) primitiveSocketLocalAddressResult(struct foo * self);
EXPORT(sqInt) primitiveSocketLocalAddressSize(struct foo * self);
EXPORT(sqInt) primitiveSocketLocalPort(struct foo * self);
EXPORT(sqInt) primitiveSocketReceiveDataAvailable(struct foo * self);
EXPORT(sqInt) primitiveSocketReceiveDataBufCount(struct foo * self);
EXPORT(sqInt) primitiveSocketReceiveUDPDataBufCount(struct foo * self);
EXPORT(sqInt) primitiveSocketRemoteAddress(struct foo * self);
EXPORT(sqInt) primitiveSocketRemoteAddressResult(struct foo * self);
EXPORT(sqInt) primitiveSocketRemoteAddressSize(struct foo * self);
EXPORT(sqInt) primitiveSocketRemotePort(struct foo * self);
EXPORT(sqInt) primitiveSocketSendDataBufCount(struct foo * self);
EXPORT(sqInt) primitiveSocketSendDone(struct foo * self);
EXPORT(sqInt) primitiveSocketSendUDPDataBufCount(struct foo * self);
EXPORT(sqInt) primitiveSocketSetOptions(struct foo * self);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
EXPORT(sqInt) shutdownModule(struct foo * self);
static sqInt socketRecordSize(struct foo * self);
static SocketPtr socketValueOf(sqInt socketOop, struct foo * self);
static sqInt sqAssert(sqInt aBool, struct foo * self);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*byteSizeOf)(sqInt oop, struct foo * self);
static sqInt (*classArray)(struct foo * self);
static sqInt (*classByteArray)(struct foo * self);
static sqInt (*classString)(struct foo * self);
static sqInt (*failed)(struct foo * self);
static sqInt (*falseObject)(struct foo * self);
static void * (*firstIndexableField)(sqInt oop, struct foo * self);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size, struct foo * self);
static sqInt (*integerObjectOf)(sqInt value, struct foo * self);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName, struct foo * self);
static sqInt (*isBytes)(sqInt oop, struct foo * self);
static sqInt (*isIntegerObject)(sqInt objectPointer, struct foo * self);
static sqInt (*isWords)(sqInt oop, struct foo * self);
static sqInt (*isWordsOrBytes)(sqInt oop, struct foo * self);
static sqInt (*methodArgumentCount)(struct foo * self);
static sqInt (*pop)(sqInt nItems, struct foo * self);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop, struct foo * self);
static sqInt (*popRemappableOop)(struct foo * self);
static sqInt (*primitiveFail)(struct foo * self);
static sqInt (*primitiveFailFor)(sqInt reasonCode, struct foo * self);
static sqInt (*pushRemappableOop)(sqInt oop, struct foo * self);
static sqInt (*slotSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stackIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackValue)(sqInt offset, struct foo * self);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer, struct foo * self);
static sqInt (*success)(sqInt aBoolean, struct foo * self);
static sqInt (*trueObject)(struct foo * self);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt byteSizeOf(sqInt oop, struct foo * self);
extern sqInt classArray(struct foo * self);
extern sqInt classByteArray(struct foo * self);
extern sqInt classString(struct foo * self);
extern sqInt failed(struct foo * self);
extern sqInt falseObject(struct foo * self);
extern void * firstIndexableField(sqInt oop, struct foo * self);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName, struct foo * self);
extern sqInt isBytes(sqInt oop, struct foo * self);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer, struct foo * self);
#endif
extern sqInt isWords(sqInt oop, struct foo * self);
extern sqInt isWordsOrBytes(sqInt oop, struct foo * self);
extern sqInt methodArgumentCount(struct foo * self);
extern sqInt pop(sqInt nItems, struct foo * self);
extern sqInt popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt popRemappableOop(struct foo * self);
extern sqInt primitiveFail(struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
extern sqInt pushRemappableOop(sqInt oop, struct foo * self);
extern sqInt slotSizeOf(sqInt oop, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer, struct foo * self);
extern sqInt success(sqInt aBoolean, struct foo * self);
extern sqInt trueObject(struct foo * self);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"SocketPlugin VMMaker.oscog-eem.2495 (i)"
#else
	"SocketPlugin VMMaker.oscog-eem.2495 (e)"
#endif
;
static void * sCCLOPfn;
static void * sCCSOTfn;
static void * sCCTPfn;
static void * sDSAfn;
static void * sHSAfn;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* SocketPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(struct foo * self)
{
	sDSAfn = ioLoadFunctionFrom("secDisableSocketAccess", "SecurityPlugin", self);
	sHSAfn = ioLoadFunctionFrom("secHasSocketAccess", "SecurityPlugin", self);
	sCCTPfn = ioLoadFunctionFrom("secCanConnectToPort", "SecurityPlugin", self);
	sCCLOPfn = ioLoadFunctionFrom("secCanListenOnPort", "SecurityPlugin", self);
	sCCSOTfn = ioLoadFunctionFrom("secCanCreateSocketOfType", "SecurityPlugin", self);
	return socketInit(self);
}


/*	Convert the given 32-bit integer into an internet network address
	represented as a four-byte ByteArray.
 */

	/* SocketPlugin>>#intToNetAddress: */
static sqInt
intToNetAddress(sqInt addr, struct foo * self)
{
	char *naPtr;
	sqInt netAddressOop;

	netAddressOop = instantiateClassindexableSize(classByteArray(self), 4, self);
	naPtr = ((char *)firstIndexableField(netAddressOop, self));
	naPtr[0] = (((char) ((((usqInt) addr) >> 24) & 0xFF)));
	naPtr[1] = (((char) ((((usqInt) addr) >> 16) & 0xFF)));
	naPtr[2] = (((char) ((((usqInt) addr) >> 8) & 0xFF)));
	naPtr[3] = (((char) (addr & 0xFF)));
	return netAddressOop;
}


/*	The module with the given name was just unloaded.
	Make sure we have no dangling references. */

	/* SocketPlugin>>#moduleUnloaded: */
EXPORT(sqInt)
moduleUnloaded(char *aModuleName, struct foo * self)
{
	if ((strcmp(aModuleName, "SecurityPlugin")) == 0) {

		/* The security plugin just shut down. How odd. */
		sDSAfn = (sHSAfn = (sCCTPfn = (sCCLOPfn = (sCCSOTfn = 0))));
	}
	return 0;
}


/*	Convert the given internet network address (represented as a four-byte
	ByteArray) into a 32-bit integer. Fail if the given ptrToByteArray does
	not appear to point to a four-byte ByteArray.
 */

	/* SocketPlugin>>#netAddressToInt: */
static sqInt
netAddressToInt(unsigned char *ptrToByteArray, struct foo * self)
{
	sqInt sz;

	sz = byteSizeOf(((sqInt)(sqIntptr_t)(ptrToByteArray) - BaseHeaderSize), self);
	if (!(sz == 4)) {
		return primitiveFail(self);
	}
	return (((ptrToByteArray[3]) + (((usqInt)((ptrToByteArray[2])) << 8))) + (((usqInt)((ptrToByteArray[1])) << 16))) + (((usqInt)((ptrToByteArray[0])) << 24));
}


/*	If the security plugin can be loaded, use it to turn off socket access
	If not, assume it's ok */

	/* SocketPlugin>>#primitiveDisableSocketAccess */
EXPORT(sqInt)
primitiveDisableSocketAccess(struct foo * self)
{
	if (sDSAfn != 0) {
		((sqInt (*) (void)) sDSAfn)();
	}
	return 0;
}

	/* SocketPlugin>>#primitiveHasSocketAccess */
EXPORT(sqInt)
primitiveHasSocketAccess(struct foo * self)
{
	popthenPush(1, ((((sHSAfn == 0)
 || ( ((sqInt (*) (void)) sHSAfn)()))) ? trueObject(self) : falseObject(self)), self);
	return null;
}

	/* SocketPlugin>>#primitiveInitializeNetwork: */
EXPORT(sqInt)
primitiveInitializeNetwork(struct foo * self)
{
	sqInt err;
	sqInt resolverSemaIndex;

	if (!(isIntegerObject(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	resolverSemaIndex = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	err = sqNetworkInit(resolverSemaIndex, self);
	success(err == 0, self);
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverAbortLookup */
EXPORT(sqInt)
primitiveResolverAbortLookup(struct foo * self)
{
	sqResolverAbort(self);
	return null;
}

	/* SocketPlugin>>#primitiveResolverAddressLookupResult */
EXPORT(sqInt)
primitiveResolverAddressLookupResult(struct foo * self)
{
	sqInt s;
	sqInt sz;

	s = 0;
	sz = sqResolverAddrLookupResultSize(self);
	if (!(failed(self))) {
		s = instantiateClassindexableSize(classString(self), sz, self);
		sqResolverAddrLookupResult(((char *)firstIndexableField(s, self)), sz, self);
	}
	if (!(failed(self))) {
		popthenPush(1, s, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverError */
EXPORT(sqInt)
primitiveResolverError(struct foo * self)
{
	popthenPush(1, integerObjectOf((sqResolverError(self)), self), self);
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetAddressInfoHost:service:flags:family:type:protocol: */
EXPORT(sqInt)
primitiveResolverGetAddressInfo(struct foo * self)
{
	sqInt family;
	sqInt flags;
	char *hostName;
	sqInt hostSize;
	sqInt protocol;
	char *servName;
	sqInt servSize;
	sqInt type;

	if (!((isBytes(stackValue(5, self), self))
		 && ((isBytes(stackValue(4, self), self))
		 && ((isIntegerObject(stackValue(3, self), self))
		 && ((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	hostName = ((char *) (firstIndexableField(stackValue(5, self), self)));
	servName = ((char *) (firstIndexableField(stackValue(4, self), self)));
	flags = stackIntegerValue(3, self);
	family = stackIntegerValue(2, self);
	type = stackIntegerValue(1, self);
	protocol = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		hostSize = byteSizeOf(((sqInt)(sqIntptr_t)(hostName) - BaseHeaderSize), self);
		servSize = byteSizeOf(((sqInt)(sqIntptr_t)(servName) - BaseHeaderSize), self);
		sqResolverGetAddressInfoHostSizeServiceSizeFlagsFamilyTypeProtocol(hostName, hostSize, servName, servSize, flags, family, type, protocol, self);
	}
	if (!(failed(self))) {
		pop(6, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetAddressInfoFamily */
EXPORT(sqInt)
primitiveResolverGetAddressInfoFamily(struct foo * self)
{
	sqInt family;

	if (!(failed(self))) {
		family = sqResolverGetAddressInfoFamily(self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(family, self), self);
		}
		return null;
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetAddressInfoNext */
EXPORT(sqInt)
primitiveResolverGetAddressInfoNext(struct foo * self)
{
	sqInt more;

	more = sqResolverGetAddressInfoNext(self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		popthenPush(1, ((more) ? trueObject(self) : falseObject(self)), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetAddressInfoProtocol */
EXPORT(sqInt)
primitiveResolverGetAddressInfoProtocol(struct foo * self)
{
	sqInt protocol;

	if (!(failed(self))) {
		protocol = sqResolverGetAddressInfoProtocol(self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(protocol, self), self);
		}
		return null;
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetAddressInfoResult: */
EXPORT(sqInt)
primitiveResolverGetAddressInfoResult(struct foo * self)
{
	sqInt addrSize;
	char *socketAddress;

	if (!(isBytes(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socketAddress = ((char *) (firstIndexableField(stackValue(0, self), self)));
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		addrSize = byteSizeOf(((sqInt)(sqIntptr_t)(socketAddress) - BaseHeaderSize), self);
		sqResolverGetAddressInfoResultSize(socketAddress, addrSize, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetAddressInfoSize */
EXPORT(sqInt)
primitiveResolverGetAddressInfoSize(struct foo * self)
{
	sqInt size;

	if (!(failed(self))) {
		size = sqResolverGetAddressInfoSize(self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(size, self), self);
		}
		return null;
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetAddressInfoType */
EXPORT(sqInt)
primitiveResolverGetAddressInfoType(struct foo * self)
{
	sqInt type;

	if (!(failed(self))) {
		type = sqResolverGetAddressInfoType(self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(type, self), self);
		}
		return null;
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetNameInfo:flags: */
EXPORT(sqInt)
primitiveResolverGetNameInfo(struct foo * self)
{
	char *addrBase;
	sqInt addrSize;
	sqInt flags;
	sqInt socketAddress;

	if (!(isIntegerObject(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socketAddress = stackValue(1, self);
	flags = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		addrSize = byteSizeOf(socketAddress, self);
		addrBase = ((char *) (firstIndexableField(socketAddress, self)));
		sqResolverGetNameInfoSizeFlags(addrBase, addrSize, flags, self);
	}
	if (!(failed(self))) {
		pop(2, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetNameInfoHostResult: */
EXPORT(sqInt)
primitiveResolverGetNameInfoHostResult(struct foo * self)
{
	sqInt addrSize;
	char *socketName;

	if (!(isBytes(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socketName = ((char *) (firstIndexableField(stackValue(0, self), self)));
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		addrSize = byteSizeOf(((sqInt)(sqIntptr_t)(socketName) - BaseHeaderSize), self);
		sqResolverGetNameInfoHostResultSize(socketName, addrSize, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetNameInfoHostSize */
EXPORT(sqInt)
primitiveResolverGetNameInfoHostSize(struct foo * self)
{
	sqInt size;

	if (!(failed(self))) {
		size = sqResolverGetNameInfoHostSize(self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(size, self), self);
		}
		return null;
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetNameInfoServiceResult: */
EXPORT(sqInt)
primitiveResolverGetNameInfoServiceResult(struct foo * self)
{
	sqInt addrSize;
	char *socketName;

	if (!(isBytes(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socketName = ((char *) (firstIndexableField(stackValue(0, self), self)));
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		addrSize = byteSizeOf(((sqInt)(sqIntptr_t)(socketName) - BaseHeaderSize), self);
		sqResolverGetNameInfoServiceResultSize(socketName, addrSize, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverGetNameInfoServiceSize */
EXPORT(sqInt)
primitiveResolverGetNameInfoServiceSize(struct foo * self)
{
	sqInt size;

	if (!(failed(self))) {
		size = sqResolverGetNameInfoServiceSize(self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(size, self), self);
		}
		return null;
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverHostNameResult: */
EXPORT(sqInt)
primitiveResolverHostNameResult(struct foo * self)
{
	sqInt nameSize;
	char *nameString;

	if (!(isBytes(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	nameString = ((char *) (firstIndexableField(stackValue(0, self), self)));
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		nameSize = byteSizeOf(((sqInt)(sqIntptr_t)(nameString) - BaseHeaderSize), self);
		sqResolverHostNameResultSize(nameString, nameSize, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverHostNameSize */
EXPORT(sqInt)
primitiveResolverHostNameSize(struct foo * self)
{
	sqInt size;

	if (!(failed(self))) {
		size = sqResolverHostNameSize(self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(size, self), self);
			return null;
		}
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverLocalAddress */
EXPORT(sqInt)
primitiveResolverLocalAddress(struct foo * self)
{
	sqInt addr;
	sqInt _return_value;

	addr = sqResolverLocalAddress(self);
	if (!(failed(self))) {
		_return_value = intToNetAddress(addr, self);
		if (!(failed(self))) {
			popthenPush(1, _return_value, self);
		}
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverNameLookupResult */
EXPORT(sqInt)
primitiveResolverNameLookupResult(struct foo * self)
{
	sqInt addr;
	sqInt _return_value;

	addr = sqResolverNameLookupResult(self);
	if (!(failed(self))) {
		_return_value = intToNetAddress(addr, self);
		if (!(failed(self))) {
			popthenPush(1, _return_value, self);
		}
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverStartAddressLookup: */
EXPORT(sqInt)
primitiveResolverStartAddressLookup(struct foo * self)
{
	sqInt addr;
	char *address;
	sqInt sz;

	if (!(isBytes(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	address = ((char *) (firstIndexableField(stackValue(0, self), self)));
	if (failed(self)) {
		return null;
	}
	/* begin netAddressToInt: */
	sz = byteSizeOf(((sqInt)(sqIntptr_t)((((unsigned char *) address))) - BaseHeaderSize), self);
	if (!(sz == 4)) {
		addr = primitiveFail(self);
		goto l1;
	}
	addr = ((((((unsigned char *) address))[3]) + (((usqInt)(((((unsigned char *) address))[2])) << 8))) + (((usqInt)(((((unsigned char *) address))[1])) << 16))) + (((usqInt)(((((unsigned char *) address))[0])) << 24));
	l1:	/* end netAddressToInt: */;
	if (!(failed(self))) {
		sqResolverStartAddrLookup(addr, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverStartNameLookup: */
EXPORT(sqInt)
primitiveResolverStartNameLookup(struct foo * self)
{
	char *name;
	sqInt sz;

	if (!(isBytes(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	name = ((char *) (firstIndexableField(stackValue(0, self), self)));
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		sz = byteSizeOf(((sqInt)(sqIntptr_t)(name) - BaseHeaderSize), self);
		sqResolverStartNameLookup(name, sz, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveResolverStatus */
EXPORT(sqInt)
primitiveResolverStatus(struct foo * self)
{
	sqInt status;

	status = sqResolverStatus(self);
	if (!(failed(self))) {
		popthenPush(1, integerObjectOf(status, self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketAbortConnection: */
EXPORT(sqInt)
primitiveSocketAbortConnection(struct foo * self)
{
	SocketPtr s;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketAbortConnection(s, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketAcceptFrom:rcvBufferSize:sndBufSize:semaIndex: */
EXPORT(sqInt)
primitiveSocketAccept(struct foo * self)
{
	sqInt recvBufSize;
	SocketPtr s;
	sqInt semaIndex;
	sqInt sendBufSize;
	SocketPtr serverSocket;
	sqInt socketOop;
	sqInt sockHandle;

	socketOop = 0;
	if (!((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	sockHandle = stackValue(3, self);
	recvBufSize = stackIntegerValue(2, self);
	sendBufSize = stackIntegerValue(1, self);
	semaIndex = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(sockHandle, self))
	 && ((byteSizeOf(sockHandle, self)) == (sizeof(SQSocket)))) {
		serverSocket = ((SocketPtr) (firstIndexableField(sockHandle, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		serverSocket = null;
	}
	if (!(failed(self))) {
		socketOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQSocket), self);
		/* begin socketValueOf: */
		if ((isBytes(socketOop, self))
		 && ((byteSizeOf(socketOop, self)) == (sizeof(SQSocket)))) {
			s = ((SocketPtr) (firstIndexableField(socketOop, self)));
		}
		else {
			primitiveFailFor(PrimErrBadArgument, self);
			s = null;
		}
		sqSocketAcceptFromRecvBytesSendBytesSemaID(s, serverSocket, recvBufSize, sendBufSize, semaIndex, self);
	}
	if (!(failed(self))) {
		popthenPush(5, socketOop, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketAcceptFrom:rcvBufferSize:sndBufSize:semaIndex:readSemaIndex:writeSemaIndex: */
EXPORT(sqInt)
primitiveSocketAccept3Semaphores(struct foo * self)
{
	sqInt aReadSema;
	sqInt aWriteSema;
	sqInt recvBufSize;
	SocketPtr s;
	sqInt semaIndex;
	sqInt sendBufSize;
	SocketPtr serverSocket;
	sqInt socketOop;
	sqInt sockHandle;

	socketOop = 0;
	if (!((isIntegerObject(stackValue(4, self), self))
		 && ((isIntegerObject(stackValue(3, self), self))
		 && ((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self))))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	sockHandle = stackValue(5, self);
	recvBufSize = stackIntegerValue(4, self);
	sendBufSize = stackIntegerValue(3, self);
	semaIndex = stackIntegerValue(2, self);
	aReadSema = stackIntegerValue(1, self);
	aWriteSema = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(sockHandle, self))
	 && ((byteSizeOf(sockHandle, self)) == (sizeof(SQSocket)))) {
		serverSocket = ((SocketPtr) (firstIndexableField(sockHandle, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		serverSocket = null;
	}
	if (!(failed(self))) {
		socketOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQSocket), self);
		/* begin socketValueOf: */
		if ((isBytes(socketOop, self))
		 && ((byteSizeOf(socketOop, self)) == (sizeof(SQSocket)))) {
			s = ((SocketPtr) (firstIndexableField(socketOop, self)));
		}
		else {
			primitiveFailFor(PrimErrBadArgument, self);
			s = null;
		}
		sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(s, serverSocket, recvBufSize, sendBufSize, semaIndex, aReadSema, aWriteSema, self);
	}
	if (!(failed(self))) {
		popthenPush(7, socketOop, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketAddressGetPort */
EXPORT(sqInt)
primitiveSocketAddressGetPort(struct foo * self)
{
	sqInt addr;
	char *addrBase;
	sqInt addrSize;
	sqInt port;

	addr = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	addrSize = byteSizeOf(addr, self);
	addrBase = ((char *) (firstIndexableField(addr, self)));
	if (!(failed(self))) {
		port = sqSocketAddressSizeGetPort(addrBase, addrSize, self);
		if (!(failed(self))) {
			popthenPush(1, integerObjectOf(port, self), self);
			return null;
		}
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketAddressSetPort: */
EXPORT(sqInt)
primitiveSocketAddressSetPort(struct foo * self)
{
	sqInt addr;
	char *addrBase;
	sqInt addrSize;
	sqInt portNumber;

	if (!(isIntegerObject(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	portNumber = stackIntegerValue(0, self);
	addr = stackValue(1, self);
	if (failed(self)) {
		return null;
	}
	addrSize = byteSizeOf(addr, self);
	addrBase = ((char *) (firstIndexableField(addr, self)));
	if (!(failed(self))) {
		sqSocketAddressSizeSetPort(addrBase, addrSize, portNumber, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:bindTo: */
EXPORT(sqInt)
primitiveSocketBindTo(struct foo * self)
{
	char *addrBase;
	sqInt addrSize;
	SocketPtr s;
	sqInt socket;
	sqInt socketAddress;

	socket = stackValue(1, self);
	socketAddress = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	addrSize = byteSizeOf(socketAddress, self);
	addrBase = ((char *) (firstIndexableField(socketAddress, self)));
	if (!(failed(self))) {
		sqSocketBindToAddressSize(s, addrBase, addrSize, self);
	}
	if (!(failed(self))) {
		pop(2, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:bindTo:port: */
EXPORT(sqInt)
primitiveSocketBindToPort(struct foo * self)
{
	sqInt addr;
	char *address;
	sqInt port;
	SocketPtr s;
	sqInt socket;
	sqInt sz;

	if (!((isBytes(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(2, self);
	address = ((char *) (firstIndexableField(stackValue(1, self), self)));
	port = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin netAddressToInt: */
	sz = byteSizeOf(((sqInt)(sqIntptr_t)((((unsigned char *) address))) - BaseHeaderSize), self);
	if (!(sz == 4)) {
		addr = primitiveFail(self);
		goto l1;
	}
	addr = ((((((unsigned char *) address))[3]) + (((usqInt)(((((unsigned char *) address))[2])) << 8))) + (((usqInt)(((((unsigned char *) address))[1])) << 16))) + (((usqInt)(((((unsigned char *) address))[0])) << 24));
	l1:	/* end netAddressToInt: */;
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketBindToPort(s, addr, port, self);
	}
	if (!(failed(self))) {
		pop(3, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketCloseConnection: */
EXPORT(sqInt)
primitiveSocketCloseConnection(struct foo * self)
{
	SocketPtr s;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketCloseConnection(s, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketConnectionStatus: */
EXPORT(sqInt)
primitiveSocketConnectionStatus(struct foo * self)
{
	SocketPtr s;
	sqInt socket;
	sqInt status;

	status = 0;
	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		status = sqSocketConnectionStatus(s, self);
	}
	if (!(failed(self))) {
		popthenPush(2, integerObjectOf(status, self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:connectTo: */
EXPORT(sqInt)
primitiveSocketConnectTo(struct foo * self)
{
	char *addrBase;
	sqInt addrSize;
	SocketPtr s;
	sqInt socket;
	sqInt socketAddress;

	socket = stackValue(1, self);
	socketAddress = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	addrSize = byteSizeOf(socketAddress, self);
	addrBase = ((char *) (firstIndexableField(socketAddress, self)));
	if (!(failed(self))) {
		sqSocketConnectToAddressSize(s, addrBase, addrSize, self);
	}
	if (!(failed(self))) {
		pop(2, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:connectTo:port: */
EXPORT(sqInt)
primitiveSocketConnectToPort(struct foo * self)
{
	sqInt addr;
	char *address;
	sqInt okToConnect;
	sqInt port;
	SocketPtr s;
	sqInt socket;
	sqInt sz;

	if (!((isBytes(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(2, self);
	address = ((char *) (firstIndexableField(stackValue(1, self), self)));
	port = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin netAddressToInt: */
	sz = byteSizeOf(((sqInt)(sqIntptr_t)((((unsigned char *) address))) - BaseHeaderSize), self);
	if (!(sz == 4)) {
		addr = primitiveFail(self);
		goto l1;
	}
	addr = ((((((unsigned char *) address))[3]) + (((usqInt)(((((unsigned char *) address))[2])) << 8))) + (((usqInt)(((((unsigned char *) address))[1])) << 16))) + (((usqInt)(((((unsigned char *) address))[0])) << 24));
	l1:	/* end netAddressToInt: */;
	if (sCCTPfn != 0) {
		okToConnect =  ((sqInt (*) (sqInt, sqInt)) sCCTPfn)(addr, port);
		if (!okToConnect) {
			primitiveFail(self);
			return null;
		}
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketConnectToPort(s, addr, port, self);
	}
	if (!(failed(self))) {
		pop(3, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex: */
EXPORT(sqInt)
primitiveSocketCreate(struct foo * self)
{
	sqInt netType;
	sqInt okToCreate;
	sqInt recvBufSize;
	SocketPtr s;
	sqInt semaIndex;
	sqInt sendBufSize;
	sqInt socketOop;
	sqInt socketType;

	if (!((isIntegerObject(stackValue(4, self), self))
		 && ((isIntegerObject(stackValue(3, self), self))
		 && ((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self))))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	netType = stackIntegerValue(4, self);
	socketType = stackIntegerValue(3, self);
	recvBufSize = stackIntegerValue(2, self);
	sendBufSize = stackIntegerValue(1, self);
	semaIndex = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	if (sCCSOTfn != 0) {
		okToCreate =  ((sqInt (*) (sqInt, sqInt)) sCCSOTfn)(netType, socketType);
		if (!okToCreate) {
			primitiveFail(self);
			return null;
		}
	}
	socketOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQSocket), self);
	/* begin socketValueOf: */
	if ((isBytes(socketOop, self))
	 && ((byteSizeOf(socketOop, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socketOop, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(s, netType, socketType, recvBufSize, sendBufSize, semaIndex, self);
	}
	if (!(failed(self))) {
		popthenPush(6, socketOop, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex: */
EXPORT(sqInt)
primitiveSocketCreate3Semaphores(struct foo * self)
{
	sqInt aReadSema;
	sqInt aWriteSema;
	sqInt netType;
	sqInt okToCreate;
	sqInt recvBufSize;
	SocketPtr s;
	sqInt semaIndex;
	sqInt sendBufSize;
	sqInt socketOop;
	sqInt socketType;

	if (!((isIntegerObject(stackValue(6, self), self))
		 && ((isIntegerObject(stackValue(5, self), self))
		 && ((isIntegerObject(stackValue(4, self), self))
		 && ((isIntegerObject(stackValue(3, self), self))
		 && ((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self))))))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	netType = stackIntegerValue(6, self);
	socketType = stackIntegerValue(5, self);
	recvBufSize = stackIntegerValue(4, self);
	sendBufSize = stackIntegerValue(3, self);
	semaIndex = stackIntegerValue(2, self);
	aReadSema = stackIntegerValue(1, self);
	aWriteSema = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	if (sCCSOTfn != 0) {
		okToCreate =  ((sqInt (*) (sqInt, sqInt)) sCCSOTfn)(netType, socketType);
		if (!okToCreate) {
			primitiveFail(self);
			return null;
		}
	}
	socketOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQSocket), self);
	/* begin socketValueOf: */
	if ((isBytes(socketOop, self))
	 && ((byteSizeOf(socketOop, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socketOop, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(s, netType, socketType, recvBufSize, sendBufSize, semaIndex, aReadSema, aWriteSema, self);
	}
	if (!(failed(self))) {
		popthenPush(8, socketOop, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketCreateRaw:type:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex: */
EXPORT(sqInt)
primitiveSocketCreateRAW(struct foo * self)
{
	sqInt aReadSema;
	sqInt aWriteSema;
	sqInt netType;
	sqInt okToCreate;
	sqInt protoType;
	sqInt recvBufSize;
	SocketPtr s;
	sqInt semaIndex;
	sqInt sendBufSize;
	sqInt socketOop;

	if (!((isIntegerObject(stackValue(6, self), self))
		 && ((isIntegerObject(stackValue(5, self), self))
		 && ((isIntegerObject(stackValue(4, self), self))
		 && ((isIntegerObject(stackValue(3, self), self))
		 && ((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self))))))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	netType = stackIntegerValue(6, self);
	protoType = stackIntegerValue(5, self);
	recvBufSize = stackIntegerValue(4, self);
	sendBufSize = stackIntegerValue(3, self);
	semaIndex = stackIntegerValue(2, self);
	aReadSema = stackIntegerValue(1, self);
	aWriteSema = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	if (sCCSOTfn != 0) {
		okToCreate =  ((sqInt (*) (sqInt, sqInt)) sCCSOTfn)(netType, protoType);
		if (!okToCreate) {
			primitiveFail(self);
			return null;
		}
	}
	socketOop = instantiateClassindexableSize(classByteArray(self), sizeof(SQSocket), self);
	/* begin socketValueOf: */
	if ((isBytes(socketOop, self))
	 && ((byteSizeOf(socketOop, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socketOop, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketCreateRawProtoTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(s, netType, protoType, recvBufSize, sendBufSize, semaIndex, aReadSema, aWriteSema, self);
	}
	if (!(failed(self))) {
		popthenPush(8, socketOop, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketDestroy: */
EXPORT(sqInt)
primitiveSocketDestroy(struct foo * self)
{
	SocketPtr s;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketDestroy(s, self);
	}
	if (!(failed(self))) {
		pop(1, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketError: */
EXPORT(sqInt)
primitiveSocketError(struct foo * self)
{
	sqInt err;
	SocketPtr s;
	sqInt socket;

	err = 0;
	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		err = sqSocketError(s, self);
	}
	if (!(failed(self))) {
		popthenPush(2, integerObjectOf(err, self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:getOptions: */
EXPORT(sqInt)
primitiveSocketGetOptions(struct foo * self)
{
	sqInt errorCode;
	sqInt optionName;
	sqInt optionNameSize;
	char *optionNameStart;
	sqInt results;
	sqInt returnedValue;
	SocketPtr s;
	sqInt socket;

	socket = stackValue(1, self);
	optionName = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	success(isBytes(optionName, self), self);
	optionNameStart = ((char *) (firstIndexableField(optionName, self)));
	optionNameSize = slotSizeOf(optionName, self);
	if (failed(self)) {
		return null;
	}
	returnedValue = 0;
	errorCode = sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(s, optionNameStart, optionNameSize, (&returnedValue), self);
	results = instantiateClassindexableSize(classArray(self), 2, self);
	storePointerofObjectwithValue(0, results, integerObjectOf(errorCode, self), self);
	storePointerofObjectwithValue(1, results, integerObjectOf(returnedValue, self), self);
	if (!(failed(self))) {
		popthenPush(3, results, self);
	}
	return null;
}


/*	one part of the wierdass dual prim primitiveSocketListenOnPort which 
	was warped by some demented evil person determined to twist the very 
	nature of reality */

	/* SocketPlugin>>#primitiveSocket:listenOnPort: */
EXPORT(sqInt)
primitiveSocketListenOnPort(struct foo * self)
{
	sqInt okToListen;
	sqInt port;
	SocketPtr s;
	sqInt socket;

	if (!(isIntegerObject(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(1, self);
	port = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (sCCLOPfn != 0) {
		okToListen =  ((sqInt (*) (sqInt, sqInt)) sCCLOPfn)((sqInt)s, port);
		if (!okToListen) {
			primitiveFail(self);
			return null;
		}
	}
	if (!(failed(self))) {
		sqSocketListenOnPort(s, port, self);
	}
	if (!(failed(self))) {
		pop(2, self);
	}
	return null;
}


/*	second part of the wierdass dual prim primitiveSocketListenOnPort 
	which was warped by some demented evil person determined to twist the 
	very nature of reality */

	/* SocketPlugin>>#primitiveSocket:listenOnPort:backlogSize: */
EXPORT(sqInt)
primitiveSocketListenOnPortBacklog(struct foo * self)
{
	sqInt backlog;
	sqInt okToListen;
	sqInt port;
	SocketPtr s;
	sqInt socket;

	if (!((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(2, self);
	port = stackIntegerValue(1, self);
	backlog = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (sCCLOPfn != 0) {
		okToListen =  ((sqInt (*) (sqInt, sqInt)) sCCLOPfn)((sqInt)s, port);
		if (!okToListen) {
			primitiveFail(self);
			return null;
		}
	}
	sqSocketListenOnPortBacklogSize(s, port, backlog, self);
	if (!(failed(self))) {
		pop(3, self);
	}
	return null;
}


/*	Bind a socket to the given port and interface address with no more than
	backlog pending connections. The socket can be UDP, in which case the
	backlog should be specified as zero.
 */

	/* SocketPlugin>>#primitiveSocket:listenOnPort:backlogSize:interface: */
EXPORT(sqInt)
primitiveSocketListenOnPortBacklogInterface(struct foo * self)
{
	sqInt addr;
	sqInt backlog;
	char *ifAddr;
	sqInt okToListen;
	sqInt port;
	SocketPtr s;
	sqInt socket;
	sqInt sz;

	if (!((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isBytes(stackValue(0, self), self))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(3, self);
	port = stackIntegerValue(2, self);
	backlog = stackIntegerValue(1, self);
	ifAddr = ((char *) (firstIndexableField(stackValue(0, self), self)));
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (sCCLOPfn != 0) {
		okToListen =  ((sqInt (*) (sqInt, sqInt)) sCCLOPfn)((sqInt)s, port);
		if (!okToListen) {
			primitiveFail(self);
			return null;
		}
	}
	/* begin netAddressToInt: */
	sz = byteSizeOf(((sqInt)(sqIntptr_t)((((unsigned char *) ifAddr))) - BaseHeaderSize), self);
	if (!(sz == 4)) {
		addr = primitiveFail(self);
		goto l1;
	}
	addr = ((((((unsigned char *) ifAddr))[3]) + (((usqInt)(((((unsigned char *) ifAddr))[2])) << 8))) + (((usqInt)(((((unsigned char *) ifAddr))[1])) << 16))) + (((usqInt)(((((unsigned char *) ifAddr))[0])) << 24));
	l1:	/* end netAddressToInt: */;
	sqSocketListenOnPortBacklogSizeInterface(s, port, backlog, addr, self);
	if (!(failed(self))) {
		pop(4, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:listenWithBacklog: */
EXPORT(sqInt)
primitiveSocketListenWithBacklog(struct foo * self)
{
	sqInt backlogSize;
	SocketPtr s;
	sqInt socket;

	if (!(isIntegerObject(stackValue(0, self), self))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(1, self);
	backlogSize = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (!(failed(self))) {
		sqSocketListenBacklog(s, backlogSize, self);
	}
	if (!(failed(self))) {
		pop(2, self);
	}
	return null;
}


/*	Backward compatibility */

	/* SocketPlugin>>#primitiveSocketListenWithOrWithoutBacklog */
EXPORT(sqInt)
primitiveSocketListenWithOrWithoutBacklog(struct foo * self)
{
	if ((methodArgumentCount(self)) == 2) {
		return primitiveSocketListenOnPort(self);
	}
	else {
		return primitiveSocketListenOnPortBacklog(self);
	}
}

	/* SocketPlugin>>#primitiveSocketLocalAddress: */
EXPORT(sqInt)
primitiveSocketLocalAddress(struct foo * self)
{
	sqInt addr;
	SocketPtr s;
	sqInt socket;
	sqInt _return_value;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	addr = sqSocketLocalAddress(s, self);
	if (!(failed(self))) {
		_return_value = intToNetAddress(addr, self);
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:localAddressResult: */
EXPORT(sqInt)
primitiveSocketLocalAddressResult(struct foo * self)
{
	char *addrBase;
	sqInt addrSize;
	SocketPtr s;
	sqInt socket;
	sqInt socketAddress;

	socket = stackValue(1, self);
	socketAddress = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	addrSize = byteSizeOf(socketAddress, self);
	addrBase = ((char *) (firstIndexableField(socketAddress, self)));
	if (!(failed(self))) {
		sqSocketLocalAddressResultSize(s, addrBase, addrSize, self);
	}
	if (!(failed(self))) {
		pop(2, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketLocalAddressSize: */
EXPORT(sqInt)
primitiveSocketLocalAddressSize(struct foo * self)
{
	SocketPtr s;
	sqInt size;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (failed(self)) {
		return null;
	}
	size = sqSocketLocalAddressSize(s, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		popthenPush(2, integerObjectOf(size, self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketLocalPort: */
EXPORT(sqInt)
primitiveSocketLocalPort(struct foo * self)
{
	sqInt port;
	SocketPtr s;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	port = sqSocketLocalPort(s, self);
	if (!(failed(self))) {
		popthenPush(2, integerObjectOf(port, self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketReceiveDataAvailable: */
EXPORT(sqInt)
primitiveSocketReceiveDataAvailable(struct foo * self)
{
	sqInt dataIsAvailable;
	SocketPtr s;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	dataIsAvailable = sqSocketReceiveDataAvailable(s, self);
	if (!(failed(self))) {
		popthenPush(2, ((dataIsAvailable) ? trueObject(self) : falseObject(self)), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:receiveDataBuf:start:count: */
EXPORT(sqInt)
primitiveSocketReceiveDataBufCount(struct foo * self)
{
	sqInt array;
	char *arrayBase;
	char *bufStart;
	sqInt byteSize;
	sqInt bytesReceived;
	sqInt count;
	SocketPtr s;
	sqInt socket;
	sqInt startIndex;

	bytesReceived = 0;
	if (!((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(3, self);
	array = stackValue(2, self);
	startIndex = stackIntegerValue(1, self);
	count = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	success(isWordsOrBytes(array, self), self);
	if (isWords(array, self)) {
		byteSize = 4;
	}
	else {
		byteSize = 1;
	}
	success((startIndex >= 1)
	 && ((count >= 0)
	 && (((startIndex + count) - 1) <= (slotSizeOf(array, self)))), self);
	if (!(failed(self))) {

		/* Note: adjust bufStart for zero-origin indexing */
		arrayBase = ((char *) (firstIndexableField(array, self)));
		bufStart = arrayBase + ((startIndex - 1) * byteSize);
		bytesReceived = sqSocketReceiveDataBufCount(s, bufStart, count * byteSize, self);
	}
	if (!(failed(self))) {
		popthenPush(5, integerObjectOf((bytesReceived / byteSize), self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:receiveUDPDataBuf:start:count: */
EXPORT(sqInt)
primitiveSocketReceiveUDPDataBufCount(struct foo * self)
{
	sqInt address;
	sqInt array;
	char *arrayBase;
	char *bufStart;
	sqInt bytesReceived;
	sqInt count;
	sqInt elementSize;
	sqInt moreFlag;
	sqInt port;
	sqInt results;
	SocketPtr s;
	sqInt socket;
	sqInt startIndex;

	results = 0;
	if (!((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(3, self);
	array = stackValue(2, self);
	startIndex = stackIntegerValue(1, self);
	count = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	success(isWordsOrBytes(array, self), self);
	if (isWords(array, self)) {
		elementSize = 4;
	}
	else {
		elementSize = 1;
	}
	success((startIndex >= 1)
	 && ((count >= 0)
	 && (((startIndex + count) - 1) <= (slotSizeOf(array, self)))), self);
	if (!(failed(self))) {

		/* Note: adjust bufStart for zero-origin indexing */
		arrayBase = ((char *) (firstIndexableField(array, self)));
		bufStart = arrayBase + ((startIndex - 1) * elementSize);
		address = 0;
		port = 0;
		moreFlag = 0;

		/* allocate storage for results, remapping newly allocated
		   oops in case GC happens during allocation */
		bytesReceived = sqSocketReceiveUDPDataBufCountaddressportmoreFlag(s, bufStart, count * elementSize, (&address), (&port), (&moreFlag), self);
		pushRemappableOop(intToNetAddress(address, self), self);
		results = instantiateClassindexableSize(classArray(self), 4, self);
		storePointerofObjectwithValue(0, results, integerObjectOf((bytesReceived / elementSize), self), self);
		storePointerofObjectwithValue(1, results, popRemappableOop(self), self);
		storePointerofObjectwithValue(2, results, integerObjectOf(port, self), self);
		storePointerofObjectwithValue(3, results, (moreFlag
			? trueObject(self)
			: falseObject(self)), self);
	}
	if (!(failed(self))) {
		popthenPush(5, results, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketRemoteAddress: */
EXPORT(sqInt)
primitiveSocketRemoteAddress(struct foo * self)
{
	sqInt addr;
	SocketPtr s;
	sqInt socket;
	sqInt _return_value;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	addr = sqSocketRemoteAddress(s, self);
	if (!(failed(self))) {
		_return_value = intToNetAddress(addr, self);
		if (!(failed(self))) {
			popthenPush(2, _return_value, self);
		}
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:remoteAddressResult: */
EXPORT(sqInt)
primitiveSocketRemoteAddressResult(struct foo * self)
{
	char *addrBase;
	sqInt addrSize;
	SocketPtr s;
	sqInt socket;
	sqInt socketAddress;

	socket = stackValue(1, self);
	socketAddress = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	addrSize = byteSizeOf(socketAddress, self);
	addrBase = ((char *) (firstIndexableField(socketAddress, self)));
	if (!(failed(self))) {
		sqSocketRemoteAddressResultSize(s, addrBase, addrSize, self);
	}
	if (!(failed(self))) {
		pop(2, self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketRemoteAddressSize: */
EXPORT(sqInt)
primitiveSocketRemoteAddressSize(struct foo * self)
{
	SocketPtr s;
	sqInt size;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	if (failed(self)) {
		return null;
	}
	size = sqSocketRemoteAddressSize(s, self);
	if (failed(self)) {
		return null;
	}
	if (!(failed(self))) {
		popthenPush(2, integerObjectOf(size, self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketRemotePort: */
EXPORT(sqInt)
primitiveSocketRemotePort(struct foo * self)
{
	sqInt port;
	SocketPtr s;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	port = sqSocketRemotePort(s, self);
	if (!(failed(self))) {
		popthenPush(2, integerObjectOf(port, self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:sendData:start:count: */
EXPORT(sqInt)
primitiveSocketSendDataBufCount(struct foo * self)
{
	sqInt array;
	char *arrayBase;
	char *bufStart;
	sqInt byteSize;
	sqInt bytesSent;
	sqInt count;
	SocketPtr s;
	sqInt socket;
	sqInt startIndex;

	bytesSent = 0;
	if (!((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(3, self);
	array = stackValue(2, self);
	startIndex = stackIntegerValue(1, self);
	count = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	success(isWordsOrBytes(array, self), self);
	if (isWords(array, self)) {
		byteSize = 4;
	}
	else {
		byteSize = 1;
	}
	success((startIndex >= 1)
	 && ((count >= 0)
	 && (((startIndex + count) - 1) <= (slotSizeOf(array, self)))), self);
	if (!(failed(self))) {

		/* Note: adjust bufStart for zero-origin indexing */
		arrayBase = ((char *) (firstIndexableField(array, self)));
		bufStart = arrayBase + ((startIndex - 1) * byteSize);
		bytesSent = sqSocketSendDataBufCount(s, bufStart, count * byteSize, self);
	}
	if (!(failed(self))) {
		popthenPush(5, integerObjectOf((bytesSent / byteSize), self), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocketSendDone: */
EXPORT(sqInt)
primitiveSocketSendDone(struct foo * self)
{
	sqInt done;
	SocketPtr s;
	sqInt socket;

	socket = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	done = sqSocketSendDone(s, self);
	if (!(failed(self))) {
		popthenPush(2, ((done) ? trueObject(self) : falseObject(self)), self);
	}
	return null;
}

	/* SocketPlugin>>#primitiveSocket:sendUDPData:toHost:port:start:count: */
EXPORT(sqInt)
primitiveSocketSendUDPDataBufCount(struct foo * self)
{
	sqInt address;
	sqInt array;
	char *arrayBase;
	char *bufStart;
	sqInt byteSize;
	sqInt bytesSent;
	sqInt count;
	char *hostAddress;
	sqInt portNumber;
	SocketPtr s;
	sqInt socket;
	sqInt startIndex;
	sqInt sz;

	bytesSent = 0;
	if (!((isBytes(stackValue(3, self), self))
		 && ((isIntegerObject(stackValue(2, self), self))
		 && ((isIntegerObject(stackValue(1, self), self))
		 && (isIntegerObject(stackValue(0, self), self)))))) {
		primitiveFailFor(PrimErrBadArgument, self);
		return null;
	}
	socket = stackValue(5, self);
	array = stackValue(4, self);
	hostAddress = ((char *) (firstIndexableField(stackValue(3, self), self)));
	portNumber = stackIntegerValue(2, self);
	startIndex = stackIntegerValue(1, self);
	count = stackIntegerValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	success(isWordsOrBytes(array, self), self);
	if (isWords(array, self)) {
		byteSize = 4;
	}
	else {
		byteSize = 1;
	}
	success((startIndex >= 1)
	 && ((count >= 0)
	 && (((startIndex + count) - 1) <= (slotSizeOf(array, self)))), self);
	if (!(failed(self))) {

		/* Note: adjust bufStart for zero-origin indexing */
		arrayBase = ((char *) (firstIndexableField(array, self)));
		bufStart = arrayBase + ((startIndex - 1) * byteSize);
		/* begin netAddressToInt: */
		sz = byteSizeOf(((sqInt)(sqIntptr_t)((((unsigned char *) hostAddress))) - BaseHeaderSize), self);
		if (!(sz == 4)) {
			address = primitiveFail(self);
			goto l1;
		}
		address = ((((((unsigned char *) hostAddress))[3]) + (((usqInt)(((((unsigned char *) hostAddress))[2])) << 8))) + (((usqInt)(((((unsigned char *) hostAddress))[1])) << 16))) + (((usqInt)(((((unsigned char *) hostAddress))[0])) << 24));
	l1:	/* end netAddressToInt: */;
		bytesSent = sqSockettoHostportSendDataBufCount(s, address, portNumber, bufStart, count * byteSize, self);
	}
	if (!(failed(self))) {
		popthenPush(7, integerObjectOf((bytesSent / byteSize), self), self);
	}
	return null;
}


/*	THIS BADLY NEEDS TO BE REWRITTEN TO TAKE Booleans AND Integers AS WELL AS
	(OR INSTEAD OF) Strings.
	It is only used with booleans and integers and parsing these back out of
	strings in

	sqSocketSetOptions:optionNameStart:optionNameSize:optionValueStart:optionValueSize:returnedValue:
	is STUPID. */

	/* SocketPlugin>>#primitiveSocket:setOptions:value: */
EXPORT(sqInt)
primitiveSocketSetOptions(struct foo * self)
{
	sqInt errorCode;
	sqInt optionName;
	sqInt optionNameSize;
	char *optionNameStart;
	sqInt optionValue;
	sqInt optionValueSize;
	char *optionValueStart;
	sqInt results;
	sqInt returnedValue;
	SocketPtr s;
	sqInt socket;

	socket = stackValue(2, self);
	optionName = stackValue(1, self);
	optionValue = stackValue(0, self);
	if (failed(self)) {
		return null;
	}
	/* begin socketValueOf: */
	if ((isBytes(socket, self))
	 && ((byteSizeOf(socket, self)) == (sizeof(SQSocket)))) {
		s = ((SocketPtr) (firstIndexableField(socket, self)));
	}
	else {
		primitiveFailFor(PrimErrBadArgument, self);
		s = null;
	}
	success(isBytes(optionName, self), self);
	optionNameStart = ((char *) (firstIndexableField(optionName, self)));
	optionNameSize = slotSizeOf(optionName, self);
	success(isBytes(optionValue, self), self);
	optionValueStart = ((char *) (firstIndexableField(optionValue, self)));
	optionValueSize = slotSizeOf(optionValue, self);
	if (failed(self)) {
		return null;
	}
	returnedValue = 0;
	errorCode = sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(s, optionNameStart, optionNameSize, optionValueStart, optionValueSize, (&returnedValue), self);
	results = instantiateClassindexableSize(classArray(self), 2, self);
	storePointerofObjectwithValue(0, results, integerObjectOf(errorCode, self), self);
	storePointerofObjectwithValue(1, results, integerObjectOf(returnedValue, self), self);
	if (!(failed(self))) {
		popthenPush(4, results, self);
	}
	return null;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		byteSizeOf = interpreterProxy->byteSizeOf;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isBytes = interpreterProxy->isBytes;
		isIntegerObject = interpreterProxy->isIntegerObject;
		isWords = interpreterProxy->isWords;
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		success = interpreterProxy->success;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* SocketPlugin>>#shutdownModule */
EXPORT(sqInt)
shutdownModule(struct foo * self)
{
	return socketShutdown(self);
}


/*	Return the size of a Smalltalk socket record in bytes. */

	/* SocketPlugin>>#socketRecordSize */
static sqInt
socketRecordSize(struct foo * self)
{
	return sizeof(SQSocket);
}


/*	Answer a pointer to the first byte of of the socket record within the 
	given Smalltalk object, or nil if socketOop is not a socket record. */

	/* SocketPlugin>>#socketValueOf: */
static SocketPtr
socketValueOf(sqInt socketOop, struct foo * self)
{
	return ((isBytes(socketOop, self))
	 && ((byteSizeOf(socketOop, self)) == (sizeof(SQSocket)))
		? ((SocketPtr) (firstIndexableField(socketOop, self)))
		: (primitiveFailFor(PrimErrBadArgument, self),
			null));
}

	/* SmartSyntaxInterpreterPlugin>>#sqAssert: */
static sqInt
sqAssert(sqInt aBool, struct foo * self)
{
	/* missing DebugCode */;
	return aBool;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "SocketPlugin";
void* SocketPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveDisableSocketAccess\000\377", (void*)primitiveDisableSocketAccess},
	{(void*)_m, "primitiveHasSocketAccess\000\377", (void*)primitiveHasSocketAccess},
	{(void*)_m, "primitiveInitializeNetwork\000\000", (void*)primitiveInitializeNetwork},
	{(void*)_m, "primitiveResolverAbortLookup\000\377", (void*)primitiveResolverAbortLookup},
	{(void*)_m, "primitiveResolverAddressLookupResult\000\377", (void*)primitiveResolverAddressLookupResult},
	{(void*)_m, "primitiveResolverError\000\377", (void*)primitiveResolverError},
	{(void*)_m, "primitiveResolverGetAddressInfo\000\000", (void*)primitiveResolverGetAddressInfo},
	{(void*)_m, "primitiveResolverGetAddressInfoFamily\000\377", (void*)primitiveResolverGetAddressInfoFamily},
	{(void*)_m, "primitiveResolverGetAddressInfoNext\000\377", (void*)primitiveResolverGetAddressInfoNext},
	{(void*)_m, "primitiveResolverGetAddressInfoProtocol\000\377", (void*)primitiveResolverGetAddressInfoProtocol},
	{(void*)_m, "primitiveResolverGetAddressInfoResult\000\377", (void*)primitiveResolverGetAddressInfoResult},
	{(void*)_m, "primitiveResolverGetAddressInfoSize\000\377", (void*)primitiveResolverGetAddressInfoSize},
	{(void*)_m, "primitiveResolverGetAddressInfoType\000\377", (void*)primitiveResolverGetAddressInfoType},
	{(void*)_m, "primitiveResolverGetNameInfo\000\000", (void*)primitiveResolverGetNameInfo},
	{(void*)_m, "primitiveResolverGetNameInfoHostResult\000\377", (void*)primitiveResolverGetNameInfoHostResult},
	{(void*)_m, "primitiveResolverGetNameInfoHostSize\000\377", (void*)primitiveResolverGetNameInfoHostSize},
	{(void*)_m, "primitiveResolverGetNameInfoServiceResult\000\377", (void*)primitiveResolverGetNameInfoServiceResult},
	{(void*)_m, "primitiveResolverGetNameInfoServiceSize\000\377", (void*)primitiveResolverGetNameInfoServiceSize},
	{(void*)_m, "primitiveResolverHostNameResult\000\377", (void*)primitiveResolverHostNameResult},
	{(void*)_m, "primitiveResolverHostNameSize\000\377", (void*)primitiveResolverHostNameSize},
	{(void*)_m, "primitiveResolverLocalAddress\000\377", (void*)primitiveResolverLocalAddress},
	{(void*)_m, "primitiveResolverNameLookupResult\000\377", (void*)primitiveResolverNameLookupResult},
	{(void*)_m, "primitiveResolverStartAddressLookup\000\377", (void*)primitiveResolverStartAddressLookup},
	{(void*)_m, "primitiveResolverStartNameLookup\000\377", (void*)primitiveResolverStartNameLookup},
	{(void*)_m, "primitiveResolverStatus\000\377", (void*)primitiveResolverStatus},
	{(void*)_m, "primitiveSocketAbortConnection\000\000", (void*)primitiveSocketAbortConnection},
	{(void*)_m, "primitiveSocketAccept\000\000", (void*)primitiveSocketAccept},
	{(void*)_m, "primitiveSocketAccept3Semaphores\000\000", (void*)primitiveSocketAccept3Semaphores},
	{(void*)_m, "primitiveSocketAddressGetPort\000\000", (void*)primitiveSocketAddressGetPort},
	{(void*)_m, "primitiveSocketAddressSetPort\000\000", (void*)primitiveSocketAddressSetPort},
	{(void*)_m, "primitiveSocketBindTo\000\000", (void*)primitiveSocketBindTo},
	{(void*)_m, "primitiveSocketBindToPort\000\000", (void*)primitiveSocketBindToPort},
	{(void*)_m, "primitiveSocketCloseConnection\000\000", (void*)primitiveSocketCloseConnection},
	{(void*)_m, "primitiveSocketConnectionStatus\000\000", (void*)primitiveSocketConnectionStatus},
	{(void*)_m, "primitiveSocketConnectTo\000\000", (void*)primitiveSocketConnectTo},
	{(void*)_m, "primitiveSocketConnectToPort\000\000", (void*)primitiveSocketConnectToPort},
	{(void*)_m, "primitiveSocketCreate\000\000", (void*)primitiveSocketCreate},
	{(void*)_m, "primitiveSocketCreate3Semaphores\000\000", (void*)primitiveSocketCreate3Semaphores},
	{(void*)_m, "primitiveSocketCreateRAW\000\000", (void*)primitiveSocketCreateRAW},
	{(void*)_m, "primitiveSocketDestroy\000\000", (void*)primitiveSocketDestroy},
	{(void*)_m, "primitiveSocketError\000\000", (void*)primitiveSocketError},
	{(void*)_m, "primitiveSocketGetOptions\000\000", (void*)primitiveSocketGetOptions},
	{(void*)_m, "primitiveSocketListenOnPort\000\000", (void*)primitiveSocketListenOnPort},
	{(void*)_m, "primitiveSocketListenOnPortBacklog\000\000", (void*)primitiveSocketListenOnPortBacklog},
	{(void*)_m, "primitiveSocketListenOnPortBacklogInterface\000\000", (void*)primitiveSocketListenOnPortBacklogInterface},
	{(void*)_m, "primitiveSocketListenWithBacklog\000\000", (void*)primitiveSocketListenWithBacklog},
	{(void*)_m, "primitiveSocketListenWithOrWithoutBacklog\000\000", (void*)primitiveSocketListenWithOrWithoutBacklog},
	{(void*)_m, "primitiveSocketLocalAddress\000\000", (void*)primitiveSocketLocalAddress},
	{(void*)_m, "primitiveSocketLocalAddressResult\000\000", (void*)primitiveSocketLocalAddressResult},
	{(void*)_m, "primitiveSocketLocalAddressSize\000\000", (void*)primitiveSocketLocalAddressSize},
	{(void*)_m, "primitiveSocketLocalPort\000\000", (void*)primitiveSocketLocalPort},
	{(void*)_m, "primitiveSocketReceiveDataAvailable\000\000", (void*)primitiveSocketReceiveDataAvailable},
	{(void*)_m, "primitiveSocketReceiveDataBufCount\000\000", (void*)primitiveSocketReceiveDataBufCount},
	{(void*)_m, "primitiveSocketReceiveUDPDataBufCount\000\000", (void*)primitiveSocketReceiveUDPDataBufCount},
	{(void*)_m, "primitiveSocketRemoteAddress\000\000", (void*)primitiveSocketRemoteAddress},
	{(void*)_m, "primitiveSocketRemoteAddressResult\000\000", (void*)primitiveSocketRemoteAddressResult},
	{(void*)_m, "primitiveSocketRemoteAddressSize\000\000", (void*)primitiveSocketRemoteAddressSize},
	{(void*)_m, "primitiveSocketRemotePort\000\000", (void*)primitiveSocketRemotePort},
	{(void*)_m, "primitiveSocketSendDataBufCount\000\000", (void*)primitiveSocketSendDataBufCount},
	{(void*)_m, "primitiveSocketSendDone\000\000", (void*)primitiveSocketSendDone},
	{(void*)_m, "primitiveSocketSendUDPDataBufCount\000\000", (void*)primitiveSocketSendUDPDataBufCount},
	{(void*)_m, "primitiveSocketSetOptions\000\000", (void*)primitiveSocketSetOptions},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{(void*)_m, "shutdownModule\000\377", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primitiveInitializeNetworkAccessorDepth = 0;
EXPORT(signed char) primitiveResolverGetAddressInfoAccessorDepth = 0;
EXPORT(signed char) primitiveResolverGetNameInfoAccessorDepth = 0;
EXPORT(signed char) primitiveSocketAbortConnectionAccessorDepth = 0;
EXPORT(signed char) primitiveSocketAcceptAccessorDepth = 0;
EXPORT(signed char) primitiveSocketAccept3SemaphoresAccessorDepth = 0;
EXPORT(signed char) primitiveSocketAddressGetPortAccessorDepth = 0;
EXPORT(signed char) primitiveSocketAddressSetPortAccessorDepth = 0;
EXPORT(signed char) primitiveSocketBindToAccessorDepth = 0;
EXPORT(signed char) primitiveSocketBindToPortAccessorDepth = 0;
EXPORT(signed char) primitiveSocketCloseConnectionAccessorDepth = 0;
EXPORT(signed char) primitiveSocketConnectionStatusAccessorDepth = 0;
EXPORT(signed char) primitiveSocketConnectToAccessorDepth = 0;
EXPORT(signed char) primitiveSocketConnectToPortAccessorDepth = 0;
EXPORT(signed char) primitiveSocketCreateAccessorDepth = 0;
EXPORT(signed char) primitiveSocketCreate3SemaphoresAccessorDepth = 0;
EXPORT(signed char) primitiveSocketCreateRAWAccessorDepth = 0;
EXPORT(signed char) primitiveSocketDestroyAccessorDepth = 0;
EXPORT(signed char) primitiveSocketErrorAccessorDepth = 0;
EXPORT(signed char) primitiveSocketGetOptionsAccessorDepth = 0;
EXPORT(signed char) primitiveSocketListenOnPortAccessorDepth = 0;
EXPORT(signed char) primitiveSocketListenOnPortBacklogAccessorDepth = 0;
EXPORT(signed char) primitiveSocketListenOnPortBacklogInterfaceAccessorDepth = 0;
EXPORT(signed char) primitiveSocketListenWithBacklogAccessorDepth = 0;
EXPORT(signed char) primitiveSocketListenWithOrWithoutBacklogAccessorDepth = 0;
EXPORT(signed char) primitiveSocketLocalAddressAccessorDepth = 0;
EXPORT(signed char) primitiveSocketLocalAddressResultAccessorDepth = 0;
EXPORT(signed char) primitiveSocketLocalAddressSizeAccessorDepth = 0;
EXPORT(signed char) primitiveSocketLocalPortAccessorDepth = 0;
EXPORT(signed char) primitiveSocketReceiveDataAvailableAccessorDepth = 0;
EXPORT(signed char) primitiveSocketReceiveDataBufCountAccessorDepth = 0;
EXPORT(signed char) primitiveSocketReceiveUDPDataBufCountAccessorDepth = 0;
EXPORT(signed char) primitiveSocketRemoteAddressAccessorDepth = 0;
EXPORT(signed char) primitiveSocketRemoteAddressResultAccessorDepth = 0;
EXPORT(signed char) primitiveSocketRemoteAddressSizeAccessorDepth = 0;
EXPORT(signed char) primitiveSocketRemotePortAccessorDepth = 0;
EXPORT(signed char) primitiveSocketSendDataBufCountAccessorDepth = 0;
EXPORT(signed char) primitiveSocketSendDoneAccessorDepth = 0;
EXPORT(signed char) primitiveSocketSendUDPDataBufCountAccessorDepth = 0;
EXPORT(signed char) primitiveSocketSetOptionsAccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
