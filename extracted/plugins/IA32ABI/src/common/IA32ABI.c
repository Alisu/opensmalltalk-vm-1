/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
   from
	IA32ABIPlugin VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
 */
static char __buildInfo[] = "IA32ABIPlugin VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <setjmp.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "vmCallback.h"
#include "ia32abi.h"
#include "sqAssert.h"
#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadReceiver 2
#define PrimErrInappropriate 6
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrNotFound 11
#if !defined(STACKVM) /* Allow this to be overridden on the compiler command line */
# define STACKVM 1
#endif

typedef struct {
	int	type;
	int	pad;
	union {
								sqIntptr_t valword;
								struct { int low, high; } valleint64;
								struct { int high, low; } valbeint64;
								double valflt64;
								struct { void *addr; sqIntptr_t size; } valstruct;
							}	crvrvs;
 } VMCallbackReturnValue;



/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
static sqInt indexlengthinRange(sqInt byteIndex, sqInt length, sqInt rcvr, struct foo * self);
EXPORT(sqInt) isAlien(sqInt anOop, struct foo * self);
EXPORT(sqInt) primAddressField(struct foo * self);
EXPORT(sqInt) primAddressFieldPut(struct foo * self);
EXPORT(sqInt) primAlienReplace(struct foo * self);
EXPORT(sqInt) primAllocateExecutablePage(struct foo * self);
EXPORT(sqInt) primBoxedFree(struct foo * self);
EXPORT(sqInt) primCallOutDoubleReturn(struct foo * self);
EXPORT(sqInt) primCallOutFloatReturn(struct foo * self);
EXPORT(sqInt) primCallOutIntegralReturn(struct foo * self);
EXPORT(sqInt) primCalloc(struct foo * self);
EXPORT(sqInt) primDoubleAt(struct foo * self);
EXPORT(sqInt) primDoubleAtPut(struct foo * self);
EXPORT(sqInt) primDrainOSEventQueue(struct foo * self);
EXPORT(sqInt) primFloatAt(struct foo * self);
EXPORT(sqInt) primFloatAtPut(struct foo * self);
EXPORT(sqInt) primFree(struct foo * self);
EXPORT(sqInt) primInIOProcessEventsFlagAddress(struct foo * self);
EXPORT(sqInt) primInLibraryFindSymbol(struct foo * self);
EXPORT(sqInt) primLoadLibrary(struct foo * self);
EXPORT(sqInt) primMalloc(struct foo * self);
EXPORT(sqInt) primReturnAsFromContextThrough(struct foo * self);
EXPORT(sqInt) primReturnFromContextThrough(struct foo * self);
EXPORT(sqInt) primSignedByteAt(struct foo * self);
EXPORT(sqInt) primSignedByteAtPut(struct foo * self);
EXPORT(sqInt) primSignedLongAt(struct foo * self);
EXPORT(sqInt) primSignedLongAtPut(struct foo * self);
EXPORT(sqInt) primSignedLongLongAt(struct foo * self);
EXPORT(sqInt) primSignedLongLongAtPut(struct foo * self);
EXPORT(sqInt) primSignedShortAt(struct foo * self);
EXPORT(sqInt) primSignedShortAtPut(struct foo * self);
EXPORT(sqInt) primSignedWordAt(struct foo * self);
EXPORT(sqInt) primSignedWordAtPut(struct foo * self);
EXPORT(sqInt) primSizeField(struct foo * self);
EXPORT(sqInt) primSizeFieldPut(struct foo * self);
EXPORT(sqInt) primStrlenFromStartIndex(struct foo * self);
EXPORT(sqInt) primStrlenThroughPointerAtIndex(struct foo * self);
EXPORT(sqInt) primThunkEntryAddress(struct foo * self);
EXPORT(sqInt) primUnsignedByteAt(struct foo * self);
EXPORT(sqInt) primUnsignedByteAtPut(struct foo * self);
EXPORT(sqInt) primUnsignedLongAt(struct foo * self);
EXPORT(sqInt) primUnsignedLongAtPut(struct foo * self);
EXPORT(sqInt) primUnsignedLongLongAt(struct foo * self);
EXPORT(sqInt) primUnsignedLongLongAtPut(struct foo * self);
EXPORT(sqInt) primUnsignedShortAt(struct foo * self);
EXPORT(sqInt) primUnsignedShortAtPut(struct foo * self);
EXPORT(sqInt) primUnsignedWordAt(struct foo * self);
EXPORT(sqInt) primUnsignedWordAtPut(struct foo * self);
EXPORT(sqInt) primVarArgsCallOutDoubleReturn(struct foo * self);
EXPORT(sqInt) primVarArgsCallOutFloatReturn(struct foo * self);
EXPORT(sqInt) primVarArgsCallOutIntegralReturn(struct foo * self);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt sizeField(sqInt rcvr);
static sqInt startOfByteData(sqInt rcvr);
static sqInt startOfData(sqInt rcvr);
static sqInt startOfDatawithSize(sqInt rcvr, sqInt sizeField);


/*** Variables ***/
static const int  andOpIndex = 0;

#if defined(SQUEAK_BUILTIN_PLUGIN)

# define isIntegerObject(oop, self) ((oop) & 1)

# if SPURVM
extern sqInt classIndexOf(sqInt, struct foo *);
#	define LargeNegativeIntegerClassIndex 32
#	define LargePositiveIntegerClassIndex 33
#	if BytesPerOop == 4
#	  define isImmediate(oop, self) ((oop) & 3)
#	else
#	  define isImmediate(oop, self) ((oop) & 7)
#	endif
#	define isKindOfInteger(oop, self) (isImmediate(oop, self) ? isIntegerObject(oop, self) : (unsigned)(classIndexOf(oop, self) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeIntegerObject(oop, self) (!isImmediate(oop, self) && (unsigned)(classIndexOf(oop, self) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeNegativeIntegerObject(oop, self) (!isImmediate(oop, self) && classIndexOf(oop, self) == LargeNegativeIntegerClassIndex)
#	define isLargePositiveIntegerObject(oop, self) (!isImmediate(oop, self) && classIndexOf(oop, self) == LargePositiveIntegerClassIndex)
# endif /* SPURVM */
#endif /* defined(SQUEAK_BUILTIN_PLUGIN) */

#if !defined(isKindOfInteger)
# define isLargeNegativeIntegerObject(oop, self) (fetchClassOf(oop, self) == classLargeNegativeInteger(self))
# define isLargePositiveIntegerObject(oop, self) (fetchClassOf(oop, self) == classLargePositiveInteger(self))
# define isLargeIntegerObject(oop, self) (isLargeNegativeIntegerObject(oop, self) || isLargePositiveIntegerObject(oop, self))
# define isKindOfInteger(oop , self) (isIntegerObject(oop, self) || isLargeNegativeIntegerObject(oop, self) || isLargePositiveIntegerObject(oop, self))
#endif

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*byteSizeOf)(sqInt oop, struct foo * self);
static sqInt (*classAlien)(struct foo * self);
static sqInt (*classLargeNegativeInteger)(struct foo * self);
static sqInt (*classLargePositiveInteger)(struct foo * self);
static sqInt (*classSemaphore)(struct foo * self);
static sqInt (*failed)(struct foo * self);
static sqInt (*falseObject)(struct foo * self);
static sqInt (*fetchClassOf)(sqInt oop, struct foo * self);
static void * (*firstIndexableField)(sqInt oop, struct foo * self);
static double (*floatValueOf)(sqInt oop, struct foo * self);
static sqInt * (*getStackPointer)(struct foo * self);
static sqInt (*includesBehaviorThatOf)(sqInt aClass, sqInt aSuperclass, struct foo * self);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size, struct foo * self);
static sqInt (*integerObjectOf)(sqInt value, struct foo * self);
static sqInt (*integerValueOf)(sqInt oop, struct foo * self);
static void * (*ioLoadModuleOfLength)(sqInt moduleNameIndex, sqInt moduleLength);
static void * (*ioLoadSymbolOfLengthFromModule)(sqInt functionNameIndex, sqInt functionLength, sqInt moduleHandle);
static sqInt (*isArray)(sqInt oop, struct foo * self);
static sqInt (*isBytes)(sqInt oop, struct foo * self);
static sqInt (*isInMemory)(sqInt address, struct foo * self);
static sqInt (*isIntegerObject)(sqInt objectPointer, struct foo * self);
static sqInt (*isNonImmediate)(sqInt anObject, struct foo * self);
#if IMMUTABILITY
static sqInt (*isOopImmutable)(sqInt oop, struct foo * self);
#endif /* IMMUTABILITY */
static sqInt (*isWordsOrBytes)(sqInt oop, struct foo * self);
static sqInt (*methodArgumentCount)(struct foo * self);
static sqInt (*methodReturnValue)(sqInt oop, struct foo * self);
static sqInt (*pop)(sqInt nItems, struct foo * self);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop, struct foo * self);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue, struct foo * self);
static usqInt (*positive32BitValueOf)(sqInt oop, struct foo * self);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue, struct foo * self);
static usqLong (*positive64BitValueOf)(sqInt oop, struct foo * self);
static usqIntptr_t (*positiveMachineIntegerValueOf)(sqInt oop, struct foo * self);
static sqInt (*primitiveFailFor)(sqInt reasonCode, struct foo * self);
static sqInt (*pushFloat)(double f, struct foo * self);
static sqInt (*returnAsThroughCallbackContext)(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext, struct foo * self);
static sqInt (*signalNoResume)(sqInt aSemaphore, struct foo * self);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue, struct foo * self);
static int (*signed32BitValueOf)(sqInt oop, struct foo * self);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue, struct foo * self);
static sqLong (*signed64BitValueOf)(sqInt oop, struct foo * self);
static sqIntptr_t (*signedMachineIntegerValueOf)(sqInt oop, struct foo * self);
static sqInt (*stSizeOf)(sqInt oop, struct foo * self);
static sqInt (*stackIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackObjectValue)(sqInt offset, struct foo * self);
static usqIntptr_t (*stackPositiveMachineIntegerValue)(sqInt offset, struct foo * self);
static sqInt (*stackValue)(sqInt offset, struct foo * self);
static sqInt (*trueObject)(struct foo * self);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt byteSizeOf(sqInt oop, struct foo * self);
extern sqInt classAlien(struct foo * self);
extern sqInt classLargeNegativeInteger(struct foo * self);
extern sqInt classLargePositiveInteger(struct foo * self);
extern sqInt classSemaphore(struct foo * self);
extern sqInt failed(struct foo * self);
extern sqInt falseObject(struct foo * self);
extern sqInt fetchClassOf(sqInt oop, struct foo * self);
extern void * firstIndexableField(sqInt oop, struct foo * self);
extern double floatValueOf(sqInt oop, struct foo * self);
extern sqInt * getStackPointer(struct foo * self);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass, struct foo * self);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size, struct foo * self);
extern sqInt integerObjectOf(sqInt value, struct foo * self);
extern sqInt integerValueOf(sqInt oop, struct foo * self);
extern void * ioLoadModuleOfLength(sqInt moduleNameIndex, sqInt moduleLength);
extern void * ioLoadSymbolOfLengthFromModule(sqInt functionNameIndex, sqInt functionLength, sqInt moduleHandle);
extern sqInt isArray(sqInt oop, struct foo * self);
extern sqInt isBytes(sqInt oop, struct foo * self);
extern sqInt isInMemory(sqInt address, struct foo * self);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer, struct foo * self);
#endif
extern sqInt isNonImmediate(sqInt anObject, struct foo * self);
#if IMMUTABILITY
#if IMMUTABILITY
extern sqInt isOopImmutable(sqInt oop, struct foo * self);
#endif /* IMMUTABILITY */
#else
# define isOopImmutable(oop) 0
#endif
extern sqInt isWordsOrBytes(sqInt oop, struct foo * self);
extern sqInt methodArgumentCount(struct foo * self);
extern sqInt methodReturnValue(sqInt oop, struct foo * self);
extern sqInt pop(sqInt nItems, struct foo * self);
extern sqInt popthenPush(sqInt nItems, sqInt oop, struct foo * self);
extern sqInt positive32BitIntegerFor(unsigned int integerValue, struct foo * self);
extern usqInt positive32BitValueOf(sqInt oop, struct foo * self);
extern sqInt positive64BitIntegerFor(usqLong integerValue, struct foo * self);
extern usqLong positive64BitValueOf(sqInt oop, struct foo * self);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop, struct foo * self);
extern sqInt primitiveFailFor(sqInt reasonCode, struct foo * self);
extern sqInt pushFloat(double f, struct foo * self);
extern sqInt returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext, struct foo * self);
extern sqInt signalNoResume(sqInt aSemaphore, struct foo * self);
extern sqInt signed32BitIntegerFor(sqInt integerValue, struct foo * self);
extern int signed32BitValueOf(sqInt oop, struct foo * self);
extern sqInt signed64BitIntegerFor(sqLong integerValue, struct foo * self);
extern sqLong signed64BitValueOf(sqInt oop, struct foo * self);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop, struct foo * self);
extern sqInt stSizeOf(sqInt oop, struct foo * self);
extern sqInt stackIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackObjectValue(sqInt offset, struct foo * self);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset, struct foo * self);
extern sqInt stackValue(sqInt offset, struct foo * self);
extern sqInt trueObject(struct foo * self);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"IA32ABI VMMaker.oscog-eem.2480 (i)"
#else
	"IA32ABI VMMaker.oscog-eem.2480 (e)"
#endif
;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}


/*	Answer if the indices byteIndex to byteIndex + length - 1 are valid
	zero-relative indices into the rcvr.
	Beware! There be dragons here. The form below (byteIndex <= (dataSize abs
	- length)) is used
	because byteIndex + length could overflow, whereas (dataSize abs - length)
	can't. We *don't* use the
	obvious optimization
	^dataSize = 0 or: [byteIndex asUnsignedInteger <= (dataSize abs - length)]
	because with C's Usual Arithmetic Conversions
	5. Otherwise, both operands are converted to the unsigned integer type
	corresponding to the type of the operand with signed integer type.
	means that the comparison will be unsigned, and if length > dataSize abs
	then dataSize abs - length is large and positive. */

	/* IA32ABIPlugin>>#index:length:inRange: */
static sqInt
indexlengthinRange(sqInt byteIndex, sqInt length, sqInt rcvr, struct foo * self)
{
    sqInt dataSize;

	dataSize = longAt(rcvr + BaseHeaderSize);
	return (dataSize == 0)
	 || ((byteIndex >= 0)
	 && (byteIndex <= ((SQABS(dataSize)) - length)));
}

	/* IA32ABIPlugin>>#isAlien: */
EXPORT(sqInt)
isAlien(sqInt anOop, struct foo * self)
{
	return includesBehaviorThatOf(fetchClassOf(anOop, self), classAlien(self), self);
}


/*	Answer the unsigned 32-bit (or 64-bit) integer comprising the address
	field (the second 32-bit or 64-bit field).
 */
/*	<Alien> primAddressField ^<Integer>
	<primitive: 'primAddressField' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primAddressField */
EXPORT(sqInt)
primAddressField(struct foo * self)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	rcvr = stackValue(0, self);
	value = longAt((rcvr + BaseHeaderSize) + BytesPerOop);
	/* begin positiveMachineIntegerFor: */
	valueOop = (BytesPerWord == 8
		? positive64BitIntegerFor(value, self)
		: positive32BitIntegerFor(value, self));
	return methodReturnValue(valueOop, self);
}


/*	Store an unsigned integer into the size field (the second 32/64 bit field;
	little endian).
 */
/*	<Alien> addressFieldPut: value <Integer> ^<Integer>
	<primitive: 'primAddressFieldPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primAddressFieldPut */
EXPORT(sqInt)
primAddressFieldPut(struct foo * self)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	rcvr = stackValue(1, self);
	value = positiveMachineIntegerValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	longAtput((rcvr + BaseHeaderSize) + BytesPerOop, value);
	return methodReturnValue(valueOop, self);
}


/*	Copy some number of bytes from some source object starting at the index
	into the receiver destination object from startIndex to stopIndex. The
	source and destination may be Aliens or byte-indexable objects. The
	primitive wll have
	either of the following signatures:
	<Alien | indexableByteSubclass | indexableWordSubclass>
	primReplaceFrom: start <Integer>
	to: stop <Integer>
	with: replacement <Alien | indexableByteSubclass | indexableWordSubclass |
	Integer> startingAt: repStart <Integer> ^<self>
	<primitive: 'primitiveAlienReplace' error: errorCode module: 'IA32ABI'>
	<Anywhere>
	primReplaceIn: dest <Alien | indexableByteSubclass |
	indexableWordSubclass> from: start <Integer>
	to: stop <Integer>
	with: replacement <Alien | indexableByteSubclass | indexableWordSubclass |
	Integer> startingAt: repStart <Integer> ^<self>
	<primitive: 'primitiveAlienReplace' error: errorCode module: 'IA32ABI'>
	 */

	/* IA32ABIPlugin>>#primAlienReplace */
EXPORT(sqInt)
primAlienReplace(struct foo * self)
{
    sqInt array;
    sqInt count;
    sqInt dest;
    sqInt repl;
    sqInt replStart;
    sqInt src;
    sqInt start;
    sqInt stop;
    sqInt totalLength;

	array = stackValue(4, self);
	start = stackIntegerValue(3, self);
	stop = stackIntegerValue(2, self);
	repl = stackValue(1, self);
	replStart = stackIntegerValue(0, self);
	if ((failed(self))
	 || (!(isWordsOrBytes(array, self)))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (includesBehaviorThatOf(fetchClassOf(array, self), classAlien(self), self)) {
		totalLength = longAt(array + BaseHeaderSize);
		dest = (((totalLength > 0
	? (array + BaseHeaderSize) + BytesPerOop
	: longAt((array + BaseHeaderSize) + BytesPerOop))) + start) - 1;
		if (totalLength == 0) {

			/* no bounds checks for zero-sized (pointer) Aliens */
			totalLength = stop;
		}
		else {
			totalLength = SQABS(totalLength);
		}
	}
	else {
		totalLength = byteSizeOf(array, self);
		dest = ((array + BaseHeaderSize) + start) - 1;
	}
	if (!((start >= 1)
		 && (((start - 1) <= stop)
		 && (stop <= totalLength)))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isKindOfInteger(repl, self)) {
		src = ((positiveMachineIntegerValueOf(repl, self)) + replStart) - 1;
		if (failed(self)) {
			return primitiveFailFor(PrimErrBadArgument, self);
		}
	}
	else {
		if (includesBehaviorThatOf(fetchClassOf(repl, self), classAlien(self), self)) {
			totalLength = longAt(repl + BaseHeaderSize);
			src = (((totalLength > 0
	? (repl + BaseHeaderSize) + BytesPerOop
	: longAt((repl + BaseHeaderSize) + BytesPerOop))) + replStart) - 1;
			if (totalLength == 0) {

				/* no bounds checks for zero-sized (pointer) Aliens */
				totalLength = (stop - start) + replStart;
			}
			else {
				totalLength = SQABS(totalLength);
			}
		}
		else {
			if (!(isWordsOrBytes(repl, self))) {
				return primitiveFailFor(PrimErrBadArgument, self);
			}
			totalLength = byteSizeOf(repl, self);
			src = ((repl + BaseHeaderSize) + replStart) - 1;
		}
		if (!((replStart >= 1)
			 && (((stop - start) + replStart) <= totalLength))) {
			return primitiveFailFor(PrimErrBadIndex, self);
		}
	}
	if (isOopImmutable(array, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	count = (stop - start) + 1;
	memmove(((void *)dest), ((void *)src), count);
	pop(methodArgumentCount(self), self);
	return 0;
}


/*	Answer an Alien for an executable page; for thunks */
/*	primAllocateExecutablePage ^<Alien>
	<primitive: 'primAllocateExecutablePage' error: errorCode module:
	'IA32ABI'> 
 */

	/* IA32ABIPlugin>>#primAllocateExecutablePage */
EXPORT(sqInt)
primAllocateExecutablePage(struct foo * self)
{
    sqInt alien;
    sqIntptr_t byteSize;
    void *mem;
    sqIntptr_t *ptr;

	mem = allocateExecutablePage(&byteSize);
	if (mem == 0) {
		return primitiveFailFor(PrimErrNoCMemory, self);
	}
	alien = instantiateClassindexableSize(classAlien(self), 2 * BytesPerOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrNoMemory, self);
	}
	ptr = firstIndexableField(alien, self);
	ptr[0] = (0 - byteSize);
	ptr[1] = (((sqIntptr_t) mem));
	methodReturnValue(alien, self);
	return 0;
}


/*	Free the memory referenced by the receiver, an Alien. */
/*	proxy <Alien> primFree ^<Alien>
	<primitive: 'primBoxedFree' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primBoxedFree */
EXPORT(sqInt)
primBoxedFree(struct foo * self)
{
    sqIntptr_t addr;
    sqIntptr_t *ptr;
    sqInt rcvr;
    sqIntptr_t sizeField;

	rcvr = stackValue(0, self);
	if (!((byteSizeOf(rcvr, self)) >= (2 * BytesPerOop))) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	ptr = firstIndexableField(rcvr, self);
	sizeField = ptr[0];

	/* Don't you dare to free Squeak's memory! */
	addr = ptr[1];
	if ((sizeField >= 0)
	 || ((addr == 0)
	 || (isInMemory(addr, self)))) {
		return primitiveFailFor(PrimErrInappropriate, self);
	}
	free((void *)addr);
	ptr[0] = 0;
	ptr[1] = 0;
	return 0;
}


/*	Call a foreign function that answers a double-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutDoubleReturn' error: errorCode module: 'IA32ABI'>.
	Answer result. If result is an Alien the value answered by the call will
	be assigned to result.
 */

	/* IA32ABIPlugin>>#primCallOutDoubleReturn */
EXPORT(sqInt)
primCallOutDoubleReturn(struct foo * self)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = methodArgumentCount(self);
	
#  if STACKVM

	/* In the STACKVM stacks grow down */

	/* ptr to 0th arg */
	/* nargs negated to imply stack direction */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32DoubleReturn(((getStackPointer(self)) + mac) - 2, 1 - mac, mac, mac - 1, self);
#  else /* STACKVM */

	/* ptr to 0th arg */
	/* nargs */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32DoubleReturn(((getStackPointer(self)) - mac) + 2, mac - 1, mac, mac - 1, self);
#  endif /* STACKVM */
	if (errCode != 0) {
		return primitiveFailFor(errCode, self);
	}
	result = stackValue(mac - 1, self);
	popthenPush(mac + 1, result, self);
	return 0;
}


/*	Call a foreign function that answers a single-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutFloatReturn' error: errorCode module: 'IA32ABI'>.
	Answer result. If result is an Alien the value answered by the call will
	be assigned to result.
 */

	/* IA32ABIPlugin>>#primCallOutFloatReturn */
EXPORT(sqInt)
primCallOutFloatReturn(struct foo * self)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = methodArgumentCount(self);
	
#  if STACKVM

	/* In the STACKVM stacks grow down */

	/* ptr to 0th arg */
	/* nargs negated to imply stack direction */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32FloatReturn(((getStackPointer(self)) + mac) - 2, 1 - mac, mac, mac - 1, self);
#  else /* STACKVM */

	/* ptr to 0th arg */
	/* nargs */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32FloatReturn(((getStackPointer(self)) - mac) + 2, mac - 1, mac, mac - 1, self);
#  endif /* STACKVM */
	if (errCode != 0) {
		return primitiveFailFor(errCode, self);
	}
	result = stackValue(mac - 1, self);
	popthenPush(mac + 1, result, self);
	return 0;
}


/*	Call a foreign function that answers an integral result in %eax (and
	possibly %edx)
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutIntegralReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primCallOutIntegralReturn */
EXPORT(sqInt)
primCallOutIntegralReturn(struct foo * self)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = methodArgumentCount(self);
	
#  if STACKVM

	/* In the STACKVM stacks grow down */

	/* ptr to 0th arg */
	/* nargs negated to imply stack direction */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32IntegralReturn(((getStackPointer(self)) + mac) - 2, 1 - mac, mac, mac - 1, self);
#  else /* STACKVM */

	/* ptr to 0th arg */
	/* nargs */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32IntegralReturn(((getStackPointer(self)) - mac) + 2, mac - 1, mac, mac - 1, self);
#  endif /* STACKVM */
	if (errCode != 0) {
		return primitiveFailFor(errCode, self);
	}
	result = stackValue(mac - 1, self);
	popthenPush(mac + 1, result, self);
	return 0;
}


/*	calloc (malloc + zero-fill) arg bytes. */
/*	primCalloc: byteSize <Integer> ^<Integer>
	<primitive: 'primCalloc' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primCalloc */
EXPORT(sqInt)
primCalloc(struct foo * self)
{
    usqInt addr;
    sqInt byteSize;

	byteSize = stackIntegerValue(0, self);
	if ((failed(self))
	 || (byteSize <= 0)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	addr = ((usqInt)(calloc(1, byteSize)));
	if (addr == 0) {
		return primitiveFailFor(PrimErrNoCMemory, self);
	}
	methodReturnValue((BytesPerWord == 8
		? positive64BitIntegerFor(addr, self)
		: positive32BitIntegerFor(addr, self)), self);
	return 0;
}


/*	Answer the 64-bit double starting at the given byte offset (little
	endian). 
 */
/*	<Alien> doubleAt: index <Integer> ^<Float>
	<primitive: 'primDoubleAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primDoubleAt */
EXPORT(sqInt)
primDoubleAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    double floatValue;
    sqInt rcvr;
    sqInt startAddr;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	memcpy((&floatValue), addr, sizeof(floatValue));
	pop(2, self);
	return pushFloat(floatValue, self);
}


/*	Store a double into 64 bits starting at the given byte offset (little
	endian). 
 */
/*	<Alien> doubleAt: index <Integer> put: value <Float | Integer> ^<Float |
	Integer> <primitive: 'primDoubleAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primDoubleAtPut */
EXPORT(sqInt)
primDoubleAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    double floatValue;
    sqInt rcvr;
    sqInt startAddr;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	if (isIntegerObject(valueOop, self)) {
		floatValue = ((double) (integerValueOf(valueOop, self)));
	}
	else {
		floatValue = ((double) (floatValueOf(valueOop, self)));
	}
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	memcpy(addr, (&floatValue), sizeof(floatValue));
	methodReturnValue(valueOop, self);
	return 0;
}

	/* IA32ABIPlugin>>#primDrainOSEventQueue */
EXPORT(sqInt)
primDrainOSEventQueue(struct foo * self)
{
	
#  if NewspeakVM
	ioDrainEventQueue();
#  endif /* NewspeakVM */
	return 0;
}


/*	Answer the 32-bit float starting at the given byte offset (little endian). */
/*	<Alien> floatAt: index <Integer> ^<Float>
	<primitive: 'primFloatAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primFloatAt */
EXPORT(sqInt)
primFloatAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    float floatValue;
    sqInt rcvr;
    sqInt startAddr;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	memcpy((&floatValue), addr, sizeof(floatValue));
	pop(2, self);
	return pushFloat(floatValue, self);
}


/*	Store a float into 32 bits starting at the given byte offset (little
	endian). 
 */
/*	<Alien> floatAt: index <Integer> put: value <Float | Integer> ^<Float |
	Integer> <primitive: 'primFloatAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primFloatAtPut */
EXPORT(sqInt)
primFloatAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    float floatValue;
    sqInt rcvr;
    sqInt startAddr;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	if (isIntegerObject(valueOop, self)) {
		floatValue = ((double) (integerValueOf(valueOop, self)));
	}
	else {
		floatValue = ((double) (floatValueOf(valueOop, self)));
	}
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	memcpy(addr, (&floatValue), sizeof(floatValue));
	methodReturnValue(valueOop, self);
	return 0;
}


/*	Free the memory referenced by the argument, an integer. */
/*	<Anywhere> primFree: address <Integer>
	<primitive: 'primFree' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primFree */
EXPORT(sqInt)
primFree(struct foo * self)
{
    sqInt addr;

	addr = stackPositiveMachineIntegerValue(0, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if ((addr == 0)
	 || (isInMemory(addr, self))) {
		return primitiveFailFor(PrimErrInappropriate, self);
	}
	free((void *)addr);
	pop(1, self);
	return 0;
}


/*	Answer the address of the int inIOProcessEvents flag. This can be used to
	disable invocation of ioProcessEvents and is for backward-compatibility.
	Please use the core VM primitiveEventProcessingControl in new code. */

	/* IA32ABIPlugin>>#primInIOProcessEventsFlagAddress */
EXPORT(sqInt)
primInIOProcessEventsFlagAddress(struct foo * self)
{
    extern int inIOProcessEvents;

	methodReturnValue((BytesPerWord == 8
		? positive64BitIntegerFor(((usqInt)((&inIOProcessEvents))), self)
		: positive32BitIntegerFor(((usqInt)((&inIOProcessEvents))), self)), self);
	return 0;
}


/*	Attempt to find the address of a symbol in a loaded library.
	The primitive can have a signature either of the form:
	<Anywhere> primInLibrary: libraryHandle <Alien> findSymbol: symbolName
	<String> ^<Integer>
	<primitive: 'primInLibraryFindSymbol' error: errorCode module: 'IA32ABI'>
	or:
	libraryHandle <Alien> primFindSymbol: symbolName <String> ^<Integer>
	<primitive: 'primInLibraryFindSymbol' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primInLibraryFindSymbol */
EXPORT(sqInt)
primInLibraryFindSymbol(struct foo * self)
{
    void *address;
    sqInt functionName;
    sqInt libraryProxy;

	functionName = stackValue(0, self);
	libraryProxy = stackValue(1, self);
	if (!((includesBehaviorThatOf(fetchClassOf(libraryProxy, self), classAlien(self), self))
		 && (((byteSizeOf(libraryProxy, self)) >= (2 * BytesPerOop))
		 && (isBytes(functionName, self))))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	address = ioLoadSymbolOfLengthFromModule(((sqInt) (firstIndexableField(functionName, self))), byteSizeOf(functionName, self), longAt((libraryProxy + BaseHeaderSize) + BytesPerOop));
	if ((failed(self))
	 || (address == 0)) {
		return primitiveFailFor(PrimErrNotFound, self);
	}
	methodReturnValue((BytesPerWord == 8
		? positive64BitIntegerFor(((usqInt)address), self)
		: positive32BitIntegerFor(((usqInt)address), self)), self);
	return 0;
}


/*	Attempt to load a library of the given name. The primitive will have a
	signature of the form:
	<Anywhere> primLoadLibrary: libraryName <String> ^<Integer>
	<primitive: 'primLoadLibrary' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primLoadLibrary */
EXPORT(sqInt)
primLoadLibrary(struct foo * self)
{
    void *libraryHandle;
    sqInt libraryName;

	libraryName = stackValue(0, self);
	if (!(isBytes(libraryName, self))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	libraryHandle = ioLoadModuleOfLength(((sqInt) (firstIndexableField(libraryName, self))), byteSizeOf(libraryName, self));
	if (libraryHandle == 0) {
		return primitiveFailFor(PrimErrNotFound, self);
	}
	methodReturnValue((BytesPerWord == 8
		? positive64BitIntegerFor(((usqInt)libraryHandle), self)
		: positive32BitIntegerFor(((usqInt)libraryHandle), self)), self);
	return 0;
}


/*	Malloc arg bytes. */
/*	primMalloc: byteSize <Integer> <^Integer>
	<primitive: 'primMalloc' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primMalloc */
EXPORT(sqInt)
primMalloc(struct foo * self)
{
    usqInt addr;
    sqInt byteSize;

	byteSize = stackIntegerValue(0, self);
	if ((failed(self))
	 || (byteSize <= 0)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	addr = ((usqInt)(malloc(byteSize)));
	if (addr == 0) {
		return primitiveFailFor(PrimErrNoCMemory, self);
	}
	methodReturnValue((BytesPerWord == 8
		? positive64BitIntegerFor(addr, self)
		: positive32BitIntegerFor(addr, self)), self);
	return 0;
}


/*	Return a result from a callback to the callback's callee. The primitive
	has a signature of either of the forms:
	result <VMCallbackContext32/64>
	primReturnAs: returnTypeCode <Integer>
	FromContext: callbackContext <Context>
	result <VMCallbackContext32/64>
	primSignal: aSemaphore <Semaphore>
	andReturnAs: returnTypeCode <Integer>
	FromContext: callbackContext <Context>
	<primitive: 'primReturnAsFromContextThrough' error: errorCode module:
	'IA32ABI'>. If of the second form answer false if this is not the most
	recent callback, and signal aSemaphore
	if it is, so as to implement LIFO ordering of callbacks. */

	/* IA32ABIPlugin>>#primReturnAsFromContextThrough */
EXPORT(sqInt)
primReturnAsFromContextThrough(struct foo * self)
{
    int isMostRecent;
    VMCallbackContext *vmCallbackContext;

	if ((methodArgumentCount(self)) == 3) {
		assert(isNonImmediate(stackValue(3, self), self));
		assert((fetchClassOf(stackValue(2, self), self)) == (classSemaphore(self)));
		assert(isIntegerObject(stackValue(1, self), self));
		assert(isNonImmediate(stackValue(0, self), self));
		vmCallbackContext = ((VMCallbackContext *) (startOfData(stackValue(3, self))));
		isMostRecent = vmCallbackContext == (getMostRecentCallbackContext(self));
		if (!isMostRecent) {
			return methodReturnValue(falseObject(self), self);
		}
		if (!((fetchClassOf(stackValue(2, self), self)) == (classSemaphore(self)))) {
			return primitiveFailFor(PrimErrBadArgument, self);
		}
		while (!(signalNoResume(stackValue(2, self), self))) {
		}
	}
	else {
		assert((methodArgumentCount(self)) == 2);
		assert(isNonImmediate(stackValue(2, self), self));
		assert(isIntegerObject(stackValue(1, self), self));
		assert(isNonImmediate(stackValue(0, self), self));
		vmCallbackContext = ((VMCallbackContext *) (startOfData(stackValue(2, self))));
	}
	if (!(returnAsThroughCallbackContext(stackValue(1, self), vmCallbackContext, stackValue(0, self), self))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	return 0;
}


/*	Return a result from a callback to the callback's callee. The primitive
	has a signature of either of the forms:
	result <FFICallbackResult> primReturnFromContext: callbackContext
	<MethodContext> through: jmpBuf <Integer>
	result <FFICallbackResult> primSignal: aSemaphore <Semaphore>
	andReturnFromContext: callbackContext <MethodContext> through: jmpBuf
	<Integer> <primitive: 'primReturnFromContextThrough' error: errorCode
	module: 'IA32ABI'>.
	If of the second form answer true if this is not the most recent callback,
	and signal aSemaphore
	if it is, so as to implement LIFO ordering of callbacks. */

	/* IA32ABIPlugin>>#primReturnFromContextThrough */
EXPORT(sqInt)
primReturnFromContextThrough(struct foo * self)
{
    int isMostRecent;
    sqInt mac;
    VMCallbackContext *vmCallbackContext;
    VMCallbackReturnValue *vmCallbackReturnValue;

	vmCallbackContext = ((VMCallbackContext *) (positiveMachineIntegerValueOf(stackValue(0, self), self)));
	if ((failed(self))
	 || (vmCallbackContext == 0)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (((mac = methodArgumentCount(self))) == 3) {
		isMostRecent = vmCallbackContext == (getMostRecentCallbackContext(self));
		if (!isMostRecent) {
			methodReturnValue(trueObject(self), self);
			return null;
		}
		if (!((fetchClassOf(stackValue(2, self), self)) == (classSemaphore(self)))) {
			return primitiveFailFor(PrimErrBadArgument, self);
		}
		while (!(signalNoResume(stackValue(2, self), self))) {
		}
	}
	vmCallbackReturnValue = ((VMCallbackReturnValue *) (startOfData(stackValue(mac, self))));
	memcpy((&((vmCallbackContext->rvs))), (&((vmCallbackReturnValue->crvrvs))), sizeof((vmCallbackContext->rvs)));
	if (!(returnAsThroughCallbackContext(integerObjectOf(((vmCallbackReturnValue->type)) + 1, self), vmCallbackContext, stackValue(1, self), self))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	return 0;
}


/*	Answer the signed 8-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> unsignedByteAt: index <Integer> ^<Integer>
	<primitive: 'primSignedByteAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedByteAt */
EXPORT(sqInt)
primSignedByteAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    signed char value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = byteAt(addr);
	valueOop = signed32BitIntegerFor(value, self);
	return methodReturnValue(valueOop, self);
}


/*	Store a signed integer into 8 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedByteAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedByteAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedByteAtPut */
EXPORT(sqInt)
primSignedByteAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = signed32BitValueOf(valueOop, self);
	if ((failed(self))
	 || ((value < -128)
	 || (value > 0x7F))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	byteAtput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Answer the signed 32-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedLongAt: index <Integer> ^<Integer>
	<primitive: 'primSignedLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongAt */
EXPORT(sqInt)
primSignedLongAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    int value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = long32At(addr);
	valueOop = signed32BitIntegerFor(value, self);
	return methodReturnValue(valueOop, self);
}


/*	Store a signed integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedLongAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongAtPut */
EXPORT(sqInt)
primSignedLongAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = signed32BitValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	long32Atput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Answer the signed 64-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedLongLongAt: index <Integer> ^<Integer>
	<primitive: 'primSignedLongLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongLongAt */
EXPORT(sqInt)
primSignedLongLongAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    long long signedlonglongvalue;
    long long *signedlonglongvaluePtr;
    sqInt startAddr;
    sqInt valueOop;

	signedlonglongvaluePtr = 0;
	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	signedlonglongvaluePtr = ((long long*) addr);
	signedlonglongvalue = *signedlonglongvaluePtr;
	valueOop = signed64BitIntegerFor(signedlonglongvalue, self);
	return methodReturnValue(valueOop, self);
}


/*	Store a signed integer into 64 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedLongLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedLongLongAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongLongAtPut */
EXPORT(sqInt)
primSignedLongLongAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    long long signedlonglongvalue;
    long long *signedlonglongvaluePtr;
    sqInt startAddr;
    sqInt valueOop;

	signedlonglongvaluePtr = 0;
	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	signedlonglongvalue = signed64BitValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	signedlonglongvaluePtr = ((long long*) addr);
	*signedlonglongvaluePtr = signedlonglongvalue;
	return methodReturnValue(valueOop, self);
}


/*	Answer the signed 32-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedShortAt: index <Integer> ^<Integer>
	<primitive: 'primSignedShortAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedShortAt */
EXPORT(sqInt)
primSignedShortAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    short value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = shortAt(addr);
	valueOop = signed32BitIntegerFor(value, self);
	return methodReturnValue(valueOop, self);
}


/*	Store a signed integer into 16 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedShortAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedShortAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedShortAtPut */
EXPORT(sqInt)
primSignedShortAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = signed32BitValueOf(valueOop, self);
	if ((failed(self))
	 || ((value < -32768)
	 || (value > 0x7FFF))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	shortAtput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Answer the signed word starting at the given byte offset (little endian). */
/*	<Alien> signedWordAt: index <Integer> ^<Integer>
	<primitive: 'primSignedWordAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedWordAt */
EXPORT(sqInt)
primSignedWordAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = longAt(addr);
	valueOop = signedMachineIntegerValueOf(value, self);
	return methodReturnValue(valueOop, self);
}


/*	Store a signed integer into the word starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedWordAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedWordAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedWordAtPut */
EXPORT(sqInt)
primSignedWordAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = signedMachineIntegerValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	longAtput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Answer the signed 32- or 64-bit integer comprising the size field (the
	first 32- or 64-bit field).
 */
/*	<Alien> primSizeField ^<Integer>
	<primitive: 'primSizeField' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSizeField */
EXPORT(sqInt)
primSizeField(struct foo * self)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	rcvr = stackValue(0, self);
	value = 
#  if BytesPerOop == 8
		((sqLong) (longAt(rcvr + BaseHeaderSize)))
#  else /* BytesPerOop == 8 */
		((int) (longAt(rcvr + BaseHeaderSize)))
#  endif /* BytesPerOop == 8 */
		;
	valueOop = (BytesPerWord == 8
		? signed64BitIntegerFor(value, self)
		: signed32BitIntegerFor(value, self));
	return methodReturnValue(valueOop, self);
}


/*	Store a signed integer into the size field (the first 32 bit field; little
	endian). 
 */
/*	<Alien> sizeFieldPut: value <Integer> ^<Integer>
	<primitive: 'primSizeFieldPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSizeFieldPut */
EXPORT(sqInt)
primSizeFieldPut(struct foo * self)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	rcvr = stackValue(1, self);
	value = signedMachineIntegerValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	
#  if BytesPerOop == 8
	longAtput(rcvr + BaseHeaderSize, ((usqInt) value));
#  else /* BytesPerOop == 8 */
	longAtput(rcvr + BaseHeaderSize, ((usqInt) value));
#  endif /* BytesPerOop == 8 */
	return methodReturnValue(valueOop, self);
}


/*	Answer the number of non-null bytes starting at index. If
	there isn't a null byte before the end of the object then the
	result will be the number of bytes from index to the end of
	the object, i.e. the result will be within the bounds of the object. */
/*	<Alien> primStrlenFrom: index <Integer> ^<Integer>
	<primitive: 'primStrlenFromStartIndex' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primStrlenFromStartIndex */
EXPORT(sqInt)
primStrlenFromStartIndex(struct foo * self)
{
    sqInt byteOffset;
    sqInt index;
    sqInt limit;
    char *ptr;
    sqInt rcvr;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	limit = longAt(rcvr + BaseHeaderSize);
	ptr = ((char *) (((limit > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset));
	if (limit == 0) {
		index = strlen(ptr);
	}
	else {
		limit = SQABS(limit);
		index = 0;
		while ((index < limit)
		 && ((ptr[index]) != 0)) {
			index += 1;
		}
	}
	return methodReturnValue(positive32BitIntegerFor(index, self), self);
}


/*	Answer the number of non-null bytes starting at the byte addressed by
	the 4-byte pointer at index. */
/*	<Alien> strlenThroughPointerAt: index <Integer> ^<Integer>
	<primitive: 'primStrlenThroughPointerAtIndex' error: errorCode module:
	'IA32ABI'> 
 */

	/* IA32ABIPlugin>>#primStrlenThroughPointerAtIndex */
EXPORT(sqInt)
primStrlenThroughPointerAtIndex(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    char *ptr;
    sqInt rcvr;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	ptr = ((char *) (longAt(addr)));
	return methodReturnValue(positive32BitIntegerFor(strlen(ptr), self), self);
}


/*	Answer the address of the entry-point for thunk callbacks:
	long thunkEntry(void *thunkp, long *stackp);
	This could be derived via loadModule: findSymbol: etc but that would
	preclude making the plugin internal. */

	/* IA32ABIPlugin>>#primThunkEntryAddress */
EXPORT(sqInt)
primThunkEntryAddress(struct foo * self)
{
    sqIntptr_t address;

	address = ((sqIntptr_t)thunkEntry);
	methodReturnValue((BytesPerWord == 8
		? positive64BitIntegerFor(address, self)
		: positive32BitIntegerFor(address, self)), self);
	return 0;
}


/*	Answer the unsigned 8-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedByteAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedByteAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedByteAt */
EXPORT(sqInt)
primUnsignedByteAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    unsigned char value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = byteAt(addr);
	valueOop = positive32BitIntegerFor(value, self);
	return methodReturnValue(valueOop, self);
}


/*	Store an unsigned integer into 8 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedByteAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedByteAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedByteAtPut */
EXPORT(sqInt)
primUnsignedByteAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = positive32BitValueOf(valueOop, self);
	if ((failed(self))
	 || (value > 0xFF)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	byteAtput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Answer the unsigned 32-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongAt */
EXPORT(sqInt)
primUnsignedLongAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    int value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = long32At(addr);
	valueOop = positive32BitIntegerFor(value, self);
	return methodReturnValue(valueOop, self);
}


/*	Store an unsigned integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedLongAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongAtPut */
EXPORT(sqInt)
primUnsignedLongAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = positive32BitValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	long32Atput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Answer the unsigned 64-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien>unsignedLongLongAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedLongLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongLongAt */
EXPORT(sqInt)
primUnsignedLongLongAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    unsigned long long unsignedlonglongvalue;
    unsigned long long *unsignedlonglongvaluePtr;
    sqInt valueOop;

	unsignedlonglongvaluePtr = 0;
	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	unsignedlonglongvaluePtr = ((unsigned long long*) addr);
	unsignedlonglongvalue = *unsignedlonglongvaluePtr;
	valueOop = positive64BitIntegerFor(unsignedlonglongvalue, self);
	return methodReturnValue(valueOop, self);
}


/*	Store a signed integer into 64 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongLongAt: index <Integer> put: value <Integer>
	^<Integer> <primitive: 'primUnSignedLongLongAtPut' error: errorCode
	module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongLongAtPut */
EXPORT(sqInt)
primUnsignedLongLongAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    unsigned long long unsignedlonglongvalue;
    unsigned long long *unsignedlonglongvaluePtr;
    sqInt valueOop;

	unsignedlonglongvaluePtr = 0;
	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	unsignedlonglongvalue = positive64BitValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	unsignedlonglongvaluePtr = ((unsigned long long*) addr);
	*unsignedlonglongvaluePtr = unsignedlonglongvalue;
	return methodReturnValue(valueOop, self);
}


/*	Answer the unsigned 16-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedShortAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedShortAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedShortAt */
EXPORT(sqInt)
primUnsignedShortAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    unsigned short value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = shortAt(addr);
	valueOop = positive32BitIntegerFor(value, self);
	return methodReturnValue(valueOop, self);
}


/*	Store an unsigned integer into 16 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedShortAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedShortAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedShortAtPut */
EXPORT(sqInt)
primUnsignedShortAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = positive32BitValueOf(valueOop, self);
	if ((failed(self))
	 || (value > 0xFFFF)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	shortAtput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Answer the unsigned word starting at the given byte offset (little
	endian). 
 */
/*	<Alien> unsignedWordAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedWordAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedWordAt */
EXPORT(sqInt)
primUnsignedWordAt(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0, self)) - 1;
	rcvr = stackObjectValue(1, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	value = longAt(addr);
	/* begin positiveMachineIntegerFor: */
	valueOop = (BytesPerWord == 8
		? positive64BitIntegerFor(value, self)
		: positive32BitIntegerFor(value, self));
	return methodReturnValue(valueOop, self);
}


/*	Store an unsigned integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedWordAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedWordAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedWordAtPut */
EXPORT(sqInt)
primUnsignedWordAtPut(struct foo * self)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqInt valueOop;

	valueOop = stackValue(0, self);
	byteOffset = (stackPositiveMachineIntegerValue(1, self)) - 1;
	rcvr = stackObjectValue(2, self);
	value = positiveMachineIntegerValueOf(valueOop, self);
	if (failed(self)) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr, self))) {
		return primitiveFailFor(PrimErrBadIndex, self);
	}
	if (isOopImmutable(rcvr, self)) {
		return primitiveFailFor(PrimErrNoModification, self);
	}
	if (((startAddr = ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver, self);
	}
	addr = startAddr + byteOffset;
	longAtput(addr, value);
	return methodReturnValue(valueOop, self);
}


/*	Call a foreign function that answers a double-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutDoubleReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primVarArgsCallOutDoubleReturn */
EXPORT(sqInt)
primVarArgsCallOutDoubleReturn(struct foo * self)
{
    sqInt array;
    sqInt errCode;
    sqInt mac;
    sqInt result;

	array = stackValue(0, self);
	if (!(isArray(array, self))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	mac = methodArgumentCount(self);

	/* ptr to 0th arg */
	/* nargs */
	/* func stackValue */
	/* result stackValue */
	errCode = callIA32DoubleReturn(firstIndexableField(array, self), stSizeOf(array, self), 2, 1, self);
	if (errCode != 0) {
		return primitiveFailFor(errCode, self);
	}
	result = stackValue(1, self);
	popthenPush(mac + 1, result, self);
	return 0;
}


/*	Call a foreign function that answers a single-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutFloatReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primVarArgsCallOutFloatReturn */
EXPORT(sqInt)
primVarArgsCallOutFloatReturn(struct foo * self)
{
    sqInt array;
    sqInt errCode;
    sqInt mac;
    sqInt result;

	array = stackValue(0, self);
	if (!(isArray(array, self))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	mac = methodArgumentCount(self);

	/* ptr to 0th arg */
	/* nargs */
	/* func stackValue */
	/* result stackValue */
	errCode = callIA32FloatReturn(firstIndexableField(array, self), stSizeOf(array, self), 2, 1, self);
	if (errCode != 0) {
		return primitiveFailFor(errCode, self);
	}
	result = stackValue(1, self);
	popthenPush(mac + 1, result, self);
	return 0;
}


/*	Call a foreign function that answers an integral result in %eax (and
	possibly %edx)
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutIntegralReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primVarArgsCallOutIntegralReturn */
EXPORT(sqInt)
primVarArgsCallOutIntegralReturn(struct foo * self)
{
    sqInt array;
    sqInt errCode;
    sqInt mac;
    sqInt result;

	array = stackValue(0, self);
	if (!(isArray(array, self))) {
		return primitiveFailFor(PrimErrBadArgument, self);
	}
	mac = methodArgumentCount(self);

	/* ptr to 0th arg */
	/* nargs */
	/* func stackValue */
	/* result stackValue */
	errCode = callIA32IntegralReturn(firstIndexableField(array, self), stSizeOf(array, self), 2, 1, self);
	if (errCode != 0) {
		return primitiveFailFor(errCode, self);
	}
	result = stackValue(1, self);
	popthenPush(mac + 1, result, self);
	return 0;
}


/*	Note: This is coded so that is can be run from Squeak. */

	/* IA32ABIPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;

	/* There was no version 0 */
	ok = ((interpreterProxy->majorVersion()) > 1)
	 || ((interpreterProxy->minorVersion()) >= 12);
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		byteSizeOf = interpreterProxy->byteSizeOf;
		classAlien = interpreterProxy->classAlien;
		classLargeNegativeInteger = interpreterProxy->classLargeNegativeInteger;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classSemaphore = interpreterProxy->classSemaphore;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatValueOf = interpreterProxy->floatValueOf;
		getStackPointer = interpreterProxy->getStackPointer;
		includesBehaviorThatOf = interpreterProxy->includesBehaviorThatOf;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
		ioLoadModuleOfLength = interpreterProxy->ioLoadModuleOfLength;
		ioLoadSymbolOfLengthFromModule = interpreterProxy->ioLoadSymbolOfLengthFromModule;
		isArray = interpreterProxy->isArray;
		isBytes = interpreterProxy->isBytes;
		isInMemory = interpreterProxy->isInMemory;
		isIntegerObject = interpreterProxy->isIntegerObject;
		isNonImmediate = interpreterProxy->isNonImmediate;
#if IMMUTABILITY
		isOopImmutable = interpreterProxy->isOopImmutable;
#else
#if !defined(isOopImmutable)
		isOopImmutable = 0;
#endif
#endif
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnValue = interpreterProxy->methodReturnValue;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		positive64BitValueOf = interpreterProxy->positive64BitValueOf;
		positiveMachineIntegerValueOf = interpreterProxy->positiveMachineIntegerValueOf;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		pushFloat = interpreterProxy->pushFloat;
		returnAsThroughCallbackContext = interpreterProxy->returnAsThroughCallbackContext;
		signalNoResume = interpreterProxy->signalNoResume;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed32BitValueOf = interpreterProxy->signed32BitValueOf;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		signed64BitValueOf = interpreterProxy->signed64BitValueOf;
		signedMachineIntegerValueOf = interpreterProxy->signedMachineIntegerValueOf;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackPositiveMachineIntegerValue = interpreterProxy->stackPositiveMachineIntegerValue;
		stackValue = interpreterProxy->stackValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Answer the first field of rcvr which is assumed to be an Alien of at least
	8 bytes
 */

	/* IA32ABIPlugin>>#sizeField: */
static sqInt
sizeField(sqInt rcvr)
{
	return longAt(rcvr + BaseHeaderSize);
}


/*	<byte indexable oop> ^<Integer> */
/*	Answer the start of rcvr's data, given that it is not an alien. */

	/* IA32ABIPlugin>>#startOfByteData: */
static sqInt
startOfByteData(sqInt rcvr)
{
	return rcvr + BaseHeaderSize;
}


/*	<Alien oop> ^<Integer> */
/*	Answer the start of rcvr's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

	/* IA32ABIPlugin>>#startOfData: */
static sqInt
startOfData(sqInt rcvr)
{
	return ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop));
}


/*	<Alien oop> */
/*	<Integer> ^<Integer> */
/*	Answer the start of rcvr's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

	/* IA32ABIPlugin>>#startOfData:withSize: */
static sqInt
startOfDatawithSize(sqInt rcvr, sqInt sizeField)
{
	return (sizeField > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop));
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "IA32ABI";
void* IA32ABI_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "isAlien", (void*)isAlien},
	{(void*)_m, "primAddressField\000\000", (void*)primAddressField},
	{(void*)_m, "primAddressFieldPut\000\000", (void*)primAddressFieldPut},
	{(void*)_m, "primAlienReplace\000\000", (void*)primAlienReplace},
	{(void*)_m, "primAllocateExecutablePage\000\377", (void*)primAllocateExecutablePage},
	{(void*)_m, "primBoxedFree\000\001", (void*)primBoxedFree},
	{(void*)_m, "primCallOutDoubleReturn\000\000", (void*)primCallOutDoubleReturn},
	{(void*)_m, "primCallOutFloatReturn\000\000", (void*)primCallOutFloatReturn},
	{(void*)_m, "primCallOutIntegralReturn\000\000", (void*)primCallOutIntegralReturn},
	{(void*)_m, "primCalloc\000\000", (void*)primCalloc},
	{(void*)_m, "primDoubleAt\000\000", (void*)primDoubleAt},
	{(void*)_m, "primDoubleAtPut\000\000", (void*)primDoubleAtPut},
	{(void*)_m, "primDrainOSEventQueue\000\377", (void*)primDrainOSEventQueue},
	{(void*)_m, "primFloatAt\000\000", (void*)primFloatAt},
	{(void*)_m, "primFloatAtPut\000\000", (void*)primFloatAtPut},
	{(void*)_m, "primFree\000\000", (void*)primFree},
	{(void*)_m, "primInIOProcessEventsFlagAddress\000\377", (void*)primInIOProcessEventsFlagAddress},
	{(void*)_m, "primInLibraryFindSymbol\000\000", (void*)primInLibraryFindSymbol},
	{(void*)_m, "primLoadLibrary\000\000", (void*)primLoadLibrary},
	{(void*)_m, "primMalloc\000\000", (void*)primMalloc},
	{(void*)_m, "primReturnAsFromContextThrough\000\000", (void*)primReturnAsFromContextThrough},
	{(void*)_m, "primReturnFromContextThrough\000\000", (void*)primReturnFromContextThrough},
	{(void*)_m, "primSignedByteAt\000\000", (void*)primSignedByteAt},
	{(void*)_m, "primSignedByteAtPut\000\000", (void*)primSignedByteAtPut},
	{(void*)_m, "primSignedLongAt\000\000", (void*)primSignedLongAt},
	{(void*)_m, "primSignedLongAtPut\000\000", (void*)primSignedLongAtPut},
	{(void*)_m, "primSignedLongLongAt\000\000", (void*)primSignedLongLongAt},
	{(void*)_m, "primSignedLongLongAtPut\000\000", (void*)primSignedLongLongAtPut},
	{(void*)_m, "primSignedShortAt\000\000", (void*)primSignedShortAt},
	{(void*)_m, "primSignedShortAtPut\000\000", (void*)primSignedShortAtPut},
	{(void*)_m, "primSignedWordAt\000\000", (void*)primSignedWordAt},
	{(void*)_m, "primSignedWordAtPut\000\000", (void*)primSignedWordAtPut},
	{(void*)_m, "primSizeField\000\000", (void*)primSizeField},
	{(void*)_m, "primSizeFieldPut\000\000", (void*)primSizeFieldPut},
	{(void*)_m, "primStrlenFromStartIndex\000\000", (void*)primStrlenFromStartIndex},
	{(void*)_m, "primStrlenThroughPointerAtIndex\000\000", (void*)primStrlenThroughPointerAtIndex},
	{(void*)_m, "primThunkEntryAddress\000\377", (void*)primThunkEntryAddress},
	{(void*)_m, "primUnsignedByteAt\000\000", (void*)primUnsignedByteAt},
	{(void*)_m, "primUnsignedByteAtPut\000\000", (void*)primUnsignedByteAtPut},
	{(void*)_m, "primUnsignedLongAt\000\000", (void*)primUnsignedLongAt},
	{(void*)_m, "primUnsignedLongAtPut\000\000", (void*)primUnsignedLongAtPut},
	{(void*)_m, "primUnsignedLongLongAt\000\000", (void*)primUnsignedLongLongAt},
	{(void*)_m, "primUnsignedLongLongAtPut\000\000", (void*)primUnsignedLongLongAtPut},
	{(void*)_m, "primUnsignedShortAt\000\000", (void*)primUnsignedShortAt},
	{(void*)_m, "primUnsignedShortAtPut\000\000", (void*)primUnsignedShortAtPut},
	{(void*)_m, "primUnsignedWordAt\000\000", (void*)primUnsignedWordAt},
	{(void*)_m, "primUnsignedWordAtPut\000\000", (void*)primUnsignedWordAtPut},
	{(void*)_m, "primVarArgsCallOutDoubleReturn\000\000", (void*)primVarArgsCallOutDoubleReturn},
	{(void*)_m, "primVarArgsCallOutFloatReturn\000\000", (void*)primVarArgsCallOutFloatReturn},
	{(void*)_m, "primVarArgsCallOutIntegralReturn\000\000", (void*)primVarArgsCallOutIntegralReturn},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primAddressFieldAccessorDepth = 0;
EXPORT(signed char) primAddressFieldPutAccessorDepth = 0;
EXPORT(signed char) primAlienReplaceAccessorDepth = 0;
EXPORT(signed char) primBoxedFreeAccessorDepth = 1;
EXPORT(signed char) primCallOutDoubleReturnAccessorDepth = 0;
EXPORT(signed char) primCallOutFloatReturnAccessorDepth = 0;
EXPORT(signed char) primCallOutIntegralReturnAccessorDepth = 0;
EXPORT(signed char) primCallocAccessorDepth = 0;
EXPORT(signed char) primDoubleAtAccessorDepth = 0;
EXPORT(signed char) primDoubleAtPutAccessorDepth = 0;
EXPORT(signed char) primFloatAtAccessorDepth = 0;
EXPORT(signed char) primFloatAtPutAccessorDepth = 0;
EXPORT(signed char) primFreeAccessorDepth = 0;
EXPORT(signed char) primInLibraryFindSymbolAccessorDepth = 0;
EXPORT(signed char) primLoadLibraryAccessorDepth = 0;
EXPORT(signed char) primMallocAccessorDepth = 0;
EXPORT(signed char) primReturnAsFromContextThroughAccessorDepth = 0;
EXPORT(signed char) primReturnFromContextThroughAccessorDepth = 0;
EXPORT(signed char) primSignedByteAtAccessorDepth = 0;
EXPORT(signed char) primSignedByteAtPutAccessorDepth = 0;
EXPORT(signed char) primSignedLongAtAccessorDepth = 0;
EXPORT(signed char) primSignedLongAtPutAccessorDepth = 0;
EXPORT(signed char) primSignedLongLongAtAccessorDepth = 0;
EXPORT(signed char) primSignedLongLongAtPutAccessorDepth = 0;
EXPORT(signed char) primSignedShortAtAccessorDepth = 0;
EXPORT(signed char) primSignedShortAtPutAccessorDepth = 0;
EXPORT(signed char) primSignedWordAtAccessorDepth = 0;
EXPORT(signed char) primSignedWordAtPutAccessorDepth = 0;
EXPORT(signed char) primSizeFieldAccessorDepth = 0;
EXPORT(signed char) primSizeFieldPutAccessorDepth = 0;
EXPORT(signed char) primStrlenFromStartIndexAccessorDepth = 0;
EXPORT(signed char) primStrlenThroughPointerAtIndexAccessorDepth = 0;
EXPORT(signed char) primUnsignedByteAtAccessorDepth = 0;
EXPORT(signed char) primUnsignedByteAtPutAccessorDepth = 0;
EXPORT(signed char) primUnsignedLongAtAccessorDepth = 0;
EXPORT(signed char) primUnsignedLongAtPutAccessorDepth = 0;
EXPORT(signed char) primUnsignedLongLongAtAccessorDepth = 0;
EXPORT(signed char) primUnsignedLongLongAtPutAccessorDepth = 0;
EXPORT(signed char) primUnsignedShortAtAccessorDepth = 0;
EXPORT(signed char) primUnsignedShortAtPutAccessorDepth = 0;
EXPORT(signed char) primUnsignedWordAtAccessorDepth = 0;
EXPORT(signed char) primUnsignedWordAtPutAccessorDepth = 0;
EXPORT(signed char) primVarArgsCallOutDoubleReturnAccessorDepth = 0;
EXPORT(signed char) primVarArgsCallOutFloatReturnAccessorDepth = 0;
EXPORT(signed char) primVarArgsCallOutIntegralReturnAccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
